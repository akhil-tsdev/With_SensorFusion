###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Aug/2016  15:48:58
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\packet\src\serial_packet.c
#    Command line =  
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\packet\src\serial_packet.c"
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN512VDC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -lC
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\obj"
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform/devices/MK22F51212\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/osa\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/device\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/device/class\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/bm_usb\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform/devices\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/common\"
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\list\serial_packet.lst
#    Object file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\obj\serial_packet.o
#
###############################################################################

C:\Users\cwati\Documents\My Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\packet\src\serial_packet.c
      1          /*
      2           * Copyright (c) 2013, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include <string.h>
     32          #include "bootloader_common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void debug_printf(char const *, ...)
   \                     debug_printf: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB500             PUSH     {LR}
   \   00000004   0xA901             ADD      R1,SP,#+4
   \   00000006   0x.... 0x....      BL       vprintf
   \   0000000A   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
     33          #include "bootloader/bl_context.h"
     34          #include "bootloader/bootloader.h"
     35          #include "packet/command_packet.h"
     36          #include "packet/serial_packet.h"
     37          #include "crc/crc16.h"
     38          #include "utilities/fsl_assert.h"
     39          
     40          #ifndef BOOTLOADER_HOST
     41          #include "microseconds/microseconds.h"
     42          #endif
     43          
     44          //! @addtogroup packet
     45          //! @{
     46          
     47          ////////////////////////////////////////////////////////////////////////////////
     48          // Definitions
     49          ////////////////////////////////////////////////////////////////////////////////
     50          
     51          //#define TEST_NAK
     52          
     53          ////////////////////////////////////////////////////////////////////////////////
     54          // Prototypes
     55          ////////////////////////////////////////////////////////////////////////////////
     56          
     57          static status_t write_data(const uint8_t *buffer, uint32_t byteCount);
     58          static status_t read_data(uint8_t *buffer, uint32_t byteCount, uint32_t timeoutMs);
     59          static status_t read_data_packet(framing_data_packet_t *packet, uint8_t *data, packet_type_t packetType);
     60          static status_t read_start_byte(framing_header_t *header);
     61          static status_t read_header(framing_header_t *header);
     62          static status_t read_length(framing_data_packet_t *packet);
     63          static status_t read_crc16(framing_data_packet_t *packet);
     64          static status_t wait_for_ack_packet(void);
     65          static status_t send_deferred_ack(void);
     66          static uint16_t calculate_framing_crc16(framing_data_packet_t *packet, const uint8_t *data);
     67          
     68          ////////////////////////////////////////////////////////////////////////////////
     69          // Variables
     70          ////////////////////////////////////////////////////////////////////////////////
     71          
     72          // See peripharal.h for documentation on this interface.

   \                                 In section .rodata, align 4, keep-with-next
     73          const peripheral_packet_interface_t g_framingPacketInterface = {
   \                     g_framingPacketInterface:
   \   00000000   0x........         DC32 serial_packet_init, serial_packet_read, serial_packet_write
   \              0x........   
   \              0x........   
   \   0000000C   0x........         DC32 serial_packet_abort, serial_packet_finalize
   \              0x........   
   \   00000014   0x........         DC32 serial_packet_get_max_packet_size, serial_packet_queue_byte
   \              0x........   
     74              serial_packet_init,      serial_packet_read,     serial_packet_write,
     75              serial_packet_abort,     serial_packet_finalize, serial_packet_get_max_packet_size,
     76              serial_packet_queue_byte
     77          };
     78          
     79          //! @brief Ping response.
     80          #if defined(__cplusplus)
     81          const ping_response_t k_PingResponse = {
     82              MAKE_VERSION(kSerialProtocol_Version_Bugfix,
     83                           kSerialProtocol_Version_Minor,
     84                           kSerialProtocol_Version_Major,
     85                           kSerialProtocol_Version_Name),
     86              0,     // options, recalculate crc16 if this value changes
     87              0xeaaa // crc16 of start byte, packet type, version and options.
     88                     // i.e. [5a a7 00 00 01 50 00 00]
     89                     // Calculated using CRC-16/XMODEM.
     90          };
     91          #else

   \                                 In section .text, align 4, keep-with-next
     92          const ping_response_t k_PingResponse = {
   \                     k_PingResponse:
   \   00000000   0x00 0x02          DC8 0, 2, 1, 80
   \              0x01 0x50    
   \   00000004   0x0000 0xEAAA      DC16 0, 60074
     93              { { kSerialProtocol_Version_Bugfix, kSerialProtocol_Version_Minor, kSerialProtocol_Version_Major,
     94                  kSerialProtocol_Version_Name } },
     95              0,     // options, recalculate crc16 if this value changes
     96              0xeaaa // crc16 of start byte, packet type, version and options.
     97                     // i.e. [5a a7 00 00 01 50 00 00]
     98                     // Calculated using CRC-16/XMODEM.
     99          };
    100          #endif
    101          
    102          //! @brief Global context data.

   \                                 In section .bss, align 4
    103          static serial_data_t g_serialContext;
   \                     g_serialContext:
   \   00000000                      DS8 148
    104          
    105          ////////////////////////////////////////////////////////////////////////////////
    106          // Code
    107          ////////////////////////////////////////////////////////////////////////////////
    108          
    109          // See serial_packet.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    110          void serial_packet_queue_byte(uint8_t byte)
    111          {
    112              g_serialContext.callbackBuffer[g_serialContext.writeOffset++] = byte;
   \                     serial_packet_queue_byte: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable18
   \   00000002   0xF8D1 0x2088      LDR      R2,[R1, #+136]
   \   00000006   0x1C53             ADDS     R3,R2,#+1
   \   00000008   0x440A             ADD      R2,R1,R2
   \   0000000A   0xF8C1 0x3088      STR      R3,[R1, #+136]
   \   0000000E   0xF882 0x0020      STRB     R0,[R2, #+32]
    113              g_serialContext.writeOffset &= kCallbackBufferSize - 1;
   \   00000012   0xF8D1 0x0088      LDR      R0,[R1, #+136]
   \   00000016   0xF000 0x003F      AND      R0,R0,#0x3F
   \   0000001A   0xF8C1 0x0088      STR      R0,[R1, #+136]
    114          }
   \   0000001E   0x4770             BX       LR               ;; return
    115          
    116          // See serial_packet.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    117          status_t serial_packet_init(const peripheral_descriptor_t *self)
    118          {
    119              return kStatus_Success;
   \                     serial_packet_init: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    120          }
    121          
    122          // See serial_packet.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    123          status_t serial_packet_finalize(const peripheral_descriptor_t *self)
    124          {
    125              return send_deferred_ack();
   \                     serial_packet_finalize: (+1)
   \   00000000   0x....             B.N      send_deferred_ack
    126          }
    127          
    128          // See serial_packet.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    129          status_t serial_packet_read(const peripheral_descriptor_t *self,
    130                                      uint8_t **packet,
    131                                      uint32_t *packetLength,
    132                                      packet_type_t packetType)
    133          {
   \                     serial_packet_read: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x4615             MOV      R5,R2
    134              if (!packet || !packetLength)
   \   00000008   0xBF18             IT       NE 
   \   0000000A   0x2D00             CMPNE    R5,#+0
   \   0000000C   0xB083             SUB      SP,SP,#+12
   \   0000000E   0x4698             MOV      R8,R3
   \   00000010   0xD105             BNE.N    ??serial_packet_read_0
    135              {
    136                  debug_printf("Error: invalid packet\r\n");
   \   00000012   0x.... 0x....      ADR.W    R0,?_0
   \   00000016   0x.... 0x....      BL       debug_printf
    137                  return kStatus_InvalidArgument;
   \   0000001A   0x2004             MOVS     R0,#+4
   \   0000001C   0xE02E             B.N      ??serial_packet_read_1
    138              }
    139              *packetLength = 0;
    140              status_t status;
    141          
    142              g_serialContext.isBackToBackWrite = false;
   \                     ??serial_packet_read_0: (+1)
   \   0000001E   0x....             LDR.N    R7,??DataTable18
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF107 0x0690      ADD      R6,R7,#+144
   \   00000026   0x6028             STR      R0,[R5, #+0]
   \   00000028   0x7070             STRB     R0,[R6, #+1]
    143          
    144              // Send ACK if needed.
    145              status = send_deferred_ack();
   \   0000002A   0x.... 0x....      BL       send_deferred_ack
    146              if (status != kStatus_Success)
   \   0000002E   0xBB28             CBNZ.N   R0,??serial_packet_read_1
    147              {
    148                  return status;
   \   00000030   0x.... 0x....      ADR.W    R9,?_1
   \   00000034   0xE005             B.N      ??serial_packet_read_2
    149              }
    150          
    151              framing_data_packet_t framingPacket;
    152          
    153              bool isPacketOk;
    154              do
    155              {
    156                  // Clear the packet data area so unsent parameters default to zero.
    157                  memset(g_serialContext.data, 0, sizeof(g_serialContext.data));
    158          
    159                  // Receive the framing data packet.
    160                  isPacketOk = true;
    161                  status_t status = read_data_packet(&framingPacket, g_serialContext.data, packetType);
    162                  if (status != kStatus_Success)
    163                  {
    164                      // No packet available.
    165                      *packetLength = 0;
    166                      return status;
    167                  }
    168          
    169                  // Verify crc.
    170                  uint16_t calculated_crc = calculate_framing_crc16(&framingPacket, g_serialContext.data);
    171                  if (framingPacket.crc16 != calculated_crc)
    172                  {
    173                      debug_printf("Error: invalid crc 0x%x, expected 0x%x\r\n", framingPacket.crc16, calculated_crc);
   \                     ??serial_packet_read_3: (+1)
   \   00000036   0x4648             MOV      R0,R9
   \   00000038   0x.... 0x....      BL       debug_printf
    174                      isPacketOk = false;
    175                  }
    176          
    177                  // Send Nak if necessary.
    178                  if (!isPacketOk)
    179                  {
    180                      serial_packet_send_sync(kFramingPacketType_Nak);
   \   0000003C   0x20A2             MOVS     R0,#+162
   \   0000003E   0x.... 0x....      BL       serial_packet_send_sync
    181                  }
   \                     ??serial_packet_read_2: (+1)
   \   00000042   0x2120             MOVS     R1,#+32
   \   00000044   0x4638             MOV      R0,R7
   \   00000046   0x.... 0x....      BL       __aeabi_memclr4
   \   0000004A   0x4642             MOV      R2,R8
   \   0000004C   0x4639             MOV      R1,R7
   \   0000004E   0x4668             MOV      R0,SP
   \   00000050   0x.... 0x....      BL       read_data_packet
   \   00000054   0xB110             CBZ.N    R0,??serial_packet_read_4
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x6029             STR      R1,[R5, #+0]
   \   0000005A   0xE00F             B.N      ??serial_packet_read_1
   \                     ??serial_packet_read_4: (+1)
   \   0000005C   0x4639             MOV      R1,R7
   \   0000005E   0x4668             MOV      R0,SP
   \   00000060   0x.... 0x....      BL       calculate_framing_crc16
   \   00000064   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000068   0x4602             MOV      R2,R0
   \   0000006A   0x4291             CMP      R1,R2
   \   0000006C   0xD1E3             BNE.N    ??serial_packet_read_3
    182              } while (!isPacketOk);
    183          
    184              // Indicate an ACK must be sent.
    185              g_serialContext.isAckNeeded = true;
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0x7030             STRB     R0,[R6, #+0]
    186          
    187              // Set caller's data buffer and length
    188              *packet = g_serialContext.data;
   \   00000072   0x6027             STR      R7,[R4, #+0]
    189              *packetLength = framingPacket.length;
   \   00000074   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   00000078   0x6028             STR      R0,[R5, #+0]
    190          
    191              return kStatus_Success;
   \   0000007A   0x2000             MOVS     R0,#+0
   \                     ??serial_packet_read_1: (+1)
   \   0000007C   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
    192          }
    193          
    194          // See serial_packet.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    195          status_t serial_packet_write(const peripheral_descriptor_t *self,
    196                                       const uint8_t *packet,
    197                                       uint32_t byteCount,
    198                                       packet_type_t packetType)
    199          {
   \                     serial_packet_write: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0xB082             SUB      SP,SP,#+8
   \   00000008   0x4615             MOV      R5,R2
   \   0000000A   0x461E             MOV      R6,R3
    200              if (!packet || (byteCount > kOutgoingPacketBufferSize))
   \   0000000C   0xD001             BEQ.N    ??serial_packet_write_0
   \   0000000E   0x2D21             CMP      R5,#+33
   \   00000010   0xD303             BCC.N    ??serial_packet_write_1
    201              {
    202                  debug_printf("Error: invalid packet or packet size %d\r\n", byteCount);
   \                     ??serial_packet_write_0: (+1)
   \   00000012   0x4629             MOV      R1,R5
   \   00000014   0x.... 0x....      ADR.W    R0,?_2
   \   00000018   0xE034             B.N      ??serial_packet_write_2
    203                  return kStatus_InvalidArgument;
    204              }
    205          
    206              // Send ACK if needed.
    207              status_t status = send_deferred_ack();
   \                     ??serial_packet_write_1: (+1)
   \   0000001A   0x.... 0x....      BL       send_deferred_ack
    208              if (status != kStatus_Success)
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD142             BNE.N    ??serial_packet_write_3
    209              {
    210                  return status;
    211              }
    212          
    213              // Back-to-back writes require delay for receiver to enter peripheral read routine.
    214              if (g_serialContext.isBackToBackWrite)
   \   00000022   0x.... 0x....      LDR.W    R8,??DataTable18
   \   00000026   0xF898 0x0091      LDRB     R0,[R8, #+145]
   \   0000002A   0xB110             CBZ.N    R0,??serial_packet_write_4
    215              {
    216                  g_serialContext.isBackToBackWrite = false;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF888 0x0091      STRB     R0,[R8, #+145]
    217          
    218          #if defined(BOOTLOADER_HOST)
    219                  host_delay(100);
    220          #endif
    221              }
    222          
    223              // Initialize the framing data packet.
    224              serial_framing_packet_t *framingPacket = &g_serialContext.framingPacket;
    225              framingPacket->dataPacket.header.startByte = kFramingPacketStartByte;
   \                     ??serial_packet_write_4: (+1)
   \   00000032   0xF108 0x0760      ADD      R7,R8,#+96
   \   00000036   0x205A             MOVS     R0,#+90
   \   00000038   0x7038             STRB     R0,[R7, #+0]
    226              framingPacket->dataPacket.header.packetType = kFramingPacketType_Command;
   \   0000003A   0x20A4             MOVS     R0,#+164
    227              if (packetType != kPacketType_Command)
   \   0000003C   0xB106             CBZ.N    R6,??serial_packet_write_5
    228              {
    229                  framingPacket->dataPacket.header.packetType = kFramingPacketType_Data;
   \   0000003E   0x20A5             MOVS     R0,#+165
   \                     ??serial_packet_write_5: (+1)
   \   00000040   0x7078             STRB     R0,[R7, #+1]
    230              }
    231              framingPacket->dataPacket.length = (uint16_t)byteCount;
   \   00000042   0x807D             STRH     R5,[R7, #+2]
    232          
    233              // Copy the caller's data buffer into the framing packet.
    234              if (byteCount)
   \   00000044   0xB12D             CBZ.N    R5,??serial_packet_write_6
    235              {
    236                  memcpy(framingPacket->data, packet, byteCount);
   \   00000046   0x462A             MOV      R2,R5
   \   00000048   0x4621             MOV      R1,R4
   \   0000004A   0xF108 0x0066      ADD      R0,R8,#+102
   \   0000004E   0x.... 0x....      BL       __aeabi_memcpy
    237              }
    238          
    239              // Calculate and set the framing packet crc.
    240              framingPacket->dataPacket.crc16 =
    241                  calculate_framing_crc16(&framingPacket->dataPacket, (uint8_t *)framingPacket->data);
   \                     ??serial_packet_write_6: (+1)
   \   00000052   0xF108 0x0166      ADD      R1,R8,#+102
   \   00000056   0x4638             MOV      R0,R7
   \   00000058   0x.... 0x....      BL       calculate_framing_crc16
   \   0000005C   0x80B8             STRH     R0,[R7, #+4]
    242          #if defined(TEST_NAK)
    243              ++framingPacket->dataPacket.crc16;
    244          #endif // TEST_NAK
    245          
    246              // Send the framing data packet.
    247              status = write_data((uint8_t *)framingPacket, sizeof(framing_data_packet_t) + byteCount);
   \   0000005E   0x1DA9             ADDS     R1,R5,#+6
   \   00000060   0x4638             MOV      R0,R7
   \   00000062   0x.... 0x....      BL       write_data
    248              if (status != kStatus_Success)
   \   00000066   0xB9F8             CBNZ.N   R0,??serial_packet_write_3
    249              {
    250                  return status;
    251              }
    252          
    253              return wait_for_ack_packet();
   \                     ??serial_packet_write_7: (+1)
   \   00000068   0x4668             MOV      R0,SP
   \   0000006A   0x.... 0x....      BL       read_header
   \   0000006E   0xB9D8             CBNZ.N   R0,??serial_packet_write_3
   \   00000070   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   00000074   0x29A1             CMP      R1,#+161
   \   00000076   0xD016             BEQ.N    ??serial_packet_write_8
   \   00000078   0x29A2             CMP      R1,#+162
   \   0000007A   0xD00A             BEQ.N    ??serial_packet_write_9
   \   0000007C   0x29A3             CMP      R1,#+163
   \   0000007E   0xD005             BEQ.N    ??serial_packet_write_10
   \   00000080   0x.... 0x....      ADR.W    R0,?_4
   \                     ??serial_packet_write_2: (+1)
   \   00000084   0x.... 0x....      BL       debug_printf
   \   00000088   0x2004             MOVS     R0,#+4
   \   0000008A   0xE00D             B.N      ??serial_packet_write_3
   \                     ??serial_packet_write_10: (+1)
   \   0000008C   0xF242 0x7012      MOVW     R0,#+10002
   \   00000090   0xE00A             B.N      ??serial_packet_write_3
   \                     ??serial_packet_write_9: (+1)
   \   00000092   0x8878             LDRH     R0,[R7, #+2]
   \   00000094   0x1D81             ADDS     R1,R0,#+6
   \   00000096   0x4638             MOV      R0,R7
   \   00000098   0x.... 0x....      BL       write_data
   \   0000009C   0xB920             CBNZ.N   R0,??serial_packet_write_3
   \   0000009E   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000000A2   0x28A2             CMP      R0,#+162
   \   000000A4   0xD0E0             BEQ.N    ??serial_packet_write_7
   \                     ??serial_packet_write_8: (+1)
   \   000000A6   0x2000             MOVS     R0,#+0
   \                     ??serial_packet_write_3: (+1)
   \   000000A8   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    254          }
    255          
    256          // See serial_packet.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    257          void serial_packet_abort(const peripheral_descriptor_t *self)
    258          {
    259              assert(g_serialContext.isAckNeeded);
    260              g_serialContext.isAckAbortNeeded = true;
   \                     serial_packet_abort: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable18_1
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x7081             STRB     R1,[R0, #+2]
    261              g_serialContext.isAckNeeded = false;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x7001             STRB     R1,[R0, #+0]
    262          }
   \   0000000A   0x4770             BX       LR               ;; return
    263          
    264          // See serial_packet.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    265          uint32_t serial_packet_get_max_packet_size(const peripheral_descriptor_t *self)
    266          {
    267              return kMinPacketBufferSize;
   \                     serial_packet_get_max_packet_size: (+1)
   \   00000000   0x2020             MOVS     R0,#+32
   \   00000002   0x4770             BX       LR               ;; return
    268          }
    269          
    270          // See serial_packet.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    271          status_t serial_packet_send_sync(uint8_t framingPacketType)
    272          {
   \                     serial_packet_send_sync: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    273              framing_sync_packet_t sync;
    274              sync.header.startByte = kFramingPacketStartByte;
   \   00000004   0x205A             MOVS     R0,#+90
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    275              sync.header.packetType = framingPacketType;
    276          
    277              // Indicate last transaction was a write.
    278              g_serialContext.isBackToBackWrite = true;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x....             LDR.N    R1,??DataTable18
   \   0000000E   0xF88D 0x4001      STRB     R4,[SP, #+1]
   \   00000012   0xF881 0x0091      STRB     R0,[R1, #+145]
    279          
    280              status_t status = write_data((uint8_t *)&sync, sizeof(sync));
   \   00000016   0x2102             MOVS     R1,#+2
   \   00000018   0x4668             MOV      R0,SP
   \   0000001A   0x.... 0x....      BL       write_data
   \   0000001E   0x0005             MOVS     R5,R0
    281              if (status != kStatus_Success)
   \   00000020   0xD007             BEQ.N    ??serial_packet_send_sync_0
    282              {
    283                  debug_printf("Error: cannot send sync packet 0x%x, status = 0x%x\r\n", framingPacketType, status);
   \   00000022   0x462A             MOV      R2,R5
   \   00000024   0x4621             MOV      R1,R4
   \   00000026   0x.... 0x....      ADR.W    R0,?_3
   \   0000002A   0x.... 0x....      BL       debug_printf
    284                  return status;
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}
    285              }
    286          
    287              return status;
   \                     ??serial_packet_send_sync_0: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    288          }
    289          
    290          //! @brief Wait for an ACK, handling NAKs as needed.
    291          static status_t wait_for_ack_packet()
    292          {
    293              framing_sync_packet_t sync;
    294              do
    295              {
    296                  // Receive the sync packet.
    297                  status_t status = read_header(&sync.header);
    298                  if (status != kStatus_Success)
    299                  {
    300                      return status;
    301                  }
    302          
    303                  if ((sync.header.packetType != kFramingPacketType_Ack) && (sync.header.packetType != kFramingPacketType_Nak) &&
    304                      (sync.header.packetType != kFramingPacketType_AckAbort))
    305                  {
    306                      debug_printf("Error: Unexpected sync byte 0x%x received, expected Ack, AckAbort or Nak\r\n",
    307                                   sync.header.packetType);
    308                      return kStatus_InvalidArgument;
    309                  }
    310          
    311                  if (sync.header.packetType == kFramingPacketType_AckAbort)
    312                  {
    313                      return kStatus_AbortDataPhase;
    314                  }
    315          
    316                  if (sync.header.packetType == kFramingPacketType_Nak)
    317                  {
    318          // Re-transmit the last packet.
    319          #if defined(TEST_NAK)
    320                      --g_serialContext.framingPacket.dataPacket.crc16;
    321          #endif // TEST_NAK
    322                      status = write_data((uint8_t *)&g_serialContext.framingPacket,
    323                                          sizeof(framing_data_packet_t) + g_serialContext.framingPacket.dataPacket.length);
    324                      if (status != kStatus_Success)
    325                      {
    326                          return status;
    327                      }
    328                  }
    329              } while (sync.header.packetType == kFramingPacketType_Nak);
    330          
    331              return kStatus_Success;
    332          }
    333          
    334          // See serial_packet.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    335          status_t serial_send_ping_response(const peripheral_descriptor_t *peripheral)
    336          {
   \                     serial_send_ping_response: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    337              assert(peripheral);
    338          
    339              // Only reply if we're in an idle state
    340              if (!g_serialContext.isAckNeeded || !g_serialContext.isBackToBackWrite || !g_serialContext.isAckAbortNeeded)
   \   00000004   0x....             LDR.N    R0,??DataTable18_1
   \   00000006   0x7801             LDRB     R1,[R0, #+0]
   \   00000008   0x7842             LDRB     R2,[R0, #+1]
   \   0000000A   0x7880             LDRB     R0,[R0, #+2]
   \   0000000C   0x4011             ANDS     R1,R2,R1
   \   0000000E   0x4201             TST      R1,R0
   \   00000010   0xB082             SUB      SP,SP,#+8
   \   00000012   0xD111             BNE.N    ??serial_send_ping_response_0
    341              {
    342                  const uint8_t header[] = { kFramingPacketStartByte, kFramingPacketType_PingResponse };
   \   00000014   0x.... 0x....      ADR.W    R0,?_5
   \   00000018   0x8800             LDRH     R0,[R0, #+0]
   \   0000001A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    343                  peripheral->byteInterface->write(peripheral, (const uint8_t *)&header, sizeof(header));
   \   0000001E   0x2202             MOVS     R2,#+2
   \   00000020   0x6923             LDR      R3,[R4, #+16]
   \   00000022   0x685B             LDR      R3,[R3, #+4]
   \   00000024   0x4669             MOV      R1,SP
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x4798             BLX      R3
    344                  peripheral->byteInterface->write(peripheral, (uint8_t *)&k_PingResponse, sizeof(k_PingResponse));
   \   0000002A   0x6923             LDR      R3,[R4, #+16]
   \   0000002C   0x.... 0x....      ADR.W    R1,k_PingResponse
   \   00000030   0x685B             LDR      R3,[R3, #+4]
   \   00000032   0x2208             MOVS     R2,#+8
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x4798             BLX      R3
    345              }
    346          
    347              return kStatus_Ping;
   \                     ??serial_send_ping_response_0: (+1)
   \   00000038   0xF242 0x7013      MOVW     R0,#+10003
   \   0000003C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    348          }
    349          
    350          //! @brief Send ACK if needed.

   \                                 In section .text, align 2, keep-with-next
    351          static status_t send_deferred_ack()
    352          {
    353              if (g_serialContext.isAckNeeded)
   \                     send_deferred_ack: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable18_1
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0xB119             CBZ.N    R1,??send_deferred_ack_0
    354              {
    355                  // Send Ack for last received packet.
    356                  g_serialContext.isAckNeeded = false;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x7001             STRB     R1,[R0, #+0]
    357                  return serial_packet_send_sync(kFramingPacketType_Ack);
   \   0000000A   0x20A1             MOVS     R0,#+161
   \   0000000C   0xE004             B.N      ??send_deferred_ack_1
    358              }
    359              else if (g_serialContext.isAckAbortNeeded)
   \                     ??send_deferred_ack_0: (+1)
   \   0000000E   0x7881             LDRB     R1,[R0, #+2]
   \   00000010   0xB119             CBZ.N    R1,??send_deferred_ack_2
    360              {
    361                  // Send AckAbort for last received packet.
    362                  g_serialContext.isAckAbortNeeded = false;
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x7081             STRB     R1,[R0, #+2]
    363                  return serial_packet_send_sync(kFramingPacketType_AckAbort);
   \   00000016   0x20A3             MOVS     R0,#+163
   \                     ??send_deferred_ack_1: (+1)
   \   00000018   0x....             B.N      serial_packet_send_sync
    364              }
    365              else
    366              {
    367                  return kStatus_Success;
   \                     ??send_deferred_ack_2: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
    368              }
    369          }
    370          
    371          //! @brief Write buffer to peripheral until all bytes sent.

   \                                 In section .text, align 2, keep-with-next
    372          static status_t write_data(const uint8_t *buffer, uint32_t byteCount)
   \                     write_data: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable18_2
   \   00000002   0x69D3             LDR      R3,[R2, #+28]
   \   00000004   0x460A             MOV      R2,R1
   \   00000006   0x4601             MOV      R1,R0
   \   00000008   0x4618             MOV      R0,R3
   \   0000000A   0x691B             LDR      R3,[R3, #+16]
   \   0000000C   0x685B             LDR      R3,[R3, #+4]
   \   0000000E   0x4718             BX       R3
    373          {
    374              status_t retVal;
    375          
    376              retVal = g_bootloaderContext.activePeripheral->byteInterface->write(g_bootloaderContext.activePeripheral, buffer,
    377                                                                                  byteCount);
    378          
    379              return retVal;
    380          }
    381          
    382          //! @brief Read from peripheral until specified number of bytes received.

   \                                 In section .text, align 2, keep-with-next
    383          static status_t read_data(uint8_t *buffer, uint32_t byteCount, uint32_t timeoutMs)
    384          {
   \                     read_data: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0x468B             MOV      R11,R1
   \   00000006   0x4616             MOV      R6,R2
    385          #ifdef BOOTLOADER_HOST
    386              // Host will not be relying on interrupts for reads so manually read the data out
    387              return g_bootloaderContext.activePeripheral->byteInterface->read(g_bootloaderContext.activePeripheral, buffer,
    388                                                                               byteCount);
    389          #else
    390              // On the target we read from our interrupt buffer
    391              uint32_t currentBytesRead = 0;
    392              uint64_t startTicks = microseconds_get_ticks();
   \   00000008   0x.... 0x....      BL       microseconds_get_ticks
   \   0000000C   0x4604             MOV      R4,R0
    393              uint64_t timeOutTicks = microseconds_convert_to_ticks(timeoutMs * 1000);
   \   0000000E   0xF44F 0x707A      MOV      R0,#+1000
   \   00000012   0x460D             MOV      R5,R1
   \   00000014   0x4370             MULS     R0,R0,R6
   \   00000016   0x.... 0x....      BL       microseconds_convert_to_ticks
    394              uint64_t endTicks = startTicks;
    395              uint64_t deltaTicks = 0;
   \   0000001A   0x.... 0x....      LDR.W    R10,??DataTable18
   \   0000001E   0x2700             MOVS     R7,#+0
   \   00000020   0x4680             MOV      R8,R0
   \   00000022   0x4689             MOV      R9,R1
   \   00000024   0xF10A 0x0688      ADD      R6,R10,#+136
   \   00000028   0xE00E             B.N      ??read_data_0
    396          
    397              while (currentBytesRead != byteCount)
    398              {
    399                  endTicks = microseconds_get_ticks();
    400                  deltaTicks = endTicks - startTicks;
    401          
    402                  // Check timer roll over
    403                  if (endTicks < startTicks)
    404                  {
    405                      deltaTicks = endTicks + (~startTicks) + 1;
    406                  }
    407          
    408                  if (timeOutTicks && (deltaTicks >= timeOutTicks))
    409                  {
    410                      return kStatus_Timeout;
    411                  }
    412          
    413                  if (g_serialContext.readOffset != g_serialContext.writeOffset)
   \                     ??read_data_1: (+1)
   \   0000002A   0x6870             LDR      R0,[R6, #+4]
   \   0000002C   0x6831             LDR      R1,[R6, #+0]
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD00C             BEQ.N    ??read_data_2
    414                  {
    415                      buffer[currentBytesRead++] = g_serialContext.callbackBuffer[g_serialContext.readOffset++];
   \   00000032   0x4450             ADD      R0,R10,R0
   \   00000034   0x9900             LDR      R1,[SP, #+0]
   \   00000036   0xF890 0x0020      LDRB     R0,[R0, #+32]
   \   0000003A   0x55C8             STRB     R0,[R1, R7]
   \   0000003C   0x1C7F             ADDS     R7,R7,#+1
    416          
    417                      g_serialContext.readOffset &= kCallbackBufferSize - 1;
   \   0000003E   0x6870             LDR      R0,[R6, #+4]
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \   00000042   0xF000 0x003F      AND      R0,R0,#0x3F
   \   00000046   0x6070             STR      R0,[R6, #+4]
    418                  }
   \                     ??read_data_0: (+1)
   \   00000048   0x455F             CMP      R7,R11
   \   0000004A   0xD01C             BEQ.N    ??read_data_3
   \                     ??read_data_2: (+1)
   \   0000004C   0x.... 0x....      BL       microseconds_get_ticks
   \   00000050   0x1B02             SUBS     R2,R0,R4
   \   00000052   0xEB61 0x0305      SBC      R3,R1,R5
   \   00000056   0x42A9             CMP      R1,R5
   \   00000058   0xD809             BHI.N    ??read_data_4
   \   0000005A   0xBF28             IT       CS 
   \   0000005C   0x42A0             CMPCS    R0,R4
   \   0000005E   0xD206             BCS.N    ??read_data_4
   \   00000060   0x43E2             MVNS     R2,R4
   \   00000062   0x43EB             MVNS     R3,R5
   \   00000064   0x1810             ADDS     R0,R2,R0
   \   00000066   0x4159             ADCS     R1,R3,R1
   \   00000068   0x1C42             ADDS     R2,R0,#+1
   \   0000006A   0xF161 0x33FF      SBC      R3,R1,#-1
   \                     ??read_data_4: (+1)
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x4581             CMP      R9,R0
   \   00000072   0xBF08             IT       EQ 
   \   00000074   0x4580             CMPEQ    R8,R0
   \   00000076   0xD0D8             BEQ.N    ??read_data_1
   \   00000078   0x454B             CMP      R3,R9
   \   0000007A   0xD3D6             BCC.N    ??read_data_1
   \   0000007C   0xD801             BHI.N    ??read_data_5
   \   0000007E   0x4542             CMP      R2,R8
   \   00000080   0xD3D3             BCC.N    ??read_data_1
   \                     ??read_data_5: (+1)
   \   00000082   0x2005             MOVS     R0,#+5
   \   00000084   0xE000             B.N      ??read_data_6
    419              }
    420          
    421              return kStatus_Success;
   \                     ??read_data_3: (+1)
   \   00000086   0x2000             MOVS     R0,#+0
   \                     ??read_data_6: (+1)
   \   00000088   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    422          #endif
    423          }
    424          
    425          //! @brief Read from peripheral until entire data framing packet read.

   \                                 In section .text, align 2, keep-with-next
    426          static status_t read_data_packet(framing_data_packet_t *packet, uint8_t *data, packet_type_t packetType)
    427          {
   \                     read_data_packet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4616             MOV      R6,R2
    428              // Read the packet header.
    429              status_t status = read_header(&packet->header);
   \   0000000A   0x.... 0x....      BL       read_header
    430              if (status != kStatus_Success)
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD131             BNE.N    ??read_data_packet_0
    431              {
    432                  return status;
    433              }
    434          
    435              if (packet->header.packetType == kFramingPacketType_Ping)
   \   00000012   0x7868             LDRB     R0,[R5, #+1]
   \   00000014   0x4601             MOV      R1,R0
   \   00000016   0x29A6             CMP      R1,#+166
   \   00000018   0xD104             BNE.N    ??read_data_packet_1
    436              {
    437                  return serial_send_ping_response(g_bootloaderContext.activePeripheral);
   \   0000001A   0x....             LDR.N    R0,??DataTable18_2
   \   0000001C   0x69C0             LDR      R0,[R0, #+28]
   \   0000001E   0x.... 0x....      BL       serial_send_ping_response
   \   00000022   0xBD76             POP      {R1,R2,R4-R6,PC}
    438              }
    439          
    440              uint8_t expectedPacketType = kFramingPacketType_Command;
   \                     ??read_data_packet_1: (+1)
   \   00000024   0x22A4             MOVS     R2,#+164
    441          
    442              if (packetType != kPacketType_Command)
   \   00000026   0xB106             CBZ.N    R6,??read_data_packet_2
    443              {
    444                  expectedPacketType = kFramingPacketType_Data;
   \   00000028   0x22A5             MOVS     R2,#+165
    445              }
    446              if (packet->header.packetType != expectedPacketType)
   \                     ??read_data_packet_2: (+1)
   \   0000002A   0x4290             CMP      R0,R2
   \   0000002C   0xD005             BEQ.N    ??read_data_packet_3
    447              {
    448                  debug_printf("Error: read_data_packet found unexpected packet type 0x%x\r\n", packet->header.packetType);
   \   0000002E   0x.... 0x....      ADR.W    R0,?_6
   \   00000032   0x.... 0x....      BL       debug_printf
    449                  return kStatus_Fail;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xBD76             POP      {R1,R2,R4-R6,PC}
    450              }
    451          
    452              // Read the packet length.
    453              status = read_length(packet);
   \                     ??read_data_packet_3: (+1)
   \   0000003A   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000003E   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000042   0x8069             STRH     R1,[R5, #+2]
    454              if (status != kStatus_Success)
   \   00000044   0xB9B8             CBNZ.N   R0,??read_data_packet_0
    455              {
    456                  return status;
    457              }
    458          
    459              // Make sure the packet doesn't exceed the allocated buffer size.
    460              packet->length = MIN(kIncomingPacketBufferSize, packet->length);
   \   00000046   0x4608             MOV      R0,R1
   \   00000048   0x2821             CMP      R0,#+33
   \   0000004A   0xBFA8             IT       GE 
   \   0000004C   0x2020             MOVGE    R0,#+32
   \   0000004E   0x8068             STRH     R0,[R5, #+2]
    461          
    462              // Read the crc
    463              status = read_crc16(packet);
   \   00000050   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000054   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000058   0x80A9             STRH     R1,[R5, #+4]
    464              if (status != kStatus_Success)
   \   0000005A   0xB960             CBNZ.N   R0,??read_data_packet_0
    465              {
    466                  return status;
    467              }
    468          
    469              // Read the data.
    470              if (packet->length > 0)
   \   0000005C   0x8869             LDRH     R1,[R5, #+2]
   \   0000005E   0x000A             MOVS     R2,R1
   \   00000060   0xD009             BEQ.N    ??read_data_packet_0
    471              {
    472                  // Clear the data area so unsent parameters default to zero.
    473                  memset(data, 0, packet->length);
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       __aeabi_memclr
    474          
    475                  status = read_data(data, packet->length, kDefaultByteReadTimeoutMs * packet->length);
   \   00000068   0x8869             LDRH     R1,[R5, #+2]
   \   0000006A   0x200A             MOVS     R0,#+10
   \   0000006C   0xFB00 0xF201      MUL      R2,R0,R1
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0x.... 0x....      BL       read_data
    476              }
    477          
    478              return status;
   \                     ??read_data_packet_0: (+1)
   \   00000076   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    479          }
    480          
    481          //! @brief Read from peripheral until start byte found.
    482          static status_t read_start_byte(framing_header_t *header)
    483          {
    484          #if defined(BOOTLOADER_HOST)
    485              uint32_t startByteReadCount = 0;
    486          #endif
    487          
    488              // Read until start byte found.
    489              do
    490              {
    491                  status_t status = read_data(&header->startByte, 1, 0); // no timeout for first byte of packet
    492                  if (status != kStatus_Success)
    493                  {
    494                      return status;
    495                  }
    496          
    497          #if defined(BOOTLOADER_HOST)
    498                  if (startByteReadCount++ > kHostMaxStartByteReadCount)
    499                  {
    500                      return kStatus_Timeout;
    501                  }
    502          
    503                  if (header->startByte != kFramingPacketStartByte)
    504                  {
    505                      // This will keep us from doing non necessary delays in case the byte received
    506                      // is actually the start byte, this delay and retry scenario is for cases when waiting
    507                      // for a response from a device that was issued a long running command like a flash-erase-region
    508                      // that may take several seconds to complete.
    509                      host_delay(kDefaultByteReadTimeoutMs);
    510                  }
    511          #endif
    512              } while (header->startByte != kFramingPacketStartByte);
    513          
    514              return kStatus_Success;
    515          }
    516          
    517          //! @brief Read from peripheral until packet header found.

   \                                 In section .text, align 2, keep-with-next
    518          static status_t read_header(framing_header_t *header)
    519          {
   \                     read_header: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    520              // Wait for start byte.
    521              status_t status = read_start_byte(header);
   \                     ??read_header_0: (+1)
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       read_data
   \   0000000E   0xB940             CBNZ.N   R0,??read_header_1
    522              if (status != kStatus_Success)
    523              {
    524                  return status;
   \   00000010   0x7820             LDRB     R0,[R4, #+0]
   \   00000012   0x285A             CMP      R0,#+90
   \   00000014   0xD1F6             BNE.N    ??read_header_0
    525              }
    526          
    527              return read_data(&header->packetType, sizeof(header->packetType),
    528                               kDefaultByteReadTimeoutMs * sizeof(header->packetType));
   \   00000016   0x1C60             ADDS     R0,R4,#+1
   \   00000018   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001C   0x220A             MOVS     R2,#+10
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x....             B.N      read_data
   \                     ??read_header_1: (+1)
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    529          }
    530          
    531          //! @brief Read from peripheral until packet length found.
    532          static status_t read_length(framing_data_packet_t *packet)
    533          {
    534              union
    535              {
    536                  uint8_t bytes[sizeof(uint16_t)];
    537                  uint16_t halfword;
    538              } buffer;
    539          
    540              status_t status = read_data((uint8_t *)&buffer.bytes, sizeof(buffer), kDefaultByteReadTimeoutMs * sizeof(buffer));
    541          
    542              packet->length = buffer.halfword;
    543              return status;
    544          }
    545          
    546          //! @brief Read from peripheral until crc16 is found.
    547          static status_t read_crc16(framing_data_packet_t *packet)
    548          {
    549              union
    550              {
    551                  uint8_t bytes[sizeof(uint16_t)];
    552                  uint16_t halfword;
    553              } buffer;
    554          
    555              status_t status = read_data((uint8_t *)&buffer.bytes, sizeof(buffer), kDefaultByteReadTimeoutMs * sizeof(buffer));
    556          
    557              packet->crc16 = buffer.halfword;
    558              return status;
    559          }
    560          
    561          //! @brief Calculate crc over framing data packet.

   \                                 In section .text, align 2, keep-with-next
    562          static uint16_t calculate_framing_crc16(framing_data_packet_t *packet, const uint8_t *data)
    563          {
   \                     calculate_framing_crc16: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    564              uint16_t crc16;
    565          
    566              // Initialize the CRC16 information
    567              crc16_data_t crcInfo;
    568              crc16_init(&crcInfo);
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x.... 0x....      BL       crc16_init
    569          
    570              // Run CRC on all header bytes besides the CRC field
    571              crc16_update(&crcInfo, (uint8_t *)&packet->header.startByte, sizeof(framing_data_packet_t) - sizeof(uint16_t));
   \   0000000E   0x2204             MOVS     R2,#+4
   \   00000010   0x4621             MOV      R1,R4
   \   00000012   0x4668             MOV      R0,SP
   \   00000014   0x.... 0x....      BL       crc16_update
    572          
    573              // Continue running CRC on any payload bytes
    574              crc16_update(&crcInfo, data, packet->length);
   \   00000018   0x8862             LDRH     R2,[R4, #+2]
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0x4668             MOV      R0,SP
   \   0000001E   0x.... 0x....      BL       crc16_update
    575          
    576              // Finalize the CRC calculations
    577              crc16_finalize(&crcInfo, &crc16);
   \   00000022   0xA901             ADD      R1,SP,#+4
   \   00000024   0x4668             MOV      R0,SP
   \   00000026   0x.... 0x....      BL       crc16_finalize
    578          
    579              return crc16;
   \   0000002A   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   0000002E   0xBD3E             POP      {R1-R5,PC}       ;; return
    580          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     g_serialContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     g_serialContext+0x90

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x........         DC32     g_bootloaderContext

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x2214             MOVS     R2,#+20
   \   00000002   0x2102             MOVS     R1,#+2
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x....             B.N      read_data

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x45 0x72          DC8 "Error: invalid packet\015\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x69    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x70    
   \              0x61 0x63    
   \              0x6B 0x65    
   \              0x74 0x0D    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x45 0x72          DC8 "Error: invalid crc 0x%x, expected 0x%x\015\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x69    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x63    
   \              0x72 0x63    
   \              0x20 0x30    
   \              0x78 0x25    
   \              0x78 0x2C    
   \              0x20 0x65    
   \              0x78 0x70    
   \              0x65 0x63    
   \              0x74 0x65    
   \              0x64 0x20    
   \              0x30 0x78    
   \              0x25 0x78    
   \              0x0D 0x0A    
   \              0x00         
   \   00000029   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x45 0x72          DC8 "Error: invalid packet or packet size %d\015\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x69    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x70    
   \              0x61 0x63    
   \              0x6B 0x65    
   \              0x74 0x20    
   \              0x6F 0x72    
   \              0x20 0x70    
   \              0x61 0x63    
   \              0x6B 0x65    
   \              0x74 0x20    
   \              0x73 0x69    
   \              0x7A 0x65    
   \              0x20 0x25    
   \              0x64 0x0D    
   \              0x0A 0x00    
   \   0000002A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x45 0x72          DC8 45H, 72H, 72H, 6FH, 72H, 3AH, 20H, 63H
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x63    
   \   00000008   0x61 0x6E          DC8 61H, 6EH, 6EH, 6FH, 74H, 20H, 73H, 65H
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x73 0x65    
   \   00000010   0x6E 0x64          DC8 6EH, 64H, 20H, 73H, 79H, 6EH, 63H, 20H
   \              0x20 0x73    
   \              0x79 0x6E    
   \              0x63 0x20    
   \   00000018   0x70 0x61          DC8 70H, 61H, 63H, 6BH, 65H, 74H, 20H, 30H
   \              0x63 0x6B    
   \              0x65 0x74    
   \              0x20 0x30    
   \   00000020   0x78 0x25          DC8 78H, 25H, 78H, 2CH, 20H, 73H, 74H, 61H
   \              0x78 0x2C    
   \              0x20 0x73    
   \              0x74 0x61    
   \   00000028   0x74 0x75          DC8 74H, 75H, 73H, 20H, 3DH, 20H, 30H, 78H
   \              0x73 0x20    
   \              0x3D 0x20    
   \              0x30 0x78    
   \   00000030   0x25 0x78          DC8 25H, 78H, 0DH, 0AH, 0
   \              0x0D 0x0A    
   \              0x00         
   \   00000035   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x45 0x72          DC8 45H, 72H, 72H, 6FH, 72H, 3AH, 20H, 55H
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x55    
   \   00000008   0x6E 0x65          DC8 6EH, 65H, 78H, 70H, 65H, 63H, 74H, 65H
   \              0x78 0x70    
   \              0x65 0x63    
   \              0x74 0x65    
   \   00000010   0x64 0x20          DC8 64H, 20H, 73H, 79H, 6EH, 63H, 20H, 62H
   \              0x73 0x79    
   \              0x6E 0x63    
   \              0x20 0x62    
   \   00000018   0x79 0x74          DC8 79H, 74H, 65H, 20H, 30H, 78H, 25H, 78H
   \              0x65 0x20    
   \              0x30 0x78    
   \              0x25 0x78    
   \   00000020   0x20 0x72          DC8 20H, 72H, 65H, 63H, 65H, 69H, 76H, 65H
   \              0x65 0x63    
   \              0x65 0x69    
   \              0x76 0x65    
   \   00000028   0x64 0x2C          DC8 64H, 2CH, 20H, 65H, 78H, 70H, 65H, 63H
   \              0x20 0x65    
   \              0x78 0x70    
   \              0x65 0x63    
   \   00000030   0x74 0x65          DC8 74H, 65H, 64H, 20H, 41H, 63H, 6BH, 2CH
   \              0x64 0x20    
   \              0x41 0x63    
   \              0x6B 0x2C    
   \   00000038   0x20 0x41          DC8 20H, 41H, 63H, 6BH, 41H, 62H, 6FH, 72H
   \              0x63 0x6B    
   \              0x41 0x62    
   \              0x6F 0x72    
   \   00000040   0x74 0x20          DC8 74H, 20H, 6FH, 72H, 20H, 4EH, 61H, 6BH
   \              0x6F 0x72    
   \              0x20 0x4E    
   \              0x61 0x6B    
   \   00000048   0x0D 0x0A          DC8 0DH, 0AH, 0
   \              0x00         
   \   0000004B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x5A 0xA7          DC8 90, 167

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x45 0x72          DC8 45H, 72H, 72H, 6FH, 72H, 3AH, 20H, 72H
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x72    
   \   00000008   0x65 0x61          DC8 65H, 61H, 64H, 5FH, 64H, 61H, 74H, 61H
   \              0x64 0x5F    
   \              0x64 0x61    
   \              0x74 0x61    
   \   00000010   0x5F 0x70          DC8 5FH, 70H, 61H, 63H, 6BH, 65H, 74H, 20H
   \              0x61 0x63    
   \              0x6B 0x65    
   \              0x74 0x20    
   \   00000018   0x66 0x6F          DC8 66H, 6FH, 75H, 6EH, 64H, 20H, 75H, 6EH
   \              0x75 0x6E    
   \              0x64 0x20    
   \              0x75 0x6E    
   \   00000020   0x65 0x78          DC8 65H, 78H, 70H, 65H, 63H, 74H, 65H, 64H
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \   00000028   0x20 0x70          DC8 20H, 70H, 61H, 63H, 6BH, 65H, 74H, 20H
   \              0x61 0x63    
   \              0x6B 0x65    
   \              0x74 0x20    
   \   00000030   0x74 0x79          DC8 74H, 79H, 70H, 65H, 20H, 30H, 78H, 25H
   \              0x70 0x65    
   \              0x20 0x30    
   \              0x78 0x25    
   \   00000038   0x78 0x0D          DC8 78H, 0DH, 0AH, 0
   \              0x0A 0x00    
    581          
    582          //! @}
    583          
    584          ////////////////////////////////////////////////////////////////////////////////
    585          // EOF
    586          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   calculate_framing_crc16
        24   -> crc16_finalize
        24   -> crc16_init
        24   -> crc16_update
      16   debug_printf
        16   -> vprintf
      40   read_data
        40   -> microseconds_convert_to_ticks
        40   -> microseconds_get_ticks
      24   read_data_packet
        24   -> __aeabi_memclr
        24   -> debug_printf
        24   -> read_data
        24   -> read_header
        24   -> serial_send_ping_response
       8   read_header
         0   -> read_data
         8   -> read_data
       0   send_deferred_ack
         0   -> serial_packet_send_sync
       0   serial_packet_abort
       0   serial_packet_finalize
         0   -> send_deferred_ack
       0   serial_packet_get_max_packet_size
       0   serial_packet_init
       0   serial_packet_queue_byte
      40   serial_packet_read
        40   -> __aeabi_memclr4
        40   -> calculate_framing_crc16
        40   -> debug_printf
        40   -> read_data_packet
        40   -> send_deferred_ack
        40   -> serial_packet_send_sync
      16   serial_packet_send_sync
        16   -> debug_printf
        16   -> write_data
      32   serial_packet_write
        32   -> __aeabi_memcpy
        32   -> calculate_framing_crc16
        32   -> debug_printf
        32   -> read_header
        32   -> send_deferred_ack
        32   -> write_data
      16   serial_send_ping_response
        16   -- Indirect call
       0   write_data
         0   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       8  ?Subroutine0
      24  ?_0
      44  ?_1
      44  ?_2
      56  ?_3
      76  ?_4
       2  ?_5
      60  ?_6
      48  calculate_framing_crc16
      14  debug_printf
      28  g_framingPacketInterface
     148  g_serialContext
       8  k_PingResponse
     140  read_data
     120  read_data_packet
      36  read_header
      30  send_deferred_ack
      12  serial_packet_abort
       2  serial_packet_finalize
       4  serial_packet_get_max_packet_size
       4  serial_packet_init
      32  serial_packet_queue_byte
     128  serial_packet_read
      54  serial_packet_send_sync
     172  serial_packet_write
      62  serial_send_ping_response
      16  write_data

 
   148 bytes in section .bss
    28 bytes in section .rodata
 1 208 bytes in section .text
 
 1 208 bytes of CODE  memory
    28 bytes of CONST memory
   148 bytes of DATA  memory

Errors: none
Warnings: none
