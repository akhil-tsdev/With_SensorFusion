###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Aug/2016  15:48:59
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bm_usb\usb_descriptor.c
#    Command line =  
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bm_usb\usb_descriptor.c"
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN512VDC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -lC
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\obj"
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform/devices/MK22F51212\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/osa\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/device\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/device/class\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/bm_usb\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform/devices\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/common\"
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\list\usb_descriptor.lst
#    Object file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\obj\usb_descriptor.o
#
###############################################################################

C:\Users\cwati\Documents\My Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bm_usb\usb_descriptor.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "usb_device_config.h"
     32          #include "usb.h"
     33          #include "usb_device.h"
     34          
     35          #include "usb_device_class.h"
     36          #include "usb_device_hid.h"
     37          #include "usb_device_msc.h"
     38          #include "bootloader_hid_report_ids.h"
     39          
     40          #include "usb_descriptor.h"
     41          
     42          #define BL_MIN_PACKET_SIZE (32)
     43          #define BL_PACKET_SIZE_HEADER_SIZE (3) // alignment byte + length lsb + length msb (does not include report id)
     44          #define BL_REPORT_SIZE (BL_MIN_PACKET_SIZE + BL_PACKET_SIZE_HEADER_SIZE)
     45          
     46          /* hidtc data buffer out report descriptor */
     47          #define HID_USAGE_HIDTC_DATA_OUT(__id, __count, __size)          \
     48              0x85, ((uint8_t)(__id)),        /*	 REPORT_ID (__id) */      \
     49                  0x19, 0x01,                 /*   USAGE_MINIMUM (1)*/     \
     50                  0x29, 0x01,                 /*   USAGE_MAXIMUM (1)*/     \
     51                  0x15, 0x00,                 /*   LOGICAL_MINIMUM (0)*/   \
     52                  0x26, 0xff, 0x00,           /*   LOGICAL_MAXIMUM (255)*/ \
     53                  0x75, ((uint8_t)(__size)),  /*	 REPORT_SIZE (n)*/        \
     54                  0x95, ((uint8_t)(__count)), /*	 REPORT_COUNT (n)*/       \
     55                  0x91, 0x02                  /*   OUTPUT (Data,Var,Abs) */
     56          
     57          /* hidtc data buffer in report descriptor */
     58          #define HID_USAGE_HIDTC_DATA_IN(__id, __count, __size)           \
     59              0x85, ((uint8_t)(__id)),        /*	 REPORT_ID (__id) */      \
     60                  0x19, 0x01,                 /*   USAGE_MINIMUM (1)*/     \
     61                  0x29, 0x01,                 /*   USAGE_MAXIMUM (1)*/     \
     62                  0x15, 0x00,                 /*   LOGICAL_MINIMUM (0)*/   \
     63                  0x26, 0xff, 0x00,           /*   LOGICAL_MAXIMUM (255)*/ \
     64                  0x75, ((uint8_t)(__size)),  /*	 REPORT_SIZE (n)*/        \
     65                  0x95, ((uint8_t)(__count)), /*	 REPORT_COUNT (n)*/       \
     66                  0x81, 0x02                  /*   INPUT (Data,Var,Abs) */
     67          
     68          /* hid device information */
     69          /* hid generic endpoint information */

   \                                 In section .data, align 4
     70          usb_device_endpoint_struct_t g_hid_generic_endpoints[USB_HID_GENERIC_ENDPOINT_COUNT] = {
   \                     g_hid_generic_endpoints:
   \   00000000   0x81 0x03          DC8 129, 3
   \   00000002   0x0040             DC16 64
   \   00000004   0x02 0x03          DC8 2, 3
   \   00000006   0x0040             DC16 64
     71              /* HID generic interrupt IN pipe */
     72              {
     73                  USB_HID_GENERIC_ENDPOINT_IN | (USB_IN << 7), USB_ENDPOINT_INTERRUPT, FS_HID_GENERIC_INTERRUPT_IN_PACKET_SIZE,
     74              },
     75              /* HID generic interrupt OUT pipe */
     76              {
     77                  USB_HID_GENERIC_ENDPOINT_OUT | (USB_OUT << 7), USB_ENDPOINT_INTERRUPT, FS_HID_GENERIC_INTERRUPT_OUT_PACKET_SIZE,
     78              }
     79          };
     80          
     81          /* HID generic interface information */
     82          usb_device_interface_struct_t g_hid_generic_interface[] = { {
     83              0, /* The alternate setting of the interface */
     84              {
     85                  USB_HID_GENERIC_ENDPOINT_COUNT, /* Endpoint count */
     86                  g_hid_generic_endpoints,        /* Endpoints handle */
     87              },
     88          } };
     89          
     90          usb_device_interfaces_struct_t g_hid_generic_interfaces[USB_HID_GENERIC_INTERFACE_COUNT] = { {
     91              USB_HID_GENERIC_CLASS,           /* HID generic class code */
     92              USB_HID_GENERIC_SUBCLASS,        /* HID generic subclass code */
     93              USB_HID_GENERIC_PROTOCOL,        /* HID generic protocol code */
     94              USB_HID_GENERIC_INTERFACE_INDEX, /* The interface number of the HID generic */
     95              g_hid_generic_interface,         /* Interfaces handle */
     96              sizeof(g_hid_generic_interface) / sizeof(usb_device_interfaces_struct_t),
     97          } };
     98          
     99          usb_device_interface_list_t g_hid_generic_interface_list[USB_CONFIGURE_COUNT] = {
    100              {
    101                  USB_HID_GENERIC_INTERFACE_COUNT, /* The interface count of the HID generic */
    102                  g_hid_generic_interfaces,        /* The interfaces handle */
    103              },
    104          };
    105          
    106          usb_device_class_struct_t g_hid_generic_class = {
    107              g_hid_generic_interface_list, /* The interface list of the HID generic */
    108              kUSB_DeviceClassTypeHid,      /* The HID class type */
    109              USB_CONFIGURE_COUNT,          /* The configuration count */
    110          };
    111          
    112          /* msc disk information */
    113          /* Define endpoint for MSC class */
    114          usb_device_endpoint_struct_t g_msc_disk_endpoints[USB_MSC_ENDPOINT_COUNT] = {
   \                     g_msc_disk_endpoints:
   \   00000008   0x83 0x02          DC8 131, 2
   \   0000000A   0x0040             DC16 64
   \   0000000C   0x04 0x02          DC8 4, 2
   \   0000000E   0x0040             DC16 64

   \                                 In section .data, align 4
   \                     g_hid_generic_interface:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 2, 0, 0, 0
   \              0x00 0x00    
   \              0x02 0x00    
   \              0x00 0x00    
   \   00000008   0x........         DC32 g_hid_generic_endpoints
   \   0000000C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .data, align 4
   \                     g_hid_generic_interfaces:
   \   00000000   0x03 0x00          DC8 3, 0, 0, 0
   \              0x00 0x00    
   \   00000004   0x........         DC32 g_hid_generic_interface
   \   00000008   0x01 0x00          DC8 1, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .data, align 4
   \                     g_hid_generic_interface_list:
   \   00000000   0x01 0x00          DC8 1, 0, 0, 0
   \              0x00 0x00    
   \   00000004   0x........         DC32 g_hid_generic_interfaces

   \                                 In section .data, align 4
   \                     g_hid_generic_class:
   \   00000000   0x........         DC32 g_hid_generic_interface_list
   \   00000004   0x01 0x01          DC8 1, 1, 0, 0
   \              0x00 0x00    
    115              {
    116                  USB_MSC_BULK_IN_ENDPOINT | (USB_IN << 7), USB_ENDPOINT_BULK, FS_BULK_IN_PACKET_SIZE,
    117              },
    118              {
    119                  USB_MSC_BULK_OUT_ENDPOINT | (USB_OUT << 7), USB_ENDPOINT_BULK, FS_BULK_OUT_PACKET_SIZE,
    120              }
    121          };
    122          
    123          /* Define interface for MSC class */

   \                                 In section .data, align 4
    124          usb_device_interface_struct_t g_msc_disk_interface[] = { {
   \                     g_msc_disk_interface:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 2, 0, 0, 0
   \              0x00 0x00    
   \              0x02 0x00    
   \              0x00 0x00    
   \   00000008   0x........         DC32 g_msc_disk_endpoints
   \   0000000C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    125              0,
    126              {
    127                  USB_MSC_ENDPOINT_COUNT, g_msc_disk_endpoints,
    128              },
    129          } };
    130          
    131          /* Define interfaces for MSC disk */

   \                                 In section .data, align 4
    132          usb_device_interfaces_struct_t g_msc_disk_interfaces[USB_MSC_INTERFACE_COUNT] = { {
   \                     g_msc_disk_interfaces:
   \   00000000   0x08 0x06          DC8 8, 6, 80, 1
   \              0x50 0x01    
   \   00000004   0x........         DC32 g_msc_disk_interface
   \   00000008   0x01 0x00          DC8 1, 0, 0, 0
   \              0x00 0x00    
    133              USB_MSC_CLASS, USB_MSC_SUBCLASS, USB_MSC_PROTOCOL, USB_MSC_INTERFACE_INDEX, g_msc_disk_interface,
    134              sizeof(g_msc_disk_interface) / sizeof(usb_device_interfaces_struct_t),
    135          } };
    136          
    137          /* Define configurations for MSC disk */

   \                                 In section .data, align 4
    138          usb_device_interface_list_t g_msc_disk_interface_list[USB_CONFIGURE_COUNT] = {
   \                     g_msc_disk_interface_list:
   \   00000000   0x01 0x00          DC8 1, 0, 0, 0
   \              0x00 0x00    
   \   00000004   0x........         DC32 g_msc_disk_interfaces
    139              {
    140                  USB_MSC_INTERFACE_COUNT, g_msc_disk_interfaces,
    141              },
    142          };
    143          
    144          /* Define class information for MSC disk */

   \                                 In section .data, align 4
    145          usb_device_class_struct_t g_msc_class = {
   \                     g_msc_class:
   \   00000000   0x........         DC32 g_msc_disk_interface_list
   \   00000004   0x03 0x01          DC8 3, 1, 0, 0
   \              0x00 0x00    
    146              g_msc_disk_interface_list, kUSB_DeviceClassTypeMsc, USB_CONFIGURE_COUNT,
    147          };
    148          

   \                                 In section .data, align 4
    149          uint8_t g_hid_generic_report_descriptor[USB_HID_REPORT_DESC_SIZE] = {
   \                     g_hid_generic_report_descriptor:
   \   00000000   0x06 0x00          DC8 6, 0, 255, 9, 1, 161, 1, 133, 1, 25, 1, 41, 1, 21, 0, 38, 255, 0
   \              0xFF 0x09    
   \              0x01 0xA1    
   \              0x01 0x85    
   \              0x01 0x19    
   \              0x01 0x29    
   \              0x01 0x15    
   \              0x00 0x26    
   \              0xFF 0x00    
   \   00000012   0x75 0x08          DC8 117, 8, 149, 35, 145, 2, 133, 2, 25, 1, 41, 1, 21, 0, 38, 255, 0
   \              0x95 0x23    
   \              0x91 0x02    
   \              0x85 0x02    
   \              0x19 0x01    
   \              0x29 0x01    
   \              0x15 0x00    
   \              0x26 0xFF    
   \              0x00         
   \   00000023   0x75 0x08          DC8 117, 8, 149, 35, 145, 2, 133, 3, 25, 1, 41, 1, 21, 0, 38, 255, 0
   \              0x95 0x23    
   \              0x91 0x02    
   \              0x85 0x03    
   \              0x19 0x01    
   \              0x29 0x01    
   \              0x15 0x00    
   \              0x26 0xFF    
   \              0x00         
   \   00000034   0x75 0x08          DC8 117, 8, 149, 35, 129, 2, 133, 4, 25, 1, 41, 1, 21, 0, 38, 255, 0
   \              0x95 0x23    
   \              0x81 0x02    
   \              0x85 0x04    
   \              0x19 0x01    
   \              0x29 0x01    
   \              0x15 0x00    
   \              0x26 0xFF    
   \              0x00         
   \   00000045   0x75 0x08          DC8 117, 8, 149, 35, 129, 2, 192
   \              0x95 0x23    
   \              0x81 0x02    
   \              0xC0         
    150              0x06,
    151              0x00,
    152              0xFF, /* Usage Page (Vendor Defined Page 1)*/
    153              0x09,
    154              0x01, /* USAGE (Vendor 1) */
    155              0xA1,
    156              0x01, /* Collection (Application) */
    157              HID_USAGE_HIDTC_DATA_OUT(kBootloaderReportID_CommandOut, BL_REPORT_SIZE, 8),
    158              HID_USAGE_HIDTC_DATA_OUT(kBootloaderReportID_DataOut, BL_REPORT_SIZE, 8),
    159              HID_USAGE_HIDTC_DATA_IN(kBootloaderReportID_CommandIn, BL_REPORT_SIZE, 8),
    160              HID_USAGE_HIDTC_DATA_IN(kBootloaderReportID_DataIn, BL_REPORT_SIZE, 8),
    161              0xC0 /* end collection */
    162          };
    163          
    164          /* Define device descriptor */

   \                                 In section .data, align 4
    165          uint8_t g_device_descriptor[USB_DEVICE_DESCRIPTOR_LENGTH] = {
   \                     g_device_descriptor:
   \   00000000   0x12 0x01          DC8 18, 1, 0, 2, 0, 0, 0, 64, 162, 21, 115, 0, 2, 0, 1, 2, 3, 1, 0, 0
   \              0x00 0x02    
   \              0x00 0x00    
   \              0x00 0x40    
   \              0xA2 0x15    
   \              0x73 0x00    
   \              0x02 0x00    
   \              0x01 0x02    
   \              0x03 0x01    
   \              0x00 0x00    
    166              /* "Device Descriptor Size */
    167              USB_DEVICE_DESCRIPTOR_LENGTH,
    168              /* "Device" Type of descriptor */
    169              USB_DESCRIPTOR_TYPE_DEVICE,
    170              /*  BCD USB version  */
    171              USB_SHORT_GET_LOW(USB_BCD_VERSION), USB_SHORT_GET_HIGH(USB_BCD_VERSION),
    172              /* Device Class is indicated in the interface descriptors */
    173              USB_DEVICE_CLASS,
    174              /*  Device Subclass is indicated in the interface descriptors  */
    175              USB_DEVICE_SUBCLASS,
    176              /*  Device Protocol  */
    177              USB_DEVICE_PROTOCOL,
    178              /* Max Packet size */
    179              USB_CONTROL_MAX_PACKET_SIZE,
    180              /* Vendor ID */
    181              0xa2, 0x15, /*  Vendor ID for Freescale       */
    182              /* Product ID */
    183              0x73, 0x00, /* 0x73,0x00,ProductID for KL25Z48M */
    184              /* BCD Device version */
    185              0x02, 0x00,
    186              /* Manufacturer string index */
    187              0x01,
    188              /* Product string index */
    189              0x02,
    190          /*  Serial number string index */
    191          #if (USB_DEVICE_CONFIG_MSC > 0)
    192              0x03,
    193          #else
    194              0x00,
    195          #endif
    196              /*  Number of configurations */
    197              USB_CONFIGURE_COUNT,
    198          };
    199          
    200          /* Define configuration descriptor */

   \                                 In section .data, align 4
    201          uint8_t g_config_descriptor[USB_CONFIGURE_DESCRIPTOR_LENGTH] = {
   \                     g_config_descriptor:
   \   00000000   0x09 0x02          DC8 9, 2, 64, 0, 2, 1, 0, 192, 50, 9, 4, 0, 0, 2, 3, 0, 0, 3, 9, 33, 0
   \              0x40 0x00    
   \              0x02 0x01    
   \              0x00 0xC0    
   \              0x32 0x09    
   \              0x04 0x00    
   \              0x00 0x02    
   \              0x03 0x00    
   \              0x00 0x03    
   \              0x09 0x21    
   \              0x00         
   \   00000015   0x01 0x00          DC8 1, 0, 1, 34, 76, 0, 7, 5, 129, 3, 64, 0, 1, 7, 5, 2, 3, 64, 0, 1, 9
   \              0x01 0x22    
   \              0x4C 0x00    
   \              0x07 0x05    
   \              0x81 0x03    
   \              0x40 0x00    
   \              0x01 0x07    
   \              0x05 0x02    
   \              0x03 0x40    
   \              0x00 0x01    
   \              0x09         
   \   0000002A   0x04 0x01          DC8 4, 1, 0, 2, 8, 6, 80, 3, 7, 5, 131, 2, 64, 0, 0, 7, 5, 4, 2, 64, 0
   \              0x00 0x02    
   \              0x08 0x06    
   \              0x50 0x03    
   \              0x07 0x05    
   \              0x83 0x02    
   \              0x40 0x00    
   \              0x00 0x07    
   \              0x05 0x04    
   \              0x02 0x40    
   \              0x00         
   \   0000003F   0x00               DC8 0
    202              /* Configuration Descriptor Size*/
    203              USB_CONFIGURE_ONLY_DESCRIPTOR_LENGTH,
    204              /* "Configuration" type of descriptor */
    205              USB_DESCRIPTOR_TYPE_CONFIGURE,
    206              /*  Total length of the Configuration descriptor */
    207              USB_SHORT_GET_LOW(USB_CONFIGURE_DESCRIPTOR_LENGTH), USB_SHORT_GET_HIGH(USB_CONFIGURE_DESCRIPTOR_LENGTH),
    208              /*  NumInterfaces */
    209              USB_COMPOSITE_INTERFACE_COUNT,
    210              /*  Configuration Value */
    211              USB_COMPOSITE_CONFIGURE_INDEX,
    212              /* Configuration Description String Index */
    213              0,
    214              /*  Attributes.support RemoteWakeup and self power */
    215              (USB_DESCRIPTOR_CONFIGURE_ATTRIBUTE_D7_MASK) |
    216                  (USB_DEVICE_CONFIG_SELF_POWER << USB_DESCRIPTOR_CONFIGURE_ATTRIBUTE_SELF_POWERED_SHIFT) |
    217                  (USB_DEVICE_CONFIG_REMOTE_WAKEUP << USB_DESCRIPTOR_CONFIGURE_ATTRIBUTE_REMOTE_WAKEUP_SHIFT),
    218              /*  Current draw from bus */
    219              USB_CONFIGURE_DRAWN,
    220          
    221          #if USB_DEVICE_CONFIG_HID
    222              /* Interface Descriptor */
    223              USB_INTERFACE_DESCRIPTOR_LENGTH, USB_DESCRIPTOR_TYPE_INTERFACE, USB_HID_GENERIC_INTERFACE_INDEX, 0x00,
    224              USB_HID_GENERIC_ENDPOINT_COUNT, USB_HID_GENERIC_CLASS, USB_HID_GENERIC_SUBCLASS, USB_HID_GENERIC_PROTOCOL, 0x03,
    225          
    226              /* HID descriptor */
    227              USB_HID_DESCRIPTOR_LENGTH, USB_DESCRIPTOR_TYPE_HID, 0x00, 0x01, 0x00, 0x01, USB_DESCRIPTOR_TYPE_HID_REPORT,
    228              USB_SHORT_GET_LOW(USB_HID_REPORT_DESC_SIZE), USB_SHORT_GET_HIGH(USB_HID_REPORT_DESC_SIZE),
    229          
    230              /*Endpoint descriptor */
    231              USB_ENDPOINT_DESCRIPTOR_LENGTH, USB_DESCRIPTOR_TYPE_ENDPOINT, USB_HID_GENERIC_ENDPOINT_IN | (USB_IN << 7),
    232              USB_ENDPOINT_INTERRUPT, FS_HID_GENERIC_INTERRUPT_IN_PACKET_SIZE, 0x00, FS_HID_GENERIC_INTERRUPT_IN_INTERVAL,
    233          
    234              /*Endpoint descriptor */
    235              USB_ENDPOINT_DESCRIPTOR_LENGTH, USB_DESCRIPTOR_TYPE_ENDPOINT, USB_HID_GENERIC_ENDPOINT_OUT | (USB_OUT << 7),
    236              USB_ENDPOINT_INTERRUPT, FS_HID_GENERIC_INTERRUPT_OUT_PACKET_SIZE, 0x00, FS_HID_GENERIC_INTERRUPT_OUT_INTERVAL,
    237          
    238          #endif // USB_DEVICE_CONFIG_HID
    239          
    240          #if USB_DEVICE_CONFIG_MSC
    241              /* MSC Interface Descriptor */
    242              USB_INTERFACE_DESCRIPTOR_LENGTH, USB_DESCRIPTOR_TYPE_INTERFACE, USB_MSC_INTERFACE_INDEX, 0x00,
    243              USB_MSC_ENDPOINT_COUNT, USB_MSC_CLASS, USB_MSC_SUBCLASS, USB_MSC_PROTOCOL,
    244              0x03, /* Interface Description String Index*/
    245          
    246              /*Bulk IN Endpoint descriptor */
    247              USB_ENDPOINT_DESCRIPTOR_LENGTH, USB_DESCRIPTOR_TYPE_ENDPOINT, USB_MSC_BULK_IN_ENDPOINT | (USB_IN << 7),
    248              USB_ENDPOINT_BULK,
    249          
    250              USB_SHORT_GET_LOW(FS_BULK_IN_PACKET_SIZE), USB_SHORT_GET_HIGH(FS_BULK_IN_PACKET_SIZE),
    251              0x00, /* This value is ignored for Bulk ENDPOINT */
    252          
    253              /*Bulk OUT Endpoint descriptor */
    254              USB_ENDPOINT_DESCRIPTOR_LENGTH, USB_DESCRIPTOR_TYPE_ENDPOINT, USB_MSC_BULK_OUT_ENDPOINT | (USB_OUT << 7),
    255              USB_ENDPOINT_BULK, USB_SHORT_GET_LOW(FS_BULK_OUT_PACKET_SIZE), USB_SHORT_GET_HIGH(FS_BULK_OUT_PACKET_SIZE),
    256              0x00 /* This value is ignored for Bulk ENDPOINT */
    257          #endif   // USB_DEVICE_CONFIG_HID
    258          };
    259          
    260          /* Define string descriptor */

   \                                 In section .data, align 4
    261          uint8_t g_usb_str_0[USB_STRING_DESCRIPTOR_0_LENGTH + USB_STRING_DESCRIPTOR_HEADER_LENGTH] = {
   \                     g_usb_str_0:
   \   00000000   0x04 0x03          DC8 4, 3, 9, 4
   \              0x09 0x04    
    262              sizeof(g_usb_str_0), USB_DESCRIPTOR_TYPE_STRING, 0x09, 0x04
    263          };
    264          

   \                                 In section .data, align 4
    265          uint8_t g_usb_str_1[USB_STRING_DESCRIPTOR_1_LENGTH + USB_STRING_DESCRIPTOR_HEADER_LENGTH] = {
   \                     g_usb_str_1:
   \   00000000   0x3A 0x03          DC8 58, 3, 70, 0, 82, 0, 69, 0, 69, 0, 83, 0, 67, 0, 65, 0, 76, 0, 69
   \              0x46 0x00    
   \              0x52 0x00    
   \              0x45 0x00    
   \              0x45 0x00    
   \              0x53 0x00    
   \              0x43 0x00    
   \              0x41 0x00    
   \              0x4C 0x00    
   \              0x45         
   \   00000013   0x00 0x20          DC8 0, 32, 0, 83, 0, 69, 0, 77, 0, 73, 0, 67, 0, 79, 0, 78, 0, 68, 0
   \              0x00 0x53    
   \              0x00 0x45    
   \              0x00 0x4D    
   \              0x00 0x49    
   \              0x00 0x43    
   \              0x00 0x4F    
   \              0x00 0x4E    
   \              0x00 0x44    
   \              0x00         
   \   00000026   0x55 0x00          DC8 85, 0, 67, 0, 84, 0, 79, 0, 82, 0, 32, 0, 73, 0, 78, 0, 67, 0, 46
   \              0x43 0x00    
   \              0x54 0x00    
   \              0x4F 0x00    
   \              0x52 0x00    
   \              0x20 0x00    
   \              0x49 0x00    
   \              0x4E 0x00    
   \              0x43 0x00    
   \              0x2E         
   \   00000039   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    266              sizeof(g_usb_str_1),
    267              USB_DESCRIPTOR_TYPE_STRING,
    268              'F',
    269              0,
    270              'R',
    271              0,
    272              'E',
    273              0,
    274              'E',
    275              0,
    276              'S',
    277              0,
    278              'C',
    279              0,
    280              'A',
    281              0,
    282              'L',
    283              0,
    284              'E',
    285              0,
    286              ' ',
    287              0,
    288              'S',
    289              0,
    290              'E',
    291              0,
    292              'M',
    293              0,
    294              'I',
    295              0,
    296              'C',
    297              0,
    298              'O',
    299              0,
    300              'N',
    301              0,
    302              'D',
    303              0,
    304              'U',
    305              0,
    306              'C',
    307              0,
    308              'T',
    309              0,
    310              'O',
    311              0,
    312              'R',
    313              0,
    314              ' ',
    315              0,
    316              'I',
    317              0,
    318              'N',
    319              0,
    320              'C',
    321              0,
    322              '.',
    323              0
    324          };
    325          

   \                                 In section .data, align 4
    326          uint8_t g_usb_str_2[USB_STRING_DESCRIPTOR_2_LENGTH + USB_STRING_DESCRIPTOR_HEADER_LENGTH] = {
   \                     g_usb_str_2:
   \   00000000   0x2A 0x03          DC8 42, 3, 85, 0, 83, 0, 66, 0, 32, 0, 67, 0, 79, 0, 77, 0, 80, 0, 79
   \              0x55 0x00    
   \              0x53 0x00    
   \              0x42 0x00    
   \              0x20 0x00    
   \              0x43 0x00    
   \              0x4F 0x00    
   \              0x4D 0x00    
   \              0x50 0x00    
   \              0x4F         
   \   00000013   0x00 0x53          DC8 0, 83, 0, 73, 0, 84, 0, 69, 0, 32, 0, 68, 0, 69, 0, 86, 0, 73, 0
   \              0x00 0x49    
   \              0x00 0x54    
   \              0x00 0x45    
   \              0x00 0x20    
   \              0x00 0x44    
   \              0x00 0x45    
   \              0x00 0x56    
   \              0x00 0x49    
   \              0x00         
   \   00000026   0x43 0x00          DC8 67, 0, 69, 0, 0, 0
   \              0x45 0x00    
   \              0x00 0x00    
    327              sizeof(g_usb_str_2),
    328              USB_DESCRIPTOR_TYPE_STRING,
    329              'U',
    330              0,
    331              'S',
    332              0,
    333              'B',
    334              0,
    335              ' ',
    336              0,
    337              'C',
    338              0,
    339              'O',
    340              0,
    341              'M',
    342              0,
    343              'P',
    344              0,
    345              'O',
    346              0,
    347              'S',
    348              0,
    349              'I',
    350              0,
    351              'T',
    352              0,
    353              'E',
    354              0,
    355              ' ',
    356              0,
    357              'D',
    358              0,
    359              'E',
    360              0,
    361              'V',
    362              0,
    363              'I',
    364              0,
    365              'C',
    366              0,
    367              'E',
    368              0
    369          };
    370          
    371          #if ((USB_DEVICE_CONFIG_MSC > 0U) && (USB_DEVICE_CONFIG_HID > 0U)) // MSC + HID

   \                                 In section .data, align 4
    372          uint8_t g_usb_str_3[USB_STRING_DESCRIPTOR_3_LENGTH + USB_STRING_DESCRIPTOR_HEADER_LENGTH] = {
   \                     g_usb_str_3:
   \   00000000   0x3E 0x03          DC8 62, 3, 77, 0, 67, 0, 85, 0, 32, 0, 77, 0, 83, 0, 67, 0, 32, 0, 65
   \              0x4D 0x00    
   \              0x43 0x00    
   \              0x55 0x00    
   \              0x20 0x00    
   \              0x4D 0x00    
   \              0x53 0x00    
   \              0x43 0x00    
   \              0x20 0x00    
   \              0x41         
   \   00000013   0x00 0x4E          DC8 0, 78, 0, 68, 0, 32, 0, 72, 0, 73, 0, 68, 0, 32, 0, 71, 0, 69, 0
   \              0x00 0x44    
   \              0x00 0x20    
   \              0x00 0x48    
   \              0x00 0x49    
   \              0x00 0x44    
   \              0x00 0x20    
   \              0x00 0x47    
   \              0x00 0x45    
   \              0x00         
   \   00000026   0x4E 0x00          DC8 78, 0, 69, 0, 82, 0, 73, 0, 67, 0, 32, 0, 68, 0, 69, 0, 86, 0, 73
   \              0x45 0x00    
   \              0x52 0x00    
   \              0x49 0x00    
   \              0x43 0x00    
   \              0x20 0x00    
   \              0x44 0x00    
   \              0x45 0x00    
   \              0x56 0x00    
   \              0x49         
   \   00000039   0x00 0x43          DC8 0, 67, 0, 69, 0, 0, 0
   \              0x00 0x45    
   \              0x00 0x00    
   \              0x00         
    373              sizeof(g_usb_str_3),
    374              USB_DESCRIPTOR_TYPE_STRING,
    375              'M',
    376              0,
    377              'C',
    378              0,
    379              'U',
    380              0,
    381              ' ',
    382              0,
    383              'M',
    384              0,
    385              'S',
    386              0,
    387              'C',
    388              0,
    389              ' ',
    390              0,
    391              'A',
    392              0,
    393              'N',
    394              0,
    395              'D',
    396              0,
    397              ' ',
    398              0,
    399              'H',
    400              0,
    401              'I',
    402              0,
    403              'D',
    404              0,
    405              ' ',
    406              0,
    407              'G',
    408              0,
    409              'E',
    410              0,
    411              'N',
    412              0,
    413              'E',
    414              0,
    415              'R',
    416              0,
    417              'I',
    418              0,
    419              'C',
    420              0,
    421              ' ',
    422              0,
    423              'D',
    424              0,
    425              'E',
    426              0,
    427              'V',
    428              0,
    429              'I',
    430              0,
    431              'C',
    432              0,
    433              'E',
    434              0
    435          };
    436          #elif((USB_DEVICE_CONFIG_MSC == 0U) && (USB_DEVICE_CONFIG_HID > 0U)) // Only HID
    437          uint8_t g_usb_str_3[USB_STRING_DESCRIPTOR_3_LENGTH + USB_STRING_DESCRIPTOR_HEADER_LENGTH] = {
    438              sizeof(g_usb_str_3),
    439              USB_DESCRIPTOR_TYPE_STRING,
    440              'M',
    441              0,
    442              'C',
    443              0,
    444              'U',
    445              0,
    446              ' ',
    447              0,
    448              'H',
    449              0,
    450              'I',
    451              0,
    452              'D',
    453              0,
    454              ' ',
    455              0,
    456              'G',
    457              0,
    458              'E',
    459              0,
    460              'N',
    461              0,
    462              'E',
    463              0,
    464              'R',
    465              0,
    466              'I',
    467              0,
    468              'C',
    469              0,
    470              ' ',
    471              0,
    472              'D',
    473              0,
    474              'E',
    475              0,
    476              'V',
    477              0,
    478              'I',
    479              0,
    480              'C',
    481              0,
    482              'E',
    483              0
    484          };
    485          #elif((USB_DEVICE_CONFIG_MSC > 0U) && (USB_DEVICE_CONFIG_HID == 0U)) // Only MSC
    486          uint8_t g_usb_str_3[USB_STRING_DESCRIPTOR_3_LENGTH + USB_STRING_DESCRIPTOR_HEADER_LENGTH] = {
    487              sizeof(g_usb_str_3),
    488              USB_DESCRIPTOR_TYPE_STRING,
    489              'M',
    490              0,
    491              'C',
    492              0,
    493              'U',
    494              0,
    495              ' ',
    496              0,
    497              'M',
    498              0,
    499              'S',
    500              0,
    501              'C',
    502              0,
    503              ' ',
    504              0,
    505              'D',
    506              0,
    507              'E',
    508              0,
    509              'V',
    510              0,
    511              'I',
    512              0,
    513              'C',
    514              0,
    515              'E',
    516              0
    517          };
    518          #else                                                                // None
    519          uint8_t g_usb_str_3[USB_STRING_DESCRIPTOR_3_LENGTH + USB_STRING_DESCRIPTOR_HEADER_LENGTH] = {
    520              sizeof(g_usb_str_3), USB_DESCRIPTOR_TYPE_STRING, ' ', 0,
    521          };
    522          #endif
    523          

   \                                 In section .data, align 4
    524          uint8_t g_usb_str_n[USB_STRING_DESCRIPTOR_ERROR_LENGTH + USB_STRING_DESCRIPTOR_HEADER_LENGTH] = {
   \                     g_usb_str_n:
   \   00000000   0x22 0x03          DC8 34, 3, 66, 0, 65, 0, 68, 0, 32, 0, 83, 0, 84, 0, 82, 0, 73, 0, 78
   \              0x42 0x00    
   \              0x41 0x00    
   \              0x44 0x00    
   \              0x20 0x00    
   \              0x53 0x00    
   \              0x54 0x00    
   \              0x52 0x00    
   \              0x49 0x00    
   \              0x4E         
   \   00000013   0x00 0x47          DC8 0, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
    525              sizeof(g_usb_str_n),
    526              USB_DESCRIPTOR_TYPE_STRING,
    527              'B',
    528              0,
    529              'A',
    530              0,
    531              'D',
    532              0,
    533              ' ',
    534              0,
    535              'S',
    536              0,
    537              'T',
    538              0,
    539              'R',
    540              0,
    541              'I',
    542              0,
    543              'N',
    544              0,
    545              'G',
    546              0
    547          };
    548          
    549          /* Define string descriptor size */

   \                                 In section .data, align 4
    550          uint32_t g_string_desc_size[USB_STRING_COUNT + 1] = { sizeof(g_usb_str_0), sizeof(g_usb_str_1), sizeof(g_usb_str_2),
   \                     g_string_desc_size:
   \   00000000   0x00000004         DC32 4, 58, 42, 62, 34
   \              0x0000003A   
   \              0x0000002A   
   \              0x0000003E   
   \              0x00000022   
    551                                                                sizeof(g_usb_str_3), sizeof(g_usb_str_n) };
    552          

   \                                 In section .data, align 4
    553          uint8_t *g_string_descriptors[USB_STRING_COUNT + 1] = { g_usb_str_0, g_usb_str_1, g_usb_str_2, g_usb_str_3,
   \                     g_string_descriptors:
   \   00000000   0x........         DC32 g_usb_str_0, g_usb_str_1, g_usb_str_2, g_usb_str_3, g_usb_str_n
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
    554                                                                  g_usb_str_n };
    555          

   \                                 In section .data, align 4
    556          usb_language_t g_usb_lang[USB_LANGUAGE_COUNT] = { {
   \                     g_usb_lang:
   \   00000000   0x........         DC32 g_string_descriptors, g_string_desc_size
   \              0x........   
   \   00000008   0x0409             DC16 1033
   \   0000000A   0x00 0x00          DC8 0, 0
    557              g_string_descriptors, g_string_desc_size, (uint16_t)0x0409,
    558          } };
    559          

   \                                 In section .data, align 4
    560          usb_language_list_t g_language_list = {
   \                     g_language_list:
   \   00000000   0x........         DC32 g_usb_str_0, 4, g_usb_lang
   \              0x00000004   
   \              0x........   
   \   0000000C   0x01 0x00          DC8 1, 0, 0, 0
   \              0x00 0x00    
    561              g_usb_str_0, sizeof(g_usb_str_0), g_usb_lang, USB_LANGUAGE_COUNT,
    562          };
    563          

   \                                 In section .bss, align 4
    564          usb_language_list_t *g_language_ptr;
   \                     g_language_ptr:
   \   00000000                      DS8 4
    565          
    566          /* Get hid descriptor request */

   \                                 In section .text, align 2, keep-with-next
    567          usb_status_t usb_device_get_hid_descriptor(usb_device_handle handle,
    568                                                     usb_device_get_hid_descriptor_struct_t *hid_descriptor)
    569          {
    570              return kStatus_USB_InvalidRequest;
   \                     usb_device_get_hid_descriptor: (+1)
   \   00000000   0x2005             MOVS     R0,#+5
   \   00000002   0x4770             BX       LR               ;; return
    571          }
    572          
    573          /* Get hid report descriptor request */

   \                                 In section .text, align 2, keep-with-next
    574          usb_status_t usb_device_get_hid_report_descriptor(usb_device_handle handle,
    575                                                            usb_device_get_hid_report_descriptor_struct_t *hid_report_descriptor)
    576          {
    577              if (USB_HID_GENERIC_INTERFACE_INDEX == hid_report_descriptor->interfaceNumber)
   \                     usb_device_get_hid_report_descriptor: (+1)
   \   00000000   0x7A08             LDRB     R0,[R1, #+8]
   \   00000002   0xB918             CBNZ.N   R0,??usb_device_get_hid_report_descriptor_0
    578              {
    579                  hid_report_descriptor->buffer = g_hid_generic_report_descriptor;
   \   00000004   0x....             LDR.N    R0,??DataTable3
   \   00000006   0x6008             STR      R0,[R1, #+0]
    580                  //        hid_report_descriptor->length = USB_HID_REPORT_DESC_SIZE;
    581                  hid_report_descriptor->length = sizeof(g_hid_generic_report_descriptor);
   \   00000008   0x204C             MOVS     R0,#+76
   \   0000000A   0x....             B.N      ?Subroutine0
    582              }
    583              else
    584              {
    585                  return kStatus_USB_InvalidRequest;
   \                     ??usb_device_get_hid_report_descriptor_0: (+1)
   \   0000000C   0x2005             MOVS     R0,#+5
   \   0000000E   0x4770             BX       LR               ;; return
    586              }
    587              return kStatus_USB_Success;
    588          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x6048             STR      R0,[R1, #+4]
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR
    589          
    590          /* Get hid physical descriptor request */

   \                                 In section .text, align 2, keep-with-next
    591          usb_status_t usb_device_get_hid_physical_descriptor(
    592              usb_device_handle handle, usb_device_get_hid_physical_descriptor_struct_t *hid_physical_descriptor)
    593          {
    594              return kStatus_USB_InvalidRequest;
   \                     usb_device_get_hid_physical_descriptor: (+1)
   \   00000000   0x2005             MOVS     R0,#+5
   \   00000002   0x4770             BX       LR               ;; return
    595          }
    596          
    597          /*!
    598           * @brief USB device get device descriptor function.
    599           *
    600           * This function gets the device descriptor of the USB devcie.
    601           *
    602           * @param handle The USB device handle.
    603           * @param device_descriptor The pointer to the device descriptor structure.
    604           *
    605           * @return A USB error code or kStatus_USB_Success.
    606           */

   \                                 In section .text, align 2, keep-with-next
    607          usb_status_t usb_device_get_device_descriptor(usb_device_handle handle,
    608                                                        usb_device_get_device_descriptor_struct_t *device_descriptor)
    609          {
    610              device_descriptor->buffer = g_device_descriptor;
   \                     usb_device_get_device_descriptor: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable3_1
   \   00000002   0x6008             STR      R0,[R1, #+0]
    611              device_descriptor->length = USB_DEVICE_DESCRIPTOR_LENGTH;
   \   00000004   0x2012             MOVS     R0,#+18
   \   00000006                      REQUIRE ?Subroutine0
   \   00000006                      ;; // Fall through to label ?Subroutine0
    612              return kStatus_USB_Success;
    613          }
    614          
    615          /*!
    616           * @brief USB device get configuration descriptor function.
    617           *
    618           * This function gets the configuration descriptor of the USB devcie.
    619           *
    620           * @param handle The USB device handle.
    621           * @param configuration_descriptor The pointer to the configuration descriptor structure.
    622           *
    623           * @return A USB error code or kStatus_USB_Success.
    624           */

   \                                 In section .text, align 2, keep-with-next
    625          usb_status_t usb_device_get_configuration_descriptor(
    626              usb_device_handle handle, usb_device_get_configuration_descriptor_struct_t *configuration_descriptor)
    627          {
    628              //    if (USB_COMPOSITE_CONFIGURE_INDEX > configuration_descriptor->configuration)
    629              if (USB_HID_GENERIC_CONFIGURE_INDEX > configuration_descriptor->configuration)
   \                     usb_device_get_configuration_descriptor: (+1)
   \   00000000   0x7A08             LDRB     R0,[R1, #+8]
   \   00000002   0xB918             CBNZ.N   R0,??usb_device_get_configuration_descriptor_0
    630              {
    631                  configuration_descriptor->buffer = g_config_descriptor;
   \   00000004   0x....             LDR.N    R0,??DataTable3_2
   \   00000006   0x6008             STR      R0,[R1, #+0]
    632                  configuration_descriptor->length = USB_CONFIGURE_DESCRIPTOR_LENGTH;
   \   00000008   0x2040             MOVS     R0,#+64
   \   0000000A   0x....             B.N      ?Subroutine0
    633                  return kStatus_USB_Success;
    634              }
    635              return kStatus_USB_InvalidRequest;
   \                     ??usb_device_get_configuration_descriptor_0: (+1)
   \   0000000C   0x2005             MOVS     R0,#+5
   \   0000000E   0x4770             BX       LR               ;; return
    636          }
    637          
    638          /*!
    639           * @brief USB device get string descriptor function.
    640           *
    641           * This function gets the string descriptor of the USB devcie.
    642           *
    643           * @param handle The USB device handle.
    644           * @param string_descriptor Pointer to the string descriptor structure.
    645           *
    646           * @return A USB error code or kStatus_USB_Success.
    647           */

   \                                 In section .text, align 2, keep-with-next
    648          usb_status_t usb_device_get_string_descriptor(usb_device_handle handle,
    649                                                        usb_device_get_string_descriptor_struct_t *string_descriptor)
    650          {
   \                     usb_device_get_string_descriptor: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    651              if (string_descriptor->stringIndex == 0)
   \   00000002   0x7A88             LDRB     R0,[R1, #+10]
   \   00000004   0x....             LDR.N    R2,??DataTable3_3
   \   00000006   0x0003             MOVS     R3,R0
   \   00000008   0xD105             BNE.N    ??usb_device_get_string_descriptor_0
    652              {
    653                  string_descriptor->buffer = (uint8_t *)g_language_list.languageString;
   \   0000000A   0x6813             LDR      R3,[R2, #+0]
    654                  string_descriptor->length = g_language_list.stringLength;
   \   0000000C   0x6850             LDR      R0,[R2, #+4]
   \                     ??usb_device_get_string_descriptor_1: (+1)
   \   0000000E   0x6048             STR      R0,[R1, #+4]
   \   00000010   0x600B             STR      R3,[R1, #+0]
    655              }
    656              else
    657              {
    658                  uint8_t lang_id = 0;
    659                  uint8_t lang_index = USB_STRING_COUNT;
    660          
    661                  for (; lang_id < USB_LANGUAGE_COUNT; lang_id++)
    662                  {
    663                      if (string_descriptor->languageId == g_language_list.languageList[lang_id].languageId)
    664                      {
    665                          if (string_descriptor->stringIndex < USB_STRING_COUNT)
    666                          {
    667                              lang_index = string_descriptor->stringIndex;
    668                          }
    669                          break;
    670                      }
    671                  }
    672          
    673                  if (USB_STRING_COUNT == lang_index)
    674                  {
    675                      return kStatus_USB_InvalidRequest;
    676                  }
    677                  string_descriptor->buffer = (uint8_t *)g_language_list.languageList[lang_id].string[lang_index];
    678                  string_descriptor->length = g_language_list.languageList[lang_id].length[lang_index];
    679              }
    680              return kStatus_USB_Success;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
   \                     ??usb_device_get_string_descriptor_0: (+1)
   \   00000016   0x6892             LDR      R2,[R2, #+8]
   \   00000018   0x890B             LDRH     R3,[R1, #+8]
   \   0000001A   0x8914             LDRH     R4,[R2, #+8]
   \   0000001C   0x42A3             CMP      R3,R4
   \   0000001E   0xD108             BNE.N    ??usb_device_get_string_descriptor_2
   \   00000020   0x2804             CMP      R0,#+4
   \   00000022   0xDA06             BGE.N    ??usb_device_get_string_descriptor_2
   \   00000024   0x6813             LDR      R3,[R2, #+0]
   \   00000026   0x6852             LDR      R2,[R2, #+4]
   \   00000028   0xF853 0x3020      LDR      R3,[R3, R0, LSL #+2]
   \   0000002C   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
   \   00000030   0xE7ED             B.N      ??usb_device_get_string_descriptor_1
   \                     ??usb_device_get_string_descriptor_2: (+1)
   \   00000032   0x2005             MOVS     R0,#+5
   \   00000034   0xBD10             POP      {R4,PC}
    681          }
    682          
    683          /*!
    684           * @brief USB device set speed function.
    685           *
    686           * This function sets the speed of the USB devcie.
    687           *
    688           * @param handle The USB device handle.
    689           * @param speed Speed type. USB_SPEED_HIGH/USB_SPEED_FULL/USB_SPEED_LOW.
    690           *
    691           * @return A USB error code or kStatus_USB_Success.
    692           */

   \                                 In section .text, align 2, keep-with-next
    693          usb_status_t usb_device_set_speed(usb_device_handle handle, uint8_t speed)
    694          {
   \                     usb_device_set_speed: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    695              usb_hid_config_descriptor_t *ptr_hid = NULL;
    696              usb_msc_config_descriptor_t *ptr_msc = NULL;
    697          
    698          #if (USB_DEVICE_CONFIG_HID == 1) && (USB_DEVICE_CONFIG_MSC == 1)
    699              ptr_hid = (usb_hid_config_descriptor_t *)&g_config_descriptor[USB_HID_CONFIG_INDEX];
    700              ptr_msc = (usb_msc_config_descriptor_t *)&g_config_descriptor[USB_MSC_CONFIG_INDEX];
    701          #elif(USB_DEVICE_CONFIG_HID == 1) && (USB_DEVICE_CONFIG_MSC == 0)
    702              // HID only
    703              //    ptr_msc = NULL;
    704              ptr_hid = (usb_hid_config_descriptor_t *)&g_config_descriptor[USB_HID_CONFIG_INDEX];
    705          #elif(USB_DEVICE_CONFIG_HID == 0) && (USB_DEVICE_CONFIG_MSC == 1)
    706              // MSC only
    707              //    ptr_hid = NULL;
    708              ptr_msc = (usb_msc_config_descriptor_t *)&g_config_descriptor[USB_MSC_CONFIG_INDEX];
    709          #endif
    710          
    711              if (USB_SPEED_HIGH == speed)
   \   00000002   0x2902             CMP      R1,#+2
   \   00000004   0x....             LDR.N    R0,??DataTable3_4
   \   00000006   0xD110             BNE.N    ??usb_device_set_speed_0
    712              {
    713                  if (ptr_hid != NULL)
    714                  {
    715                      // HID interface
    716                      USB_SHORT_TO_LITTLE_ENDIAN_ADDRESS(HS_HID_GENERIC_INTERRUPT_IN_PACKET_SIZE,
    717                                                         ptr_hid->endpoint_in.wMaxPacketSize);
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x7042             STRB     R2,[R0, #+1]
   \   0000000C   0x2240             MOVS     R2,#+64
   \   0000000E   0x7002             STRB     R2,[R0, #+0]
    718                      ptr_hid->endpoint_in.bInterval = HS_HID_GENERIC_INTERRUPT_IN_INTERVAL;
   \   00000010   0x2204             MOVS     R2,#+4
   \   00000012   0x.... 0x....      BL       ?Subroutine1
    719          
    720                      USB_SHORT_TO_LITTLE_ENDIAN_ADDRESS(HS_HID_GENERIC_INTERRUPT_OUT_PACKET_SIZE,
    721                                                         ptr_hid->endpoint_out.wMaxPacketSize);
    722                      ptr_hid->endpoint_out.bInterval = HS_HID_GENERIC_INTERRUPT_OUT_INTERVAL;
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000016   0x2204             MOVS     R2,#+4
   \   00000018   0x7242             STRB     R2,[R0, #+9]
    723                  }
    724                  if (ptr_msc != NULL)
    725                  {
    726                      // MSC interface
    727                      USB_SHORT_TO_LITTLE_ENDIAN_ADDRESS(HS_BULK_IN_PACKET_SIZE, ptr_msc->endpoint_in.wMaxPacketSize);
   \   0000001A   0x2202             MOVS     R2,#+2
   \   0000001C   0x7602             STRB     R2,[R0, #+24]
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x75C2             STRB     R2,[R0, #+23]
    728                      USB_SHORT_TO_LITTLE_ENDIAN_ADDRESS(HS_BULK_OUT_PACKET_SIZE, ptr_msc->endpoint_out.wMaxPacketSize);
   \   00000022   0x2202             MOVS     R2,#+2
   \   00000024   0x77C2             STRB     R2,[R0, #+31]
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0xE00F             B.N      ??usb_device_set_speed_1
    729                  }
    730              }
    731              else
    732              {
    733                  if (ptr_hid != NULL)
    734                  {
    735                      // HID interface
    736                      USB_SHORT_TO_LITTLE_ENDIAN_ADDRESS(FS_HID_GENERIC_INTERRUPT_IN_PACKET_SIZE,
    737                                                         ptr_hid->endpoint_in.wMaxPacketSize);
   \                     ??usb_device_set_speed_0: (+1)
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x7042             STRB     R2,[R0, #+1]
   \   0000002E   0x2240             MOVS     R2,#+64
   \   00000030   0x7002             STRB     R2,[R0, #+0]
    738                      ptr_hid->endpoint_in.bInterval = FS_HID_GENERIC_INTERRUPT_IN_INTERVAL;
   \   00000032   0x2201             MOVS     R2,#+1
   \   00000034   0x.... 0x....      BL       ?Subroutine1
    739          
    740                      USB_SHORT_TO_LITTLE_ENDIAN_ADDRESS(FS_HID_GENERIC_INTERRUPT_OUT_PACKET_SIZE,
    741                                                         ptr_hid->endpoint_out.wMaxPacketSize);
    742                      ptr_hid->endpoint_out.bInterval = FS_HID_GENERIC_INTERRUPT_OUT_INTERVAL;
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000038   0x2201             MOVS     R2,#+1
   \   0000003A   0x7242             STRB     R2,[R0, #+9]
    743                  }
    744                  if (ptr_msc != NULL)
    745                  {
    746                      // MSC interface
    747                      USB_SHORT_TO_LITTLE_ENDIAN_ADDRESS(FS_BULK_IN_PACKET_SIZE, ptr_msc->endpoint_in.wMaxPacketSize);
   \   0000003C   0x2200             MOVS     R2,#+0
   \   0000003E   0x7602             STRB     R2,[R0, #+24]
   \   00000040   0x2240             MOVS     R2,#+64
   \   00000042   0x75C2             STRB     R2,[R0, #+23]
    748                      USB_SHORT_TO_LITTLE_ENDIAN_ADDRESS(FS_BULK_OUT_PACKET_SIZE, ptr_msc->endpoint_out.wMaxPacketSize);
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x77C2             STRB     R2,[R0, #+31]
   \   00000048   0x2240             MOVS     R2,#+64
   \                     ??usb_device_set_speed_1: (+1)
   \   0000004A   0x7782             STRB     R2,[R0, #+30]
    749                  }
    750              }
    751          
    752              for (uint32_t i = 0; i < USB_HID_GENERIC_ENDPOINT_COUNT; i++)
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x....             LDR.N    R2,??DataTable3_5
   \   00000050   0x2340             MOVS     R3,#+64
    753              {
    754                  if (USB_SPEED_HIGH == speed)
    755                  {
    756                      if (g_hid_generic_endpoints[i].endpointAddress & USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_IN)
    757                      {
    758                          g_hid_generic_endpoints[i].maxPacketSize = HS_HID_GENERIC_INTERRUPT_IN_PACKET_SIZE;
    759                      }
    760                      else
    761                      {
    762                          g_hid_generic_endpoints[i].maxPacketSize = HS_HID_GENERIC_INTERRUPT_OUT_PACKET_SIZE;
    763                      }
    764                  }
    765                  else
    766                  {
    767                      if (g_hid_generic_endpoints[i].endpointAddress & USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_IN)
    768                      {
    769                          g_hid_generic_endpoints[i].maxPacketSize = FS_HID_GENERIC_INTERRUPT_IN_PACKET_SIZE;
    770                      }
    771                      else
    772                      {
    773                          g_hid_generic_endpoints[i].maxPacketSize = FS_HID_GENERIC_INTERRUPT_OUT_PACKET_SIZE;
   \                     ??usb_device_set_speed_2: (+1)
   \   00000052   0xEB02 0x0480      ADD      R4,R2,R0, LSL #+2
    774                      }
    775                  }
    776              }
   \   00000056   0x1C40             ADDS     R0,R0,#+1
   \   00000058   0x2802             CMP      R0,#+2
   \   0000005A   0x8063             STRH     R3,[R4, #+2]
   \   0000005C   0xD3F9             BCC.N    ??usb_device_set_speed_2
    777          
    778              for (uint32_t i = 0; i < USB_MSC_ENDPOINT_COUNT; i++)
   \   0000005E   0x2000             MOVS     R0,#+0
    779              {
    780                  if (USB_SPEED_HIGH == speed)
   \                     ??usb_device_set_speed_3: (+1)
   \   00000060   0xEB02 0x0380      ADD      R3,R2,R0, LSL #+2
   \   00000064   0x2902             CMP      R1,#+2
   \   00000066   0xBF0C             ITE      EQ 
   \   00000068   0xF44F 0x7400      MOVEQ    R4,#+512
   \   0000006C   0x2440             MOVNE    R4,#+64
    781                  {
    782                      if ((USB_IN << USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT) ==
    783                          (g_msc_disk_endpoints[i].endpointAddress & USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_MASK))
    784                      {
    785                          g_msc_disk_endpoints[i].maxPacketSize = HS_BULK_IN_PACKET_SIZE;
    786                      }
    787                      else
    788                      {
    789                          g_msc_disk_endpoints[i].maxPacketSize = HS_BULK_OUT_PACKET_SIZE;
    790                      }
    791                  }
    792                  else
    793                  {
    794                      if ((USB_IN << USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT) ==
    795                          (g_msc_disk_endpoints[i].endpointAddress & USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_MASK))
    796                      {
    797                          g_msc_disk_endpoints[i].maxPacketSize = FS_BULK_IN_PACKET_SIZE;
    798                      }
    799                      else
    800                      {
    801                          g_msc_disk_endpoints[i].maxPacketSize = FS_BULK_OUT_PACKET_SIZE;
    802                      }
    803                  }
    804              }
   \   0000006E   0x1C40             ADDS     R0,R0,#+1
   \   00000070   0x2802             CMP      R0,#+2
   \   00000072   0x815C             STRH     R4,[R3, #+10]
   \   00000074   0xD3F4             BCC.N    ??usb_device_set_speed_3
    805              return kStatus_USB_Success;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xBD10             POP      {R4,PC}          ;; return
    806          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x7082             STRB     R2,[R0, #+2]
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x7202             STRB     R2,[R0, #+8]
   \   00000006   0x2240             MOVS     R2,#+64
   \   00000008   0x71C2             STRB     R2,[R0, #+7]
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     g_hid_generic_report_descriptor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     g_device_descriptor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     g_config_descriptor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     g_language_list

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     g_config_descriptor+0x1F

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     g_hid_generic_endpoints

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   usb_device_get_configuration_descriptor
       0   usb_device_get_device_descriptor
       0   usb_device_get_hid_descriptor
       0   usb_device_get_hid_physical_descriptor
       0   usb_device_get_hid_report_descriptor
       8   usb_device_get_string_descriptor
       8   usb_device_set_speed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       6  ?Subroutine0
      12  ?Subroutine1
      64  g_config_descriptor
      20  g_device_descriptor
       8  g_hid_generic_class
      16  g_hid_generic_endpoints
          g_msc_disk_endpoints
      16  g_hid_generic_interface
       8  g_hid_generic_interface_list
      12  g_hid_generic_interfaces
      76  g_hid_generic_report_descriptor
      16  g_language_list
       4  g_language_ptr
       8  g_msc_class
      16  g_msc_disk_interface
       8  g_msc_disk_interface_list
      12  g_msc_disk_interfaces
      20  g_string_desc_size
      20  g_string_descriptors
      12  g_usb_lang
       4  g_usb_str_0
      60  g_usb_str_1
      44  g_usb_str_2
      64  g_usb_str_3
      36  g_usb_str_n
      16  usb_device_get_configuration_descriptor
       6  usb_device_get_device_descriptor
       4  usb_device_get_hid_descriptor
       4  usb_device_get_hid_physical_descriptor
      16  usb_device_get_hid_report_descriptor
      54  usb_device_get_string_descriptor
     122  usb_device_set_speed

 
   4 bytes in section .bss
 540 bytes in section .data
 264 bytes in section .text
 
 264 bytes of CODE memory
 544 bytes of DATA memory

Errors: none
Warnings: none
