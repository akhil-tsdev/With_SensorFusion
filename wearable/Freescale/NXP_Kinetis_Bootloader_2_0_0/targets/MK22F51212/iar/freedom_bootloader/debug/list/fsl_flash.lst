###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Aug/2016  15:48:53
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\flash\fsl_flash.c
#    Command line =  
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\flash\fsl_flash.c"
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN512VDC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -lC
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\obj"
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform/devices/MK22F51212\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/osa\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/device\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/device/class\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/bm_usb\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform/devices\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/common\"
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\list\fsl_flash.lst
#    Object file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\obj\fsl_flash.o
#
###############################################################################

C:\Users\cwati\Documents\My Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\flash\fsl_flash.c
      1          /*
      2           * Copyright (c) 2015-2016, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "fsl_flash.h"
     32          
     33          /*******************************************************************************
     34           * Definitions
     35           ******************************************************************************/
     36          
     37          /*!
     38           * @name Misc utility defines
     39           * @{
     40           */
     41          #ifndef ALIGN_DOWN
     42          #define ALIGN_DOWN(x, a) ((x) & (uint32_t)(-((int32_t)(a))))
     43          #endif
     44          #ifndef ALIGN_UP
     45          #define ALIGN_UP(x, a) (-((int32_t)((uint32_t)(-((int32_t)(x))) & (uint32_t)(-((int32_t)(a))))))
     46          #endif
     47          
     48          #define BYTES_JOIN_TO_WORD_1_3(x, y) ((((uint32_t)(x)&0xFFU) << 24) | ((uint32_t)(y)&0xFFFFFFU))
     49          #define BYTES_JOIN_TO_WORD_2_2(x, y) ((((uint32_t)(x)&0xFFFFU) << 16) | ((uint32_t)(y)&0xFFFFU))
     50          #define BYTES_JOIN_TO_WORD_3_1(x, y) ((((uint32_t)(x)&0xFFFFFFU) << 8) | ((uint32_t)(y)&0xFFU))
     51          #define BYTES_JOIN_TO_WORD_1_1_2(x, y, z) \
     52              ((((uint32_t)(x)&0xFFU) << 24) | (((uint32_t)(y)&0xFFU) << 16) | ((uint32_t)(z)&0xFFFFU))
     53          #define BYTES_JOIN_TO_WORD_1_2_1(x, y, z) \
     54              ((((uint32_t)(x)&0xFFU) << 24) | (((uint32_t)(y)&0xFFFFU) << 8) | ((uint32_t)(z)&0xFFU))
     55          #define BYTES_JOIN_TO_WORD_2_1_1(x, y, z) \
     56              ((((uint32_t)(x)&0xFFFFU) << 16) | (((uint32_t)(y)&0xFFU) << 8) | ((uint32_t)(z)&0xFFU))
     57          #define BYTES_JOIN_TO_WORD_1_1_1_1(x, y, z, w)                                                      \
     58              ((((uint32_t)(x)&0xFFU) << 24) | (((uint32_t)(y)&0xFFU) << 16) | (((uint32_t)(z)&0xFFU) << 8) | \
     59               ((uint32_t)(w)&0xFFU))
     60          /*@}*/
     61          
     62          /*! @brief Data flash IFR map Field*/
     63          #if defined(FSL_FEATURE_FLASH_IS_FTFE) && FSL_FEATURE_FLASH_IS_FTFE
     64          #define DFLASH_IFR_READRESOURCE_START_ADDRESS 0x8003F8U
     65          #else /* FSL_FEATURE_FLASH_IS_FTFL == 1 or FSL_FEATURE_FLASH_IS_FTFA = =1 */
     66          #define DFLASH_IFR_READRESOURCE_START_ADDRESS 0x8000F8U
     67          #endif
     68          
     69          /*!
     70           * @name Reserved FlexNVM size (For a variety of purposes) defines
     71           * @{
     72           */
     73          #define FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED 0xFFFFFFFFU
     74          #define FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_RESERVED 0xFFFFU
     75          /*@}*/
     76          
     77          /*!
     78           * @name Flash Program Once Field defines
     79           * @{
     80           */
     81          #if defined(FSL_FEATURE_FLASH_IS_FTFA) && FSL_FEATURE_FLASH_IS_FTFA
     82          /* FTFA parts(eg. K80, KL80, L5K) support both 4-bytes and 8-bytes unit size */
     83          #define FLASH_PROGRAM_ONCE_MIN_ID_8BYTES \
     84              0x10U /* Minimum Index indcating one of Progam Once Fields which is accessed in 8-byte records */
     85          #define FLASH_PROGRAM_ONCE_MAX_ID_8BYTES \
     86              0x13U /* Maximum Index indcating one of Progam Once Fields which is accessed in 8-byte records */
     87          #define FLASH_PROGRAM_ONCE_IS_4BYTES_UNIT_SUPPORT 1
     88          #define FLASH_PROGRAM_ONCE_IS_8BYTES_UNIT_SUPPORT 1
     89          #elif defined(FSL_FEATURE_FLASH_IS_FTFE) && FSL_FEATURE_FLASH_IS_FTFE
     90          /* FTFE parts(eg. K65, KE18) only support 8-bytes unit size */
     91          #define FLASH_PROGRAM_ONCE_IS_4BYTES_UNIT_SUPPORT 0
     92          #define FLASH_PROGRAM_ONCE_IS_8BYTES_UNIT_SUPPORT 1
     93          #elif defined(FSL_FEATURE_FLASH_IS_FTFL) && FSL_FEATURE_FLASH_IS_FTFL
     94          /* FTFL parts(eg. K20) only support 4-bytes unit size */
     95          #define FLASH_PROGRAM_ONCE_IS_4BYTES_UNIT_SUPPORT 1
     96          #define FLASH_PROGRAM_ONCE_IS_8BYTES_UNIT_SUPPORT 0
     97          #endif
     98          /*@}*/
     99          
    100          /*!
    101           * @name Flash security status defines
    102           * @{
    103           */
    104          #define FLASH_SECURITY_STATE_KEYEN 0x80U
    105          #define FLASH_SECURITY_STATE_UNSECURED 0x02U
    106          #define FLASH_NOT_SECURE 0x01U
    107          #define FLASH_SECURE_BACKDOOR_ENABLED 0x02U
    108          #define FLASH_SECURE_BACKDOOR_DISABLED 0x04U
    109          /*@}*/
    110          
    111          /*!
    112           * @name Flash controller command numbers
    113           * @{
    114           */
    115          #define FTFx_VERIFY_BLOCK 0x00U                    /*!< RD1BLK*/
    116          #define FTFx_VERIFY_SECTION 0x01U                  /*!< RD1SEC*/
    117          #define FTFx_PROGRAM_CHECK 0x02U                   /*!< PGMCHK*/
    118          #define FTFx_READ_RESOURCE 0x03U                   /*!< RDRSRC*/
    119          #define FTFx_PROGRAM_LONGWORD 0x06U                /*!< PGM4*/
    120          #define FTFx_PROGRAM_PHRASE 0x07U                  /*!< PGM8*/
    121          #define FTFx_ERASE_BLOCK 0x08U                     /*!< ERSBLK*/
    122          #define FTFx_ERASE_SECTOR 0x09U                    /*!< ERSSCR*/
    123          #define FTFx_PROGRAM_SECTION 0x0BU                 /*!< PGMSEC*/
    124          #define FTFx_VERIFY_ALL_BLOCK 0x40U                /*!< RD1ALL*/
    125          #define FTFx_READ_ONCE 0x41U                       /*!< RDONCE or RDINDEX*/
    126          #define FTFx_PROGRAM_ONCE 0x43U                    /*!< PGMONCE or PGMINDEX*/
    127          #define FTFx_ERASE_ALL_BLOCK 0x44U                 /*!< ERSALL*/
    128          #define FTFx_SECURITY_BY_PASS 0x45U                /*!< VFYKEY*/
    129          #define FTFx_SWAP_CONTROL 0x46U                    /*!< SWAP*/
    130          #define FTFx_ERASE_ALL_BLOCK_UNSECURE 0x49U        /*!< ERSALLU*/
    131          #define FTFx_VERIFY_ALL_EXECUTE_ONLY_SEGMENT 0x4AU /*!< RD1XA*/
    132          #define FTFx_ERASE_ALL_EXECUTE_ONLY_SEGMENT 0x4BU  /*!< ERSXA*/
    133          #define FTFx_PROGRAM_PARTITION 0x80U               /*!< PGMPART)*/
    134          #define FTFx_SET_FLEXRAM_FUNCTION 0x81U            /*!< SETRAM*/
    135                                                             /*@}*/
    136          
    137          /*!
    138           * @name Common flash register info defines
    139           * @{
    140           */
    141          #if defined(FTFA)
    142          #define FTFx FTFA
    143          #define FTFx_BASE FTFA_BASE
    144          #define FTFx_FSTAT_CCIF_MASK FTFA_FSTAT_CCIF_MASK
    145          #define FTFx_FSTAT_RDCOLERR_MASK FTFA_FSTAT_RDCOLERR_MASK
    146          #define FTFx_FSTAT_ACCERR_MASK FTFA_FSTAT_ACCERR_MASK
    147          #define FTFx_FSTAT_FPVIOL_MASK FTFA_FSTAT_FPVIOL_MASK
    148          #define FTFx_FSTAT_MGSTAT0_MASK FTFA_FSTAT_MGSTAT0_MASK
    149          #define FTFx_FSEC_SEC_MASK FTFA_FSEC_SEC_MASK
    150          #define FTFx_FSEC_KEYEN_MASK FTFA_FSEC_KEYEN_MASK
    151          #if defined(FSL_FEATURE_FLASH_HAS_FLEX_RAM) && FSL_FEATURE_FLASH_HAS_FLEX_RAM
    152          #define FTFx_FCNFG_RAMRDY_MASK FTFA_FCNFG_RAMRDY_MASK
    153          #endif /* FSL_FEATURE_FLASH_HAS_FLEX_RAM */
    154          #if defined(FSL_FEATURE_FLASH_HAS_FLEX_NVM) && FSL_FEATURE_FLASH_HAS_FLEX_NVM
    155          #define FTFx_FCNFG_EEERDY_MASK FTFA_FCNFG_EEERDY_MASK
    156          #endif /* FSL_FEATURE_FLASH_HAS_FLEX_NVM */
    157          #elif defined(FTFE)
    158          #define FTFx FTFE
    159          #define FTFx_BASE FTFE_BASE
    160          #define FTFx_FSTAT_CCIF_MASK FTFE_FSTAT_CCIF_MASK
    161          #define FTFx_FSTAT_RDCOLERR_MASK FTFE_FSTAT_RDCOLERR_MASK
    162          #define FTFx_FSTAT_ACCERR_MASK FTFE_FSTAT_ACCERR_MASK
    163          #define FTFx_FSTAT_FPVIOL_MASK FTFE_FSTAT_FPVIOL_MASK
    164          #define FTFx_FSTAT_MGSTAT0_MASK FTFE_FSTAT_MGSTAT0_MASK
    165          #define FTFx_FSEC_SEC_MASK FTFE_FSEC_SEC_MASK
    166          #define FTFx_FSEC_KEYEN_MASK FTFE_FSEC_KEYEN_MASK
    167          #if defined(FSL_FEATURE_FLASH_HAS_FLEX_RAM) && FSL_FEATURE_FLASH_HAS_FLEX_RAM
    168          #define FTFx_FCNFG_RAMRDY_MASK FTFE_FCNFG_RAMRDY_MASK
    169          #endif /* FSL_FEATURE_FLASH_HAS_FLEX_RAM */
    170          #if defined(FSL_FEATURE_FLASH_HAS_FLEX_NVM) && FSL_FEATURE_FLASH_HAS_FLEX_NVM
    171          #define FTFx_FCNFG_EEERDY_MASK FTFE_FCNFG_EEERDY_MASK
    172          #endif /* FSL_FEATURE_FLASH_HAS_FLEX_NVM */
    173          #elif defined(FTFL)
    174          #define FTFx FTFL
    175          #define FTFx_BASE FTFL_BASE
    176          #define FTFx_FSTAT_CCIF_MASK FTFL_FSTAT_CCIF_MASK
    177          #define FTFx_FSTAT_RDCOLERR_MASK FTFL_FSTAT_RDCOLERR_MASK
    178          #define FTFx_FSTAT_ACCERR_MASK FTFL_FSTAT_ACCERR_MASK
    179          #define FTFx_FSTAT_FPVIOL_MASK FTFL_FSTAT_FPVIOL_MASK
    180          #define FTFx_FSTAT_MGSTAT0_MASK FTFL_FSTAT_MGSTAT0_MASK
    181          #define FTFx_FSEC_SEC_MASK FTFL_FSEC_SEC_MASK
    182          #define FTFx_FSEC_KEYEN_MASK FTFL_FSEC_KEYEN_MASK
    183          #if defined(FSL_FEATURE_FLASH_HAS_FLEX_RAM) && FSL_FEATURE_FLASH_HAS_FLEX_RAM
    184          #define FTFx_FCNFG_RAMRDY_MASK FTFL_FCNFG_RAMRDY_MASK
    185          #endif /* FSL_FEATURE_FLASH_HAS_FLEX_RAM */
    186          #if defined(FSL_FEATURE_FLASH_HAS_FLEX_NVM) && FSL_FEATURE_FLASH_HAS_FLEX_NVM
    187          #define FTFx_FCNFG_EEERDY_MASK FTFL_FCNFG_EEERDY_MASK
    188          #endif /* FSL_FEATURE_FLASH_HAS_FLEX_NVM */
    189          #else
    190          #error "Unknown flash controller"
    191          #endif
    192          /*@}*/
    193          
    194          /*!
    195           * @brief Enumeration for access segment property.
    196           */
    197          enum _flash_access_segment_property
    198          {
    199              kFLASH_AccessSegmentBase = 256UL,
    200          };
    201          
    202          /*!
    203           * @brief Enumeration for flash config area.
    204           */
    205          enum _flash_config_area_range
    206          {
    207              kFLASH_ConfigAreaStart = 0x400U,
    208              kFLASH_ConfigAreaEnd = 0x40FU
    209          };
    210          
    211          /*! @brief Total flash region count*/
    212          #define FSL_FEATURE_FTFx_REGION_COUNT (32U)
    213          
    214          /*!
    215           * @name Flash register access type defines
    216           * @{
    217           */
    218          #if FLASH_DRIVER_IS_FLASH_RESIDENT
    219          #define FTFx_REG_ACCESS_TYPE volatile uint8_t *
    220          #define FTFx_REG32_ACCESS_TYPE volatile uint32_t *
    221          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
    222                 /*@}*/
    223          
    224          /*******************************************************************************
    225           * Prototypes
    226           ******************************************************************************/
    227          
    228          #if FLASH_DRIVER_IS_FLASH_RESIDENT
    229          /*! @brief Copy flash_run_command() to RAM*/
    230          static void copy_flash_run_command(uint32_t *flashRunCommand);
    231          /*! @brief Copy flash_cache_clear_command() to RAM*/
    232          static void copy_flash_cache_clear_command(uint32_t *flashCacheClearCommand);
    233          /*! @brief Check whether flash execute-in-ram functions are ready*/
    234          static status_t flash_check_execute_in_ram_function_info(flash_config_t *config);
    235          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
    236          
    237          /*! @brief Internal function Flash command sequence. Called by driver APIs only*/
    238          static status_t flash_command_sequence(flash_config_t *config);
    239          
    240          /*! @brief Perform the cache clear to the flash*/
    241          void flash_cache_clear(flash_config_t *config);
    242          
    243          /*! @brief Validates the range and alignment of the given address range.*/
    244          static status_t flash_check_range(flash_config_t *config,
    245                                            uint32_t startAddress,
    246                                            uint32_t lengthInBytes,
    247                                            uint32_t alignmentBaseline);
    248          /*! @brief Gets the right address, sector and block size of current flash type which is indicated by address.*/
    249          static status_t flash_get_matched_operation_info(flash_config_t *config,
    250                                                           uint32_t address,
    251                                                           flash_operation_config_t *info);
    252          /*! @brief Validates the given user key for flash erase APIs.*/
    253          static status_t flash_check_user_key(uint32_t key);
    254          
    255          #if FLASH_SSD_IS_FLEXNVM_ENABLED
    256          /*! @brief Updates FlexNVM memory partition status according to data flash 0 IFR.*/
    257          static status_t flash_update_flexnvm_memory_partition_status(flash_config_t *config);
    258          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
    259          
    260          #if defined(FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD) && FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD
    261          /*! @brief Validates the range of the given resource address.*/
    262          static status_t flash_check_resource_range(uint32_t start,
    263                                                     uint32_t lengthInBytes,
    264                                                     uint32_t alignmentBaseline,
    265                                                     flash_read_resource_option_t option);
    266          #endif /* FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD */
    267          
    268          #if defined(FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD) && FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD
    269          /*! @brief Validates the gived swap control option.*/
    270          static status_t flash_check_swap_control_option(flash_swap_control_option_t option);
    271          #endif /* FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD */
    272          
    273          #if defined(FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP) && FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP
    274          /*! @brief Validates the gived address to see if it is equal to swap indicator address in pflash swap IFR.*/
    275          static status_t flash_validate_swap_indicator_address(flash_config_t *config, uint32_t address);
    276          #endif /* FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP */
    277          
    278          #if defined(FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD) && FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD
    279          /*! @brief Validates the gived flexram function option.*/
    280          static inline status_t flasn_check_flexram_function_option_range(flash_flexram_function_option_t option);
    281          #endif /* FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD */
    282          
    283          /*******************************************************************************
    284           * Variables
    285           ******************************************************************************/
    286          
    287          /*! @brief Access to FTFx->FCCOB */
    288          #if defined(FSL_FEATURE_FLASH_IS_FTFA) && FSL_FEATURE_FLASH_IS_FTFA

   \                                 In section .rodata, align 4, keep-with-next
    289          volatile uint32_t *const kFCCOBx = (volatile uint32_t *)&FTFA->FCCOB3;
   \                     kFCCOBx:
   \   00000000   0x40020004         DC32 40020004H
    290          #elif defined(FSL_FEATURE_FLASH_IS_FTFE) && FSL_FEATURE_FLASH_IS_FTFE
    291          volatile uint32_t *const kFCCOBx = (volatile uint32_t *)&FTFE->FCCOB3;
    292          #elif defined(FSL_FEATURE_FLASH_IS_FTFL) && FSL_FEATURE_FLASH_IS_FTFL
    293          volatile uint32_t *const kFCCOBx = (volatile uint32_t *)&FTFL->FCCOB3;
    294          #else
    295          #error "Unknown flash controller"
    296          #endif
    297          
    298          /*! @brief Access to FTFx->FPROT */
    299          #if defined(FSL_FEATURE_FLASH_IS_FTFA) && FSL_FEATURE_FLASH_IS_FTFA

   \                                 In section .rodata, align 4, keep-with-next
    300          volatile uint32_t *const kFPROT = (volatile uint32_t *)&FTFA->FPROT3;
   \                     kFPROT:
   \   00000000   0x40020010         DC32 40020010H
    301          #elif defined(FSL_FEATURE_FLASH_IS_FTFE) && FSL_FEATURE_FLASH_IS_FTFE
    302          volatile uint32_t *const kFPROT = (volatile uint32_t *)&FTFE->FPROT3;
    303          #elif defined(FSL_FEATURE_FLASH_IS_FTFL) && FSL_FEATURE_FLASH_IS_FTFL
    304          volatile uint32_t *const kFPROT = (volatile uint32_t *)&FTFL->FPROT3;
    305          #else
    306          #error "Unknown flash controller"
    307          #endif
    308          
    309          #if FLASH_DRIVER_IS_FLASH_RESIDENT
    310          /*! @brief A function pointer used to point to relocated flash_run_command() */

   \                                 In section .bss, align 4
    311          static void (*callFlashRunCommand)(FTFx_REG_ACCESS_TYPE ftfx_fstat);
   \                     callFlashRunCommand:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
    312          /*! @brief A function pointer used to point to relocated flash_cache_clear_command() */
    313          static void (*callFlashCacheClearCommand)(FTFx_REG32_ACCESS_TYPE ftfx_reg);
    314          
    315          /*!
    316           * @brief Position independent code of flash_run_command()
    317           *
    318           * Note1: The prototype of C function is shown as below:
    319           * @code
    320           *   void flash_run_command(FTFx_REG_ACCESS_TYPE ftfx_fstat)
    321           *   {
    322           *       // clear CCIF bit
    323           *       *ftfx_fstat = FTFx_FSTAT_CCIF_MASK;
    324           *
    325           *       // Check CCIF bit of the flash status register, wait till it is set.
    326           *       // IP team indicates that this loop will always complete.
    327           *       while (!((*ftfx_fstat) & FTFx_FSTAT_CCIF_MASK))
    328           *       {
    329           *       }
    330           *   }
    331           * @endcode
    332           * Note2: The binary code is generated by IAR 7.50.1
    333           */

   \                                 In section .text, align 4, keep-with-next
    334          const static uint16_t s_flashRunCommandFunctionCode[] = {
   \                     s_flashRunCommandFunctionCode:
   \   00000000   0x2180 0x7001      DC16 8576, 28673, 30722, 16906, 53500, 18288
   \              0x7802 0x420A
   \              0xD0FC 0x4770
    335              0x2180, /* MOVS  R1, #128 ; 0x80 */
    336              0x7001, /* STRB  R1, [R0] */
    337              /* @4: */
    338              0x7802, /* LDRB  R2, [R0] */
    339              0x420a, /* TST   R2, R1 */
    340              0xd0fc, /* BEQ.N @4 */
    341              0x4770  /* BX    LR */
    342          };
    343          
    344          /*!
    345           * @brief Position independent code of flash_cache_clear_command()
    346           *
    347           * Note1: The prototype of C function is shown as below:
    348           * @code
    349           *   void flash_cache_clear_command(FTFx_REG32_ACCESS_TYPE ftfx_reg)
    350           *   {
    351           *   #if defined(FSL_FEATURE_FLASH_HAS_MCM_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_MCM_FLASH_CACHE_CONTROLS
    352           *       *ftfx_reg |= MCM_PLACR_CFCC_MASK;
    353           *   #elif defined(FSL_FEATURE_FLASH_HAS_FMC_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_FMC_FLASH_CACHE_CONTROLS
    354           *   #if defined(FMC_PFB01CR_CINV_WAY_MASK)
    355           *       *ftfx_reg = (*ftfx_reg & ~FMC_PFB01CR_CINV_WAY_MASK) | FMC_PFB01CR_CINV_WAY(~0);
    356           *   #else
    357           *       *ftfx_reg = (*ftfx_reg & ~FMC_PFB0CR_CINV_WAY_MASK) | FMC_PFB0CR_CINV_WAY(~0);
    358           *   #endif
    359           *   #elif defined(FSL_FEATURE_FLASH_HAS_MSCM_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_MSCM_FLASH_CACHE_CONTROLS
    360           *       *ftfx_reg |= MSCM_OCMDR_OCMC1(2);
    361           *       *ftfx_reg |= MSCM_OCMDR_OCMC1(1);
    362           *   #else
    363           *   #if defined(FMC_PFB0CR_S_INV_MASK)
    364           *       *ftfx_reg |= FMC_PFB0CR_S_INV_MASK;
    365           *   #elif defined(FMC_PFB01CR_S_INV_MASK)
    366           *       *ftfx_reg |= FMC_PFB01CR_S_INV_MASK;
    367           *   #endif
    368           *   //    #error "Unknown flash cache controller"
    369           *   #endif // FSL_FEATURE_FTFx_MCM_FLASH_CACHE_CONTROLS
    370           *       // Memory barriers for good measure.
    371           *       // All Cache, Branch predictor and TLB maintenance operations before this instruction complete
    372           *       __ISB();
    373           *       __DSB();
    374           *   }
    375           * @endcode
    376           * Note2: The binary code is generated by IAR 7.50.1
    377           */
    378          #if defined(FSL_FEATURE_FLASH_HAS_MCM_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_MCM_FLASH_CACHE_CONTROLS
    379          const static uint16_t s_flashCacheClearCommandFunctionCode[] = {
    380              0x6801,         /* LDR  R1, [R0] */
    381              0x2280,         /* MOVS R2, #128   ; 0x80 */
    382              0x00d2,         /* LSLS R2, R2, #3 */
    383              0x430a,         /* ORRS R2, R2, R1 */
    384              0x6002,         /* STR  R2, [R0] */
    385              0xf3bf, 0x8f6f, /* ISB */
    386              0xf3bf, 0x8f4f, /* DSB */
    387              0x4770          /* BX   LR */
    388          };
    389          #elif defined(FSL_FEATURE_FLASH_HAS_FMC_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_FMC_FLASH_CACHE_CONTROLS

   \                                 In section .text, align 4, keep-with-next
    390          const static uint16_t s_flashCacheClearCommandFunctionCode[] = {
   \                     s_flashCacheClearCommandFunctionCode:
   \   00000000   0x6801 0x22F0      DC16 26625, 8944, 1042, 17162, 24578, 62399, 36719, 62399, 36687, 18288
   \              0x0412 0x430A
   \              0x6002 0xF3BF
   \              0x8F6F 0xF3BF
   \              0x8F4F 0x4770
    391              0x6801,         /* LDR  R1, [R0] */
    392              0x22f0,         /* MOVS R2, #240    ; 0xf0 */
    393              0x0412,         /* LSLS R2, R2, #16 */
    394              0x430a,         /* ORRS R2, R2, R1 */
    395              0x6002,         /* STR  R2, [R0] */
    396              0xf3bf, 0x8f6f, /* ISB */
    397              0xf3bf, 0x8f4f, /* DSB */
    398              0x4770          /* BX   LR */
    399          };
    400          #elif defined(FSL_FEATURE_FLASH_HAS_MSCM_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_MSCM_FLASH_CACHE_CONTROLS
    401          const static uint16_t s_flashCacheClearCommandFunctionCode[] = {
    402              0x6801,         /* LDR  R1, [R0] */
    403              0x2220,         /* MOVS R2, #32    ; 0x20 */
    404              0x430a,         /* ORRS R2, R2, R1 */
    405              0x6002,         /* STR  R2, [R0] */
    406              0x6801,         /* LDR  R1, [R0] */
    407              0x2210,         /* MOVS R2, #16    ; 0x10 */
    408              0x430a,         /* ORRS R2, R2, R1 */
    409              0x6002,         /* STR  R2, [R0] */
    410              0xf3bf, 0x8f6f, /* ISB */
    411              0xf3bf, 0x8f4f, /* DSB */
    412              0x4770          /* BX   LR */
    413          };
    414          #else
    415          #if defined(FMC_PFB0CR_S_INV_MASK) || defined(FMC_PFB01CR_S_INV_MASK)
    416          const static uint16_t s_flashCacheClearCommandFunctionCode[] = {
    417              0x6801,         /* LDR  R1, [R0]  */
    418              0x2280,         /* MOVS R2, #128    ; 0x80 */
    419              0x0312,         /* LSLS R2, R2, #12 */
    420              0x430a,         /* ORRS R2, R2, R1 */
    421              0x6002,         /* STR  R2, [R0] */
    422              0xf3bf, 0x8f6f, /* ISB */
    423              0xf3bf, 0x8f4f, /* DSB */
    424              0x4770          /* BX   LR */
    425          };
    426          #else
    427          const static uint16_t s_flashCacheClearCommandFunctionCode[] = {
    428              0xf3bf, 0x8f6f, /* ISB */
    429              0xf3bf, 0x8f4f, /* DSB */
    430              0x4770          /* BX   LR */
    431          };
    432          #endif
    433          #endif
    434          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
    435          
    436          #if (FLASH_DRIVER_IS_FLASH_RESIDENT && !FLASH_DRIVER_IS_EXPORTED)
    437          /*! @brief A static buffer used to hold flash_run_command() */
    438          static uint32_t s_flashRunCommand[kFLASH_ExecuteInRamFunctionMaxSizeInWords];
    439          /*! @brief A static buffer used to hold flash_cache_clear_command() */
    440          static uint32_t s_flashCacheClearCommand[kFLASH_ExecuteInRamFunctionMaxSizeInWords];
    441          /*! @brief Flash execute-in-ram function information */
    442          static flash_execute_in_ram_function_config_t s_flashExecuteInRamFunctionInfo;
    443          #endif
    444          
    445          /*!
    446           * @brief Table of pflash sizes.
    447           *
    448           *  The index into this table is the value of the SIM_FCFG1.PFSIZE bitfield.
    449           *
    450           *  The values in this table have been right shifted 10 bits so that they will all fit within
    451           *  an 16-bit integer. To get the actual flash density, you must left shift the looked up value
    452           *  by 10 bits.
    453           *
    454           *  Elements of this table have a value of 0 in cases where the PFSIZE bitfield value is
    455           *  reserved.
    456           *
    457           *  Code to use the table:
    458           *  @code
    459           *      uint8_t pfsize = (SIM->FCFG1 & SIM_FCFG1_PFSIZE_MASK) >> SIM_FCFG1_PFSIZE_SHIFT;
    460           *      flashDensity = ((uint32_t)kPFlashDensities[pfsize]) << 10;
    461           *  @endcode
    462           */

   \                                 In section .text, align 4, keep-with-next
    463          const uint16_t kPFlashDensities[] = {
   \                     kPFlashDensities:
   \   00000000   0x0008 0x0010      DC16 8, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024
   \              0x0018 0x0020
   \              0x0030 0x0040
   \              0x0060 0x0080
   \              0x00C0 0x0100
   \              0x0180 0x0200
   \              0x0300 0x0400
   \   0000001C   0x0600             DC16 1536
   \   0000001E   0x00 0x00          DC8 0, 0
    464              8,    /* 0x0 - 8192, 8KB */
    465              16,   /* 0x1 - 16384, 16KB */
    466              24,   /* 0x2 - 24576, 24KB */
    467              32,   /* 0x3 - 32768, 32KB */
    468              48,   /* 0x4 - 49152, 48KB */
    469              64,   /* 0x5 - 65536, 64KB */
    470              96,   /* 0x6 - 98304, 96KB */
    471              128,  /* 0x7 - 131072, 128KB */
    472              192,  /* 0x8 - 196608, 192KB */
    473              256,  /* 0x9 - 262144, 256KB */
    474              384,  /* 0xa - 393216, 384KB */
    475              512,  /* 0xb - 524288, 512KB */
    476              768,  /* 0xc - 786432, 768KB */
    477              1024, /* 0xd - 1048576, 1MB */
    478              1536, /* 0xe - 1572864, 1.5MB */
    479              /* 2048,  0xf - 2097152, 2MB */
    480          };
    481          
    482          /*******************************************************************************
    483           * Code
    484           ******************************************************************************/
    485          

   \                                 In section .text, align 2, keep-with-next
    486          status_t FLASH_Init(flash_config_t *config)
    487          {
    488              uint32_t flashDensity;
    489          
    490              if (config == NULL)
   \                     FLASH_Init: (+1)
   \   00000000   0xB908             CBNZ.N   R0,??FLASH_Init_0
    491              {
    492                  return kStatus_FLASH_InvalidArgument;
   \   00000002   0x2004             MOVS     R0,#+4
   \   00000004   0x4770             BX       LR
    493              }
    494          
    495              /* calculate the flash density from SIM_FCFG1.PFSIZE */
    496              uint8_t pfsize = (SIM->FCFG1 & SIM_FCFG1_PFSIZE_MASK) >> SIM_FCFG1_PFSIZE_SHIFT;
   \                     ??FLASH_Init_0: (+1)
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable23  ;; 0x4004804c
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x0E09             LSRS     R1,R1,#+24
   \   0000000E   0xF001 0x010F      AND      R1,R1,#0xF
    497              /* PFSIZE=0xf means that on customer parts the IFR was not correctly programmed.
    498               * We just use the pre-defined flash size in feature file here to support pre-production parts */
    499              if (pfsize == 0xf)
   \   00000012   0x290F             CMP      R1,#+15
   \   00000014   0xBF0F             ITEEE    EQ 
   \   00000016   0xF44F 0x2100      MOVEQ    R1,#+524288
   \   0000001A   0x.... 0x....      ADRNE.W  R2,kPFlashDensities
   \   0000001E   0xF832 0x1011      LDRHNE   R1,[R2, R1, LSL #+1]
   \   00000022   0x0289             LSLNE    R1,R1,#+10
    500              {
    501                  flashDensity = FSL_FEATURE_FLASH_PFLASH_BLOCK_COUNT * FSL_FEATURE_FLASH_PFLASH_BLOCK_SIZE;
    502              }
    503              else
    504              {
    505                  flashDensity = ((uint32_t)kPFlashDensities[pfsize]) << 10;
    506              }
    507          
    508              /* fill out a few of the structure members */
    509              config->PFlashBlockBase = FSL_FEATURE_FLASH_PFLASH_START_ADDRESS;
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0x6002             STR      R2,[R0, #+0]
    510              config->PFlashTotalSize = flashDensity;
   \   00000028   0x6041             STR      R1,[R0, #+4]
    511              config->PFlashBlockCount = FSL_FEATURE_FLASH_PFLASH_BLOCK_COUNT;
    512              config->PFlashSectorSize = FSL_FEATURE_FLASH_PFLASH_BLOCK_SECTOR_SIZE;
    513          
    514          #if defined(FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL) && FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    515              config->PFlashAccessSegmentSize = kFLASH_AccessSegmentBase << FTFx->FACSS;
   \   0000002A   0xF44F 0x7280      MOV      R2,#+256
   \   0000002E   0x2102             MOVS     R1,#+2
   \   00000030   0x6081             STR      R1,[R0, #+8]
   \   00000032   0xF44F 0x6100      MOV      R1,#+2048
   \   00000036   0x60C1             STR      R1,[R0, #+12]
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable23_1  ;; 0x40020028
   \   0000003C   0xF991 0x3000      LDRSB    R3,[R1, #+0]
   \   00000040   0x409A             LSLS     R2,R2,R3
   \   00000042   0x6142             STR      R2,[R0, #+20]
    516              config->PFlashAccessSegmentCount = FTFx->FACSN;
   \   00000044   0x78C9             LDRB     R1,[R1, #+3]
   \   00000046   0x6181             STR      R1,[R0, #+24]
    517          #else
    518              config->PFlashAccessSegmentSize = 0;
    519              config->PFlashAccessSegmentCount = 0;
    520          #endif /* FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL */
    521          
    522              config->PFlashCallback = NULL;
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x6101             STR      R1,[R0, #+16]
    523          
    524          /* copy required flash commands to RAM */
    525          #if (FLASH_DRIVER_IS_FLASH_RESIDENT && !FLASH_DRIVER_IS_EXPORTED)
    526              if (kStatus_FLASH_Success != flash_check_execute_in_ram_function_info(config))
    527              {
    528                  s_flashExecuteInRamFunctionInfo.activeFunctionCount = 0;
    529                  s_flashExecuteInRamFunctionInfo.flashRunCommand = s_flashRunCommand;
    530                  s_flashExecuteInRamFunctionInfo.flashCacheClearCommand = s_flashCacheClearCommand;
    531                  config->flashExecuteInRamFunctionInfo = &s_flashExecuteInRamFunctionInfo.activeFunctionCount;
    532                  FLASH_PrepareExecuteInRamFunctions(config);
    533              }
    534          #endif
    535          
    536              config->FlexRAMBlockBase = FSL_FEATURE_FLASH_FLEX_RAM_START_ADDRESS;
   \   0000004C   0x6201             STR      R1,[R0, #+32]
    537              config->FlexRAMTotalSize = FSL_FEATURE_FLASH_FLEX_RAM_SIZE;
   \   0000004E   0x6241             STR      R1,[R0, #+36]
    538          
    539          #if FLASH_SSD_IS_FLEXNVM_ENABLED
    540              {
    541                  status_t returnCode;
    542                  config->DFlashBlockBase = FSL_FEATURE_FLASH_FLEX_NVM_START_ADDRESS;
    543                  returnCode = flash_update_flexnvm_memory_partition_status(config);
    544                  if (returnCode != kStatus_FLASH_Success)
    545                  {
    546                      return returnCode;
    547                  }
    548              }
    549          #endif
    550          
    551              return kStatus_FLASH_Success;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x4770             BX       LR               ;; return
    552          }
    553          

   \                                 In section .text, align 2, keep-with-next
    554          status_t FLASH_SetCallback(flash_config_t *config, flash_callback_t callback)
    555          {
    556              if (config == NULL)
   \                     FLASH_SetCallback: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xBF0E             ITEE     EQ 
   \   00000004   0x2004             MOVEQ    R0,#+4
   \   00000006   0x6101             STRNE    R1,[R0, #+16]
   \   00000008   0x2000             MOVNE    R0,#+0
    557              {
    558                  return kStatus_FLASH_InvalidArgument;
    559              }
    560          
    561              config->PFlashCallback = callback;
    562          
    563              return kStatus_FLASH_Success;
   \   0000000A   0x4770             BX       LR
    564          }
    565          
    566          #if FLASH_DRIVER_IS_FLASH_RESIDENT

   \                                 In section .text, align 2, keep-with-next
    567          status_t FLASH_PrepareExecuteInRamFunctions(flash_config_t *config)
    568          {
   \                     FLASH_PrepareExecuteInRamFunctions: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    569              flash_execute_in_ram_function_config_t *flashExecuteInRamFunctionInfo;
    570          
    571              if (config == NULL)
   \   00000002   0xB908             CBNZ.N   R0,??FLASH_PrepareExecuteInRamFunctions_0
    572              {
    573                  return kStatus_FLASH_InvalidArgument;
   \   00000004   0x2004             MOVS     R0,#+4
   \   00000006   0xBD70             POP      {R4-R6,PC}
    574              }
    575          
    576              flashExecuteInRamFunctionInfo = (flash_execute_in_ram_function_config_t *)config->flashExecuteInRamFunctionInfo;
   \                     ??FLASH_PrepareExecuteInRamFunctions_0: (+1)
   \   00000008   0x69C4             LDR      R4,[R0, #+28]
    577          
    578              copy_flash_run_command(flashExecuteInRamFunctionInfo->flashRunCommand);
   \   0000000A   0x.... 0x....      ADR.W    R1,s_flashRunCommandFunctionCode
   \   0000000E   0x6865             LDR      R5,[R4, #+4]
   \   00000010   0x220C             MOVS     R2,#+12
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       __aeabi_memcpy
   \   00000018   0x.... 0x....      LDR.W    R6,??DataTable23_2
    579              copy_flash_cache_clear_command(flashExecuteInRamFunctionInfo->flashCacheClearCommand);
   \   0000001C   0x.... 0x....      ADR.W    R1,s_flashCacheClearCommandFunctionCode
   \   00000020   0x1C68             ADDS     R0,R5,#+1
   \   00000022   0x6030             STR      R0,[R6, #+0]
   \   00000024   0x2214             MOVS     R2,#+20
   \   00000026   0x68A5             LDR      R5,[R4, #+8]
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x.... 0x....      BL       __aeabi_memcpy
   \   0000002E   0x1C68             ADDS     R0,R5,#+1
   \   00000030   0x6070             STR      R0,[R6, #+4]
    580              flashExecuteInRamFunctionInfo->activeFunctionCount = kFLASH_ExecuteInRamFunctionTotalNum;
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x6020             STR      R0,[R4, #+0]
    581          
    582              return kStatus_FLASH_Success;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
    583          }
    584          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
    585          

   \                                 In section .text, align 2, keep-with-next
    586          status_t FLASH_EraseAll(flash_config_t *config, uint32_t key)
    587          {
   \                     FLASH_EraseAll: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    588              status_t returnCode;
    589          
    590              if (config == NULL)
   \   00000004   0xD101             BNE.N    ??FLASH_EraseAll_0
    591              {
    592                  return kStatus_FLASH_InvalidArgument;
   \   00000006   0x2004             MOVS     R0,#+4
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}
    593              }
    594          
    595              /* preparing passing parameter to erase all flash blocks */
    596              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_ERASE_ALL_BLOCK, 0xFFFFFFU);
   \                     ??FLASH_EraseAll_0: (+1)
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable23_3  ;; 0x40020004
   \   0000000E   0xF06F 0x403B      MVN      R0,#-1157627904
   \   00000012   0x6010             STR      R0,[R2, #+0]
    597          
    598              /* Validate the user key */
    599              returnCode = flash_check_user_key(key);
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable23_4  ;; 0x6b65666b
   \   00000018   0x4281             CMP      R1,R0
   \   0000001A   0xD001             BEQ.N    ??FLASH_EraseAll_1
    600              if (returnCode)
    601              {
    602                  return returnCode;
   \   0000001C   0x206B             MOVS     R0,#+107
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}
    603              }
    604          
    605              /* calling flash command sequence function to execute the command */
    606              returnCode = flash_command_sequence(config);
   \                     ??FLASH_EraseAll_1: (+1)
   \   00000020   0x....             B.N      ?Subroutine0
    607          
    608              flash_cache_clear(config);
    609          
    610          #if FLASH_SSD_IS_FLEXNVM_ENABLED
    611              /* Data flash IFR will be erased by erase all command, so we need to
    612               *  update FlexNVM memory partition status synchronously */
    613              if (returnCode == kStatus_FLASH_Success)
    614              {
    615                  returnCode = flash_update_flexnvm_memory_partition_status(config);
    616              }
    617          #endif
    618          
    619              return returnCode;
    620          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x4620             MOV      R0,R4
   \   00000002   0x.... 0x....      BL       flash_command_sequence
   \   00000006   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_13: (+1)
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x4605             MOV      R5,R0
   \                     ??Subroutine6_0: (+1)
   \   00000002   0x4620             MOV      R0,R4
   \   00000004   0x....             B.N      flash_cache_clear
    621          

   \                                 In section .text, align 2, keep-with-next
    622          status_t FLASH_Erase(flash_config_t *config, uint32_t start, uint32_t lengthInBytes, uint32_t key)
    623          {
   \                     FLASH_Erase: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x4680             MOV      R8,R0
   \   0000000A   0x460D             MOV      R5,R1
   \   0000000C   0x.... 0x....      BL       ?Subroutine3
    624              uint32_t sectorSize;
    625              flash_operation_config_t flashInfo;
    626              uint32_t endAddress;      /* storing end address */
    627              uint32_t numberOfSectors; /* number of sectors calculated by endAddress */
    628              status_t returnCode;
    629          
    630              flash_get_matched_operation_info(config, start, &flashInfo);
    631          
    632              /* Check the supplied address range. */
    633              returnCode = flash_check_range(config, start, lengthInBytes, flashInfo.sectorCmdAddressAligment);
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000010   0x9B04             LDR      R3,[SP, #+16]
   \   00000012   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000016   0x0004             MOVS     R4,R0
    634              if (returnCode)
   \   00000018   0xD11B             BNE.N    ??FLASH_Erase_0
    635              {
    636                  return returnCode;
    637              }
    638          
    639              start = flashInfo.convertedAddress;
   \   0000001A   0x9D00             LDR      R5,[SP, #+0]
    640              sectorSize = flashInfo.activeSectorSize;
   \   0000001C   0x9F01             LDR      R7,[SP, #+4]
    641          
    642              /* calculating Flash end address */
    643              endAddress = start + lengthInBytes - 1;
   \   0000001E   0x1970             ADDS     R0,R6,R5
   \   00000020   0x1E46             SUBS     R6,R0,#+1
    644          
    645              /* re-calculate the endAddress and align it to the start of the next sector
    646               * which will be used in the comparison below */
    647              if (endAddress % sectorSize)
   \   00000022   0xFBB6 0xF0F7      UDIV     R0,R6,R7
   \   00000026   0xFB07 0x6110      MLS      R1,R7,R0,R6
   \   0000002A   0xB121             CBZ.N    R1,??FLASH_Erase_1
    648              {
    649                  numberOfSectors = endAddress / sectorSize + 1;
    650                  endAddress = numberOfSectors * sectorSize - 1;
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0x4378             MULS     R0,R7,R0
   \   00000030   0x1E46             SUBS     R6,R0,#+1
   \   00000032   0xE000             B.N      ??FLASH_Erase_1
    651              }
    652          
    653              /* the start address will increment to the next sector address
    654               * until it reaches the endAdddress */
    655              while (start <= endAddress)
    656              {
    657                  /* preparing passing parameter to erase a flash block */
    658                  kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_ERASE_SECTOR, start);
    659          
    660                  /* Validate the user key */
    661                  returnCode = flash_check_user_key(key);
    662                  if (returnCode)
    663                  {
    664                      return returnCode;
    665                  }
    666          
    667                  /* calling flash command sequence function to execute the command */
    668                  returnCode = flash_command_sequence(config);
    669          
    670                  /* calling flash callback function if it is available */
    671                  if (config->PFlashCallback)
    672                  {
    673                      config->PFlashCallback();
    674                  }
    675          
    676                  /* checking the success of command execution */
    677                  if (kStatus_FLASH_Success != returnCode)
    678                  {
    679                      break;
    680                  }
    681                  else
    682                  {
    683                      /* Increment to the next sector */
    684                      start += sectorSize;
   \                     ??FLASH_Erase_2: (+1)
   \   00000034   0x197D             ADDS     R5,R7,R5
    685                  }
   \                     ??FLASH_Erase_1: (+1)
   \   00000036   0x42AE             CMP      R6,R5
   \   00000038   0xD317             BCC.N    ??FLASH_Erase_3
   \   0000003A   0xF025 0x407F      BIC      R0,R5,#0xFF000000
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable23_3  ;; 0x40020004
   \   00000042   0xF040 0x6010      ORR      R0,R0,#0x9000000
   \   00000046   0x6008             STR      R0,[R1, #+0]
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable23_4  ;; 0x6b65666b
   \   0000004C   0x4581             CMP      R9,R0
   \   0000004E   0xD002             BEQ.N    ??FLASH_Erase_4
   \   00000050   0x246B             MOVS     R4,#+107
   \                     ??FLASH_Erase_0: (+1)
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x....             B.N      ?Subroutine1
   \                     ??FLASH_Erase_4: (+1)
   \   00000056   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_10: (+1)
   \   0000005A   0x4604             MOV      R4,R0
   \   0000005C   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \   00000060   0x0001             MOVS     R1,R0
   \   00000062   0xBF18             IT       NE 
   \   00000064   0x4780             BLXNE    R0
   \   00000066   0x2C00             CMP      R4,#+0
   \   00000068   0xD0E4             BEQ.N    ??FLASH_Erase_2
    686              }
    687          
    688              flash_cache_clear(config);
   \                     ??FLASH_Erase_3: (+1)
   \   0000006A   0x4640             MOV      R0,R8
   \   0000006C   0x.... 0x....      BL       flash_cache_clear
   \   00000070   0xE7EF             B.N      ??FLASH_Erase_0
    689          
    690              return (returnCode);
    691          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xB009             ADD      SP,SP,#+36
   \   00000002   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x4640             MOV      R0,R8
   \   00000002   0x....             B.N      flash_command_sequence

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x4632             MOV      R2,R6
   \   00000002   0x4629             MOV      R1,R5
   \   00000004   0x4640             MOV      R0,R8
   \   00000006   0x....             B.N      flash_check_range

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x4699             MOV      R9,R3
   \                     ??Subroutine3_0: (+1)
   \   00000002   0x466A             MOV      R2,SP
   \   00000004   0x....             B.N      flash_get_matched_operation_info
    692          
    693          #if defined(FSL_FEATURE_FLASH_HAS_ERASE_ALL_BLOCKS_UNSECURE_CMD) && FSL_FEATURE_FLASH_HAS_ERASE_ALL_BLOCKS_UNSECURE_CMD
    694          status_t FLASH_EraseAllUnsecure(flash_config_t *config, uint32_t key)
    695          {
    696              status_t returnCode;
    697          
    698              if (config == NULL)
    699              {
    700                  return kStatus_FLASH_InvalidArgument;
    701              }
    702          
    703              /* Prepare passing parameter to erase all flash blocks (unsecure). */
    704              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_ERASE_ALL_BLOCK_UNSECURE, 0xFFFFFFU);
    705          
    706              /* Validate the user key */
    707              returnCode = flash_check_user_key(key);
    708              if (returnCode)
    709              {
    710                  return returnCode;
    711              }
    712          
    713              /* calling flash command sequence function to execute the command */
    714              returnCode = flash_command_sequence(config);
    715          
    716              flash_cache_clear(config);
    717          
    718          #if FLASH_SSD_IS_FLEXNVM_ENABLED
    719              /* Data flash IFR will be erased by erase all unsecure command, so we need to
    720               *  update FlexNVM memory partition status synchronously */
    721              if (returnCode == kStatus_FLASH_Success)
    722              {
    723                  returnCode = flash_update_flexnvm_memory_partition_status(config);
    724              }
    725          #endif
    726          
    727              return returnCode;
    728          }
    729          #endif /* FSL_FEATURE_FLASH_HAS_ERASE_ALL_BLOCKS_UNSECURE_CMD */
    730          

   \                                 In section .text, align 2, keep-with-next
    731          status_t FLASH_EraseAllExecuteOnlySegments(flash_config_t *config, uint32_t key)
    732          {
   \                     FLASH_EraseAllExecuteOnlySegments: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    733              status_t returnCode;
    734          
    735              if (config == NULL)
   \   00000004   0xD101             BNE.N    ??FLASH_EraseAllExecuteOnlySegments_0
    736              {
    737                  return kStatus_FLASH_InvalidArgument;
   \   00000006   0x2004             MOVS     R0,#+4
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}
    738              }
    739          
    740              /* preparing passing parameter to erase all execute-only segments
    741               * 1st element for the FCCOB register */
    742              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_ERASE_ALL_EXECUTE_ONLY_SEGMENT, 0xFFFFFFU);
   \                     ??FLASH_EraseAllExecuteOnlySegments_0: (+1)
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable23_3  ;; 0x40020004
   \   0000000E   0xF06F 0x4034      MVN      R0,#-1275068416
   \   00000012   0x6010             STR      R0,[R2, #+0]
    743          
    744              /* Validate the user key */
    745              returnCode = flash_check_user_key(key);
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable23_4  ;; 0x6b65666b
   \   00000018   0x4281             CMP      R1,R0
   \   0000001A   0xD001             BEQ.N    ??FLASH_EraseAllExecuteOnlySegments_1
    746              if (returnCode)
    747              {
    748                  return returnCode;
   \   0000001C   0x206B             MOVS     R0,#+107
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}
    749              }
    750          
    751              /* calling flash command sequence function to execute the command */
    752              returnCode = flash_command_sequence(config);
   \                     ??FLASH_EraseAllExecuteOnlySegments_1: (+1)
   \   00000020                      REQUIRE ?Subroutine0
   \   00000020                      ;; // Fall through to label ?Subroutine0
    753          
    754              flash_cache_clear(config);
    755          
    756              return returnCode;
    757          }
    758          

   \                                 In section .text, align 2, keep-with-next
    759          status_t FLASH_Program(flash_config_t *config, uint32_t start, uint32_t *src, uint32_t lengthInBytes)
    760          {
   \                     FLASH_Program: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xEA5F 0x0802      MOVS     R8,R2
   \   0000000A   0xB089             SUB      SP,SP,#+36
   \   0000000C   0x460F             MOV      R7,R1
   \   0000000E   0x461D             MOV      R5,R3
    761              status_t returnCode;
    762              flash_operation_config_t flashInfo;
    763          
    764              if (src == NULL)
   \   00000010   0xBF08             IT       EQ 
   \   00000012   0x2004             MOVEQ    R0,#+4
    765              {
    766                  return kStatus_FLASH_InvalidArgument;
   \   00000014   0xD033             BEQ.N    ??FLASH_Program_0
    767              }
    768          
    769              flash_get_matched_operation_info(config, start, &flashInfo);
   \   00000016   0x.... 0x....      BL       ??Subroutine3_0
    770          
    771              /* Check the supplied address range. */
    772              returnCode = flash_check_range(config, start, lengthInBytes, flashInfo.blockWriteUnitSize);
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000001A   0x9B03             LDR      R3,[SP, #+12]
   \   0000001C   0x462A             MOV      R2,R5
   \   0000001E   0x4639             MOV      R1,R7
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       flash_check_range
   \   00000026   0xEA5F 0x0900      MOVS     R9,R0
    773              if (returnCode)
   \   0000002A   0xD128             BNE.N    ??FLASH_Program_0
    774              {
    775                  return returnCode;
    776              }
    777          
    778              start = flashInfo.convertedAddress;
   \   0000002C   0x9F00             LDR      R7,[SP, #+0]
   \   0000002E   0x.... 0x....      LDR.W    R6,??DataTable23_3  ;; 0x40020004
   \   00000032   0xE002             B.N      ??FLASH_Program_1
    779          
    780              while (lengthInBytes > 0)
    781              {
    782                  /* preparing passing parameter to program the flash block */
    783                  kFCCOBx[1] = *src++;
    784                  if (4 == flashInfo.blockWriteUnitSize)
    785                  {
    786                      kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_PROGRAM_LONGWORD, start);
    787                  }
    788                  else if (8 == flashInfo.blockWriteUnitSize)
    789                  {
    790                      kFCCOBx[2] = *src++;
    791                      kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_PROGRAM_PHRASE, start);
    792                  }
    793                  else
    794                  {
    795                  }
    796          
    797                  /* calling flash command sequence function to execute the command */
    798                  returnCode = flash_command_sequence(config);
    799          
    800                  /* calling flash callback function if it is available */
    801                  if (config->PFlashCallback)
    802                  {
    803                      config->PFlashCallback();
    804                  }
    805          
    806                  /* checking for the success of command execution */
    807                  if (kStatus_FLASH_Success != returnCode)
    808                  {
    809                      break;
    810                  }
    811                  else
    812                  {
    813                      /* update start address for next iteration */
    814                      start += flashInfo.blockWriteUnitSize;
   \                     ??FLASH_Program_2: (+1)
   \   00000034   0x9803             LDR      R0,[SP, #+12]
   \   00000036   0x19C7             ADDS     R7,R0,R7
    815          
    816                      /* update lengthInBytes for next iteration */
    817                      lengthInBytes -= flashInfo.blockWriteUnitSize;
   \   00000038   0x1A2D             SUBS     R5,R5,R0
    818                  }
   \                     ??FLASH_Program_1: (+1)
   \   0000003A   0xB1ED             CBZ.N    R5,??FLASH_Program_3
   \   0000003C   0xF858 0x0B04      LDR      R0,[R8], #+4
   \   00000040   0x6070             STR      R0,[R6, #+4]
   \   00000042   0xF027 0x417F      BIC      R1,R7,#0xFF000000
   \   00000046   0x9803             LDR      R0,[SP, #+12]
   \   00000048   0x2804             CMP      R0,#+4
   \   0000004A   0xBF08             IT       EQ 
   \   0000004C   0xF041 0x60C0      ORREQ    R0,R1,#0x6000000
   \   00000050   0xD006             BEQ.N    ??FLASH_Program_4
   \   00000052   0x2808             CMP      R0,#+8
   \   00000054   0xD105             BNE.N    ??FLASH_Program_5
   \   00000056   0xF858 0x0B04      LDR      R0,[R8], #+4
   \   0000005A   0x60B0             STR      R0,[R6, #+8]
   \   0000005C   0xF041 0x60E0      ORR      R0,R1,#0x7000000
   \                     ??FLASH_Program_4: (+1)
   \   00000060   0x6030             STR      R0,[R6, #+0]
   \                     ??FLASH_Program_5: (+1)
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       flash_command_sequence
   \   00000068   0x4681             MOV      R9,R0
   \   0000006A   0x6920             LDR      R0,[R4, #+16]
   \   0000006C   0x0001             MOVS     R1,R0
   \   0000006E   0xBF18             IT       NE 
   \   00000070   0x4780             BLXNE    R0
   \   00000072   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000076   0xD0DD             BEQ.N    ??FLASH_Program_2
    819              }
    820          
    821              flash_cache_clear(config);
   \                     ??FLASH_Program_3: (+1)
   \   00000078   0x.... 0x....      BL       ??Subroutine6_0
    822          
    823              return (returnCode);
   \                     ??CrossCallReturnLabel_11: (+1)
   \   0000007C   0x4648             MOV      R0,R9
   \                     ??FLASH_Program_0: (+1)
   \   0000007E                      REQUIRE ?Subroutine1
   \   0000007E                      ;; // Fall through to label ?Subroutine1
    824          }
    825          

   \                                 In section .text, align 2, keep-with-next
    826          status_t FLASH_ProgramOnce(flash_config_t *config, uint32_t index, uint32_t *src, uint32_t lengthInBytes)
    827          {
   \                     FLASH_ProgramOnce: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    828              status_t returnCode;
    829          
    830              if ((config == NULL) || (src == NULL))
   \   00000004   0xBF18             IT       NE 
   \   00000006   0x2A00             CMPNE    R2,#+0
   \   00000008   0xD101             BNE.N    ??FLASH_ProgramOnce_0
    831              {
    832                  return kStatus_FLASH_InvalidArgument;
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0xBD70             POP      {R4-R6,PC}
    833              }
    834          
    835              /* pass paramters to FTFx */
    836              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_1_2(FTFx_PROGRAM_ONCE, index, 0xFFFFU);
   \                     ??FLASH_ProgramOnce_0: (+1)
   \   0000000E   0x040D             LSLS     R5,R1,#+16
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable23_3  ;; 0x40020004
   \   00000014   0x.... 0x....      LDR.W    R6,??DataTable23_5  ;; 0x4300ffff
   \   00000018   0xF405 0x057F      AND      R5,R5,#0xFF0000
   \   0000001C   0x4335             ORRS     R5,R6,R5
   \   0000001E   0x6005             STR      R5,[R0, #+0]
    837          
    838              kFCCOBx[1] = *src;
    839          
    840          /* Note: Have to seperate the first index from the rest if it equals 0
    841           * to avoid a pointless comparison of unsigned int to 0 compiler warning */
    842          #if FLASH_PROGRAM_ONCE_IS_8BYTES_UNIT_SUPPORT
    843          #if FLASH_PROGRAM_ONCE_IS_4BYTES_UNIT_SUPPORT
    844              if (((index == FLASH_PROGRAM_ONCE_MIN_ID_8BYTES) ||
    845                   /* Range check */
    846                   ((index >= FLASH_PROGRAM_ONCE_MIN_ID_8BYTES + 1) && (index <= FLASH_PROGRAM_ONCE_MAX_ID_8BYTES))) &&
    847                  (lengthInBytes == 8))
   \   00000020   0x2910             CMP      R1,#+16
   \   00000022   0x6815             LDR      R5,[R2, #+0]
   \   00000024   0x6045             STR      R5,[R0, #+4]
   \   00000026   0xD002             BEQ.N    ??FLASH_ProgramOnce_1
   \   00000028   0x3911             SUBS     R1,R1,#+17
   \   0000002A   0x2903             CMP      R1,#+3
   \   0000002C   0xD203             BCS.N    ??FLASH_ProgramOnce_2
   \                     ??FLASH_ProgramOnce_1: (+1)
   \   0000002E   0x2B08             CMP      R3,#+8
   \   00000030   0xBF04             ITT      EQ 
   \   00000032   0x6851             LDREQ    R1,[R2, #+4]
   \   00000034   0x6081             STREQ    R1,[R0, #+8]
    848          #endif /* FLASH_PROGRAM_ONCE_IS_4BYTES_UNIT_SUPPORT */
    849              {
    850                  kFCCOBx[2] = *(src + 1);
    851              }
    852          #endif /* FLASH_PROGRAM_ONCE_IS_8BYTES_UNIT_SUPPORT */
    853          
    854              /* calling flash command sequence function to execute the command */
    855              returnCode = flash_command_sequence(config);
   \                     ??FLASH_ProgramOnce_2: (+1)
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       flash_command_sequence
   \   0000003C   0x.... 0x....      BL       ?Subroutine6
    856          
    857              flash_cache_clear(config);
    858          
    859              return returnCode;
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000040   0x4628             MOV      R0,R5
   \   00000042   0xBD70             POP      {R4-R6,PC}       ;; return
    860          }
    861          
    862          #if defined(FSL_FEATURE_FLASH_HAS_PROGRAM_SECTION_CMD) && FSL_FEATURE_FLASH_HAS_PROGRAM_SECTION_CMD
    863          status_t FLASH_ProgramSection(flash_config_t *config, uint32_t start, uint32_t *src, uint32_t lengthInBytes)
    864          {
    865              status_t returnCode;
    866              uint32_t sectorSize;
    867              flash_operation_config_t flashInfo;
    868          #if defined(FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD) && FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD
    869              bool needSwitchFlexRamMode = false;
    870          #endif /* FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD */
    871          
    872              if (src == NULL)
    873              {
    874                  return kStatus_FLASH_InvalidArgument;
    875              }
    876          
    877              flash_get_matched_operation_info(config, start, &flashInfo);
    878          
    879              /* Check the supplied address range. */
    880              returnCode = flash_check_range(config, start, lengthInBytes, flashInfo.sectionCmdAddressAligment);
    881              if (returnCode)
    882              {
    883                  return returnCode;
    884              }
    885          
    886              start = flashInfo.convertedAddress;
    887              sectorSize = flashInfo.activeSectorSize;
    888          
    889          #if defined(FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD) && FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD
    890              /* Switch function of FlexRAM if needed */
    891              if (!(FTFx->FCNFG & FTFx_FCNFG_RAMRDY_MASK))
    892              {
    893                  needSwitchFlexRamMode = true;
    894          
    895                  returnCode = FLASH_SetFlexramFunction(config, kFLASH_FlexramFunctionOptionAvailableAsRam);
    896                  if (returnCode != kStatus_FLASH_Success)
    897                  {
    898                      return kStatus_FLASH_SetFlexramAsRamError;
    899                  }
    900              }
    901          #endif /* FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD */
    902          
    903              while (lengthInBytes > 0)
    904              {
    905                  /* Make sure the write operation doesn't span two sectors */
    906                  uint32_t endAddressOfCurrentSector = ALIGN_UP(start, sectorSize);
    907                  uint32_t lengthTobeProgrammedOfCurrentSector;
    908                  uint32_t currentOffset = 0;
    909          
    910                  if (endAddressOfCurrentSector == start)
    911                  {
    912                      endAddressOfCurrentSector += sectorSize;
    913                  }
    914          
    915                  if (lengthInBytes + start > endAddressOfCurrentSector)
    916                  {
    917                      lengthTobeProgrammedOfCurrentSector = endAddressOfCurrentSector - start;
    918                  }
    919                  else
    920                  {
    921                      lengthTobeProgrammedOfCurrentSector = lengthInBytes;
    922                  }
    923          
    924                  /* Program Current Sector */
    925                  while (lengthTobeProgrammedOfCurrentSector > 0)
    926                  {
    927                      /* Make sure the program size doesn't exceeds Acceleration RAM size */
    928                      uint32_t programSizeOfCurrentPass;
    929                      uint32_t numberOfPhases;
    930          
    931                      if (lengthTobeProgrammedOfCurrentSector > kFLASH_AccelerationRamSize)
    932                      {
    933                          programSizeOfCurrentPass = kFLASH_AccelerationRamSize;
    934                      }
    935                      else
    936                      {
    937                          programSizeOfCurrentPass = lengthTobeProgrammedOfCurrentSector;
    938                      }
    939          
    940                      /* Copy data to FlexRAM */
    941                      memcpy((void *)FSL_FEATURE_FLASH_FLEX_RAM_START_ADDRESS, src + currentOffset / 4, programSizeOfCurrentPass);
    942                      /* Set start address of the data to be programmed */
    943                      kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_PROGRAM_SECTION, start + currentOffset);
    944                      /* Set program size in terms of FEATURE_FLASH_SECTION_CMD_ADDRESS_ALIGMENT */
    945                      numberOfPhases = programSizeOfCurrentPass / flashInfo.sectionCmdAddressAligment;
    946          
    947                      kFCCOBx[1] = BYTES_JOIN_TO_WORD_2_2(numberOfPhases, 0xFFFFU);
    948          
    949                      /* Peform command sequence */
    950                      returnCode = flash_command_sequence(config);
    951          
    952                      /* calling flash callback function if it is available */
    953                      if (config->PFlashCallback)
    954                      {
    955                          config->PFlashCallback();
    956                      }
    957          
    958                      if (returnCode != kStatus_FLASH_Success)
    959                      {
    960                          flash_cache_clear(config);
    961                          return returnCode;
    962                      }
    963          
    964                      lengthTobeProgrammedOfCurrentSector -= programSizeOfCurrentPass;
    965                      currentOffset += programSizeOfCurrentPass;
    966                  }
    967          
    968                  src += currentOffset / 4;
    969                  start += currentOffset;
    970                  lengthInBytes -= currentOffset;
    971              }
    972          
    973              flash_cache_clear(config);
    974          
    975          #if defined(FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD) && FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD
    976              /* Restore function of FlexRAM if needed. */
    977              if (needSwitchFlexRamMode)
    978              {
    979                  returnCode = FLASH_SetFlexramFunction(config, kFLASH_FlexramFunctionOptionAvailableForEeprom);
    980                  if (returnCode != kStatus_FLASH_Success)
    981                  {
    982                      return kStatus_FLASH_RecoverFlexramAsEepromError;
    983                  }
    984              }
    985          #endif /* FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD */
    986          
    987              return returnCode;
    988          }
    989          #endif /* FSL_FEATURE_FLASH_HAS_PROGRAM_SECTION_CMD */
    990          
    991          #if FLASH_SSD_IS_FLEXNVM_ENABLED
    992          status_t FLASH_EepromWrite(flash_config_t *config, uint32_t start, uint8_t *src, uint32_t lengthInBytes)
    993          {
    994              status_t returnCode;
    995              bool needSwitchFlexRamMode = false;
    996          
    997              if (config == NULL)
    998              {
    999                  return kStatus_FLASH_InvalidArgument;
   1000              }
   1001          
   1002              /* Validates the range of the given address */
   1003              if ((start < config->FlexRAMBlockBase) ||
   1004                  ((start + lengthInBytes) > (config->FlexRAMBlockBase + config->EEpromTotalSize)))
   1005              {
   1006                  return kStatus_FLASH_AddressError;
   1007              }
   1008          
   1009              returnCode = kStatus_FLASH_Success;
   1010          
   1011              /* Switch function of FlexRAM if needed */
   1012              if (!(FTFx->FCNFG & FTFx_FCNFG_EEERDY_MASK))
   1013              {
   1014                  needSwitchFlexRamMode = true;
   1015          
   1016                  returnCode = FLASH_SetFlexramFunction(config, kFLASH_FlexramFunctionOptionAvailableForEeprom);
   1017                  if (returnCode != kStatus_FLASH_Success)
   1018                  {
   1019                      return kStatus_FLASH_SetFlexramAsEepromError;
   1020                  }
   1021              }
   1022          
   1023              /* Write data to FlexRAM when it is used as EEPROM emulator */
   1024              while (lengthInBytes > 0)
   1025              {
   1026                  if ((!(start & 0x3U)) && (lengthInBytes >= 4))
   1027                  {
   1028                      *(uint32_t *)start = *(uint32_t *)src;
   1029                      start += 4;
   1030                      src += 4;
   1031                      lengthInBytes -= 4;
   1032                  }
   1033                  else if ((!(start & 0x1U)) && (lengthInBytes >= 2))
   1034                  {
   1035                      *(uint16_t *)start = *(uint16_t *)src;
   1036                      start += 2;
   1037                      src += 2;
   1038                      lengthInBytes -= 2;
   1039                  }
   1040                  else
   1041                  {
   1042                      *(uint8_t *)start = *src;
   1043                      start += 1;
   1044                      src += 1;
   1045                      lengthInBytes -= 1;
   1046                  }
   1047                  /* Wait till EEERDY bit is set */
   1048                  while (!(FTFx->FCNFG & FTFx_FCNFG_EEERDY_MASK))
   1049                  {
   1050                  }
   1051          
   1052                  /* Check for protection violation error */
   1053                  if (FTFx->FSTAT & FTFx_FSTAT_FPVIOL_MASK)
   1054                  {
   1055                      return kStatus_FLASH_ProtectionViolation;
   1056                  }
   1057              }
   1058          
   1059              /* Switch function of FlexRAM if needed */
   1060              if (needSwitchFlexRamMode)
   1061              {
   1062                  returnCode = FLASH_SetFlexramFunction(config, kFLASH_FlexramFunctionOptionAvailableAsRam);
   1063                  if (returnCode != kStatus_FLASH_Success)
   1064                  {
   1065                      return kStatus_FLASH_RecoverFlexramAsRamError;
   1066                  }
   1067              }
   1068          
   1069              return returnCode;
   1070          }
   1071          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   1072          
   1073          #if defined(FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD) && FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD

   \                                 In section .text, align 2, keep-with-next
   1074          status_t FLASH_ReadResource(
   1075              flash_config_t *config, uint32_t start, uint32_t *dst, uint32_t lengthInBytes, flash_read_resource_option_t option)
   1076          {
   \                     FLASH_ReadResource: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xEA5F 0x0800      MOVS     R8,R0
   \   00000008   0x4691             MOV      R9,R2
   1077              status_t returnCode;
   1078              flash_operation_config_t flashInfo;
   1079          
   1080              if ((config == NULL) || (dst == NULL))
   \   0000000A   0xBF14             ITE      NE 
   \   0000000C   0xF1B9 0x0F00      CMPNE    R9,#+0
   \   00000010   0x2004             MOVEQ    R0,#+4
   \   00000012   0xB089             SUB      SP,SP,#+36
   \   00000014   0x460E             MOV      R6,R1
   \   00000016   0x461D             MOV      R5,R3
   1081              {
   1082                  return kStatus_FLASH_InvalidArgument;
   \   00000018   0xD046             BEQ.N    ??FLASH_ReadResource_0
   1083              }
   1084          
   1085              flash_get_matched_operation_info(config, start, &flashInfo);
   \   0000001A   0x.... 0x....      BL       ??Subroutine3_0
   1086          
   1087              /* Check the supplied address range. */
   1088              returnCode = flash_check_resource_range(start, lengthInBytes, flashInfo.resourceCmdAddressAligment, option);
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000001E   0x9806             LDR      R0,[SP, #+24]
   \   00000020   0x1E40             SUBS     R0,R0,#+1
   \   00000022   0x4206             TST      R6,R0
   \   00000024   0xBF08             IT       EQ 
   \   00000026   0x4205             TSTEQ    R5,R0
   \   00000028   0xD11B             BNE.N    ??FLASH_ReadResource_1
   \   0000002A   0x19A9             ADDS     R1,R5,R6
   \   0000002C   0x9C10             LDR      R4,[SP, #+64]
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x1E49             SUBS     R1,R1,#+1
   \   00000032   0x2C01             CMP      R4,#+1
   \   00000034   0xD105             BNE.N    ??FLASH_ReadResource_2
   \   00000036   0x2E00             CMP      R6,#+0
   \   00000038   0xBF04             ITT      EQ 
   \   0000003A   0x1E69             SUBEQ    R1,R5,#+1
   \   0000003C   0x2907             CMPEQ    R1,#+7
   \   0000003E   0xD10B             BNE.N    ??FLASH_ReadResource_3
   \   00000040   0xE00B             B.N      ??FLASH_ReadResource_4
   \                     ??FLASH_ReadResource_2: (+1)
   \   00000042   0x0022             MOVS     R2,R4
   \   00000044   0xD108             BNE.N    ??FLASH_ReadResource_3
   \   00000046   0x29FF             CMP      R1,#+255
   \   00000048   0xD907             BLS.N    ??FLASH_ReadResource_4
   \   0000004A   0xF5B6 0x0F00      CMP      R6,#+8388608
   \   0000004E   0xD303             BCC.N    ??FLASH_ReadResource_3
   \   00000050   0x.... 0x....      LDR.W    R2,??DataTable23_6  ;; 0x800400
   \   00000054   0x4291             CMP      R1,R2
   \   00000056   0xD300             BCC.N    ??FLASH_ReadResource_4
   \                     ??FLASH_ReadResource_3: (+1)
   \   00000058   0x2004             MOVS     R0,#+4
   1089              if (returnCode != kStatus_FLASH_Success)
   \                     ??FLASH_ReadResource_4: (+1)
   \   0000005A   0xBB28             CBNZ.N   R0,??FLASH_ReadResource_0
   \   0000005C   0x.... 0x....      LDR.W    R7,??DataTable23_3  ;; 0x40020004
   \   00000060   0xE00D             B.N      ??FLASH_ReadResource_5
   \                     ??FLASH_ReadResource_1: (+1)
   \   00000062   0x2065             MOVS     R0,#+101
   \   00000064   0xE020             B.N      ??FLASH_ReadResource_0
   1090              {
   1091                  return returnCode;
   1092              }
   1093          
   1094              while (lengthInBytes > 0)
   1095              {
   1096                  /* preparing passing parameter */
   1097                  kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_READ_RESOURCE, start);
   1098                  if (flashInfo.resourceCmdAddressAligment == 4)
   1099                  {
   1100                      kFCCOBx[2] = BYTES_JOIN_TO_WORD_1_3(option, 0xFFFFFFU);
   1101                  }
   1102                  else if (flashInfo.resourceCmdAddressAligment == 8)
   1103                  {
   1104                      kFCCOBx[1] = BYTES_JOIN_TO_WORD_1_3(option, 0xFFFFFFU);
   1105                  }
   1106                  else
   1107                  {
   1108                  }
   1109          
   1110                  /* calling flash command sequence function to execute the command */
   1111                  returnCode = flash_command_sequence(config);
   1112          
   1113                  if (kStatus_FLASH_Success != returnCode)
   1114                  {
   1115                      break;
   1116                  }
   1117          
   1118                  /* fetch data */
   1119                  *dst++ = kFCCOBx[1];
   \                     ??FLASH_ReadResource_6: (+1)
   \   00000066   0x6879             LDR      R1,[R7, #+4]
   \   00000068   0xF849 0x1B04      STR      R1,[R9], #+4
   1120                  if (flashInfo.resourceCmdAddressAligment == 8)
   \   0000006C   0x9906             LDR      R1,[SP, #+24]
   \   0000006E   0x2908             CMP      R1,#+8
   \   00000070   0xBF04             ITT      EQ 
   \   00000072   0x68B9             LDREQ    R1,[R7, #+8]
   \   00000074   0xF849 0x1B04      STREQ    R1,[R9], #+4
   1121                  {
   1122                      *dst++ = kFCCOBx[2];
   1123                  }
   1124                  /* update start address for next iteration */
   1125                  start += flashInfo.resourceCmdAddressAligment;
   \   00000078   0x9906             LDR      R1,[SP, #+24]
   \   0000007A   0x198E             ADDS     R6,R1,R6
   1126                  /* update lengthInBytes for next iteration */
   1127                  lengthInBytes -= flashInfo.resourceCmdAddressAligment;
   \   0000007C   0x1A6D             SUBS     R5,R5,R1
   \                     ??FLASH_ReadResource_5: (+1)
   \   0000007E   0xB19D             CBZ.N    R5,??FLASH_ReadResource_0
   \   00000080   0xF026 0x407F      BIC      R0,R6,#0xFF000000
   \   00000084   0xF040 0x7040      ORR      R0,R0,#0x3000000
   \   00000088   0x6038             STR      R0,[R7, #+0]
   \   0000008A   0x0620             LSLS     R0,R4,#+24
   \   0000008C   0x9906             LDR      R1,[SP, #+24]
   \   0000008E   0xF060 0x407F      ORN      R0,R0,#-16777216
   \   00000092   0x2904             CMP      R1,#+4
   \   00000094   0xBF08             IT       EQ 
   \   00000096   0x60B8             STREQ    R0,[R7, #+8]
   \   00000098   0xD002             BEQ.N    ??FLASH_ReadResource_7
   \   0000009A   0x2908             CMP      R1,#+8
   \   0000009C   0xBF08             IT       EQ 
   \   0000009E   0x6078             STREQ    R0,[R7, #+4]
   \                     ??FLASH_ReadResource_7: (+1)
   \   000000A0   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_9: (+1)
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD0DE             BEQ.N    ??FLASH_ReadResource_6
   1128              }
   1129          
   1130              return (returnCode);
   \                     ??FLASH_ReadResource_0: (+1)
   \   000000A8   0x....             B.N      ?Subroutine1
   1131          }
   1132          #endif /* FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD */
   1133          

   \                                 In section .text, align 2, keep-with-next
   1134          status_t FLASH_ReadOnce(flash_config_t *config, uint32_t index, uint32_t *dst, uint32_t lengthInBytes)
   1135          {
   \                     FLASH_ReadOnce: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4615             MOV      R5,R2
   1136              status_t returnCode;
   1137          
   1138              if ((config == NULL) || (dst == NULL))
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xBF18             IT       NE 
   \   00000008   0x2D00             CMPNE    R5,#+0
   \   0000000A   0x460C             MOV      R4,R1
   \   0000000C   0x461E             MOV      R6,R3
   \   0000000E   0xD101             BNE.N    ??FLASH_ReadOnce_0
   1139              {
   1140                  return kStatus_FLASH_InvalidArgument;
   \   00000010   0x2004             MOVS     R0,#+4
   \   00000012   0xBDF2             POP      {R1,R4-R7,PC}
   1141              }
   1142          
   1143              /* pass paramters to FTFx */
   1144              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_1_2(FTFx_READ_ONCE, index, 0xFFFFU);
   \                     ??FLASH_ReadOnce_0: (+1)
   \   00000014   0x0421             LSLS     R1,R4,#+16
   \   00000016   0x.... 0x....      LDR.W    R7,??DataTable23_3  ;; 0x40020004
   \   0000001A   0x.... 0x....      LDR.W    R2,??DataTable23_7  ;; 0x4100ffff
   \   0000001E   0xF401 0x017F      AND      R1,R1,#0xFF0000
   \   00000022   0x4311             ORRS     R1,R2,R1
   \   00000024   0x6039             STR      R1,[R7, #+0]
   1145          
   1146              /* calling flash command sequence function to execute the command */
   1147              returnCode = flash_command_sequence(config);
   \   00000026   0x.... 0x....      BL       flash_command_sequence
   1148          
   1149              if (kStatus_FLASH_Success == returnCode)
   \   0000002A   0xB958             CBNZ.N   R0,??FLASH_ReadOnce_1
   1150              {
   1151                  *dst = kFCCOBx[1];
   \   0000002C   0x6879             LDR      R1,[R7, #+4]
   \   0000002E   0x6029             STR      R1,[R5, #+0]
   1152          /* Note: Have to seperate the first index from the rest if it equals 0
   1153           *       to avoid a pointless comparison of unsigned int to 0 compiler warning */
   1154          #if FLASH_PROGRAM_ONCE_IS_8BYTES_UNIT_SUPPORT
   1155          #if FLASH_PROGRAM_ONCE_IS_4BYTES_UNIT_SUPPORT
   1156                  if (((index == FLASH_PROGRAM_ONCE_MIN_ID_8BYTES) ||
   1157                       /* Range check */
   1158                       ((index >= FLASH_PROGRAM_ONCE_MIN_ID_8BYTES + 1) && (index <= FLASH_PROGRAM_ONCE_MAX_ID_8BYTES))) &&
   1159                      (lengthInBytes == 8))
   \   00000030   0x2C10             CMP      R4,#+16
   \   00000032   0xD003             BEQ.N    ??FLASH_ReadOnce_2
   \   00000034   0xF1A4 0x0111      SUB      R1,R4,#+17
   \   00000038   0x2903             CMP      R1,#+3
   \   0000003A   0xD203             BCS.N    ??FLASH_ReadOnce_1
   \                     ??FLASH_ReadOnce_2: (+1)
   \   0000003C   0x2E08             CMP      R6,#+8
   \   0000003E   0xBF04             ITT      EQ 
   \   00000040   0x68B9             LDREQ    R1,[R7, #+8]
   \   00000042   0x6069             STREQ    R1,[R5, #+4]
   1160          #endif /* FLASH_PROGRAM_ONCE_IS_4BYTES_UNIT_SUPPORT */
   1161                  {
   1162                      *(dst + 1) = kFCCOBx[2];
   1163                  }
   1164          #endif /* FLASH_PROGRAM_ONCE_IS_8BYTES_UNIT_SUPPORT */
   1165              }
   1166          
   1167              return returnCode;
   \                     ??FLASH_ReadOnce_1: (+1)
   \   00000044   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1168          }
   1169          

   \                                 In section .text, align 2, keep-with-next
   1170          status_t FLASH_GetSecurityState(flash_config_t *config, flash_security_state_t *state)
   1171          {
   1172              /* store data read from flash register */
   1173              uint8_t registerValue;
   1174          
   1175              if ((config == NULL) || (state == NULL))
   \                     FLASH_GetSecurityState: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xBF18             IT       NE 
   \   00000004   0x2900             CMPNE    R1,#+0
   \   00000006   0xD101             BNE.N    ??FLASH_GetSecurityState_0
   1176              {
   1177                  return kStatus_FLASH_InvalidArgument;
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0x4770             BX       LR
   1178              }
   1179          
   1180              /* Get flash security register value */
   1181              registerValue = FTFx->FSEC;
   \                     ??FLASH_GetSecurityState_0: (+1)
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable23_8  ;; 0x40020002
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   1182          
   1183              /* check the status of the flash security bits in the security register */
   1184              if (FLASH_SECURITY_STATE_UNSECURED == (registerValue & FTFx_FSEC_SEC_MASK))
   \   00000012   0xF000 0x0203      AND      R2,R0,#0x3
   \   00000016   0x2A02             CMP      R2,#+2
   \   00000018   0xBF08             IT       EQ 
   \   0000001A   0x2000             MOVEQ    R0,#+0
   1185              {
   1186                  /* Flash in unsecured state */
   1187                  *state = kFLASH_SecurityStateNotSecure;
   \   0000001C   0xD005             BEQ.N    ??FLASH_GetSecurityState_1
   1188              }
   1189              else
   1190              {
   1191                  /* Flash in secured state
   1192                   * check for backdoor key security enable bit */
   1193                  if (FLASH_SECURITY_STATE_KEYEN == (registerValue & FTFx_FSEC_KEYEN_MASK))
   \   0000001E   0xF000 0x00C0      AND      R0,R0,#0xC0
   \   00000022   0x2880             CMP      R0,#+128
   \   00000024   0xBF0C             ITE      EQ 
   \   00000026   0x2001             MOVEQ    R0,#+1
   \   00000028   0x2002             MOVNE    R0,#+2
   1194                  {
   1195                      /* Backdoor key security enabled */
   1196                      *state = kFLASH_SecurityStateBackdoorEnabled;
   1197                  }
   1198                  else
   1199                  {
   1200                      /* Backdoor key security disabled */
   1201                      *state = kFLASH_SecurityStateBackdoorDisabled;
   \                     ??FLASH_GetSecurityState_1: (+1)
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
   1202                  }
   1203              }
   1204          
   1205              return (kStatus_FLASH_Success);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x4770             BX       LR               ;; return
   1206          }
   1207          

   \                                 In section .text, align 2, keep-with-next
   1208          status_t FLASH_SecurityBypass(flash_config_t *config, const uint8_t *backdoorKey)
   1209          {
   \                     FLASH_SecurityBypass: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460A             MOV      R2,R1
   1210              uint8_t registerValue; /* registerValue */
   1211              status_t returnCode;   /* return code variable */
   1212          
   1213              if ((config == NULL) || (backdoorKey == NULL))
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xBF18             IT       NE 
   \   00000008   0x2A00             CMPNE    R2,#+0
   \   0000000A   0xD101             BNE.N    ??FLASH_SecurityBypass_0
   1214              {
   1215                  return kStatus_FLASH_InvalidArgument;
   \   0000000C   0x2004             MOVS     R0,#+4
   \   0000000E   0xBD10             POP      {R4,PC}
   1216              }
   1217          
   1218              /* set the default return code as kStatus_Success */
   1219              returnCode = kStatus_FLASH_Success;
   1220          
   1221              /* Get flash security register value */
   1222              registerValue = FTFx->FSEC;
   \                     ??FLASH_SecurityBypass_0: (+1)
   \   00000010   0x.... 0x....      LDR.W    R3,??DataTable23_8  ;; 0x40020002
   \   00000014   0x781C             LDRB     R4,[R3, #+0]
   \   00000016   0x2100             MOVS     R1,#+0
   1223          
   1224              /* Check to see if flash is in secure state (any state other than 0x2)
   1225               * If not, then skip this since flash is not secure */
   1226              if (0x02 != (registerValue & 0x03))
   \   00000018   0xF004 0x0403      AND      R4,R4,#0x3
   \   0000001C   0x2C02             CMP      R4,#+2
   \   0000001E   0xD01E             BEQ.N    ??FLASH_SecurityBypass_1
   1227              {
   1228                  /* preparing passing parameter to erase a flash block */
   1229                  kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_SECURITY_BY_PASS, 0xFFFFFFU);
   \   00000020   0xF06F 0x413A      MVN      R1,#-1174405120
   \   00000024   0xF8C3 0x1002      STR      R1,[R3, #+2]
   1230                  kFCCOBx[1] = BYTES_JOIN_TO_WORD_1_1_1_1(backdoorKey[0], backdoorKey[1], backdoorKey[2], backdoorKey[3]);
   \   00000028   0x7854             LDRB     R4,[R2, #+1]
   \   0000002A   0x7811             LDRB     R1,[R2, #+0]
   \   0000002C   0x0424             LSLS     R4,R4,#+16
   \   0000002E   0xEA44 0x6101      ORR      R1,R4,R1, LSL #+24
   \   00000032   0x7894             LDRB     R4,[R2, #+2]
   \   00000034   0xEA41 0x2104      ORR      R1,R1,R4, LSL #+8
   \   00000038   0x78D4             LDRB     R4,[R2, #+3]
   \   0000003A   0x4321             ORRS     R1,R4,R1
   \   0000003C   0xF8C3 0x1006      STR      R1,[R3, #+6]
   1231                  kFCCOBx[2] = BYTES_JOIN_TO_WORD_1_1_1_1(backdoorKey[4], backdoorKey[5], backdoorKey[6], backdoorKey[7]);
   \   00000040   0x7954             LDRB     R4,[R2, #+5]
   \   00000042   0x7911             LDRB     R1,[R2, #+4]
   \   00000044   0x0424             LSLS     R4,R4,#+16
   \   00000046   0xEA44 0x6101      ORR      R1,R4,R1, LSL #+24
   \   0000004A   0x7994             LDRB     R4,[R2, #+6]
   \   0000004C   0x79D2             LDRB     R2,[R2, #+7]
   \   0000004E   0xEA41 0x2104      ORR      R1,R1,R4, LSL #+8
   \   00000052   0x4311             ORRS     R1,R2,R1
   \   00000054   0xF8C3 0x100A      STR      R1,[R3, #+10]
   1232          
   1233                  /* calling flash command sequence function to execute the command */
   1234                  returnCode = flash_command_sequence(config);
   \   00000058   0x.... 0x....      BL       flash_command_sequence
   \   0000005C   0x4601             MOV      R1,R0
   1235              }
   1236          
   1237              return (returnCode);
   \                     ??FLASH_SecurityBypass_1: (+1)
   \   0000005E   0x4608             MOV      R0,R1
   \   00000060   0xBD10             POP      {R4,PC}          ;; return
   1238          }
   1239          

   \                                 In section .text, align 2, keep-with-next
   1240          status_t FLASH_VerifyEraseAll(flash_config_t *config, flash_margin_value_t margin)
   1241          {
   1242              if (config == NULL)
   \                     FLASH_VerifyEraseAll: (+1)
   \   00000000   0xB908             CBNZ.N   R0,??FLASH_VerifyEraseAll_0
   1243              {
   1244                  return kStatus_FLASH_InvalidArgument;
   \   00000002   0x2004             MOVS     R0,#+4
   \   00000004   0x4770             BX       LR
   1245              }
   1246          
   1247              /* preparing passing parameter to verify all block command */
   1248              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_1_2(FTFx_VERIFY_ALL_BLOCK, margin, 0xFFFFU);
   \                     ??FLASH_VerifyEraseAll_0: (+1)
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable23_9  ;; 0x4000ffff
   \   0000000A   0x....             B.N      ?Subroutine2
   1249          
   1250              /* calling flash command sequence function to execute the command */
   1251              return flash_command_sequence(config);
   1252          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000004   0x....             LDR.N    R2,??DataTable23_3  ;; 0x40020004
   \   00000006   0x6011             STR      R1,[R2, #+0]
   \   00000008   0x....             B.N      flash_command_sequence
   1253          

   \                                 In section .text, align 2, keep-with-next
   1254          status_t FLASH_VerifyErase(flash_config_t *config, uint32_t start, uint32_t lengthInBytes, flash_margin_value_t margin)
   1255          {
   \                     FLASH_VerifyErase: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x4692             MOV      R10,R2
   \   00000008   0x4680             MOV      R8,R0
   \   0000000A   0x460C             MOV      R4,R1
   \   0000000C   0x.... 0x....      BL       ?Subroutine3
   1256              /* Check arguments. */
   1257              uint32_t blockSize;
   1258              flash_operation_config_t flashInfo;
   1259              uint32_t nextBlockStartAddress;
   1260              uint32_t remainingBytes;
   1261              status_t returnCode;
   1262          
   1263              flash_get_matched_operation_info(config, start, &flashInfo);
   1264          
   1265              returnCode = flash_check_range(config, start, lengthInBytes, flashInfo.sectionCmdAddressAligment);
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000010   0x9B05             LDR      R3,[SP, #+20]
   \   00000012   0x4652             MOV      R2,R10
   \   00000014   0x4621             MOV      R1,R4
   \   00000016   0x4640             MOV      R0,R8
   \   00000018   0x.... 0x....      BL       flash_check_range
   1266              if (returnCode)
   \   0000001C   0xBB78             CBNZ.N   R0,??FLASH_VerifyErase_0
   1267              {
   1268                  return returnCode;
   1269              }
   1270          
   1271              flash_get_matched_operation_info(config, start, &flashInfo);
   \   0000001E   0x466A             MOV      R2,SP
   \   00000020   0x4621             MOV      R1,R4
   \   00000022   0x4640             MOV      R0,R8
   \   00000024   0x.... 0x....      BL       flash_get_matched_operation_info
   1272              start = flashInfo.convertedAddress;
   \   00000028   0x9C00             LDR      R4,[SP, #+0]
   1273              blockSize = flashInfo.activeBlockSize;
   \   0000002A   0x9E02             LDR      R6,[SP, #+8]
   1274          
   1275              nextBlockStartAddress = ALIGN_UP(start, blockSize);
   \   0000002C   0x4260             RSBS     R0,R4,#+0
   \   0000002E   0x4271             RSBS     R1,R6,#+0
   \   00000030   0x4008             ANDS     R0,R1,R0
   \   00000032   0x4245             RSBS     R5,R0,#+0
   1276              if (nextBlockStartAddress == start)
   \   00000034   0x42A5             CMP      R5,R4
   \   00000036   0xBF08             IT       EQ 
   \   00000038   0x1975             ADDEQ    R5,R6,R5
   1277              {
   1278                  nextBlockStartAddress += blockSize;
   1279              }
   1280          
   1281              remainingBytes = lengthInBytes;
   \   0000003A   0x....             LDR.N    R7,??DataTable23_3  ;; 0x40020004
   \   0000003C   0xE003             B.N      ??FLASH_VerifyErase_1
   1282          
   1283              while (remainingBytes)
   1284              {
   1285                  uint32_t numberOfPhrases;
   1286                  uint32_t verifyLength = nextBlockStartAddress - start;
   1287                  if (verifyLength > remainingBytes)
   1288                  {
   1289                      verifyLength = remainingBytes;
   1290                  }
   1291          
   1292                  numberOfPhrases = verifyLength / flashInfo.sectionCmdAddressAligment;
   1293          
   1294                  /* Fill in verify section command parameters. */
   1295                  kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_VERIFY_SECTION, start);
   1296                  kFCCOBx[1] = BYTES_JOIN_TO_WORD_2_1_1(numberOfPhrases, margin, 0xFFU);
   1297          
   1298                  /* calling flash command sequence function to execute the command */
   1299                  returnCode = flash_command_sequence(config);
   1300                  if (returnCode)
   1301                  {
   1302                      return returnCode;
   1303                  }
   1304          
   1305                  remainingBytes -= verifyLength;
   \                     ??FLASH_VerifyErase_2: (+1)
   \   0000003E   0xEBAA 0x0A0B      SUB      R10,R10,R11
   1306                  start += verifyLength;
   \   00000042   0x445C             ADD      R4,R11,R4
   1307                  nextBlockStartAddress += blockSize;
   \   00000044   0x1975             ADDS     R5,R6,R5
   \                     ??FLASH_VerifyErase_1: (+1)
   \   00000046   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000004A   0xD017             BEQ.N    ??FLASH_VerifyErase_3
   \   0000004C   0x1B28             SUBS     R0,R5,R4
   \   0000004E   0x46D3             MOV      R11,R10
   \   00000050   0x4582             CMP      R10,R0
   \   00000052   0xBF88             IT       HI 
   \   00000054   0x4683             MOVHI    R11,R0
   \   00000056   0x9805             LDR      R0,[SP, #+20]
   \   00000058   0xFBBB 0xF0F0      UDIV     R0,R11,R0
   \   0000005C   0xF024 0x417F      BIC      R1,R4,#0xFF000000
   \   00000060   0x0400             LSLS     R0,R0,#+16
   \   00000062   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000066   0xEA40 0x2009      ORR      R0,R0,R9, LSL #+8
   \   0000006A   0x6039             STR      R1,[R7, #+0]
   \   0000006C   0xF040 0x00FF      ORR      R0,R0,#0xFF
   \   00000070   0x6078             STR      R0,[R7, #+4]
   \   00000072   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_8: (+1)
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD0E1             BEQ.N    ??FLASH_VerifyErase_2
   \   0000007A   0xE000             B.N      ??FLASH_VerifyErase_0
   1308              }
   1309          
   1310              return kStatus_FLASH_Success;
   \                     ??FLASH_VerifyErase_3: (+1)
   \   0000007C   0x2000             MOVS     R0,#+0
   \                     ??FLASH_VerifyErase_0: (+1)
   \   0000007E   0xB009             ADD      SP,SP,#+36
   \   00000080   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1311          }
   1312          

   \                                 In section .text, align 2, keep-with-next
   1313          status_t FLASH_VerifyProgram(flash_config_t *config,
   1314                                       uint32_t start,
   1315                                       uint32_t lengthInBytes,
   1316                                       const uint32_t *expectedData,
   1317                                       flash_margin_value_t margin,
   1318                                       uint32_t *failedAddress,
   1319                                       uint32_t *failedData)
   1320          {
   \                     FLASH_VerifyProgram: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0xEA5F 0x0903      MOVS     R9,R3
   \   0000000A   0xB089             SUB      SP,SP,#+36
   \   0000000C   0x460D             MOV      R5,R1
   \   0000000E   0x4616             MOV      R6,R2
   1321              status_t returnCode;
   1322              flash_operation_config_t flashInfo;
   1323          
   1324              if (expectedData == NULL)
   \   00000010   0xBF08             IT       EQ 
   \   00000012   0x2004             MOVEQ    R0,#+4
   1325              {
   1326                  return kStatus_FLASH_InvalidArgument;
   \   00000014   0xD027             BEQ.N    ??FLASH_VerifyProgram_0
   1327              }
   1328          
   1329              flash_get_matched_operation_info(config, start, &flashInfo);
   \   00000016   0x.... 0x....      BL       ??Subroutine3_0
   1330          
   1331              returnCode = flash_check_range(config, start, lengthInBytes, flashInfo.checkCmdAddressAligment);
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000001A   0x9B07             LDR      R3,[SP, #+28]
   \   0000001C   0x.... 0x....      BL       ?Subroutine4
   1332              if (returnCode)
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000020   0xBB08             CBNZ.N   R0,??FLASH_VerifyProgram_0
   1333              {
   1334                  return returnCode;
   1335              }
   1336          
   1337              start = flashInfo.convertedAddress;
   \   00000022   0x9D00             LDR      R5,[SP, #+0]
   \   00000024   0x9C10             LDR      R4,[SP, #+64]
   \   00000026   0x....             LDR.N    R7,??DataTable23_3  ;; 0x40020004
   \   00000028   0xE005             B.N      ??FLASH_VerifyProgram_1
   1338          
   1339              while (lengthInBytes)
   1340              {
   1341                  /* preparing passing parameter to program check the flash block */
   1342                  kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_PROGRAM_CHECK, start);
   1343                  kFCCOBx[1] = BYTES_JOIN_TO_WORD_1_3(margin, 0xFFFFFFU);
   1344                  kFCCOBx[2] = *expectedData;
   1345          
   1346                  /* calling flash command sequence function to execute the command */
   1347                  returnCode = flash_command_sequence(config);
   1348          
   1349                  /* checking for the success of command execution */
   1350                  if (kStatus_FLASH_Success != returnCode)
   1351                  {
   1352                      if (failedAddress)
   1353                      {
   1354                          *failedAddress = start;
   1355                      }
   1356                      if (failedData)
   1357                      {
   1358                          *failedData = 0;
   1359                      }
   1360                      break;
   1361                  }
   1362          
   1363                  lengthInBytes -= flashInfo.checkCmdAddressAligment;
   \                     ??FLASH_VerifyProgram_2: (+1)
   \   0000002A   0x9907             LDR      R1,[SP, #+28]
   1364                  expectedData += flashInfo.checkCmdAddressAligment / sizeof(*expectedData);
   \   0000002C   0x088A             LSRS     R2,R1,#+2
   \   0000002E   0x1A76             SUBS     R6,R6,R1
   \   00000030   0xEB09 0x0982      ADD      R9,R9,R2, LSL #+2
   1365                  start += flashInfo.checkCmdAddressAligment;
   \   00000034   0x194D             ADDS     R5,R1,R5
   \                     ??FLASH_VerifyProgram_1: (+1)
   \   00000036   0xB1B6             CBZ.N    R6,??FLASH_VerifyProgram_0
   \   00000038   0xF025 0x407F      BIC      R0,R5,#0xFF000000
   \   0000003C   0xF040 0x7000      ORR      R0,R0,#0x2000000
   \   00000040   0x6038             STR      R0,[R7, #+0]
   \   00000042   0x0620             LSLS     R0,R4,#+24
   \   00000044   0xF060 0x407F      ORN      R0,R0,#-16777216
   \   00000048   0x6078             STR      R0,[R7, #+4]
   \   0000004A   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   0000004E   0x60B8             STR      R0,[R7, #+8]
   \   00000050   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD0E8             BEQ.N    ??FLASH_VerifyProgram_2
   \   00000058   0x9911             LDR      R1,[SP, #+68]
   \   0000005A   0xB101             CBZ.N    R1,??FLASH_VerifyProgram_3
   \   0000005C   0x600D             STR      R5,[R1, #+0]
   \                     ??FLASH_VerifyProgram_3: (+1)
   \   0000005E   0x9912             LDR      R1,[SP, #+72]
   \   00000060   0xB109             CBZ.N    R1,??FLASH_VerifyProgram_0
   \   00000062   0x2200             MOVS     R2,#+0
   \   00000064   0x600A             STR      R2,[R1, #+0]
   1366              }
   1367          
   1368              return (returnCode);
   \                     ??FLASH_VerifyProgram_0: (+1)
   \   00000066   0x....             B.N      ?Subroutine1
   1369          }
   1370          

   \                                 In section .text, align 2, keep-with-next
   1371          status_t FLASH_VerifyEraseAllExecuteOnlySegments(flash_config_t *config, flash_margin_value_t margin)
   1372          {
   1373              if (config == NULL)
   \                     FLASH_VerifyEraseAllExecuteOnlySegments: (+1)
   \   00000000   0xB908             CBNZ.N   R0,??FLASH_VerifyEraseAllExecuteOnlySegments_0
   1374              {
   1375                  return kStatus_FLASH_InvalidArgument;
   \   00000002   0x2004             MOVS     R0,#+4
   \   00000004   0x4770             BX       LR
   1376              }
   1377          
   1378              /* preparing passing parameter to verify erase all execute-only segments command */
   1379              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_1_2(FTFx_VERIFY_ALL_EXECUTE_ONLY_SEGMENT, margin, 0xFFFFU);
   \                     ??FLASH_VerifyEraseAllExecuteOnlySegments_0: (+1)
   \   00000006   0x....             LDR.N    R2,??DataTable23_10  ;; 0x4a00ffff
   \   00000008                      REQUIRE ?Subroutine2
   \   00000008                      ;; // Fall through to label ?Subroutine2
   1380          
   1381              /* calling flash command sequence function to execute the command */
   1382              return flash_command_sequence(config);
   1383          }
   1384          

   \                                 In section .text, align 2, keep-with-next
   1385          status_t FLASH_IsProtected(flash_config_t *config,
   1386                                     uint32_t start,
   1387                                     uint32_t lengthInBytes,
   1388                                     flash_protection_state_t *protection_state)
   1389          {
   \                     FLASH_IsProtected: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x001D             MOVS     R5,R3
   \   00000008   0xB0A9             SUB      SP,SP,#+164
   \   0000000A   0x460C             MOV      R4,R1
   \   0000000C   0x4617             MOV      R7,R2
   1390              uint32_t endAddress;           /* end address for protection check */
   1391              uint32_t protectionRegionSize; /* size of flash protection region */
   1392              uint32_t regionCheckedCounter; /* increments each time the flash address was checked for
   1393                                              * protection status */
   1394              uint32_t regionCounter;        /* incrementing variable used to increment through the flash
   1395                                              * protection regions */
   1396              uint32_t protectStatusCounter; /* increments each time a flash region was detected as protected */
   1397          
   1398              uint8_t flashRegionProtectStatus[FSL_FEATURE_FTFx_REGION_COUNT]; /* array of the protection status for each
   1399                                                                                * protection region */
   1400              uint32_t flashRegionAddress[FSL_FEATURE_FTFx_REGION_COUNT + 1];  /* array of the start addresses for each flash
   1401                                                                                * protection region. Note this is REGION_COUNT+1
   1402                                                                                * due to requiring the next start address after
   1403                                                                                * the end of flash for loop-check purposes below */
   1404              status_t returnCode;
   1405          
   1406              if (protection_state == NULL)
   \   0000000E   0xBF08             IT       EQ 
   \   00000010   0x2004             MOVEQ    R0,#+4
   1407              {
   1408                  return kStatus_FLASH_InvalidArgument;
   \   00000012   0xD06A             BEQ.N    ??FLASH_IsProtected_0
   1409              }
   1410          
   1411              /* Check the supplied address range. */
   1412              returnCode = flash_check_range(config, start, lengthInBytes, FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
   \   00000014   0x2304             MOVS     R3,#+4
   \   00000016   0x.... 0x....      BL       flash_check_range
   1413              if (returnCode)
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD165             BNE.N    ??FLASH_IsProtected_0
   1414              {
   1415                  return returnCode;
   1416              }
   1417          
   1418              /* calculating Flash end address */
   1419              endAddress = start + lengthInBytes;
   1420          
   1421              /* Calculate the size of the flash protection region
   1422               * If the flash density is > 32KB, then protection region is 1/32 of total flash density
   1423               * Else if flash density is < 32KB, then flash protection region is set to 1KB */
   1424              if (config->PFlashTotalSize > 32 * 1024)
   \   0000001E   0x6872             LDR      R2,[R6, #+4]
   \   00000020   0x1939             ADDS     R1,R7,R4
   \   00000022   0xF5B2 0x4F00      CMP      R2,#+32768
   \   00000026   0xBF8C             ITE      HI 
   \   00000028   0x0952             LSRHI    R2,R2,#+5
   \   0000002A   0xF44F 0x6280      MOVLS    R2,#+1024
   1425              {
   1426                  protectionRegionSize = (config->PFlashTotalSize) / FSL_FEATURE_FTFx_REGION_COUNT;
   1427              }
   1428              else
   1429              {
   1430                  protectionRegionSize = 1024;
   1431              }
   1432          
   1433              /* populate the flashRegionAddress array with the start address of each flash region */
   1434              regionCounter = 0; /* make sure regionCounter is initialized to 0 first */
   \   0000002E   0x2700             MOVS     R7,#+0
   1435          
   1436              /* populate up to 33rd element of array, this is the next address after end of flash array */
   1437              while (regionCounter <= FSL_FEATURE_FTFx_REGION_COUNT)
   1438              {
   1439                  flashRegionAddress[regionCounter] = config->PFlashBlockBase + protectionRegionSize * regionCounter;
   \                     ??FLASH_IsProtected_1: (+1)
   \   00000030   0xF8D6 0xC000      LDR      R12,[R6, #+0]
   \   00000034   0xFB07 0xCC02      MLA      R12,R7,R2,R12
   \   00000038   0xF84D 0xC027      STR      R12,[SP, R7, LSL #+2]
   1440                  regionCounter++;
   \   0000003C   0x1C7F             ADDS     R7,R7,#+1
   1441              }
   \   0000003E   0x2F21             CMP      R7,#+33
   \   00000040   0xD3F6             BCC.N    ??FLASH_IsProtected_1
   1442          
   1443              /* populate flashRegionProtectStatus array with status information
   1444               * Protection status for each region is stored in the FPROT[3:0] registers
   1445               * Each bit represents one region of flash
   1446               * 4 registers * 8-bits-per-register = 32-bits (32-regions)
   1447               * The convention is:
   1448               * FPROT3[bit 0] is the first protection region (start of flash memory)
   1449               * FPROT0[bit 7] is the last protection region (end of flash memory)
   1450               * regionCounter is used to determine which FPROT[3:0] register to check for protection status
   1451               * Note: FPROT=1 means NOT protected, FPROT=0 means protected */
   1452              regionCounter = 0; /* make sure regionCounter is initialized to 0 first */
   \   00000042   0x2700             MOVS     R7,#+0
   \   00000044   0x....             LDR.N    R3,??DataTable23_11  ;; 0x40020010
   \   00000046   0xAE21             ADD      R6,SP,#+132
   \   00000048   0xE001             B.N      ??FLASH_IsProtected_2
   1453              while (regionCounter < FSL_FEATURE_FTFx_REGION_COUNT)
   1454              {
   1455                  if (regionCounter < 8)
   \                     ??FLASH_IsProtected_3: (+1)
   \   0000004A   0x2F08             CMP      R7,#+8
   \   0000004C   0xD204             BCS.N    ??FLASH_IsProtected_4
   1456                  {
   1457                      flashRegionProtectStatus[regionCounter] = ((FTFx->FPROT3) >> regionCounter) & (0x01u);
   \                     ??FLASH_IsProtected_2: (+1)
   \   0000004E   0xF893 0xE000      LDRB     LR,[R3, #+0]
   \   00000052   0xFA2E 0xFE07      LSR      LR,LR,R7
   \   00000056   0xE018             B.N      ??FLASH_IsProtected_5
   1458                  }
   1459                  else if ((regionCounter >= 8) && (regionCounter < 16))
   \                     ??FLASH_IsProtected_4: (+1)
   \   00000058   0xF1A7 0x0E08      SUB      LR,R7,#+8
   \   0000005C   0xF1BE 0x0F08      CMP      LR,#+8
   \   00000060   0xD204             BCS.N    ??FLASH_IsProtected_6
   1460                  {
   1461                      flashRegionProtectStatus[regionCounter] = ((FTFx->FPROT2) >> (regionCounter - 8)) & (0x01u);
   \   00000062   0xF893 0xE001      LDRB     LR,[R3, #+1]
   \   00000066   0xF1A7 0x0808      SUB      R8,R7,#+8
   \   0000006A   0xE00C             B.N      ??FLASH_IsProtected_7
   1462                  }
   1463                  else if ((regionCounter >= 16) && (regionCounter < 24))
   \                     ??FLASH_IsProtected_6: (+1)
   \   0000006C   0xF1A7 0x0E10      SUB      LR,R7,#+16
   \   00000070   0xF1BE 0x0F08      CMP      LR,#+8
   \   00000074   0xBF39             ITTEE    CC 
   \   00000076   0xF893 0xE002      LDRBCC   LR,[R3, #+2]
   \   0000007A   0xF1A7 0x0810      SUBCC    R8,R7,#+16
   \   0000007E   0xF893 0xE003      LDRBCS   LR,[R3, #+3]
   \   00000082   0xF1A7 0x0818      SUBCS    R8,R7,#+24
   1464                  {
   1465                      flashRegionProtectStatus[regionCounter] = ((FTFx->FPROT1) >> (regionCounter - 16)) & (0x01u);
   1466                  }
   1467                  else
   1468                  {
   1469                      flashRegionProtectStatus[regionCounter] = ((FTFx->FPROT0) >> (regionCounter - 24)) & (0x01u);
   \                     ??FLASH_IsProtected_7: (+1)
   \   00000086   0xFA2E 0xFE08      LSR      LR,LR,R8
   \                     ??FLASH_IsProtected_5: (+1)
   \   0000008A   0xF00E 0x0E01      AND      LR,LR,#0x1
   \   0000008E   0xF806 0xE007      STRB     LR,[R6, R7]
   1470                  }
   1471                  regionCounter++;
   \   00000092   0x1C7F             ADDS     R7,R7,#+1
   1472              }
   \   00000094   0x2F20             CMP      R7,#+32
   \   00000096   0xD3D8             BCC.N    ??FLASH_IsProtected_3
   1473          
   1474              /* loop through the flash regions and check
   1475               * desired flash address range for protection status
   1476               * loop stops when it is detected that start has exceeded the endAddress */
   1477              regionCounter = 0; /* make sure regionCounter is initialized to 0 first */
   1478              regionCheckedCounter = 0;
   \   00000098   0x2700             MOVS     R7,#+0
   \   0000009A   0xF04F 0x0E00      MOV      LR,#+0
   1479              protectStatusCounter = 0; /* make sure protectStatusCounter is initialized to 0 first */
   \   0000009E   0x46BC             MOV      R12,R7
   \   000000A0   0xE017             B.N      ??FLASH_IsProtected_8
   1480              while (start < endAddress)
   1481              {
   1482                  /* check to see if the address falls within this protection region
   1483                   * Note that if the entire flash is to be checked, the last protection
   1484                   * region checked would consist of the last protection start address and
   1485                   * the start address following the end of flash */
   1486                  if ((start >= flashRegionAddress[regionCounter]) && (start < flashRegionAddress[regionCounter + 1]))
   \                     ??FLASH_IsProtected_9: (+1)
   \   000000A2   0x469E             MOV      LR,R3
   \                     ??FLASH_IsProtected_10: (+1)
   \   000000A4   0xF85D 0x902E      LDR      R9,[SP, LR, LSL #+2]
   \   000000A8   0x454C             CMP      R4,R9
   \   000000AA   0xF10E 0x0301      ADD      R3,LR,#+1
   \   000000AE   0xD3F8             BCC.N    ??FLASH_IsProtected_9
   \   000000B0   0x46E9             MOV      R9,SP
   \   000000B2   0xEB09 0x098E      ADD      R9,R9,LR, LSL #+2
   \   000000B6   0xF8D9 0x9004      LDR      R9,[R9, #+4]
   \   000000BA   0x454C             CMP      R4,R9
   \   000000BC   0xD2F1             BCS.N    ??FLASH_IsProtected_9
   1487                  {
   1488                      /* increment regionCheckedCounter to indicate this region was checked */
   1489                      regionCheckedCounter++;
   1490          
   1491                      /* check the protection status of this region
   1492                       * Note: FPROT=1 means NOT protected, FPROT=0 means protected */
   1493                      if (!flashRegionProtectStatus[regionCounter])
   \   000000BE   0xF816 0xE00E      LDRB     LR,[R6, LR]
   \   000000C2   0x1C7F             ADDS     R7,R7,#+1
   \   000000C4   0xF1BE 0x0F00      CMP      LR,#+0
   \   000000C8   0xBF08             IT       EQ 
   \   000000CA   0xF10C 0x0C01      ADDEQ    R12,R12,#+1
   1494                      {
   1495                          /* increment protectStatusCounter to indicate this region is protected */
   1496                          protectStatusCounter++;
   1497                      }
   1498                      start += protectionRegionSize; /* increment to an address within the next region */
   \   000000CE   0x1914             ADDS     R4,R2,R4
   1499                  }
   1500                  regionCounter++; /* increment regionCounter to check for the next flash protection region */
   \   000000D0   0x469E             MOV      LR,R3
   1501              }
   \                     ??FLASH_IsProtected_8: (+1)
   \   000000D2   0x428C             CMP      R4,R1
   \   000000D4   0xD3E6             BCC.N    ??FLASH_IsProtected_10
   1502          
   1503              /* if protectStatusCounter == 0, then no region of the desired flash region is protected */
   1504              if (protectStatusCounter == 0)
   \   000000D6   0xF1BC 0x0F00      CMP      R12,#+0
   \   000000DA   0xBF08             IT       EQ 
   \   000000DC   0x2100             MOVEQ    R1,#+0
   1505              {
   1506                  *protection_state = kFLASH_ProtectionStateUnprotected;
   \   000000DE   0xD003             BEQ.N    ??FLASH_IsProtected_11
   1507              }
   1508              /* if protectStatusCounter == regionCheckedCounter, then each region checked was protected */
   1509              else if (protectStatusCounter == regionCheckedCounter)
   \   000000E0   0x45BC             CMP      R12,R7
   \   000000E2   0xBF0C             ITE      EQ 
   \   000000E4   0x2101             MOVEQ    R1,#+1
   \   000000E6   0x2102             MOVNE    R1,#+2
   1510              {
   1511                  *protection_state = kFLASH_ProtectionStateProtected;
   1512              }
   1513              /* if protectStatusCounter != regionCheckedCounter, then protection status is mixed
   1514               * In other words, some regions are protected while others are unprotected */
   1515              else
   1516              {
   1517                  *protection_state = kFLASH_ProtectionStateMixed;
   \                     ??FLASH_IsProtected_11: (+1)
   \   000000E8   0x7029             STRB     R1,[R5, #+0]
   1518              }
   1519          
   1520              return (returnCode);
   \                     ??FLASH_IsProtected_0: (+1)
   \   000000EA   0xB029             ADD      SP,SP,#+164
   \   000000EC   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   1521          }
   1522          

   \                                 In section .text, align 2, keep-with-next
   1523          status_t FLASH_IsExecuteOnly(flash_config_t *config,
   1524                                       uint32_t start,
   1525                                       uint32_t lengthInBytes,
   1526                                       flash_execute_only_access_state_t *access_state)
   1527          {
   \                     FLASH_IsExecuteOnly: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x001E             MOVS     R6,R3
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4617             MOV      R7,R2
   1528              status_t returnCode;
   1529          
   1530              if (access_state == NULL)
   \   0000000C   0xBF08             IT       EQ 
   \   0000000E   0x2004             MOVEQ    R0,#+4
   1531              {
   1532                  return kStatus_FLASH_InvalidArgument;
   \   00000010   0xD034             BEQ.N    ??FLASH_IsExecuteOnly_0
   1533              }
   1534          
   1535              /* Check the supplied address range. */
   1536              returnCode = flash_check_range(config, start, lengthInBytes, FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
   \   00000012   0x2304             MOVS     R3,#+4
   \   00000014   0x.... 0x....      BL       flash_check_range
   1537              if (returnCode)
   \   00000018   0xBB80             CBNZ.N   R0,??FLASH_IsExecuteOnly_0
   1538              {
   1539                  return returnCode;
   1540              }
   1541          
   1542          #if defined(FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL) && FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
   1543              {
   1544                  uint32_t executeOnlySegmentCounter = 0;
   1545          
   1546                  /* calculating end address */
   1547                  uint32_t endAddress = start + lengthInBytes;
   1548          
   1549                  /* Aligning start address and end address */
   1550                  uint32_t alignedStartAddress = ALIGN_DOWN(start, config->PFlashAccessSegmentSize);
   1551                  uint32_t alignedEndAddress = ALIGN_UP(endAddress, config->PFlashAccessSegmentSize);
   1552          
   1553                  uint32_t segmentIndex = 0;
   1554                  uint32_t maxSupportedExecuteOnlySegmentCount =
   1555                      (alignedEndAddress - alignedStartAddress) / config->PFlashAccessSegmentSize;
   \   0000001A   0xF8D8 0x3014      LDR      R3,[R8, #+20]
   \   0000001E   0x197A             ADDS     R2,R7,R5
   \   00000020   0x425F             RSBS     R7,R3,#+0
   \   00000022   0xF1C2 0x0C00      RSB      R12,R2,#+0
   \   00000026   0xEA07 0x0C0C      AND      R12,R7,R12
   \   0000002A   0xF1CC 0x0C00      RSB      R12,R12,#+0
   \   0000002E   0x402F             ANDS     R7,R7,R5
   \   00000030   0xEBAC 0x0707      SUB      R7,R12,R7
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0xFBB7 0xF7F3      UDIV     R7,R7,R3
   \   0000003A   0x.... 0x....      LDR.W    R12,??DataTable23_12  ;; 0x40020018
   \   0000003E   0xE00A             B.N      ??FLASH_IsExecuteOnly_1
   1556          
   1557                  while (start < endAddress)
   1558                  {
   1559                      uint32_t xacc;
   1560          
   1561                      segmentIndex = start / config->PFlashAccessSegmentSize;
   1562          
   1563                      if (segmentIndex < 32)
   1564                      {
   1565                          xacc = *(const volatile uint32_t *)&FTFx->XACCL3;
   1566                      }
   1567                      else if (segmentIndex < config->PFlashAccessSegmentCount)
   1568                      {
   1569                          xacc = *(const volatile uint32_t *)&FTFx->XACCH3;
   \                     ??FLASH_IsExecuteOnly_2: (+1)
   \   00000040   0xF8DC 0xE000      LDR      LR,[R12, #+0]
   1570                          segmentIndex -= 32;
   \   00000044   0x3C20             SUBS     R4,R4,#+32
   1571                      }
   1572                      else
   1573                      {
   1574                          break;
   1575                      }
   1576          
   1577                      /* Determine if this address range is in a execute-only protection flash segment. */
   1578                      if ((~xacc) & (1u << segmentIndex))
   \                     ??FLASH_IsExecuteOnly_3: (+1)
   \   00000046   0xEA6F 0x0E0E      MVN      LR,LR
   \   0000004A   0xFA2E 0xF404      LSR      R4,LR,R4
   \   0000004E   0x07E4             LSLS     R4,R4,#+31
   \   00000050   0xBF48             IT       MI 
   \   00000052   0x1C49             ADDMI    R1,R1,#+1
   1579                      {
   1580                          executeOnlySegmentCounter++;
   1581                      }
   1582          
   1583                      start += config->PFlashAccessSegmentSize;
   \   00000054   0x195D             ADDS     R5,R3,R5
   \                     ??FLASH_IsExecuteOnly_1: (+1)
   \   00000056   0x4295             CMP      R5,R2
   \   00000058   0xD20A             BCS.N    ??FLASH_IsExecuteOnly_4
   \   0000005A   0xFBB5 0xF4F3      UDIV     R4,R5,R3
   \   0000005E   0x2C20             CMP      R4,#+32
   \   00000060   0xBF38             IT       CC 
   \   00000062   0xF8DC 0xE004      LDRCC    LR,[R12, #+4]
   \   00000066   0xD3EE             BCC.N    ??FLASH_IsExecuteOnly_3
   \   00000068   0xF8D8 0xE018      LDR      LR,[R8, #+24]
   \   0000006C   0x4574             CMP      R4,LR
   \   0000006E   0xD3E7             BCC.N    ??FLASH_IsExecuteOnly_2
   1584                  }
   1585          
   1586                  if (executeOnlySegmentCounter < 1u)
   \                     ??FLASH_IsExecuteOnly_4: (+1)
   \   00000070   0xB119             CBZ.N    R1,??FLASH_IsExecuteOnly_5
   1587                  {
   1588                      *access_state = kFLASH_AccessStateUnLimited;
   1589                  }
   1590                  else if (executeOnlySegmentCounter < maxSupportedExecuteOnlySegmentCount)
   \   00000072   0x42B9             CMP      R1,R7
   \   00000074   0xBF34             ITE      CC 
   \   00000076   0x2102             MOVCC    R1,#+2
   \   00000078   0x2101             MOVCS    R1,#+1
   1591                  {
   1592                      *access_state = kFLASH_AccessStateMixed;
   1593                  }
   1594                  else
   1595                  {
   1596                      *access_state = kFLASH_AccessStateExecuteOnly;
   \                     ??FLASH_IsExecuteOnly_5: (+1)
   \   0000007A   0x7031             STRB     R1,[R6, #+0]
   1597                  }
   1598              }
   1599          #else
   1600              *access_state = kFLASH_AccessStateUnLimited;
   1601          #endif /* FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL */
   1602          
   1603              return (returnCode);
   \                     ??FLASH_IsExecuteOnly_0: (+1)
   \   0000007C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1604          }
   1605          

   \                                 In section .text, align 4, keep-with-next
   1606          status_t FLASH_GetProperty(flash_config_t *config, flash_property_tag_t whichProperty, uint32_t *value)
   1607          {
   1608              if ((config == NULL) || (value == NULL))
   \                     FLASH_GetProperty: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xBF18             IT       NE 
   \   00000004   0x2A00             CMPNE    R2,#+0
   \   00000006   0xD101             BNE.N    ??FLASH_GetProperty_1
   1609              {
   1610                  return kStatus_FLASH_InvalidArgument;
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0x4770             BX       LR
   1611              }
   1612          
   1613              switch (whichProperty)
   \                     ??FLASH_GetProperty_1: (+1)
   \   0000000C   0x2909             CMP      R1,#+9
   \   0000000E   0xD81D             BHI.N    ??FLASH_GetProperty_2
   \   00000010   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??FLASH_GetProperty_0:
   \   00000014   0x05 0x09          DC8      0x5,0x9,0xB,0xE
   \              0x0B 0x0E    
   \   00000018   0x10 0x12          DC8      0x10,0x12,0x14,0x16
   \              0x14 0x16    
   \   0000001C   0x18 0x1A          DC8      0x18,0x1A
   1614              {
   1615                  case kFLASH_PropertyPflashSectorSize:
   1616                      *value = config->PFlashSectorSize;
   \                     ??FLASH_GetProperty_3: (+1)
   \   0000001E   0x68C0             LDR      R0,[R0, #+12]
   \                     ??FLASH_GetProperty_4: (+1)
   \   00000020   0x6010             STR      R0,[R2, #+0]
   1617                      break;
   1618          
   1619                  case kFLASH_PropertyPflashTotalSize:
   1620                      *value = config->PFlashTotalSize;
   1621                      break;
   1622          
   1623                  case kFLASH_PropertyPflashBlockSize:
   1624                      *value = config->PFlashTotalSize / FSL_FEATURE_FLASH_PFLASH_BLOCK_COUNT;
   1625                      break;
   1626          
   1627                  case kFLASH_PropertyPflashBlockCount:
   1628                      *value = config->PFlashBlockCount;
   1629                      break;
   1630          
   1631                  case kFLASH_PropertyPflashBlockBaseAddr:
   1632                      *value = config->PFlashBlockBase;
   1633                      break;
   1634          
   1635                  case kFLASH_PropertyPflashFacSupport:
   1636          #if defined(FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL)
   1637                      *value = FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL;
   1638          #else
   1639                      *value = 0;
   1640          #endif /* FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL */
   1641                      break;
   1642          
   1643                  case kFLASH_PropertyPflashAccessSegmentSize:
   1644                      *value = config->PFlashAccessSegmentSize;
   1645                      break;
   1646          
   1647                  case kFLASH_PropertyPflashAccessSegmentCount:
   1648                      *value = config->PFlashAccessSegmentCount;
   1649                      break;
   1650          
   1651                  case kFLASH_PropertyFlexRamBlockBaseAddr:
   1652                      *value = config->FlexRAMBlockBase;
   1653                      break;
   1654          
   1655                  case kFLASH_PropertyFlexRamTotalSize:
   1656                      *value = config->FlexRAMTotalSize;
   1657                      break;
   1658          
   1659          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   1660                  case kFLASH_PropertyDflashSectorSize:
   1661                      *value = FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_SECTOR_SIZE;
   1662                      break;
   1663                  case kFLASH_PropertyDflashTotalSize:
   1664                      *value = config->DFlashTotalSize;
   1665                      break;
   1666                  case kFLASH_PropertyDflashBlockSize:
   1667                      *value = FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_SIZE;
   1668                      break;
   1669                  case kFLASH_PropertyDflashBlockCount:
   1670                      *value = FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_COUNT;
   1671                      break;
   1672                  case kFLASH_PropertyDflashBlockBaseAddr:
   1673                      *value = config->DFlashBlockBase;
   1674                      break;
   1675                  case kFLASH_PropertyEepromTotalSize:
   1676                      *value = config->EEpromTotalSize;
   1677                      break;
   1678          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   1679          
   1680                  default: /* catch inputs that are not recognized */
   1681                      return kStatus_FLASH_UnknownProperty;
   1682              }
   1683          
   1684              return kStatus_FLASH_Success;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x4770             BX       LR               ;; return
   \                     ??FLASH_GetProperty_5: (+1)
   \   00000026   0x6840             LDR      R0,[R0, #+4]
   \   00000028   0xE7FA             B.N      ??FLASH_GetProperty_4
   \                     ??FLASH_GetProperty_6: (+1)
   \   0000002A   0x6840             LDR      R0,[R0, #+4]
   \   0000002C   0x0840             LSRS     R0,R0,#+1
   \   0000002E   0xE7F7             B.N      ??FLASH_GetProperty_4
   \                     ??FLASH_GetProperty_7: (+1)
   \   00000030   0x6880             LDR      R0,[R0, #+8]
   \   00000032   0xE7F5             B.N      ??FLASH_GetProperty_4
   \                     ??FLASH_GetProperty_8: (+1)
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xE7F3             B.N      ??FLASH_GetProperty_4
   \                     ??FLASH_GetProperty_9: (+1)
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xE7F1             B.N      ??FLASH_GetProperty_4
   \                     ??FLASH_GetProperty_10: (+1)
   \   0000003C   0x6940             LDR      R0,[R0, #+20]
   \   0000003E   0xE7EF             B.N      ??FLASH_GetProperty_4
   \                     ??FLASH_GetProperty_11: (+1)
   \   00000040   0x6980             LDR      R0,[R0, #+24]
   \   00000042   0xE7ED             B.N      ??FLASH_GetProperty_4
   \                     ??FLASH_GetProperty_12: (+1)
   \   00000044   0x6A00             LDR      R0,[R0, #+32]
   \   00000046   0xE7EB             B.N      ??FLASH_GetProperty_4
   \                     ??FLASH_GetProperty_13: (+1)
   \   00000048   0x6A40             LDR      R0,[R0, #+36]
   \   0000004A   0xE7E9             B.N      ??FLASH_GetProperty_4
   \                     ??FLASH_GetProperty_2: (+1)
   \   0000004C   0x206A             MOVS     R0,#+106
   \   0000004E   0x4770             BX       LR
   1685          }
   1686          
   1687          #if defined(FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD) && FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD
   1688          status_t FLASH_SetFlexramFunction(flash_config_t *config, flash_flexram_function_option_t option)
   1689          {
   1690              status_t status;
   1691          
   1692              if (config == NULL)
   1693              {
   1694                  return kStatus_FLASH_InvalidArgument;
   1695              }
   1696          
   1697              status = flasn_check_flexram_function_option_range(option);
   1698              if (status != kStatus_FLASH_Success)
   1699              {
   1700                  return status;
   1701              }
   1702          
   1703              /* preparing passing parameter to verify all block command */
   1704              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_1_2(FTFx_SET_FLEXRAM_FUNCTION, option, 0xFFFFU);
   1705          
   1706              /* calling flash command sequence function to execute the command */
   1707              return flash_command_sequence(config);
   1708          }
   1709          #endif /* FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD */
   1710          
   1711          #if defined(FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD) && FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD
   1712          status_t FLASH_SwapControl(flash_config_t *config,
   1713                                     uint32_t address,
   1714                                     flash_swap_control_option_t option,
   1715                                     flash_swap_state_config_t *returnInfo)
   1716          {
   1717              status_t returnCode;
   1718          
   1719              if ((config == NULL) || (returnInfo == NULL))
   1720              {
   1721                  return kStatus_FLASH_InvalidArgument;
   1722              }
   1723          
   1724              if (address & (FSL_FEATURE_FLASH_PFLASH_SWAP_CONTROL_CMD_ADDRESS_ALIGMENT - 1))
   1725              {
   1726                  return kStatus_FLASH_AlignmentError;
   1727              }
   1728          
   1729              /* Make sure address provided is in the lower half of Program flash but not in the Flash Configuration Field */
   1730              if ((address >= (config->PFlashTotalSize / 2)) ||
   1731                  ((address >= kFLASH_ConfigAreaStart) && (address <= kFLASH_ConfigAreaEnd)))
   1732              {
   1733                  return kStatus_FLASH_SwapIndicatorAddressError;
   1734              }
   1735          
   1736              /* Check the option. */
   1737              returnCode = flash_check_swap_control_option(option);
   1738              if (returnCode)
   1739              {
   1740                  return returnCode;
   1741              }
   1742          
   1743              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_SWAP_CONTROL, address);
   1744              kFCCOBx[1] = BYTES_JOIN_TO_WORD_1_3(option, 0xFFFFFFU);
   1745          
   1746              returnCode = flash_command_sequence(config);
   1747          
   1748              returnInfo->flashSwapState = (flash_swap_state_t)FTFx->FCCOB5;
   1749              returnInfo->currentSwapBlockStatus = (flash_swap_block_status_t)FTFx->FCCOB6;
   1750              returnInfo->nextSwapBlockStatus = (flash_swap_block_status_t)FTFx->FCCOB7;
   1751          
   1752              return returnCode;
   1753          }
   1754          #endif /* FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD */
   1755          
   1756          #if defined(FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP) && FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP
   1757          status_t FLASH_Swap(flash_config_t *config, uint32_t address, flash_swap_function_option_t option)
   1758          {
   1759              flash_swap_state_config_t returnInfo;
   1760              status_t returnCode;
   1761          
   1762              memset(&returnInfo, 0xFFU, sizeof(returnInfo));
   1763          
   1764              do
   1765              {
   1766                  returnCode = FLASH_SwapControl(config, address, kFLASH_SwapControlOptionReportStatus, &returnInfo);
   1767                  if (returnCode != kStatus_FLASH_Success)
   1768                  {
   1769                      return returnCode;
   1770                  }
   1771          
   1772                  if (kFLASH_SwapFunctionOptionDisable == option)
   1773                  {
   1774                      if (returnInfo.flashSwapState == kFLASH_SwapStateDisabled)
   1775                      {
   1776                          return kStatus_FLASH_Success;
   1777                      }
   1778                      else if (returnInfo.flashSwapState == kFLASH_SwapStateUninitialized)
   1779                      {
   1780                          /* The swap system changed to the DISABLED state with Program flash block 0
   1781                           * located at relative flash address 0x0_0000 */
   1782                          returnCode = FLASH_SwapControl(config, address, kFLASH_SwapControlOptionDisableSystem, &returnInfo);
   1783                      }
   1784                      else
   1785                      {
   1786                          /* Swap disable should be requested only when swap system is in the uninitialized state */
   1787                          return kStatus_FLASH_SwapSystemNotInUninitialized;
   1788                      }
   1789                  }
   1790                  else
   1791                  {
   1792                      /* When first swap: the initial swap state is Uninitialized, flash swap inidicator address is unset,
   1793                       *    the swap procedure should be Uninitialized -> Update-Erased -> Complete.
   1794                       * After the first swap has been completed, the flash swap inidicator address cannot be modified
   1795                       *    unless EraseAllBlocks command is issued, the swap procedure is changed to Update -> Update-Erased ->
   1796                       *    Complete. */
   1797                      switch (returnInfo.flashSwapState)
   1798                      {
   1799                          case kFLASH_SwapStateUninitialized:
   1800                              /* If current swap mode is Uninitialized, Initialize Swap to Initialized/READY state. */
   1801                              returnCode =
   1802                                  FLASH_SwapControl(config, address, kFLASH_SwapControlOptionIntializeSystem, &returnInfo);
   1803                              break;
   1804                          case kFLASH_SwapStateReady:
   1805                              /* Validate whether the address provided to the swap system is matched to
   1806                               * swap indicator address in the IFR */
   1807                              returnCode = flash_validate_swap_indicator_address(config, address);
   1808                              if (returnCode == kStatus_FLASH_Success)
   1809                              {
   1810                                  /* If current swap mode is Initialized/Ready, Initialize Swap to UPDATE state. */
   1811                                  returnCode =
   1812                                      FLASH_SwapControl(config, address, kFLASH_SwapControlOptionSetInUpdateState, &returnInfo);
   1813                              }
   1814                              break;
   1815                          case kFLASH_SwapStateUpdate:
   1816                              /* If current swap mode is Update, Erase indicator sector in non active block
   1817                               * to proceed swap system to update-erased state */
   1818                              returnCode = FLASH_Erase(config, address + (config->PFlashTotalSize >> 1),
   1819                                                       FSL_FEATURE_FLASH_PFLASH_SECTOR_CMD_ADDRESS_ALIGMENT, kFLASH_ApiEraseKey);
   1820                              break;
   1821                          case kFLASH_SwapStateUpdateErased:
   1822                              /* If current swap mode is Update or Update-Erased, progress Swap to COMPLETE State */
   1823                              returnCode =
   1824                                  FLASH_SwapControl(config, address, kFLASH_SwapControlOptionSetInCompleteState, &returnInfo);
   1825                              break;
   1826                          case kFLASH_SwapStateComplete:
   1827                              break;
   1828                          case kFLASH_SwapStateDisabled:
   1829                              /* When swap system is in disabled state, We need to clear swap system back to uninitialized
   1830                               * by issuing EraseAllBlocks command */
   1831                              returnCode = kStatus_FLASH_SwapSystemNotInUninitialized;
   1832                              break;
   1833                          default:
   1834                              returnCode = kStatus_FLASH_InvalidArgument;
   1835                              break;
   1836                      }
   1837                  }
   1838                  if (returnCode != kStatus_FLASH_Success)
   1839                  {
   1840                      break;
   1841                  }
   1842              } while (!((kFLASH_SwapStateComplete == returnInfo.flashSwapState) && (kFLASH_SwapFunctionOptionEnable == option)));
   1843          
   1844              return returnCode;
   1845          }
   1846          #endif /* FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP */
   1847          
   1848          #if defined(FSL_FEATURE_FLASH_HAS_PROGRAM_PARTITION_CMD) && FSL_FEATURE_FLASH_HAS_PROGRAM_PARTITION_CMD
   1849          status_t FLASH_ProgramPartition(flash_config_t *config,
   1850                                          flash_partition_flexram_load_option_t option,
   1851                                          uint32_t eepromDataSizeCode,
   1852                                          uint32_t flexnvmPartitionCode)
   1853          {
   1854              status_t returnCode;
   1855          
   1856              if (config == NULL)
   1857              {
   1858                  return kStatus_FLASH_InvalidArgument;
   1859              }
   1860          
   1861              /* eepromDataSizeCode[7:6], flexnvmPartitionCode[7:4] should be all 1'b0
   1862               *  or it will cause access error. */
   1863              /* eepromDataSizeCode &= 0x3FU;  */
   1864              /* flexnvmPartitionCode &= 0x0FU; */
   1865          
   1866              /* preparing passing parameter to program the flash block */
   1867              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_2_1(FTFx_PROGRAM_PARTITION, 0xFFFFU, option);
   1868              kFCCOBx[1] = BYTES_JOIN_TO_WORD_1_1_2(eepromDataSizeCode, flexnvmPartitionCode, 0xFFFFU);
   1869          
   1870              /* calling flash command sequence function to execute the command */
   1871              returnCode = flash_command_sequence(config);
   1872          
   1873              flash_cache_clear(config);
   1874          
   1875          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   1876              /* Data flash IFR will be updated by program partition command during reset sequence,
   1877               * so we just set reserved values for partitioned FlexNVM size here */
   1878              config->EEpromTotalSize = FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_RESERVED;
   1879              config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   1880          #endif
   1881          
   1882              return (returnCode);
   1883          }
   1884          #endif /* FSL_FEATURE_FLASH_HAS_PROGRAM_PARTITION_CMD */
   1885          

   \                                 In section .text, align 2, keep-with-next
   1886          status_t FLASH_PflashSetProtection(flash_config_t *config, uint32_t protectStatus)
   1887          {
   1888              if (config == NULL)
   \                     FLASH_PflashSetProtection: (+1)
   \   00000000   0xB908             CBNZ.N   R0,??FLASH_PflashSetProtection_0
   1889              {
   1890                  return kStatus_FLASH_InvalidArgument;
   \   00000002   0x2004             MOVS     R0,#+4
   \   00000004   0x4770             BX       LR
   1891              }
   1892          
   1893              *kFPROT = protectStatus;
   \                     ??FLASH_PflashSetProtection_0: (+1)
   \   00000006   0x....             LDR.N    R0,??DataTable23_11  ;; 0x40020010
   \   00000008   0x6001             STR      R1,[R0, #+0]
   1894          
   1895              if (protectStatus != *kFPROT)
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x4281             CMP      R1,R0
   \   0000000E   0xBF14             ITE      NE 
   \   00000010   0x2069             MOVNE    R0,#+105
   \   00000012   0x2000             MOVEQ    R0,#+0
   1896              {
   1897                  return kStatus_FLASH_CommandFailure;
   1898              }
   1899          
   1900              return kStatus_FLASH_Success;
   \   00000014   0x4770             BX       LR
   1901          }
   1902          

   \                                 In section .text, align 2, keep-with-next
   1903          status_t FLASH_PflashGetProtection(flash_config_t *config, uint32_t *protectStatus)
   1904          {
   1905              if ((config == NULL) || (protectStatus == NULL))
   \                     FLASH_PflashGetProtection: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xBF18             IT       NE 
   \   00000004   0x2900             CMPNE    R1,#+0
   \   00000006   0xD101             BNE.N    ??FLASH_PflashGetProtection_0
   1906              {
   1907                  return kStatus_FLASH_InvalidArgument;
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0x4770             BX       LR
   1908              }
   1909          
   1910              *protectStatus = *kFPROT;
   \                     ??FLASH_PflashGetProtection_0: (+1)
   \   0000000C   0x....             LDR.N    R0,??DataTable23_11  ;; 0x40020010
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x6008             STR      R0,[R1, #+0]
   1911          
   1912              return kStatus_FLASH_Success;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4770             BX       LR               ;; return
   1913          }
   1914          
   1915          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   1916          status_t FLASH_DflashSetProtection(flash_config_t *config, uint8_t protectStatus)
   1917          {
   1918              if (config == NULL)
   1919              {
   1920                  return kStatus_FLASH_InvalidArgument;
   1921              }
   1922          
   1923              if ((config->DFlashTotalSize == 0) || (config->DFlashTotalSize == FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED))
   1924              {
   1925                  return kStatus_FLASH_CommandNotSupported;
   1926              }
   1927          
   1928              FTFx->FDPROT = protectStatus;
   1929          
   1930              if (FTFx->FDPROT != protectStatus)
   1931              {
   1932                  return kStatus_FLASH_CommandFailure;
   1933              }
   1934          
   1935              return kStatus_FLASH_Success;
   1936          }
   1937          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   1938          
   1939          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   1940          status_t FLASH_DflashGetProtection(flash_config_t *config, uint8_t *protectStatus)
   1941          {
   1942              if ((config == NULL) || (protectStatus == NULL))
   1943              {
   1944                  return kStatus_FLASH_InvalidArgument;
   1945              }
   1946          
   1947              if ((config->DFlashTotalSize == 0) || (config->DFlashTotalSize == FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED))
   1948              {
   1949                  return kStatus_FLASH_CommandNotSupported;
   1950              }
   1951          
   1952              *protectStatus = FTFx->FDPROT;
   1953          
   1954              return kStatus_FLASH_Success;
   1955          }
   1956          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   1957          
   1958          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   1959          status_t FLASH_EepromSetProtection(flash_config_t *config, uint8_t protectStatus)
   1960          {
   1961              if (config == NULL)
   1962              {
   1963                  return kStatus_FLASH_InvalidArgument;
   1964              }
   1965          
   1966              if ((config->EEpromTotalSize == 0) || (config->EEpromTotalSize == FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_RESERVED))
   1967              {
   1968                  return kStatus_FLASH_CommandNotSupported;
   1969              }
   1970          
   1971              FTFx->FEPROT = protectStatus;
   1972          
   1973              if (FTFx->FEPROT != protectStatus)
   1974              {
   1975                  return kStatus_FLASH_CommandFailure;
   1976              }
   1977          
   1978              return kStatus_FLASH_Success;
   1979          }
   1980          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   1981          
   1982          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   1983          status_t FLASH_EepromGetProtection(flash_config_t *config, uint8_t *protectStatus)
   1984          {
   1985              if ((config == NULL) || (protectStatus == NULL))
   1986              {
   1987                  return kStatus_FLASH_InvalidArgument;
   1988              }
   1989          
   1990              if ((config->EEpromTotalSize == 0) || (config->EEpromTotalSize == FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_RESERVED))
   1991              {
   1992                  return kStatus_FLASH_CommandNotSupported;
   1993              }
   1994          
   1995              *protectStatus = FTFx->FEPROT;
   1996          
   1997              return kStatus_FLASH_Success;
   1998          }
   1999          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   2000          
   2001          #if FLASH_DRIVER_IS_FLASH_RESIDENT
   2002          /*!
   2003           * @brief Copy PIC of flash_run_command() to RAM
   2004           */
   2005          static void copy_flash_run_command(uint32_t *flashRunCommand)
   2006          {
   2007              assert(sizeof(s_flashRunCommandFunctionCode) <= (kFLASH_ExecuteInRamFunctionMaxSizeInWords * 4));
   2008          
   2009              /* Since the value of ARM function pointer is always odd, but the real start address
   2010               * of function memory should be even, that's why +1 operation exist. */
   2011              memcpy((void *)flashRunCommand, (void *)s_flashRunCommandFunctionCode, sizeof(s_flashRunCommandFunctionCode));
   2012              callFlashRunCommand = (void (*)(FTFx_REG_ACCESS_TYPE ftfx_fstat))((uint32_t)flashRunCommand + 1);
   2013          }
   2014          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
   2015          
   2016          /*!
   2017           * @brief Flash Command Sequence
   2018           *
   2019           * This function is used to perform the command write sequence to the flash.
   2020           *
   2021           * @param driver Pointer to storage for the driver runtime state.
   2022           * @return An error code or kStatus_FLASH_Success
   2023           */

   \                                 In section .text, align 2, keep-with-next
   2024          static status_t flash_command_sequence(flash_config_t *config)
   2025          {
   \                     flash_command_sequence: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2026              uint8_t registerValue;
   2027          
   2028          #if FLASH_DRIVER_IS_FLASH_RESIDENT
   2029              /* clear RDCOLERR & ACCERR & FPVIOL flag in flash status register */
   2030              FTFx->FSTAT = FTFx_FSTAT_RDCOLERR_MASK | FTFx_FSTAT_ACCERR_MASK | FTFx_FSTAT_FPVIOL_MASK;
   \   00000002   0x....             LDR.N    R4,??DataTable23_13  ;; 0x40020000
   \   00000004   0x2170             MOVS     R1,#+112
   \   00000006   0x7021             STRB     R1,[R4, #+0]
   2031          
   2032              status_t returnCode = flash_check_execute_in_ram_function_info(config);
   \   00000008   0x.... 0x....      BL       flash_check_execute_in_ram_function_info
   2033              if (kStatus_FLASH_Success != returnCode)
   \   0000000C   0xB988             CBNZ.N   R0,??flash_command_sequence_0
   2034              {
   2035                  return returnCode;
   2036              }
   2037          
   2038              /* We pass the ftfx_fstat address as a parameter to flash_run_comamnd() instead of using
   2039               * pre-processed MICRO sentences or operating global variable in flash_run_comamnd()
   2040               * to make sure that flash_run_command() will be compiled into position-independent code (PIC). */
   2041              callFlashRunCommand((FTFx_REG_ACCESS_TYPE)(&FTFx->FSTAT));
   \   0000000E   0x....             LDR.N    R1,??DataTable23_2
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x4788             BLX      R1
   2042          #else
   2043              /* clear RDCOLERR & ACCERR & FPVIOL flag in flash status register */
   2044              FTFx->FSTAT = FTFx_FSTAT_RDCOLERR_MASK | FTFx_FSTAT_ACCERR_MASK | FTFx_FSTAT_FPVIOL_MASK;
   2045          
   2046              /* clear CCIF bit */
   2047              FTFx->FSTAT = FTFx_FSTAT_CCIF_MASK;
   2048          
   2049              /* Check CCIF bit of the flash status register, wait till it is set.
   2050               * IP team indicates that this loop will always complete. */
   2051              while (!(FTFx->FSTAT & FTFx_FSTAT_CCIF_MASK))
   2052              {
   2053              }
   2054          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
   2055          
   2056              /* Check error bits */
   2057              /* Get flash status register value */
   2058              registerValue = FTFx->FSTAT;
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   2059          
   2060              /* checking access error */
   2061              if (registerValue & FTFx_FSTAT_ACCERR_MASK)
   \   00000018   0x0681             LSLS     R1,R0,#+26
   \   0000001A   0xD501             BPL.N    ??flash_command_sequence_1
   2062              {
   2063                  return kStatus_FLASH_AccessError;
   \   0000001C   0x2067             MOVS     R0,#+103
   \   0000001E   0xBD10             POP      {R4,PC}
   2064              }
   2065              /* checking protection error */
   2066              else if (registerValue & FTFx_FSTAT_FPVIOL_MASK)
   \                     ??flash_command_sequence_1: (+1)
   \   00000020   0x06C1             LSLS     R1,R0,#+27
   \   00000022   0xD501             BPL.N    ??flash_command_sequence_2
   2067              {
   2068                  return kStatus_FLASH_ProtectionViolation;
   \   00000024   0x2068             MOVS     R0,#+104
   \   00000026   0xBD10             POP      {R4,PC}
   2069              }
   2070              /* checking MGSTAT0 non-correctable error */
   2071              else if (registerValue & FTFx_FSTAT_MGSTAT0_MASK)
   \                     ??flash_command_sequence_2: (+1)
   \   00000028   0x07C0             LSLS     R0,R0,#+31
   \   0000002A   0xD501             BPL.N    ??flash_command_sequence_3
   2072              {
   2073                  return kStatus_FLASH_CommandFailure;
   \   0000002C   0x2069             MOVS     R0,#+105
   \   0000002E   0xBD10             POP      {R4,PC}
   2074              }
   2075              else
   2076              {
   2077                  return kStatus_FLASH_Success;
   \                     ??flash_command_sequence_3: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??flash_command_sequence_0: (+1)
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
   2078              }
   2079          }
   2080          
   2081          #if FLASH_DRIVER_IS_FLASH_RESIDENT
   2082          /*!
   2083           * @brief Copy PIC of flash_cache_clear_command() to RAM
   2084           *
   2085           */
   2086          static void copy_flash_cache_clear_command(uint32_t *flashCacheClearCommand)
   2087          {
   2088              assert(sizeof(s_flashCacheClearCommandFunctionCode) <= (kFLASH_ExecuteInRamFunctionMaxSizeInWords * 4));
   2089          
   2090              /* Since the value of ARM function pointer is always odd, but the real start address
   2091               * of function memory should be even, that's why +1 operation exist. */
   2092              memcpy((void *)flashCacheClearCommand, (void *)s_flashCacheClearCommandFunctionCode,
   2093                     sizeof(s_flashCacheClearCommandFunctionCode));
   2094              callFlashCacheClearCommand = (void (*)(FTFx_REG32_ACCESS_TYPE ftfx_reg))((uint32_t)flashCacheClearCommand + 1);
   2095          }
   2096          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
   2097          
   2098          /*!
   2099           * @brief Flash Cache Clear
   2100           *
   2101           * This function is used to perform the cache clear to the flash.
   2102           */
   2103          #if (defined(__GNUC__))
   2104          /* #pragma GCC push_options */
   2105          /* #pragma GCC optimize("O0") */
   2106          void __attribute__((optimize("O0"))) flash_cache_clear(flash_config_t *config)
   2107          #else
   2108          #if (defined(__ICCARM__))
   2109          #pragma optimize = none
   2110          #endif
   2111          #if (defined(__CC_ARM))
   2112          #pragma push
   2113          #pragma O0
   2114          #endif

   \                                 In section .text, align 2, keep-with-next
   2115          void flash_cache_clear(flash_config_t *config)
   2116          #endif
   2117          {
   \                     flash_cache_clear: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2118          #if FLASH_DRIVER_IS_FLASH_RESIDENT
   2119              status_t returnCode = flash_check_execute_in_ram_function_info(config);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       flash_check_execute_in_ram_function_info
   \   0000000A   0x0005             MOVS     R5,R0
   2120              if (kStatus_FLASH_Success != returnCode)
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xD103             BNE.N    ??flash_cache_clear_0
   2121              {
   2122                  return;
   2123              }
   2124          
   2125          /* We pass the ftfx register address as a parameter to flash_cache_clear_comamnd() instead of using
   2126           * pre-processed MACROs or a global variable in flash_cache_clear_comamnd()
   2127           * to make sure that flash_cache_clear_command() will be compiled into position-independent code (PIC). */
   2128          #if defined(FSL_FEATURE_FLASH_HAS_MCM_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_MCM_FLASH_CACHE_CONTROLS
   2129          #if defined(MCM)
   2130              callFlashCacheClearCommand((FTFx_REG32_ACCESS_TYPE)&MCM->PLACR);
   2131          #endif
   2132          #if defined(MCM0)
   2133              callFlashCacheClearCommand((FTFx_REG32_ACCESS_TYPE)&MCM0->PLACR);
   2134          #endif
   2135          #if defined(MCM1)
   2136              callFlashCacheClearCommand((FTFx_REG32_ACCESS_TYPE)&MCM1->PLACR);
   2137          #endif
   2138          #elif defined(FSL_FEATURE_FLASH_HAS_FMC_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_FMC_FLASH_CACHE_CONTROLS
   2139          #if defined(FMC_PFB01CR_CINV_WAY_MASK)
   2140              callFlashCacheClearCommand((FTFx_REG32_ACCESS_TYPE)&FMC->PFB01CR);
   2141          #else
   2142              callFlashCacheClearCommand((FTFx_REG32_ACCESS_TYPE)&FMC->PFB0CR);
   \                     ??flash_cache_clear_1: (+1)
   \   00000010   0x....             LDR.N    R0,??DataTable23_14  ;; 0x4001f004
   \   00000012   0x....             LDR.N    R1,??DataTable23_2
   \   00000014   0x6849             LDR      R1,[R1, #+4]
   \   00000016   0x4788             BLX      R1
   2143          #endif
   2144          #elif defined(FSL_FEATURE_FLASH_HAS_MSCM_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_MSCM_FLASH_CACHE_CONTROLS
   2145              callFlashCacheClearCommand((FTFx_REG32_ACCESS_TYPE)&MSCM->OCMDR[0]);
   2146          #else
   2147          #if defined(FMC_PFB0CR_S_INV_MASK)
   2148              callFlashCacheClearCommand((FTFx_REG32_ACCESS_TYPE)&FMC->PFB0CR);
   2149          #elif defined(FMC_PFB01CR_S_INV_MASK)
   2150              callFlashCacheClearCommand((FTFx_REG32_ACCESS_TYPE)&FMC->PFB01CR);
   2151          #else
   2152              /* meaningless code, just a workaround to solve warning*/
   2153              callFlashCacheClearCommand((FTFx_REG32_ACCESS_TYPE)0);
   2154          #endif
   2155          /* #error "Unknown flash cache controller" */
   2156          #endif /* FSL_FEATURE_FTFx_MCM_FLASH_CACHE_CONTROLS */
   2157          
   2158          #else
   2159          
   2160          #if defined(FSL_FEATURE_FLASH_HAS_MCM_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_MCM_FLASH_CACHE_CONTROLS
   2161          #if defined(MCM)
   2162              MCM->PLACR |= MCM_PLACR_CFCC_MASK;
   2163          #endif
   2164          #if defined(MCM0)
   2165              MCM0->PLACR |= MCM_PLACR_CFCC_MASK;
   2166          #endif
   2167          #if defined(MCM1)
   2168              MCM1->PLACR |= MCM_PLACR_CFCC_MASK;
   2169          #endif
   2170          #elif defined(FSL_FEATURE_FLASH_HAS_FMC_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_FMC_FLASH_CACHE_CONTROLS
   2171          #if defined(FMC_PFB01CR_CINV_WAY_MASK)
   2172              FMC->PFB01CR = (FMC->PFB01CR & ~FMC_PFB01CR_CINV_WAY_MASK) | FMC_PFB01CR_CINV_WAY(~0);
   2173          #else
   2174              FMC->PFB0CR = (FMC->PFB0CR & ~FMC_PFB0CR_CINV_WAY_MASK) | FMC_PFB0CR_CINV_WAY(~0);
   2175          #endif
   2176          #elif defined(FSL_FEATURE_FLASH_HAS_MSCM_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_MSCM_FLASH_CACHE_CONTROLS
   2177              MSCM->OCMDR[0] |= MSCM_OCMDR_OCMC1(2);
   2178              MSCM->OCMDR[0] |= MSCM_OCMDR_OCMC1(1);
   2179          #else
   2180          #if defined(FMC_PFB0CR_S_INV_MASK)
   2181              FMC->PFB0CR |= FMC_PFB0CR_S_INV_MASK;
   2182          #elif defined(FMC_PFB01CR_S_INV_MASK)
   2183              FMC->PFB01CR |= FMC_PFB01CR_S_INV_MASK;
   2184          #endif
   2185          /*    #error "Unknown flash cache controller" */
   2186          #endif /* FSL_FEATURE_FTFx_MCM_FLASH_CACHE_CONTROLS */
   2187          
   2188              /* Memory barriers for good measure.
   2189               * All Cache, Branch predictor and TLB maintenance operations before this instruction complete */
   2190              __ISB();
   2191              __DSB();
   2192          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
   2193          }
   \                     ??flash_cache_clear_0: (+1)
   \   00000018   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2194          #if (defined(__CC_ARM))
   2195          #pragma pop
   2196          #endif
   2197          #if (defined(__GNUC__))
   2198          /* #pragma GCC pop_options */
   2199          #endif
   2200          
   2201          #if FLASH_DRIVER_IS_FLASH_RESIDENT
   2202          /*! @brief Check whether flash execute-in-ram functions are ready  */

   \                                 In section .text, align 2, keep-with-next
   2203          static status_t flash_check_execute_in_ram_function_info(flash_config_t *config)
   2204          {
   2205              flash_execute_in_ram_function_config_t *flashExecuteInRamFunctionInfo;
   2206          
   2207              if (config == NULL)
   \                     flash_check_execute_in_ram_function_info: (+1)
   \   00000000   0xB908             CBNZ.N   R0,??flash_check_execute_in_ram_function_info_0
   2208              {
   2209                  return kStatus_FLASH_InvalidArgument;
   \   00000002   0x2004             MOVS     R0,#+4
   \   00000004   0x4770             BX       LR
   2210              }
   2211          
   2212              flashExecuteInRamFunctionInfo = (flash_execute_in_ram_function_config_t *)config->flashExecuteInRamFunctionInfo;
   2213          
   2214              if ((config->flashExecuteInRamFunctionInfo) &&
   2215                  (kFLASH_ExecuteInRamFunctionTotalNum == flashExecuteInRamFunctionInfo->activeFunctionCount))
   \                     ??flash_check_execute_in_ram_function_info_0: (+1)
   \   00000006   0x69C0             LDR      R0,[R0, #+28]
   \   00000008   0xB120             CBZ.N    R0,??flash_check_execute_in_ram_function_info_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??flash_check_execute_in_ram_function_info_1
   2216              {
   2217                  return kStatus_FLASH_Success;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR
   2218              }
   2219          
   2220              return kStatus_FLASH_ExecuteInRamFunctionNotReady;
   \                     ??flash_check_execute_in_ram_function_info_1: (+1)
   \   00000014   0x206D             MOVS     R0,#+109
   \   00000016   0x4770             BX       LR               ;; return
   2221          }
   2222          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
   2223          
   2224          /*! @brief Validates the range and alignment of the given address range.*/

   \                                 In section .text, align 2, keep-with-next
   2225          static status_t flash_check_range(flash_config_t *config,
   2226                                            uint32_t startAddress,
   2227                                            uint32_t lengthInBytes,
   2228                                            uint32_t alignmentBaseline)
   2229          {
   2230              if (config == NULL)
   \                     flash_check_range: (+1)
   \   00000000   0xB908             CBNZ.N   R0,??flash_check_range_0
   2231              {
   2232                  return kStatus_FLASH_InvalidArgument;
   \   00000002   0x2004             MOVS     R0,#+4
   \   00000004   0x4770             BX       LR
   2233              }
   2234          
   2235              /* Verify the start and length are alignmentBaseline aligned. */
   2236              if ((startAddress & (alignmentBaseline - 1)) || (lengthInBytes & (alignmentBaseline - 1)))
   \                     ??flash_check_range_0: (+1)
   \   00000006   0x1E5B             SUBS     R3,R3,#+1
   \   00000008   0x4219             TST      R1,R3
   \   0000000A   0xBF08             IT       EQ 
   \   0000000C   0x421A             TSTEQ    R2,R3
   \   0000000E   0xD001             BEQ.N    ??flash_check_range_1
   2237              {
   2238                  return kStatus_FLASH_AlignmentError;
   \   00000010   0x2065             MOVS     R0,#+101
   \   00000012   0x4770             BX       LR
   2239              }
   2240          
   2241          /* check for valid range of the target addresses */
   2242          #if !FLASH_SSD_IS_FLEXNVM_ENABLED
   2243              if ((startAddress < config->PFlashBlockBase) ||
   2244                  ((startAddress + lengthInBytes) > (config->PFlashBlockBase + config->PFlashTotalSize)))
   \                     ??flash_check_range_1: (+1)
   \   00000014   0x6803             LDR      R3,[R0, #+0]
   \   00000016   0x4299             CMP      R1,R3
   \   00000018   0xBF21             ITTTT    CS 
   \   0000001A   0x6840             LDRCS    R0,[R0, #+4]
   \   0000001C   0x18C0             ADDCS    R0,R0,R3
   \   0000001E   0x1851             ADDCS    R1,R2,R1
   \   00000020   0x4288             CMPCS    R0,R1
   \   00000022   0xBF34             ITE      CC 
   \   00000024   0x2066             MOVCC    R0,#+102
   \   00000026   0x2000             MOVCS    R0,#+0
   2245          #else
   2246              if (!(((startAddress >= config->PFlashBlockBase) &&
   2247                     ((startAddress + lengthInBytes) <= (config->PFlashBlockBase + config->PFlashTotalSize))) ||
   2248                    ((startAddress >= config->DFlashBlockBase) &&
   2249                     ((startAddress + lengthInBytes) <= (config->DFlashBlockBase + config->DFlashTotalSize)))))
   2250          #endif
   2251              {
   2252                  return kStatus_FLASH_AddressError;
   2253              }
   2254          
   2255              return kStatus_FLASH_Success;
   \   00000028   0x4770             BX       LR
   2256          }
   2257          
   2258          /*! @brief Gets the right address, sector and block size of current flash type which is indicated by address.*/

   \                                 In section .text, align 2, keep-with-next
   2259          static status_t flash_get_matched_operation_info(flash_config_t *config,
   2260                                                           uint32_t address,
   2261                                                           flash_operation_config_t *info)
   2262          {
   \                     flash_get_matched_operation_info: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4614             MOV      R4,R2
   2263              if (config == NULL)
   \   00000008   0xD101             BNE.N    ??flash_get_matched_operation_info_0
   2264              {
   2265                  return kStatus_FLASH_InvalidArgument;
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0xBD70             POP      {R4-R6,PC}
   2266              }
   2267          
   2268              /* Clean up info Structure*/
   2269              memset(info, 0, sizeof(flash_operation_config_t));
   \                     ??flash_get_matched_operation_info_0: (+1)
   \   0000000E   0x2120             MOVS     R1,#+32
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       __aeabi_memclr4
   2270          
   2271          /* When required by the command, address bit 23 selects between program flash memory
   2272           * (=0) and data flash memory (=1).*/
   2273          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   2274              if ((address >= config->DFlashBlockBase) && (address <= (config->DFlashBlockBase + config->DFlashTotalSize)))
   2275              {
   2276                  info->convertedAddress = address - config->DFlashBlockBase + 0x800000U;
   2277                  info->activeSectorSize = FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_SECTOR_SIZE;
   2278                  info->activeBlockSize = config->DFlashTotalSize / FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_COUNT;
   2279          
   2280                  info->blockWriteUnitSize = FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_WRITE_UNIT_SIZE;
   2281                  info->sectorCmdAddressAligment = FSL_FEATURE_FLASH_FLEX_NVM_SECTOR_CMD_ADDRESS_ALIGMENT;
   2282                  info->sectionCmdAddressAligment = FSL_FEATURE_FLASH_FLEX_NVM_SECTION_CMD_ADDRESS_ALIGMENT;
   2283                  info->resourceCmdAddressAligment = FSL_FEATURE_FLASH_FLEX_NVM_RESOURCE_CMD_ADDRESS_ALIGMENT;
   2284                  info->checkCmdAddressAligment = FSL_FEATURE_FLASH_FLEX_NVM_CHECK_CMD_ADDRESS_ALIGMENT;
   2285              }
   2286              else
   2287          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   2288              {
   2289                  info->convertedAddress = address - config->PFlashBlockBase;
   \   00000016   0x6828             LDR      R0,[R5, #+0]
   \   00000018   0x1A30             SUBS     R0,R6,R0
   \   0000001A   0x6020             STR      R0,[R4, #+0]
   2290                  info->activeSectorSize = config->PFlashSectorSize;
   \   0000001C   0x68E8             LDR      R0,[R5, #+12]
   \   0000001E   0x6060             STR      R0,[R4, #+4]
   2291                  info->activeBlockSize = config->PFlashTotalSize / config->PFlashBlockCount;
   \   00000020   0x68A9             LDR      R1,[R5, #+8]
   \   00000022   0x6868             LDR      R0,[R5, #+4]
   \   00000024   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000028   0x60A0             STR      R0,[R4, #+8]
   2292          
   2293                  info->blockWriteUnitSize = FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE;
   \   0000002A   0x2004             MOVS     R0,#+4
   \   0000002C   0x60E0             STR      R0,[R4, #+12]
   2294                  info->sectorCmdAddressAligment = FSL_FEATURE_FLASH_PFLASH_SECTOR_CMD_ADDRESS_ALIGMENT;
   \   0000002E   0x2008             MOVS     R0,#+8
   \   00000030   0x6120             STR      R0,[R4, #+16]
   2295                  info->sectionCmdAddressAligment = FSL_FEATURE_FLASH_PFLASH_SECTION_CMD_ADDRESS_ALIGMENT;
   \   00000032   0x6160             STR      R0,[R4, #+20]
   2296                  info->resourceCmdAddressAligment = FSL_FEATURE_FLASH_PFLASH_RESOURCE_CMD_ADDRESS_ALIGMENT;
   \   00000034   0x2004             MOVS     R0,#+4
   \   00000036   0x61A0             STR      R0,[R4, #+24]
   2297                  info->checkCmdAddressAligment = FSL_FEATURE_FLASH_PFLASH_CHECK_CMD_ADDRESS_ALIGMENT;
   \   00000038   0x61E0             STR      R0,[R4, #+28]
   2298              }
   2299          
   2300              return kStatus_FLASH_Success;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
   2301          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x4004804C         DC32     0x4004804c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \   00000000   0x40020028         DC32     0x40020028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \   00000000   0x........         DC32     callFlashRunCommand

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \   00000000   0x40020004         DC32     0x40020004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_4:
   \   00000000   0x6B65666B         DC32     0x6b65666b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_5:
   \   00000000   0x4300FFFF         DC32     0x4300ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_6:
   \   00000000   0x00800400         DC32     0x800400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_7:
   \   00000000   0x4100FFFF         DC32     0x4100ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_8:
   \   00000000   0x40020002         DC32     0x40020002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_9:
   \   00000000   0x4000FFFF         DC32     0x4000ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_10:
   \   00000000   0x4A00FFFF         DC32     0x4a00ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_11:
   \   00000000   0x40020010         DC32     0x40020010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_12:
   \   00000000   0x40020018         DC32     0x40020018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_13:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_14:
   \   00000000   0x4001F004         DC32     0x4001f004
   2302          
   2303          /*! @brief Validates the given user key for flash erase APIs.*/
   2304          static status_t flash_check_user_key(uint32_t key)
   2305          {
   2306              /* Validate the user key */
   2307              if (key != kFLASH_ApiEraseKey)
   2308              {
   2309                  return kStatus_FLASH_EraseKeyError;
   2310              }
   2311          
   2312              return kStatus_FLASH_Success;
   2313          }
   2314          
   2315          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   2316          /*! @brief Updates FlexNVM memory partition status according to data flash 0 IFR.*/
   2317          static status_t flash_update_flexnvm_memory_partition_status(flash_config_t *config)
   2318          {
   2319              struct
   2320              {
   2321                  uint32_t reserved0;
   2322                  uint8_t FlexNVMPartitionCode;
   2323                  uint8_t EEPROMDataSetSize;
   2324                  uint16_t reserved1;
   2325              } dataIFRReadOut;
   2326              status_t returnCode;
   2327          
   2328              if (config == NULL)
   2329              {
   2330                  return kStatus_FLASH_InvalidArgument;
   2331              }
   2332          
   2333              /* Get FlexNVM memory partition info from data flash IFR */
   2334              returnCode = FLASH_ReadResource(config, DFLASH_IFR_READRESOURCE_START_ADDRESS, (uint32_t *)&dataIFRReadOut,
   2335                                              sizeof(dataIFRReadOut), kFLASH_ResourceOptionFlashIfr);
   2336              if (returnCode != kStatus_FLASH_Success)
   2337              {
   2338                  return kStatus_FLASH_PartitionStatusUpdateFailure;
   2339              }
   2340          
   2341              /* Fill out partitioned EEPROM size */
   2342              dataIFRReadOut.EEPROMDataSetSize &= 0x0FU;
   2343              switch (dataIFRReadOut.EEPROMDataSetSize)
   2344              {
   2345                  case 0x00U:
   2346                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0000;
   2347                      break;
   2348                  case 0x01U:
   2349                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0001;
   2350                      break;
   2351                  case 0x02U:
   2352                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0010;
   2353                      break;
   2354                  case 0x03U:
   2355                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0011;
   2356                      break;
   2357                  case 0x04U:
   2358                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0100;
   2359                      break;
   2360                  case 0x05U:
   2361                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0101;
   2362                      break;
   2363                  case 0x06U:
   2364                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0110;
   2365                      break;
   2366                  case 0x07U:
   2367                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0111;
   2368                      break;
   2369                  case 0x08U:
   2370                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1000;
   2371                      break;
   2372                  case 0x09U:
   2373                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1001;
   2374                      break;
   2375                  case 0x0AU:
   2376                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1010;
   2377                      break;
   2378                  case 0x0BU:
   2379                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1011;
   2380                      break;
   2381                  case 0x0CU:
   2382                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1100;
   2383                      break;
   2384                  case 0x0DU:
   2385                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1101;
   2386                      break;
   2387                  case 0x0EU:
   2388                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1110;
   2389                      break;
   2390                  case 0x0FU:
   2391                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1111;
   2392                      break;
   2393                  default:
   2394                      config->EEpromTotalSize = FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_RESERVED;
   2395                      break;
   2396              }
   2397          
   2398              /* Fill out partitioned DFlash size */
   2399              dataIFRReadOut.FlexNVMPartitionCode &= 0x0FU;
   2400              switch (dataIFRReadOut.FlexNVMPartitionCode)
   2401              {
   2402                  case 0x00U:
   2403          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0000 != 0xFFFFFFFF)
   2404                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0000;
   2405          #else
   2406                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2407          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0000 */
   2408                      break;
   2409                  case 0x01U:
   2410          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0001 != 0xFFFFFFFF)
   2411                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0001;
   2412          #else
   2413                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2414          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0001 */
   2415                      break;
   2416                  case 0x02U:
   2417          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0010 != 0xFFFFFFFF)
   2418                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0010;
   2419          #else
   2420                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2421          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0010 */
   2422                      break;
   2423                  case 0x03U:
   2424          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0011 != 0xFFFFFFFF)
   2425                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0011;
   2426          #else
   2427                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2428          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0011 */
   2429                      break;
   2430                  case 0x04U:
   2431          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0100 != 0xFFFFFFFF)
   2432                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0100;
   2433          #else
   2434                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2435          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0100 */
   2436                      break;
   2437                  case 0x05U:
   2438          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0101 != 0xFFFFFFFF)
   2439                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0101;
   2440          #else
   2441                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2442          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0101 */
   2443                      break;
   2444                  case 0x06U:
   2445          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0110 != 0xFFFFFFFF)
   2446                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0110;
   2447          #else
   2448                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2449          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0110 */
   2450                      break;
   2451                  case 0x07U:
   2452          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0111 != 0xFFFFFFFF)
   2453                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0111;
   2454          #else
   2455                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2456          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0111 */
   2457                      break;
   2458                  case 0x08U:
   2459          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1000 != 0xFFFFFFFF)
   2460                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1000;
   2461          #else
   2462                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2463          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1000 */
   2464                      break;
   2465                  case 0x09U:
   2466          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1001 != 0xFFFFFFFF)
   2467                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1001;
   2468          #else
   2469                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2470          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1001 */
   2471                      break;
   2472                  case 0x0AU:
   2473          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1010 != 0xFFFFFFFF)
   2474                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1010;
   2475          #else
   2476                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2477          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1010 */
   2478                      break;
   2479                  case 0x0BU:
   2480          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1011 != 0xFFFFFFFF)
   2481                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1011;
   2482          #else
   2483                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2484          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1011 */
   2485                      break;
   2486                  case 0x0CU:
   2487          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1100 != 0xFFFFFFFF)
   2488                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1100;
   2489          #else
   2490                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2491          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1100 */
   2492                      break;
   2493                  case 0x0DU:
   2494          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1101 != 0xFFFFFFFF)
   2495                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1101;
   2496          #else
   2497                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2498          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1101 */
   2499                      break;
   2500                  case 0x0EU:
   2501          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1110 != 0xFFFFFFFF)
   2502                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1110;
   2503          #else
   2504                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2505          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1110 */
   2506                      break;
   2507                  case 0x0FU:
   2508          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1111 != 0xFFFFFFFF)
   2509                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1111;
   2510          #else
   2511                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2512          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1111 */
   2513                      break;
   2514                  default:
   2515                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2516                      break;
   2517              }
   2518          
   2519              return kStatus_FLASH_Success;
   2520          }
   2521          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   2522          
   2523          #if defined(FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD) && FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD
   2524          /*! @brief Validates the range of the given resource address.*/
   2525          static status_t flash_check_resource_range(uint32_t start,
   2526                                                     uint32_t lengthInBytes,
   2527                                                     uint32_t alignmentBaseline,
   2528                                                     flash_read_resource_option_t option)
   2529          {
   2530              status_t status;
   2531              uint32_t maxReadbleAddress;
   2532          
   2533              if ((start & (alignmentBaseline - 1)) || (lengthInBytes & (alignmentBaseline - 1)))
   2534              {
   2535                  return kStatus_FLASH_AlignmentError;
   2536              }
   2537          
   2538              status = kStatus_FLASH_Success;
   2539          
   2540              maxReadbleAddress = start + lengthInBytes - 1;
   2541              if (option == kFLASH_ResourceOptionVersionId)
   2542              {
   2543                  if ((start != kFLASH_ResourceRangeVersionIdStart) ||
   2544                      ((start + lengthInBytes - 1) != kFLASH_ResourceRangeVersionIdEnd))
   2545                  {
   2546                      status = kStatus_FLASH_InvalidArgument;
   2547                  }
   2548              }
   2549              else if (option == kFLASH_ResourceOptionFlashIfr)
   2550              {
   2551                  if (maxReadbleAddress < kFLASH_ResourceRangePflashIfrSizeInBytes)
   2552                  {
   2553                  }
   2554          #if defined(FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP) && FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP
   2555                  else if ((start >= kFLASH_ResourceRangePflashSwapIfrStart) &&
   2556                           (maxReadbleAddress <= kFLASH_ResourceRangePflashSwapIfrEnd))
   2557                  {
   2558                  }
   2559          #endif /* FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP */
   2560                  else if ((start >= kFLASH_ResourceRangeDflashIfrStart) &&
   2561                           (maxReadbleAddress <= kFLASH_ResourceRangeDflashIfrEnd))
   2562                  {
   2563                  }
   2564                  else
   2565                  {
   2566                      status = kStatus_FLASH_InvalidArgument;
   2567                  }
   2568              }
   2569              else
   2570              {
   2571                  status = kStatus_FLASH_InvalidArgument;
   2572              }
   2573          
   2574              return status;
   2575          }
   2576          #endif /* FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD */
   2577          
   2578          #if defined(FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD) && FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD
   2579          /*! @brief Validates the gived swap control option.*/
   2580          static status_t flash_check_swap_control_option(flash_swap_control_option_t option)
   2581          {
   2582              if ((option == kFLASH_SwapControlOptionIntializeSystem) || (option == kFLASH_SwapControlOptionSetInUpdateState) ||
   2583                  (option == kFLASH_SwapControlOptionSetInCompleteState) || (option == kFLASH_SwapControlOptionReportStatus) ||
   2584                  (option == kFLASH_SwapControlOptionDisableSystem))
   2585              {
   2586                  return kStatus_FLASH_Success;
   2587              }
   2588          
   2589              return kStatus_FLASH_InvalidArgument;
   2590          }
   2591          #endif /* FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD */
   2592          
   2593          #if defined(FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP) && FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP
   2594          /*! @brief Validates the gived address to see if it is equal to swap indicator address in pflash swap IFR.*/
   2595          static status_t flash_validate_swap_indicator_address(flash_config_t *config, uint32_t address)
   2596          {
   2597              flash_swap_ifr_field_data_t flashSwapIfrFieldData;
   2598              uint32_t swapIndicatorAddress;
   2599          
   2600              status_t returnCode;
   2601              returnCode =
   2602                  FLASH_ReadResource(config, kFLASH_ResourceRangePflashSwapIfrStart, flashSwapIfrFieldData.flashSwapIfrData,
   2603                                     sizeof(flashSwapIfrFieldData.flashSwapIfrData), kFLASH_ResourceOptionFlashIfr);
   2604          
   2605              if (returnCode != kStatus_FLASH_Success)
   2606              {
   2607                  return returnCode;
   2608              }
   2609          
   2610              /* The high bits value of Swap Indicator Address is stored in Program Flash Swap IFR Field,
   2611               * the low severval bit value of Swap Indicator Address is always 1'b0 */
   2612              swapIndicatorAddress = (uint32_t)flashSwapIfrFieldData.flashSwapIfrField.swapIndicatorAddress *
   2613                                     FSL_FEATURE_FLASH_PFLASH_SWAP_CONTROL_CMD_ADDRESS_ALIGMENT;
   2614              if (address != swapIndicatorAddress)
   2615              {
   2616                  return kStatus_FLASH_SwapIndicatorAddressError;
   2617              }
   2618          
   2619              return returnCode;
   2620          }
   2621          #endif /* FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP */
   2622          
   2623          #if defined(FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD) && FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD
   2624          /*! @brief Validates the gived flexram function option.*/
   2625          static inline status_t flasn_check_flexram_function_option_range(flash_flexram_function_option_t option)
   2626          {
   2627              if ((option != kFLASH_FlexramFunctionOptionAvailableAsRam) &&
   2628                  (option != kFLASH_FlexramFunctionOptionAvailableForEeprom))
   2629              {
   2630                  return kStatus_FLASH_InvalidArgument;
   2631              }
   2632          
   2633              return kStatus_FLASH_Success;
   2634          }
   2635          #endif /* FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      64   FLASH_Erase
        64   -- Indirect call
        64   -> flash_cache_clear
        64   -> flash_check_range
        64   -> flash_command_sequence
        64   -> flash_get_matched_operation_info
      16   FLASH_EraseAll
        16   -> flash_cache_clear
        16   -> flash_command_sequence
      16   FLASH_EraseAllExecuteOnlySegments
        16   -> flash_cache_clear
        16   -> flash_command_sequence
       0   FLASH_GetProperty
       0   FLASH_GetSecurityState
       0   FLASH_Init
      24   FLASH_IsExecuteOnly
        24   -> flash_check_range
     192   FLASH_IsProtected
       192   -> flash_check_range
       0   FLASH_PflashGetProtection
       0   FLASH_PflashSetProtection
      16   FLASH_PrepareExecuteInRamFunctions
        16   -> __aeabi_memcpy
      64   FLASH_Program
        64   -- Indirect call
        64   -> flash_cache_clear
        64   -> flash_check_range
        64   -> flash_command_sequence
        64   -> flash_get_matched_operation_info
      16   FLASH_ProgramOnce
        16   -> flash_cache_clear
        16   -> flash_command_sequence
      24   FLASH_ReadOnce
        24   -> flash_command_sequence
      64   FLASH_ReadResource
        64   -> flash_command_sequence
        64   -> flash_get_matched_operation_info
       8   FLASH_SecurityBypass
         8   -> flash_command_sequence
       0   FLASH_SetCallback
      72   FLASH_VerifyErase
        72   -> flash_check_range
        72   -> flash_command_sequence
        72   -> flash_get_matched_operation_info
       0   FLASH_VerifyEraseAll
         0   -> flash_command_sequence
       0   FLASH_VerifyEraseAllExecuteOnlySegments
         0   -> flash_command_sequence
      64   FLASH_VerifyProgram
        64   -> flash_check_range
        64   -> flash_command_sequence
        64   -> flash_get_matched_operation_info
      16   flash_cache_clear
        16   -- Indirect call
        16   -> flash_check_execute_in_ram_function_info
       0   flash_check_execute_in_ram_function_info
       0   flash_check_range
       8   flash_command_sequence
         8   -- Indirect call
         8   -> flash_check_execute_in_ram_function_info
      16   flash_get_matched_operation_info
        16   -> __aeabi_memclr4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_10
       4  ??DataTable23_11
       4  ??DataTable23_12
       4  ??DataTable23_13
       4  ??DataTable23_14
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable23_5
       4  ??DataTable23_6
       4  ??DataTable23_7
       4  ??DataTable23_8
       4  ??DataTable23_9
      14  ?Subroutine0
       6  ?Subroutine1
      10  ?Subroutine2
       6  ?Subroutine3
       8  ?Subroutine4
       4  ?Subroutine5
       6  ?Subroutine6
     114  FLASH_Erase
      34  FLASH_EraseAll
      32  FLASH_EraseAllExecuteOnlySegments
      80  FLASH_GetProperty
      48  FLASH_GetSecurityState
      84  FLASH_Init
     128  FLASH_IsExecuteOnly
     240  FLASH_IsProtected
      22  FLASH_PflashGetProtection
      22  FLASH_PflashSetProtection
      58  FLASH_PrepareExecuteInRamFunctions
     126  FLASH_Program
      68  FLASH_ProgramOnce
      70  FLASH_ReadOnce
     170  FLASH_ReadResource
      98  FLASH_SecurityBypass
      12  FLASH_SetCallback
     132  FLASH_VerifyErase
      12  FLASH_VerifyEraseAll
       8  FLASH_VerifyEraseAllExecuteOnlySegments
     104  FLASH_VerifyProgram
       8  callFlashRunCommand
          callFlashCacheClearCommand
      26  flash_cache_clear
      24  flash_check_execute_in_ram_function_info
      42  flash_check_range
      52  flash_command_sequence
      62  flash_get_matched_operation_info
       4  kFCCOBx
       4  kFPROT
      32  kPFlashDensities
      20  s_flashCacheClearCommandFunctionCode
      12  s_flashRunCommandFunctionCode

 
     8 bytes in section .bss
     8 bytes in section .rodata
 2 046 bytes in section .text
 
 2 046 bytes of CODE  memory
     8 bytes of CONST memory
     8 bytes of DATA  memory

Errors: none
Warnings: none
