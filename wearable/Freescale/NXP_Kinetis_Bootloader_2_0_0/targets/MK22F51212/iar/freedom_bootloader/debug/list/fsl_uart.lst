###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Aug/2016  15:48:55
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\uart\fsl_uart.c
#    Command line =  
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\uart\fsl_uart.c"
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN512VDC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -lC
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\obj"
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform/devices/MK22F51212\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/osa\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/device\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/device/class\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/bm_usb\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform/devices\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/common\"
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\list\fsl_uart.lst
#    Object file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\obj\fsl_uart.o
#
###############################################################################

C:\Users\cwati\Documents\My Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\uart\fsl_uart.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "fsl_uart.h"
     32          
     33          /*******************************************************************************
     34           * Definitions
     35           ******************************************************************************/
     36          
     37          /* UART transfer state. */
     38          enum _uart_tansfer_states
     39          {
     40              kUART_TxIdle, /* TX idle. */
     41              kUART_TxBusy, /* TX busy. */
     42              kUART_RxIdle, /* RX idle. */
     43              kUART_RxBusy  /* RX busy. */
     44          };
     45          
     46          /*******************************************************************************
     47           * Prototypes
     48           ******************************************************************************/
     49          
     50          /*!
     51           * @brief Get the UART instance from peripheral base address.
     52           *
     53           * @param base UART peripheral base address.
     54           * @return UART instance.
     55           */
     56          uint32_t UART_GetInstance(UART_Type *base);
     57          
     58          /*!
     59           * @brief Get the length of received data in RX ring buffer.
     60           *
     61           * @param handle UART handle pointer.
     62           * @return Length of received data in RX ring buffer.
     63           */
     64          static size_t UART_GetRxRingBufferLength(uart_handle_t *handle);
     65          
     66          /*!
     67           * @brief Check whether the RX ring buffer is full.
     68           *
     69           * @param handle UART handle pointer.
     70           * @retval true  RX ring buffer is full.
     71           * @retval false RX ring buffer is not full.
     72           */
     73          static bool UART_IsRxRingBufferFull(uart_handle_t *handle);
     74          
     75          /*!
     76           * @brief Read RX register using non-blocking method.
     77           *
     78           * This function reads data from the TX register directly, upper layer must make
     79           * sure the RX register is full or TX FIFO has data before calling this function.
     80           *
     81           * @param base UART peripheral base address.
     82           * @param data Start addresss of the buffer to store the received data.
     83           * @param length Size of the buffer.
     84           */
     85          static void UART_ReadNonBlocking(UART_Type *base, uint8_t *data, size_t length);
     86          
     87          /*!
     88           * @brief Write to TX register using non-blocking method.
     89           *
     90           * This function writes data to the TX register directly, upper layer must make
     91           * sure the TX register is empty or TX FIFO has empty room before calling this function.
     92           *
     93           * @note This function does not check whether all the data has been sent out to bus,
     94           * so before disable TX, check kUART_TransmissionCompleteFlag to ensure the TX is
     95           * finished.
     96           *
     97           * @param base UART peripheral base address.
     98           * @param data Start addresss of the data to write.
     99           * @param length Size of the buffer to be sent.
    100           */
    101          static void UART_WriteNonBlocking(UART_Type *base, const uint8_t *data, size_t length);
    102          
    103          /*******************************************************************************
    104           * Variables
    105           ******************************************************************************/
    106          /* Array of UART handle. */
    107          #if (defined(UART5))
    108          #define UART_HANDLE_ARRAY_SIZE 6
    109          #else /* UART5 */
    110          #if (defined(UART4))
    111          #define UART_HANDLE_ARRAY_SIZE 5
    112          #else /* UART4 */
    113          #if (defined(UART3))
    114          #define UART_HANDLE_ARRAY_SIZE 4
    115          #else /* UART3 */
    116          #if (defined(UART2))
    117          #define UART_HANDLE_ARRAY_SIZE 3
    118          #else /* UART2 */
    119          #if (defined(UART1))
    120          #define UART_HANDLE_ARRAY_SIZE 2
    121          #else /* UART1 */
    122          #if (defined(UART0))
    123          #define UART_HANDLE_ARRAY_SIZE 1
    124          #else /* UART0 */
    125          #error No UART instance.
    126          #endif /* UART 0 */
    127          #endif /* UART 1 */
    128          #endif /* UART 2 */
    129          #endif /* UART 3 */
    130          #endif /* UART 4 */
    131          #endif /* UART 5 */

   \                                 In section .bss, align 4
    132          static uart_handle_t *s_uartHandle[UART_HANDLE_ARRAY_SIZE];
   \                     s_uartHandle:
   \   00000000                      DS8 12
    133          /* Array of UART peripheral base address. */

   \                                 In section .text, align 4, keep-with-next
    134          static UART_Type *const s_uartBases[] = UART_BASE_PTRS;
   \                     s_uartBases:
   \   00000000   0x4006A000         DC32 4006A000H, 4006B000H, 4006C000H
   \              0x4006B000   
   \              0x4006C000   
    135          
    136          /* Array of UART IRQ number. */

   \                                 In section .text, align 4, keep-with-next
    137          static const IRQn_Type s_uartIRQ[] = UART_RX_TX_IRQS;
   \                     s_uartIRQ:
   \   00000000   0x1F 0x21          DC8 31, 33, 35, 0
   \              0x23 0x00    
    138          /* Array of UART clock name. */

   \                                 In section .text, align 4, keep-with-next
    139          static const clock_ip_name_t s_uartClock[] = UART_CLOCKS;
   \                     s_uartClock:
   \   00000000   0x1034000A         DC32 271843338, 271843339, 271843340
   \              0x1034000B   
   \              0x1034000C   
    140          
    141          /*******************************************************************************
    142           * Code
    143           ******************************************************************************/
    144          

   \                                 In section .text, align 2, keep-with-next
    145          uint32_t UART_GetInstance(UART_Type *base)
    146          {
    147              uint32_t instance;
    148              uint32_t uartArrayCount = (sizeof(s_uartBases) / sizeof(s_uartBases[0]));
    149          
    150              /* Find the instance index from base address mappings. */
    151              for (instance = 0; instance < uartArrayCount; instance++)
   \                     UART_GetInstance: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x.... 0x....      ADR.W    R2,s_uartBases
    152              {
    153                  if (s_uartBases[instance] == base)
   \                     ??UART_GetInstance_0: (+1)
   \   00000006   0xF852 0x3021      LDR      R3,[R2, R1, LSL #+2]
   \   0000000A   0x4283             CMP      R3,R0
   \   0000000C   0xD002             BEQ.N    ??UART_GetInstance_1
    154                  {
    155                      break;
    156                  }
    157              }
   \   0000000E   0x1C49             ADDS     R1,R1,#+1
   \   00000010   0x2903             CMP      R1,#+3
   \   00000012   0xD3F8             BCC.N    ??UART_GetInstance_0
    158          
    159              assert(instance < uartArrayCount);
    160          
    161              return instance;
   \                     ??UART_GetInstance_1: (+1)
   \   00000014   0x4608             MOV      R0,R1
   \   00000016   0x4770             BX       LR               ;; return
    162          }
    163          

   \                                 In section .text, align 2, keep-with-next
    164          static size_t UART_GetRxRingBufferLength(uart_handle_t *handle)
    165          {
    166              size_t size;
    167          
    168              if (handle->rxRingBufferTail > handle->rxRingBufferHead)
   \                     UART_GetRxRingBufferLength: (+1)
   \   00000000   0x8C01             LDRH     R1,[R0, #+32]
   \   00000002   0x8C42             LDRH     R2,[R0, #+34]
   \   00000004   0x4291             CMP      R1,R2
   \   00000006   0x8C01             LDRH     R1,[R0, #+32]
   \   00000008   0xBF3C             ITT      CC 
   \   0000000A   0x69C2             LDRCC    R2,[R0, #+28]
   \   0000000C   0x1851             ADDCC    R1,R2,R1
    169              {
    170                  size = (size_t)(handle->rxRingBufferHead + handle->rxRingBufferSize - handle->rxRingBufferTail);
    171              }
    172              else
    173              {
    174                  size = (size_t)(handle->rxRingBufferHead - handle->rxRingBufferTail);
   \   0000000E   0x8C40             LDRH     R0,[R0, #+34]
   \   00000010   0x1A08             SUBS     R0,R1,R0
    175              }
    176          
    177              return size;
   \   00000012   0x4770             BX       LR               ;; return
    178          }
    179          

   \                                 In section .text, align 2, keep-with-next
    180          static bool UART_IsRxRingBufferFull(uart_handle_t *handle)
    181          {
   \                     UART_IsRxRingBufferFull: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    182              bool full;
    183          
    184              if (UART_GetRxRingBufferLength(handle) == (handle->rxRingBufferSize - 1U))
   \   00000004   0x.... 0x....      BL       UART_GetRxRingBufferLength
   \   00000008   0x69E1             LDR      R1,[R4, #+28]
   \   0000000A   0x1E49             SUBS     R1,R1,#+1
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xBF0C             ITE      EQ 
   \   00000010   0x2001             MOVEQ    R0,#+1
   \   00000012   0x2000             MOVNE    R0,#+0
    185              {
    186                  full = true;
    187              }
    188              else
    189              {
    190                  full = false;
   \   00000014   0xBD10             POP      {R4,PC}
    191              }
    192          
    193              return full;
    194          }
    195          

   \                                 In section .text, align 2, keep-with-next
    196          status_t UART_Init(UART_Type *base, const uart_config_t *config, uint32_t srcClock_Hz)
    197          {
   \                     UART_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4604             MOV      R4,R0
    198              assert(config);
    199              assert(config->baudRate_Bps);
    200          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    201              assert(FSL_FEATURE_UART_FIFO_SIZEn(base) >= config->txFifoWatermark);
    202              assert(FSL_FEATURE_UART_FIFO_SIZEn(base) >= config->rxFifoWatermark);
    203          #endif
    204          
    205              uint16_t sbr = 0;
    206              uint8_t temp = 0;
    207              uint32_t baudDiff = 0;
    208          
    209              /* Calculate the baud rate modulo divisor, sbr*/
    210              sbr = srcClock_Hz / (config->baudRate_Bps * 16);
   \   00000006   0x6828             LDR      R0,[R5, #+0]
   \   00000008   0x0101             LSLS     R1,R0,#+4
   \   0000000A   0xFBB2 0xF6F1      UDIV     R6,R2,R1
   \   0000000E   0xB2B6             UXTH     R6,R6
    211              /* set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate */
    212              if (sbr == 0)
   \   00000010   0xB906             CBNZ.N   R6,??UART_Init_0
    213              {
    214                  sbr = 1;
   \   00000012   0x2601             MOVS     R6,#+1
    215              }
    216              
    217          #if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
    218              /* Determine if a fractional divider is needed to fine tune closer to the
    219               * desired baud, each value of brfa is in 1/32 increments,
    220               * hence the multiply-by-32. */
    221              uint16_t brfa = (32 * srcClock_Hz / (config->baudRate_Bps * 16)) - 32 * sbr;
   \                     ??UART_Init_0: (+1)
   \   00000014   0x0153             LSLS     R3,R2,#+5
   \   00000016   0xFBB3 0xF1F1      UDIV     R1,R3,R1
   \   0000001A   0xEBA1 0x1746      SUB      R7,R1,R6, LSL #+5
    222          
    223              /* Calculate the baud rate based on the temporary SBR values and BRFA */
    224              baudDiff = (srcClock_Hz*2 / ((sbr*32 + brfa))) - config->baudRate_Bps;
    225          
    226          #else
    227              /* Calculate the baud rate based on the temporary SBR values */
    228              baudDiff = (srcClock_Hz / (sbr * 16)) - config->baudRate_Bps;
    229          
    230              /* Select the better value between sbr and (sbr + 1) */
    231              if (baudDiff > (config->baudRate_Bps - (srcClock_Hz / (16 * (sbr + 1)))))
    232              {
    233                  baudDiff = config->baudRate_Bps - (srcClock_Hz / (16 * (sbr + 1)));
    234                  sbr++;
    235              }
    236          #endif
    237              
    238              /* next, check to see if actual baud rate is within 3% of desired baud rate
    239               * based on the calculate SBR value */
    240              if (baudDiff > ((config->baudRate_Bps / 100) * 3))
   \   0000001E   0x0051             LSLS     R1,R2,#+1
   \   00000020   0x0172             LSLS     R2,R6,#+5
   \   00000022   0xFA12 0xF287      UXTAH    R2,R2,R7
   \   00000026   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000002A   0x1A09             SUBS     R1,R1,R0
   \   0000002C   0x2264             MOVS     R2,#+100
   \   0000002E   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \   00000032   0xEB00 0x0040      ADD      R0,R0,R0, LSL #+1
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xD202             BCS.N    ??UART_Init_1
    241              {
    242                  /* Unacceptable baud rate difference of more than 3%*/
    243                  return kStatus_UART_BaudrateNotSupport;
   \   0000003A   0xF240 0x30F5      MOVW     R0,#+1013
   \   0000003E   0xBDF2             POP      {R1,R4-R7,PC}
    244              }
    245          
    246              /* Enable uart clock */
    247              CLOCK_EnableClock(s_uartClock[UART_GetInstance(base)]);
   \                     ??UART_Init_1: (+1)
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       UART_GetInstance
   \   00000046   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000004A   0x4310             ORRS     R0,R0,R2
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    248          
    249              /* Disable UART TX RX before setting. */
    250              base->C2 &= ~(UART_C2_TE_MASK | UART_C2_RE_MASK);
    251          
    252              /* Write the sbr value to the BDH and BDL registers*/
    253              base->BDH = (base->BDH & ~UART_BDH_SBR_MASK) | (uint8_t)(sbr >> 8);
    254              base->BDL = (uint8_t)sbr;
    255          
    256          #if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
    257              /* Write the brfa value to the register*/
    258              base->C4 = (base->C4 & ~UART_C4_BRFA_MASK) | (brfa & UART_C4_BRFA_MASK);
   \   0000004E   0xF007 0x011F      AND      R1,R7,#0x1F
   \   00000052   0x78E0             LDRB     R0,[R4, #+3]
   \   00000054   0xF000 0x00F3      AND      R0,R0,#0xF3
   \   00000058   0x70E0             STRB     R0,[R4, #+3]
   \   0000005A   0x7820             LDRB     R0,[R4, #+0]
   \   0000005C   0xF000 0x00E0      AND      R0,R0,#0xE0
   \   00000060   0xEA40 0x2026      ORR      R0,R0,R6, ASR #+8
   \   00000064   0x7020             STRB     R0,[R4, #+0]
   \   00000066   0x7066             STRB     R6,[R4, #+1]
   \   00000068   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000006A   0xF000 0x00E0      AND      R0,R0,#0xE0
   \   0000006E   0x4308             ORRS     R0,R1,R0
   \   00000070   0x72A0             STRB     R0,[R4, #+10]
    259          #endif
    260          
    261              /* Set bit count */
    262              temp = base->C1 & ~UART_C1_M_MASK;
    263          
    264              /* Set parity mode */
    265              temp = temp & ~(UART_C1_PE_MASK | UART_C1_PT_MASK);
    266              base->C1 = temp | (uint8_t)config->parityMode;
   \   00000072   0x78A0             LDRB     R0,[R4, #+2]
   \   00000074   0x7929             LDRB     R1,[R5, #+4]
   \   00000076   0xF000 0x00EC      AND      R0,R0,#0xEC
   \   0000007A   0x4308             ORRS     R0,R1,R0
   \   0000007C   0x70A0             STRB     R0,[R4, #+2]
    267          
    268          #if defined(FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT
    269              /* Set stop bit per char */
    270              base->BDH = (base->BDH & ~UART_BDH_SBNS_MASK) | UART_BDH_SBNS((uint8_t)config->stopBitCount);
    271          #endif
    272          
    273          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    274              /* Set tx/rx FIFO watermark */
    275              base->TWFIFO = config->txFifoWatermark;
   \   0000007E   0x7968             LDRB     R0,[R5, #+5]
   \   00000080   0x74E0             STRB     R0,[R4, #+19]
    276              base->RWFIFO = config->rxFifoWatermark;
   \   00000082   0x79A8             LDRB     R0,[R5, #+6]
   \   00000084   0x7560             STRB     R0,[R4, #+21]
    277          
    278              /* Enable tx/rx FIFO */
    279              base->PFIFO |= (UART_PFIFO_TXFE_MASK | UART_PFIFO_RXFE_MASK);
   \   00000086   0x7C20             LDRB     R0,[R4, #+16]
   \   00000088   0xF040 0x0088      ORR      R0,R0,#0x88
   \   0000008C   0x7420             STRB     R0,[R4, #+16]
    280          
    281              /* Flush FIFO */
    282              base->CFIFO |= (UART_CFIFO_TXFLUSH_MASK | UART_CFIFO_RXFLUSH_MASK);
   \   0000008E   0x7C60             LDRB     R0,[R4, #+17]
   \   00000090   0xF040 0x00C0      ORR      R0,R0,#0xC0
   \   00000094   0x7460             STRB     R0,[R4, #+17]
    283          #endif
    284          
    285              /* Enable TX/RX base on configure structure. */
    286              temp = base->C2;
   \   00000096   0x78E0             LDRB     R0,[R4, #+3]
    287          
    288              if (config->enableTx)
   \   00000098   0x79E9             LDRB     R1,[R5, #+7]
   \   0000009A   0xB109             CBZ.N    R1,??UART_Init_2
    289              {
    290                  temp |= UART_C2_TE_MASK;
   \   0000009C   0xF040 0x0008      ORR      R0,R0,#0x8
    291              }
    292          
    293              if (config->enableRx)
   \                     ??UART_Init_2: (+1)
   \   000000A0   0x7A29             LDRB     R1,[R5, #+8]
   \   000000A2   0xB109             CBZ.N    R1,??UART_Init_3
    294              {
    295                  temp |= UART_C2_RE_MASK;
   \   000000A4   0xF040 0x0004      ORR      R0,R0,#0x4
    296              }
    297          
    298              base->C2 = temp;
   \                     ??UART_Init_3: (+1)
   \   000000A8   0x70E0             STRB     R0,[R4, #+3]
    299          
    300              return kStatus_Success;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    301          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x.... 0x....      ADR.W    R1,s_uartClock
   \   00000004   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000008   0x0C01             LSRS     R1,R0,#+16
   \   0000000A   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   0000000E   0xF501 0x218E      ADD      R1,R1,#+290816
   \   00000012   0x2301             MOVS     R3,#+1
   \   00000014   0x680A             LDR      R2,[R1, #+0]
   \   00000016   0xFA03 0xF000      LSL      R0,R3,R0
   \   0000001A   0x4770             BX       LR
    302          

   \                                 In section .text, align 2, keep-with-next
    303          void UART_Deinit(UART_Type *base)
    304          {
   \                     UART_Deinit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    305          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    306              /* Wait tx FIFO send out*/
    307              while (0 != base->TCFIFO)
   \                     ??UART_Deinit_0: (+1)
   \   00000002   0x7D01             LDRB     R1,[R0, #+20]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD1FC             BNE.N    ??UART_Deinit_0
    308              {
    309              }
    310          #endif
    311              /* Wait last char shoft out */
    312              while (0 == (base->S1 & UART_S1_TC_MASK))
   \                     ??UART_Deinit_1: (+1)
   \   00000008   0x7901             LDRB     R1,[R0, #+4]
   \   0000000A   0x0649             LSLS     R1,R1,#+25
   \   0000000C   0xD5FC             BPL.N    ??UART_Deinit_1
    313              {
    314              }
    315          
    316              /* Disable the module. */
    317              base->C2 = 0;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x70C1             STRB     R1,[R0, #+3]
    318          
    319              /* Disable uart clock */
    320              CLOCK_DisableClock(s_uartClock[UART_GetInstance(base)]);
   \   00000012   0x.... 0x....      BL       UART_GetInstance
   \   00000016   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000001A   0xEA22 0x0000      BIC      R0,R2,R0
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    321          }
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
    322          

   \                                 In section .text, align 2, keep-with-next
    323          void UART_GetDefaultConfig(uart_config_t *config)
    324          {
    325              assert(config);
    326          
    327              config->baudRate_Bps = 115200U;
   \                     UART_GetDefaultConfig: (+1)
   \   00000000   0xF44F 0x31E1      MOV      R1,#+115200
   \   00000004   0x6001             STR      R1,[R0, #+0]
    328              config->parityMode = kUART_ParityDisabled;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x7101             STRB     R1,[R0, #+4]
    329          #if defined(FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT
    330              config->stopBitCount = kUART_OneStopBit;
    331          #endif
    332          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    333              config->txFifoWatermark = 0;
   \   0000000A   0x7141             STRB     R1,[R0, #+5]
    334              config->rxFifoWatermark = 1;
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x7181             STRB     R1,[R0, #+6]
    335          #endif
    336              config->enableTx = false;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x71C1             STRB     R1,[R0, #+7]
    337              config->enableRx = false;
   \   00000014   0x7201             STRB     R1,[R0, #+8]
    338          }
   \   00000016   0x4770             BX       LR               ;; return
    339          

   \                                 In section .text, align 2, keep-with-next
    340          status_t UART_SetBaudRate(UART_Type *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz)
    341          {
   \                     UART_SetBaudRate: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    342              assert(baudRate_Bps);
    343          
    344              uint16_t sbr = 0;
    345              uint32_t baudDiff = 0;
    346              uint8_t oldCtrl;
    347          
    348              /* Calculate the baud rate modulo divisor, sbr*/
    349              sbr = srcClock_Hz / (baudRate_Bps * 16);
   \   00000002   0x010C             LSLS     R4,R1,#+4
   \   00000004   0xFBB2 0xF3F4      UDIV     R3,R2,R4
   \   00000008   0xB29B             UXTH     R3,R3
    350              /* set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate */
    351              if (sbr == 0)
   \   0000000A   0xB903             CBNZ.N   R3,??UART_SetBaudRate_0
    352              {
    353                  sbr = 1;
   \   0000000C   0x2301             MOVS     R3,#+1
    354              }
    355              
    356          #if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
    357              /* Determine if a fractional divider is needed to fine tune closer to the
    358               * desired baud, each value of brfa is in 1/32 increments,
    359               * hence the multiply-by-32. */
    360              uint16_t brfa = (32 * srcClock_Hz / (baudRate_Bps * 16)) - 32 * sbr;
   \                     ??UART_SetBaudRate_0: (+1)
   \   0000000E   0x0155             LSLS     R5,R2,#+5
   \   00000010   0xFBB5 0xF4F4      UDIV     R4,R5,R4
   \   00000014   0xEBA4 0x1443      SUB      R4,R4,R3, LSL #+5
    361          
    362              /* Calculate the baud rate based on the temporary SBR values and BRFA */
    363              baudDiff = (srcClock_Hz*2 / ((sbr*32 + brfa))) - baudRate_Bps;
    364          
    365          #else    
    366              /* Calculate the baud rate based on the temporary SBR values */
    367              baudDiff = (srcClock_Hz / (sbr * 16)) - baudRate_Bps;
    368          
    369              /* Select the better value between sbr and (sbr + 1) */
    370              if (baudDiff > (baudRate_Bps - (srcClock_Hz / (16 * (sbr + 1)))))
    371              {
    372                  baudDiff = baudRate_Bps - (srcClock_Hz / (16 * (sbr + 1)));
    373                  sbr++;
    374              }
    375          #endif
    376              
    377              /* next, check to see if actual baud rate is within 3% of desired baud rate
    378               * based on the calculate SBR value */
    379              if (baudDiff < ((baudRate_Bps / 100) * 3))
   \   00000018   0x015E             LSLS     R6,R3,#+5
   \   0000001A   0x2564             MOVS     R5,#+100
   \   0000001C   0x0052             LSLS     R2,R2,#+1
   \   0000001E   0xFA16 0xF684      UXTAH    R6,R6,R4
   \   00000022   0xFBB1 0xF5F5      UDIV     R5,R1,R5
   \   00000026   0xFBB2 0xF2F6      UDIV     R2,R2,R6
   \   0000002A   0xEB05 0x0545      ADD      R5,R5,R5, LSL #+1
   \   0000002E   0x1A51             SUBS     R1,R2,R1
   \   00000030   0x42A9             CMP      R1,R5
   \   00000032   0xD215             BCS.N    ??UART_SetBaudRate_1
    380              {
    381                  /* Store C2 before disable Tx and Rx */
    382                  oldCtrl = base->C2;
   \   00000034   0x78C1             LDRB     R1,[R0, #+3]
    383          
    384                  /* Disable UART TX RX before setting. */
    385                  base->C2 &= ~(UART_C2_TE_MASK | UART_C2_RE_MASK);
   \   00000036   0x78C2             LDRB     R2,[R0, #+3]
   \   00000038   0xF002 0x02F3      AND      R2,R2,#0xF3
   \   0000003C   0x70C2             STRB     R2,[R0, #+3]
    386          
    387                  /* Write the sbr value to the BDH and BDL registers*/
    388                  base->BDH = (base->BDH & ~UART_BDH_SBR_MASK) | (uint8_t)(sbr >> 8);
   \   0000003E   0x7802             LDRB     R2,[R0, #+0]
   \   00000040   0xF002 0x02E0      AND      R2,R2,#0xE0
   \   00000044   0xEA42 0x2223      ORR      R2,R2,R3, ASR #+8
   \   00000048   0x7002             STRB     R2,[R0, #+0]
    389                  base->BDL = (uint8_t)sbr;
   \   0000004A   0x7043             STRB     R3,[R0, #+1]
    390          
    391          #if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
    392                  /* Write the brfa value to the register*/
    393                  base->C4 = (base->C4 & ~UART_C4_BRFA_MASK) | (brfa & UART_C4_BRFA_MASK);
   \   0000004C   0xF004 0x031F      AND      R3,R4,#0x1F
   \   00000050   0x7A82             LDRB     R2,[R0, #+10]
   \   00000052   0xF002 0x02E0      AND      R2,R2,#0xE0
   \   00000056   0x431A             ORRS     R2,R3,R2
   \   00000058   0x7282             STRB     R2,[R0, #+10]
    394          #endif
    395                  /* Restore C2. */
    396                  base->C2 = oldCtrl;
   \   0000005A   0x70C1             STRB     R1,[R0, #+3]
    397          
    398                  return kStatus_Success;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xBD70             POP      {R4-R6,PC}
    399              }
    400              else
    401              {
    402                  /* Unacceptable baud rate difference of more than 3%*/
    403                  return kStatus_UART_BaudrateNotSupport;
   \                     ??UART_SetBaudRate_1: (+1)
   \   00000060   0xF240 0x30F5      MOVW     R0,#+1013
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
    404              }
    405          }
    406          

   \                                 In section .text, align 2, keep-with-next
    407          void UART_EnableInterrupts(UART_Type *base, uint32_t mask)
    408          {
    409              /* The interrupt mask is combined by control bits from several register: ((CFIFO<<24) | (C3<<16) | (C2<<8) |(BDH))
    410               */
    411              base->BDH |= (mask & 0xFF);
   \                     UART_EnableInterrupts: (+1)
   \   00000000   0x7802             LDRB     R2,[R0, #+0]
   \   00000002   0x430A             ORRS     R2,R1,R2
   \   00000004   0x7002             STRB     R2,[R0, #+0]
    412              base->C2 |= ((mask >> 8) & 0xFF);
   \   00000006   0x78C2             LDRB     R2,[R0, #+3]
   \   00000008   0xEA42 0x2211      ORR      R2,R2,R1, LSR #+8
   \   0000000C   0x70C2             STRB     R2,[R0, #+3]
    413              base->C3 |= ((mask >> 16) & 0xFF);
   \   0000000E   0x7982             LDRB     R2,[R0, #+6]
   \   00000010   0xEA42 0x4211      ORR      R2,R2,R1, LSR #+16
   \   00000014   0x7182             STRB     R2,[R0, #+6]
    414          
    415          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    416              base->CFIFO |= ((mask >> 24) & 0xFF);
   \   00000016   0x7C42             LDRB     R2,[R0, #+17]
   \   00000018   0xEA42 0x6111      ORR      R1,R2,R1, LSR #+24
   \   0000001C   0x7441             STRB     R1,[R0, #+17]
    417          #endif
    418          }
   \   0000001E   0x4770             BX       LR               ;; return
    419          

   \                                 In section .text, align 2, keep-with-next
    420          void UART_DisableInterrupts(UART_Type *base, uint32_t mask)
    421          {
    422              /* The interrupt mask is combined by control bits from several register: ((CFIFO<<24) | (C3<<16) | (C2<<8) |(BDH))
    423               */
    424              base->BDH &= ~(mask & 0xFF);
   \                     UART_DisableInterrupts: (+1)
   \   00000000   0x7802             LDRB     R2,[R0, #+0]
   \   00000002   0x438A             BICS     R2,R2,R1
   \   00000004   0x7002             STRB     R2,[R0, #+0]
    425              base->C2 &= ~((mask >> 8) & 0xFF);
   \   00000006   0x78C2             LDRB     R2,[R0, #+3]
   \   00000008   0xEA22 0x2211      BIC      R2,R2,R1, LSR #+8
   \   0000000C   0x70C2             STRB     R2,[R0, #+3]
    426              base->C3 &= ~((mask >> 16) & 0xFF);
   \   0000000E   0x7982             LDRB     R2,[R0, #+6]
   \   00000010   0xEA22 0x4211      BIC      R2,R2,R1, LSR #+16
   \   00000014   0x7182             STRB     R2,[R0, #+6]
    427          
    428          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    429              base->CFIFO &= ~((mask >> 24) & 0xFF);
   \   00000016   0x7C42             LDRB     R2,[R0, #+17]
   \   00000018   0xEA22 0x6111      BIC      R1,R2,R1, LSR #+24
   \   0000001C   0x7441             STRB     R1,[R0, #+17]
    430          #endif
    431          }
   \   0000001E   0x4770             BX       LR               ;; return
    432          

   \                                 In section .text, align 2, keep-with-next
    433          uint32_t UART_GetEnabledInterrupts(UART_Type *base)
    434          {
    435              uint32_t temp;
    436          
    437              temp = base->BDH | ((uint32_t)(base->C2) << 8) | ((uint32_t)(base->C3) << 16);
   \                     UART_GetEnabledInterrupts: (+1)
   \   00000000   0x7801             LDRB     R1,[R0, #+0]
   \   00000002   0x78C2             LDRB     R2,[R0, #+3]
   \   00000004   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   00000008   0x7982             LDRB     R2,[R0, #+6]
    438          
    439          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    440              temp |= ((uint32_t)(base->CFIFO) << 24);
   \   0000000A   0x7C40             LDRB     R0,[R0, #+17]
    441          #endif
    442          
    443              return temp;
   \   0000000C   0x....             B.N      ?Subroutine1
    444          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000004   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   00000008   0x4770             BX       LR               ;; return
    445          

   \                                 In section .text, align 2, keep-with-next
    446          uint32_t UART_GetStatusFlags(UART_Type *base)
    447          {
    448              uint32_t status_flag;
    449          
    450              status_flag = base->S1 | ((uint32_t)(base->S2) << 8);
   \                     UART_GetStatusFlags: (+1)
   \   00000000   0x7901             LDRB     R1,[R0, #+4]
   \   00000002   0x7942             LDRB     R2,[R0, #+5]
   \   00000004   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
    451          
    452          #if defined(FSL_FEATURE_UART_HAS_EXTENDED_DATA_REGISTER_FLAGS) && FSL_FEATURE_UART_HAS_EXTENDED_DATA_REGISTER_FLAGS
    453              status_flag |= ((uint32_t)(base->ED) << 16);
   \   00000008   0x7B02             LDRB     R2,[R0, #+12]
    454          #endif
    455          
    456          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    457              status_flag |= ((uint32_t)(base->SFIFO) << 24);
   \   0000000A   0x7C80             LDRB     R0,[R0, #+18]
    458          #endif
    459          
    460              return status_flag;
   \   0000000C                      REQUIRE ?Subroutine1
   \   0000000C                      ;; // Fall through to label ?Subroutine1
    461          }
    462          

   \                                 In section .text, align 2, keep-with-next
    463          status_t UART_ClearStatusFlags(UART_Type *base, uint32_t mask)
    464          {
   \                     UART_ClearStatusFlags: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    465              uint8_t reg = base->S2;
    466              status_t status;
    467          
    468          #if defined(FSL_FEATURE_UART_HAS_LIN_BREAK_DETECT) && FSL_FEATURE_UART_HAS_LIN_BREAK_DETECT
    469              reg &= ~(UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK);
    470          #else
    471              reg &= ~UART_S2_RXEDGIF_MASK;
    472          #endif
    473          
    474              base->S2 = reg | (uint8_t)(mask >> 8);
   \   00000004   0x7941             LDRB     R1,[R0, #+5]
   \   00000006   0xF001 0x013F      AND      R1,R1,#0x3F
   \   0000000A   0xEA41 0x2114      ORR      R1,R1,R4, LSR #+8
   \   0000000E   0x7141             STRB     R1,[R0, #+5]
    475          
    476          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    477              base->SFIFO = (uint8_t)(mask >> 24);
   \   00000010   0x0E21             LSRS     R1,R4,#+24
   \   00000012   0x7481             STRB     R1,[R0, #+18]
    478          #endif
    479          
    480              if (mask & (kUART_IdleLineFlag | kUART_RxOverrunFlag | kUART_NoiseErrorFlag | kUART_FramingErrorFlag |
    481                          kUART_ParityErrorFlag))
   \   00000014   0xF014 0x0F1F      TST      R4,#0x1F
   \   00000018   0xBF1C             ITT      NE 
   \   0000001A   0x7901             LDRBNE   R1,[R0, #+4]
   \   0000001C   0x79C1             LDRBNE   R1,[R0, #+7]
    482              {
    483                  /* Read base->D to clear the flags. */
    484                  (void)base->S1;
    485                  (void)base->D;
    486              }
    487          
    488              /* If some flags still pending. */
    489              if (mask & UART_GetStatusFlags(base))
   \   0000001E   0x.... 0x....      BL       UART_GetStatusFlags
   \   00000022   0x4020             ANDS     R0,R0,R4
   \   00000024   0xBF18             IT       NE 
   \   00000026   0xF240 0x30EE      MOVWNE   R0,#+1006
    490              {
    491                  /* Some flags can only clear or set by the hardware itself, these flags are: kUART_TxDataRegEmptyFlag,
    492                  kUART_TransmissionCompleteFlag, kUART_RxDataRegFullFlag, kUART_RxActiveFlag, kUART_NoiseErrorInRxDataRegFlag,
    493                  kUART_ParityErrorInRxDataRegFlag, kUART_TxFifoEmptyFlag, kUART_RxFifoEmptyFlag. */
    494                  status = kStatus_UART_FlagCannotClearManually;
    495              }
    496              else
    497              {
    498                  status = kStatus_Success;
    499              }
    500          
    501              return status;
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    502          }
    503          

   \                                 In section .text, align 2, keep-with-next
    504          void UART_WriteBlocking(UART_Type *base, const uint8_t *data, size_t length)
    505          {
   \                     UART_WriteBlocking: (+1)
   \   00000000   0xE005             B.N      ??UART_WriteBlocking_0
    506              /* This API can only ensure that the data is written into the data buffer but can't
    507              ensure all data in the data buffer are sent into the transmit shift buffer. */
    508              while (length--)
    509              {
    510                  while (!(base->S1 & UART_S1_TDRE_MASK))
   \                     ??UART_WriteBlocking_1: (+1)
   \   00000002   0x7903             LDRB     R3,[R0, #+4]
   \   00000004   0x061B             LSLS     R3,R3,#+24
   \   00000006   0xD5FC             BPL.N    ??UART_WriteBlocking_1
    511                  {
    512                  }
    513                  base->D = *(data++);
   \   00000008   0xF811 0x3B01      LDRB     R3,[R1], #+1
   \   0000000C   0x71C3             STRB     R3,[R0, #+7]
    514              }
   \                     ??UART_WriteBlocking_0: (+1)
   \   0000000E   0x4613             MOV      R3,R2
   \   00000010   0x1E5A             SUBS     R2,R3,#+1
   \   00000012   0x2B00             CMP      R3,#+0
   \   00000014   0xD1F5             BNE.N    ??UART_WriteBlocking_1
    515          }
   \   00000016   0x4770             BX       LR               ;; return
    516          
    517          static void UART_WriteNonBlocking(UART_Type *base, const uint8_t *data, size_t length)
    518          {
    519              /* The Non Blocking write data API assume user have ensured there is enough space in
    520              peripheral to write. */
    521              for (size_t i = 0; i < length; i++)
    522              {
    523                  base->D = data[i];
    524              }
    525          }
    526          

   \                                 In section .text, align 2, keep-with-next
    527          void UART_ReadBlocking(UART_Type *base, uint8_t *data, size_t length)
    528          {
   \                     UART_ReadBlocking: (+1)
   \   00000000   0xE005             B.N      ??UART_ReadBlocking_0
    529              while (length--)
    530              {
    531          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    532                  while (!base->RCFIFO)
   \                     ??UART_ReadBlocking_1: (+1)
   \   00000002   0x7D83             LDRB     R3,[R0, #+22]
   \   00000004   0x2B00             CMP      R3,#+0
   \   00000006   0xD0FC             BEQ.N    ??UART_ReadBlocking_1
    533          #else
    534                  while (!(base->S1 & UART_S1_RDRF_MASK))
    535          #endif
    536                  {
    537                  }
    538                  *(data++) = base->D;
   \   00000008   0x79C3             LDRB     R3,[R0, #+7]
   \   0000000A   0xF801 0x3B01      STRB     R3,[R1], #+1
    539              }
   \                     ??UART_ReadBlocking_0: (+1)
   \   0000000E   0x4613             MOV      R3,R2
   \   00000010   0x1E5A             SUBS     R2,R3,#+1
   \   00000012   0x2B00             CMP      R3,#+0
   \   00000014   0xD1F5             BNE.N    ??UART_ReadBlocking_1
    540          }
   \   00000016   0x4770             BX       LR               ;; return
    541          
    542          static void UART_ReadNonBlocking(UART_Type *base, uint8_t *data, size_t length)
    543          {
    544              /* The Non Blocking read data API assume user have ensured there is enough space in
    545              peripheral to write. */
    546              for (size_t i = 0; i < length; i++)
    547              {
    548                  data[i] = base->D;
    549              }
    550          }
    551          

   \                                 In section .text, align 2, keep-with-next
    552          void UART_CreateHandle(UART_Type *base, uart_handle_t *handle, uart_transfer_callback_t callback, void *userData)
    553          {
   \                     UART_CreateHandle: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
    554              assert(handle);
    555          
    556              uint32_t instance;
    557          
    558              /* Zero the handle. */
    559              memset(handle, 0, sizeof(*handle));
   \   0000000A   0x2130             MOVS     R1,#+48
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       __aeabi_memclr4
    560          
    561              /* Set the TX/RX state. */
    562              handle->rxState = kUART_RxIdle;
   \   00000012   0xF104 0x002C      ADD      R0,R4,#+44
   \   00000016   0x2102             MOVS     R1,#+2
   \   00000018   0x7041             STRB     R1,[R0, #+1]
    563              handle->txState = kUART_TxIdle;
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x7001             STRB     R1,[R0, #+0]
    564          
    565              /* Set the callback and user data. */
    566              handle->callback = callback;
   \   0000001E   0x6266             STR      R6,[R4, #+36]
    567              handle->userData = userData;
   \   00000020   0x62A7             STR      R7,[R4, #+40]
    568          
    569          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    570              /* Note:
    571                 Take care of the RX FIFO, RX interrupt request only assert when received bytes
    572                 equal or more than RX water mark, there is potential issue if RX water
    573                 mark larger than 1.
    574                 For example, if RX FIFO water mark is 2, upper layer needs 5 bytes and
    575                 5 bytes are received. the last byte will be saved in FIFO but not trigger
    576                 RX interrupt because the water mark is 2.
    577               */
    578              base->RWFIFO = 1U;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x7568             STRB     R0,[R5, #+21]
    579          #endif
    580          
    581              /* Get instance from peripheral base address. */
    582              instance = UART_GetInstance(base);
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x.... 0x....      BL       UART_GetInstance
    583          
    584              /* Save the handle in global variables to support the double weak mechanism. */
    585              s_uartHandle[instance] = handle;
   \   0000002C   0x....             LDR.N    R1,??DataTable7
   \   0000002E   0xF841 0x4020      STR      R4,[R1, R0, LSL #+2]
    586          
    587              /* Enable interrupt in NVIC. */
    588              EnableIRQ(s_uartIRQ[instance]);
   \   00000032   0x.... 0x....      ADR.W    R1,s_uartIRQ
   \   00000036   0x5608             LDRSB    R0,[R1, R0]
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0xF000 0x021F      AND      R2,R0,#0x1F
   \   0000003E   0x4091             LSLS     R1,R1,R2
   \   00000040   0x....             LDR.N    R2,??DataTable7_1  ;; 0xe000e100
   \   00000042   0x0940             LSRS     R0,R0,#+5
   \   00000044   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    589          }
   \   00000048   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    590          

   \                                 In section .text, align 2, keep-with-next
    591          void UART_StartRingBuffer(UART_Type *base, uart_handle_t *handle, uint8_t *ringBuffer, size_t ringBufferSize)
    592          {
    593              assert(handle);
    594          
    595              /* Setup the ringbuffer address */
    596              if (ringBuffer)
   \                     UART_StartRingBuffer: (+1)
   \   00000000   0xB13A             CBZ.N    R2,??UART_StartRingBuffer_0
    597              {
    598                  handle->rxRingBuffer = ringBuffer;
   \   00000002   0x618A             STR      R2,[R1, #+24]
    599                  handle->rxRingBufferSize = ringBufferSize;
   \   00000004   0x61CB             STR      R3,[R1, #+28]
    600                  handle->rxRingBufferHead = 0U;
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x840A             STRH     R2,[R1, #+32]
    601                  handle->rxRingBufferTail = 0U;
   \   0000000A   0x844A             STRH     R2,[R1, #+34]
    602          
    603                  /* Enable the interrupt to accept the data when user need the ring buffer. */
    604                  UART_EnableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable);
   \   0000000C   0xF44F 0x2102      MOV      R1,#+532480
   \   00000010   0x....             B.N      UART_EnableInterrupts
    605              }
    606          }
   \                     ??UART_StartRingBuffer_0: (+1)
   \   00000012   0x4770             BX       LR               ;; return
    607          

   \                                 In section .text, align 2, keep-with-next
    608          void UART_StopRingBuffer(UART_Type *base, uart_handle_t *handle)
    609          {
   \                     UART_StopRingBuffer: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    610              assert(handle);
    611          
    612              if (handle->rxState == kUART_RxIdle)
   \   00000002   0xF101 0x0418      ADD      R4,R1,#+24
   \   00000006   0x7D61             LDRB     R1,[R4, #+21]
   \   00000008   0x2902             CMP      R1,#+2
   \   0000000A   0xBF04             ITT      EQ 
    613              {
    614                  UART_DisableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable);
   \   0000000C   0xF44F 0x2102      MOVEQ    R1,#+532480
   \   00000010   0x.... 0x....      BLEQ     UART_DisableInterrupts
    615              }
    616          
    617              handle->rxRingBuffer = NULL;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x6020             STR      R0,[R4, #+0]
    618              handle->rxRingBufferSize = 0U;
   \   00000018   0x6060             STR      R0,[R4, #+4]
    619              handle->rxRingBufferHead = 0U;
   \   0000001A   0x8120             STRH     R0,[R4, #+8]
    620              handle->rxRingBufferTail = 0U;
   \   0000001C   0x8160             STRH     R0,[R4, #+10]
    621          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    622          

   \                                 In section .text, align 2, keep-with-next
    623          status_t UART_SendNonBlocking(UART_Type *base, uart_handle_t *handle, uart_transfer_t *xfer)
    624          {
   \                     UART_SendNonBlocking: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    625              status_t status;
    626          
    627              /* Return error if current TX busy. */
    628              if (kUART_TxBusy == handle->txState)
   \   00000002   0xF891 0x302C      LDRB     R3,[R1, #+44]
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD102             BNE.N    ??UART_SendNonBlocking_0
    629              {
    630                  status = kStatus_UART_TxBusy;
   \   0000000A   0xF44F 0x707A      MOV      R0,#+1000
   \   0000000E   0xBD02             POP      {R1,PC}
    631              }
    632              else
    633              {
    634                  handle->txData = xfer->data;
   \                     ??UART_SendNonBlocking_0: (+1)
   \   00000010   0x6813             LDR      R3,[R2, #+0]
   \   00000012   0x600B             STR      R3,[R1, #+0]
    635                  handle->txDataSize = xfer->dataSize;
   \   00000014   0x6853             LDR      R3,[R2, #+4]
   \   00000016   0x604B             STR      R3,[R1, #+4]
    636                  handle->txDataSizeAll = xfer->dataSize;
   \   00000018   0x6852             LDR      R2,[R2, #+4]
   \   0000001A   0x608A             STR      R2,[R1, #+8]
    637                  handle->txState = kUART_TxBusy;
   \   0000001C   0x2201             MOVS     R2,#+1
   \   0000001E   0xF881 0x202C      STRB     R2,[R1, #+44]
    638          
    639                  /* Enable transmiter interrupt. */
    640                  UART_EnableInterrupts(base, kUART_TxDataRegEmptyInterruptEnable);
   \   00000022   0xF44F 0x4100      MOV      R1,#+32768
   \   00000026   0x.... 0x....      BL       UART_EnableInterrupts
    641          
    642                  status = kStatus_Success;
   \   0000002A   0x2000             MOVS     R0,#+0
    643              }
    644          
    645              return status;
   \   0000002C   0xBD02             POP      {R1,PC}          ;; return
    646          }
    647          

   \                                 In section .text, align 2, keep-with-next
    648          void UART_AbortSend(UART_Type *base, uart_handle_t *handle)
    649          {
   \                     UART_AbortSend: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    650              UART_DisableInterrupts(base, kUART_TxDataRegEmptyInterruptEnable | kUART_TransmissionCompleteInterruptEnable);
   \   00000004   0xF44F 0x4140      MOV      R1,#+49152
   \   00000008   0x.... 0x....      BL       UART_DisableInterrupts
    651          
    652              handle->txDataSize = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6060             STR      R0,[R4, #+4]
    653              handle->txState = kUART_TxIdle;
   \   00000010   0xF884 0x002C      STRB     R0,[R4, #+44]
    654          }
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    655          

   \                                 In section .text, align 2, keep-with-next
    656          status_t UART_GetSendCount(UART_Type *base, uart_handle_t *handle, uint32_t *count)
    657          {
    658              if (kUART_TxIdle == handle->txState)
   \                     UART_GetSendCount: (+1)
   \   00000000   0xF891 0x002C      LDRB     R0,[R1, #+44]
   \   00000004   0xB908             CBNZ.N   R0,??UART_GetSendCount_0
    659              {
    660                  return kStatus_NoTransferInProgress;
   \   00000006   0x2006             MOVS     R0,#+6
   \   00000008   0x4770             BX       LR
    661              }
    662          
    663              if (!count)
   \                     ??UART_GetSendCount_0: (+1)
   \   0000000A   0xB90A             CBNZ.N   R2,??UART_GetSendCount_1
    664              {
    665                  return kStatus_InvalidArgument;
   \   0000000C   0x2004             MOVS     R0,#+4
   \   0000000E   0x4770             BX       LR
    666              }
    667          
    668              *count = handle->txDataSizeAll - handle->txDataSize;
   \                     ??UART_GetSendCount_1: (+1)
   \   00000010   0x1D08             ADDS     R0,R1,#+4
   \   00000012   0x....             B.N      ?Subroutine0
    669          
    670              return kStatus_Success;
    671          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x6841             LDR      R1,[R0, #+4]
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x1A08             SUBS     R0,R1,R0
   \   00000006   0x6010             STR      R0,[R2, #+0]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4770             BX       LR               ;; return
    672          

   \                                 In section .text, align 2, keep-with-next
    673          status_t UART_ReceiveNonBlocking(UART_Type *base, uart_handle_t *handle, uart_transfer_t *xfer, size_t *receivedBytes)
    674          {
   \                     UART_ReceiveNonBlocking: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4688             MOV      R8,R1
   \   00000006   0x4615             MOV      R5,R2
    675              uint32_t i;
    676              status_t status;
    677              /* How many bytes to copy from ring buffer to user memory. */
    678              size_t bytesToCopy = 0U;
    679              /* How many bytes to receive. */
    680              size_t bytesToReceive;
    681              /* How many bytes currently have received. */
    682              size_t bytesCurrentReceived;
    683              uint32_t regPrimask = 0U;
    684          
    685              /* How to get data:
    686                 1. If RX ring buffer is not enabled, then save xfer->data and xfer->dataSize
    687                    to uart handle, enable interrupt to store received data to xfer->data. When
    688                    all data received, trigger callback.
    689                 2. If RX ring buffer is enabled and not empty, get data from ring buffer first.
    690                    If there are enough data in ring buffer, copy them to xfer->data and return.
    691                    If there are not enough data in ring buffer, copy all of them to xfer->data,
    692                    save the xfer->data remained empty space to uart handle, receive data
    693                    to this empty space and trigger callback when finished. */
    694          
    695              if (kUART_RxBusy == handle->rxState)
   \   00000008   0xF898 0x102D      LDRB     R1,[R8, #+45]
   \   0000000C   0x2903             CMP      R1,#+3
   \   0000000E   0x4699             MOV      R9,R3
   \   00000010   0xBF08             IT       EQ 
   \   00000012   0xF240 0x30E9      MOVWEQ   R0,#+1001
    696              {
    697                  status = kStatus_UART_RxBusy;
   \   00000016   0xD042             BEQ.N    ??UART_ReceiveNonBlocking_0
    698              }
    699              else
    700              {
    701                  bytesToReceive = xfer->dataSize;
    702                  bytesCurrentReceived = 0U;
    703          
    704                  /* If RX ring buffer is used. */
    705                  if (handle->rxRingBuffer)
   \   00000018   0xF108 0x060C      ADD      R6,R8,#+12
   \   0000001C   0x686F             LDR      R7,[R5, #+4]
   \   0000001E   0x68F1             LDR      R1,[R6, #+12]
   \   00000020   0x2400             MOVS     R4,#+0
   \   00000022   0xB359             CBZ.N    R1,??UART_ReceiveNonBlocking_1
    706                  {
    707                      /* Disable IRQ, protect ring buffer. */
    708                      regPrimask = __get_PRIMASK();
   \   00000024   0xF3EF 0x8A10      MRS      R10,PRIMASK
    709                      __disable_irq();
   \   00000028   0xB672             CPSID    I
    710          
    711                      /* How many bytes in RX ring buffer currently. */
    712                      bytesToCopy = UART_GetRxRingBufferLength(handle);
   \   0000002A   0x4640             MOV      R0,R8
   \   0000002C   0x.... 0x....      BL       UART_GetRxRingBufferLength
    713          
    714                      if (bytesToCopy)
   \   00000030   0xB1C0             CBZ.N    R0,??UART_ReceiveNonBlocking_2
    715                      {
    716                          bytesToCopy = MIN(bytesToReceive, bytesToCopy);
   \   00000032   0x4287             CMP      R7,R0
   \   00000034   0xBF98             IT       LS 
   \   00000036   0x4638             MOVLS    R0,R7
    717          
    718                          bytesToReceive -= bytesToCopy;
   \   00000038   0x1A3F             SUBS     R7,R7,R0
    719          
    720                          /* Copy data from ring buffer to user memory. */
    721                          for (i = 0U; i < bytesToCopy; i++)
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0xE001             B.N      ??UART_ReceiveNonBlocking_3
    722                          {
    723                              xfer->data[bytesCurrentReceived++] = handle->rxRingBuffer[handle->rxRingBufferTail];
    724          
    725                              /* Wrap to 0. Not use modulo (%) because it might be large and slow. */
    726                              if (handle->rxRingBufferTail + 1U == handle->rxRingBufferSize)
    727                              {
    728                                  handle->rxRingBufferTail = 0U;
    729                              }
    730                              else
    731                              {
    732                                  handle->rxRingBufferTail++;
   \                     ??UART_ReceiveNonBlocking_4: (+1)
   \   0000003E   0x82F2             STRH     R2,[R6, #+22]
   \   00000040   0x1C49             ADDS     R1,R1,#+1
   \                     ??UART_ReceiveNonBlocking_3: (+1)
   \   00000042   0x4281             CMP      R1,R0
   \   00000044   0xD20E             BCS.N    ??UART_ReceiveNonBlocking_2
   \   00000046   0x68F2             LDR      R2,[R6, #+12]
   \   00000048   0x8AF3             LDRH     R3,[R6, #+22]
   \   0000004A   0x5CD2             LDRB     R2,[R2, R3]
   \   0000004C   0x682B             LDR      R3,[R5, #+0]
   \   0000004E   0x551A             STRB     R2,[R3, R4]
   \   00000050   0x1C64             ADDS     R4,R4,#+1
   \   00000052   0x8AF2             LDRH     R2,[R6, #+22]
   \   00000054   0x6933             LDR      R3,[R6, #+16]
   \   00000056   0x1C52             ADDS     R2,R2,#+1
   \   00000058   0x429A             CMP      R2,R3
   \   0000005A   0xBF0E             ITEE     EQ 
   \   0000005C   0x2200             MOVEQ    R2,#+0
   \   0000005E   0x8AF2             LDRHNE   R2,[R6, #+22]
   \   00000060   0x1C52             ADDNE    R2,R2,#+1
   \   00000062   0xE7EC             B.N      ??UART_ReceiveNonBlocking_4
    733                              }
    734                          }
    735                      }
    736          
    737                      /* If ring buffer does not have enough data, still need to read more data. */
    738                      if (bytesToReceive)
   \                     ??UART_ReceiveNonBlocking_2: (+1)
   \   00000064   0xB13F             CBZ.N    R7,??UART_ReceiveNonBlocking_5
    739                      {
    740                          /* No data in ring buffer, save the request to UART handle. */
    741                          handle->rxData = xfer->data + bytesCurrentReceived;
   \   00000066   0x6828             LDR      R0,[R5, #+0]
   \   00000068   0x1900             ADDS     R0,R0,R4
   \   0000006A   0x6030             STR      R0,[R6, #+0]
    742                          handle->rxDataSize = bytesToReceive;
   \   0000006C   0x6077             STR      R7,[R6, #+4]
    743                          handle->rxDataSizeAll = bytesToReceive;
   \   0000006E   0x60B7             STR      R7,[R6, #+8]
    744                          handle->rxState = kUART_RxBusy;
   \   00000070   0x2003             MOVS     R0,#+3
   \   00000072   0xF888 0x002D      STRB     R0,[R8, #+45]
    745                      }
    746          
    747                      /* Recover PRIMASK, enable IRQ if previously enabled. */
    748                      __set_PRIMASK(regPrimask);
   \                     ??UART_ReceiveNonBlocking_5: (+1)
   \   00000076   0xF38A 0x8810      MSR      PRIMASK,R10
   \   0000007A   0xE00A             B.N      ??UART_ReceiveNonBlocking_6
    749                  }
    750                  /* Ring buffer not used. */
    751                  else
    752                  {
    753                      handle->rxData = xfer->data + bytesCurrentReceived;
   \                     ??UART_ReceiveNonBlocking_1: (+1)
   \   0000007C   0x6829             LDR      R1,[R5, #+0]
   \   0000007E   0x6031             STR      R1,[R6, #+0]
    754                      handle->rxDataSize = bytesToReceive;
   \   00000080   0x6077             STR      R7,[R6, #+4]
    755                      handle->rxDataSizeAll = bytesToReceive;
   \   00000082   0x60B7             STR      R7,[R6, #+8]
    756                      handle->rxState = kUART_RxBusy;
   \   00000084   0x2103             MOVS     R1,#+3
   \   00000086   0xF888 0x102D      STRB     R1,[R8, #+45]
    757          
    758                      /* Enable RX interrupt. */
    759                      UART_EnableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable);
   \   0000008A   0xF44F 0x2102      MOV      R1,#+532480
   \   0000008E   0x.... 0x....      BL       UART_EnableInterrupts
    760                  }
    761          
    762                  /* Return the how many bytes have read. */
    763                  if (receivedBytes)
   \                     ??UART_ReceiveNonBlocking_6: (+1)
   \   00000092   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000096   0xBF18             IT       NE 
   \   00000098   0xF8C9 0x4000      STRNE    R4,[R9, #+0]
    764                  {
    765                      *receivedBytes = bytesCurrentReceived;
    766                  }
    767          
    768                  status = kStatus_Success;
   \   0000009C   0x2000             MOVS     R0,#+0
    769              }
    770          
    771              return status;
   \                     ??UART_ReceiveNonBlocking_0: (+1)
   \   0000009E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    772          }
    773          

   \                                 In section .text, align 2, keep-with-next
    774          void UART_AbortReceive(UART_Type *base, uart_handle_t *handle)
    775          {
   \                     UART_AbortReceive: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    776              /* Only abort the receive to handle->rxData, the RX ring buffer is still working. */
    777              if (!handle->rxRingBuffer)
   \   00000002   0xF101 0x0410      ADD      R4,R1,#+16
   \   00000006   0x68A1             LDR      R1,[R4, #+8]
   \   00000008   0xB919             CBNZ.N   R1,??UART_AbortReceive_0
    778              {
    779                  /* Disable RX interrupt. */
    780                  UART_DisableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable);
   \   0000000A   0xF44F 0x2102      MOV      R1,#+532480
   \   0000000E   0x.... 0x....      BL       UART_DisableInterrupts
    781              }
    782          
    783              handle->rxDataSize = 0U;
   \                     ??UART_AbortReceive_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x6020             STR      R0,[R4, #+0]
    784              handle->rxState = kUART_RxIdle;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x7760             STRB     R0,[R4, #+29]
    785          }
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    786          

   \                                 In section .text, align 2, keep-with-next
    787          status_t UART_GetReceiveCount(UART_Type *base, uart_handle_t *handle, uint32_t *count)
    788          {
    789              if (kUART_RxIdle == handle->rxState)
   \                     UART_GetReceiveCount: (+1)
   \   00000000   0xF101 0x0010      ADD      R0,R1,#+16
   \   00000004   0x7F41             LDRB     R1,[R0, #+29]
   \   00000006   0x2902             CMP      R1,#+2
   \   00000008   0xD101             BNE.N    ??UART_GetReceiveCount_0
    790              {
    791                  return kStatus_NoTransferInProgress;
   \   0000000A   0x2006             MOVS     R0,#+6
   \   0000000C   0x4770             BX       LR
    792              }
    793          
    794              if (!count)
   \                     ??UART_GetReceiveCount_0: (+1)
   \   0000000E   0xB90A             CBNZ.N   R2,??UART_GetReceiveCount_1
    795              {
    796                  return kStatus_InvalidArgument;
   \   00000010   0x2004             MOVS     R0,#+4
   \   00000012   0x4770             BX       LR
    797              }
    798          
    799              *count = handle->rxDataSizeAll - handle->rxDataSize;
   \                     ??UART_GetReceiveCount_1: (+1)
   \   00000014                      REQUIRE ?Subroutine0
   \   00000014                      ;; // Fall through to label ?Subroutine0
    800          
    801              return kStatus_Success;
    802          }
    803          

   \                                 In section .text, align 2, keep-with-next
    804          void UART_HandleIRQ(UART_Type *base, uart_handle_t *handle)
    805          {
   \                     UART_HandleIRQ: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    806              uint8_t count;
    807              uint8_t tempCount;
    808          
    809              /* If RX overrun. */
    810              if (UART_S1_OR_MASK & base->S1)
   \   00000006   0x7920             LDRB     R0,[R4, #+4]
   \   00000008   0x0700             LSLS     R0,R0,#+28
   \   0000000A   0xD508             BPL.N    ??UART_HandleIRQ_0
    811              {
    812                  /* Read base->D, otherwise the RX does not work. */
    813                  (void)base->D;
   \   0000000C   0x79E0             LDRB     R0,[R4, #+7]
    814          
    815                  /* Trigger callback. */
    816                  if (handle->callback)
   \   0000000E   0x6A6E             LDR      R6,[R5, #+36]
   \   00000010   0x0030             MOVS     R0,R6
   \   00000012   0xD004             BEQ.N    ??UART_HandleIRQ_0
    817                  {
    818                      handle->callback(base, handle, kStatus_UART_RxHardwareOverrun, handle->userData);
   \   00000014   0x6AAB             LDR      R3,[R5, #+40]
   \   00000016   0xF240 0x32F1      MOVW     R2,#+1009
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x47B0             BLX      R6
    819                  }
    820              }
    821          
    822              /* Receive data register full */
    823              if ((UART_S1_RDRF_MASK & base->S1) && (UART_C2_RIE_MASK & base->C2))
   \                     ??UART_HandleIRQ_0: (+1)
   \   0000001E   0x7920             LDRB     R0,[R4, #+4]
   \   00000020   0x0680             LSLS     R0,R0,#+26
   \   00000022   0xF105 0x062C      ADD      R6,R5,#+44
   \   00000026   0xD536             BPL.N    ??UART_HandleIRQ_1
   \   00000028   0x78E0             LDRB     R0,[R4, #+3]
   \   0000002A   0x0680             LSLS     R0,R0,#+26
   \   0000002C   0xD533             BPL.N    ??UART_HandleIRQ_1
    824              {
    825          /* Get the size that can be stored into buffer for this interrupt. */
    826          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    827                  count = base->RCFIFO;
   \   0000002E   0x7DA7             LDRB     R7,[R4, #+22]
   \   00000030   0xE01A             B.N      ??UART_HandleIRQ_2
    828          #else
    829                  count = 1;
    830          #endif
    831          
    832                  /* If handle->rxDataSize is not 0, first save data to handle->rxData. */
    833                  while ((count) && (handle->rxDataSize))
    834                  {
   \                     ??UART_HandleIRQ_3: (+1)
   \   00000032   0x79E3             LDRB     R3,[R4, #+7]
   \   00000034   0x548B             STRB     R3,[R1, R2]
   \   00000036   0x1C52             ADDS     R2,R2,#+1
   \                     ??UART_HandleIRQ_4: (+1)
   \   00000038   0x4282             CMP      R2,R0
   \   0000003A   0xD3FA             BCC.N    ??UART_HandleIRQ_3
    835          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    836                      tempCount = MIN(handle->rxDataSize, count);
    837          #else
    838                      tempCount = 1;
    839          #endif
    840          
    841                      /* Using non block API to read the data from the registers. */
    842                      UART_ReadNonBlocking(base, handle->rxData, tempCount);
    843                      handle->rxData += tempCount;
   \   0000003C   0x68E9             LDR      R1,[R5, #+12]
   \   0000003E   0x4401             ADD      R1,R1,R0
   \   00000040   0x60E9             STR      R1,[R5, #+12]
    844                      handle->rxDataSize -= tempCount;
    845                      count -= tempCount;
   \   00000042   0x1A3F             SUBS     R7,R7,R0
   \   00000044   0x6929             LDR      R1,[R5, #+16]
   \   00000046   0x1A09             SUBS     R1,R1,R0
   \   00000048   0x6129             STR      R1,[R5, #+16]
    846          
    847                      /* If all the data required for upper layer is ready, trigger callback. */
    848                      if (!handle->rxDataSize)
   \   0000004A   0x6928             LDR      R0,[R5, #+16]
   \   0000004C   0xB960             CBNZ.N   R0,??UART_HandleIRQ_2
    849                      {
    850                          handle->rxState = kUART_RxIdle;
   \   0000004E   0x2002             MOVS     R0,#+2
   \   00000050   0x7070             STRB     R0,[R6, #+1]
    851          
    852                          if (handle->callback)
   \   00000052   0xF8D5 0xC024      LDR      R12,[R5, #+36]
   \   00000056   0xF1BC 0x0F00      CMP      R12,#+0
   \   0000005A   0xD005             BEQ.N    ??UART_HandleIRQ_2
    853                          {
    854                              handle->callback(base, handle, kStatus_UART_RxIdle, handle->userData);
   \   0000005C   0x6AAB             LDR      R3,[R5, #+40]
   \   0000005E   0xF240 0x32EB      MOVW     R2,#+1003
   \   00000062   0x4629             MOV      R1,R5
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x47E0             BLX      R12
    855                          }
    856                      }
   \                     ??UART_HandleIRQ_2: (+1)
   \   00000068   0xB2F8             UXTB     R0,R7
   \   0000006A   0xB158             CBZ.N    R0,??UART_HandleIRQ_5
   \   0000006C   0x6928             LDR      R0,[R5, #+16]
   \   0000006E   0xB148             CBZ.N    R0,??UART_HandleIRQ_5
   \   00000070   0xB2FF             UXTB     R7,R7
   \   00000072   0x6929             LDR      R1,[R5, #+16]
   \   00000074   0x4638             MOV      R0,R7
   \   00000076   0x4281             CMP      R1,R0
   \   00000078   0xBF3C             ITT      CC 
   \   0000007A   0x6928             LDRCC    R0,[R5, #+16]
   \   0000007C   0xB2C0             UXTBCC   R0,R0
   \   0000007E   0x68E9             LDR      R1,[R5, #+12]
   \   00000080   0x2200             MOVS     R2,#+0
   \   00000082   0xE7D9             B.N      ??UART_HandleIRQ_4
    857                  }
    858          
    859                  /* If use RX ring buffer, receive data to ring buffer. */
    860                  if (handle->rxRingBuffer)
   \                     ??UART_HandleIRQ_5: (+1)
   \   00000084   0x69A8             LDR      R0,[R5, #+24]
   \   00000086   0xB990             CBNZ.N   R0,??UART_HandleIRQ_6
    861                  {
    862                      while (count--)
    863                      {
    864                          /* If RX ring buffer is full, trigger callback to notify over run. */
    865                          if (UART_IsRxRingBufferFull(handle))
    866                          {
    867                              if (handle->callback)
    868                              {
    869                                  handle->callback(base, handle, kStatus_UART_RxRingBufferOverrun, handle->userData);
    870                              }
    871                          }
    872          
    873                          /* If ring buffer is still full after callback function, the oldest data is overrided. */
    874                          if (UART_IsRxRingBufferFull(handle))
    875                          {
    876                              /* Increase handle->rxRingBufferTail to make room for new data. */
    877                              if (handle->rxRingBufferTail + 1U == handle->rxRingBufferSize)
    878                              {
    879                                  handle->rxRingBufferTail = 0U;
    880                              }
    881                              else
    882                              {
    883                                  handle->rxRingBufferTail++;
    884                              }
    885                          }
    886          
    887                          /* Read data. */
    888                          handle->rxRingBuffer[handle->rxRingBufferHead] = base->D;
    889          
    890                          /* Increase handle->rxRingBufferHead. */
    891                          if (handle->rxRingBufferHead + 1U == handle->rxRingBufferSize)
    892                          {
    893                              handle->rxRingBufferHead = 0U;
    894                          }
    895                          else
    896                          {
    897                              handle->rxRingBufferHead++;
    898                          }
    899                      }
    900                  }
    901                  /* If no receive requst pending, stop RX interrupt. */
    902                  else if (!handle->rxDataSize)
   \   00000088   0x6928             LDR      R0,[R5, #+16]
   \   0000008A   0xB920             CBNZ.N   R0,??UART_HandleIRQ_1
    903                  {
    904                      UART_DisableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable);
   \   0000008C   0xF44F 0x2102      MOV      R1,#+532480
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x.... 0x....      BL       UART_DisableInterrupts
    905                  }
    906                  else
    907                  {
    908                  }
    909              }
    910          
    911              /* Send data register empty and the interrupt is enabled. */
    912              if ((base->S1 & UART_S1_TDRE_MASK) && (base->C2 & UART_C2_TIE_MASK))
   \                     ??UART_HandleIRQ_1: (+1)
   \   00000096   0x7920             LDRB     R0,[R4, #+4]
   \   00000098   0x0600             LSLS     R0,R0,#+24
   \   0000009A   0xD56D             BPL.N    ??UART_HandleIRQ_7
   \   0000009C   0x78E0             LDRB     R0,[R4, #+3]
   \   0000009E   0x0600             LSLS     R0,R0,#+24
   \   000000A0   0xD56A             BPL.N    ??UART_HandleIRQ_7
    913              {
    914          /* Get the bytes that available at this moment. */
    915          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    916                  count = FSL_FEATURE_UART_FIFO_SIZEn(base) - base->TCFIFO;
   \   000000A2   0x....             LDR.N    R0,??DataTable7_2  ;; 0x4006a000
   \   000000A4   0x4284             CMP      R4,R0
   \   000000A6   0xD131             BNE.N    ??UART_HandleIRQ_8
   \   000000A8   0x2008             MOVS     R0,#+8
   \   000000AA   0xE036             B.N      ??UART_HandleIRQ_9
   \                     ??UART_HandleIRQ_10: (+1)
   \   000000AC   0x8428             STRH     R0,[R5, #+32]
   \                     ??UART_HandleIRQ_6: (+1)
   \   000000AE   0x4638             MOV      R0,R7
   \   000000B0   0x1E47             SUBS     R7,R0,#+1
   \   000000B2   0xB2C0             UXTB     R0,R0
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD0EE             BEQ.N    ??UART_HandleIRQ_1
   \   000000B8   0x4628             MOV      R0,R5
   \   000000BA   0x.... 0x....      BL       UART_IsRxRingBufferFull
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xBF1C             ITT      NE 
   \   000000C2   0xF8D5 0xC024      LDRNE    R12,[R5, #+36]
   \   000000C6   0xF1BC 0x0F00      CMPNE    R12,#+0
   \   000000CA   0xD005             BEQ.N    ??UART_HandleIRQ_11
   \   000000CC   0x6AAB             LDR      R3,[R5, #+40]
   \   000000CE   0xF44F 0x727C      MOV      R2,#+1008
   \   000000D2   0x4629             MOV      R1,R5
   \   000000D4   0x4620             MOV      R0,R4
   \   000000D6   0x47E0             BLX      R12
   \                     ??UART_HandleIRQ_11: (+1)
   \   000000D8   0x4628             MOV      R0,R5
   \   000000DA   0x.... 0x....      BL       UART_IsRxRingBufferFull
   \   000000DE   0xB140             CBZ.N    R0,??UART_HandleIRQ_12
   \   000000E0   0x8C68             LDRH     R0,[R5, #+34]
   \   000000E2   0x69E9             LDR      R1,[R5, #+28]
   \   000000E4   0x1C40             ADDS     R0,R0,#+1
   \   000000E6   0x4288             CMP      R0,R1
   \   000000E8   0xBF0E             ITEE     EQ 
   \   000000EA   0x2000             MOVEQ    R0,#+0
   \   000000EC   0x8C68             LDRHNE   R0,[R5, #+34]
   \   000000EE   0x1C40             ADDNE    R0,R0,#+1
   \   000000F0   0x8468             STRH     R0,[R5, #+34]
   \                     ??UART_HandleIRQ_12: (+1)
   \   000000F2   0x8C28             LDRH     R0,[R5, #+32]
   \   000000F4   0x79E1             LDRB     R1,[R4, #+7]
   \   000000F6   0x69AA             LDR      R2,[R5, #+24]
   \   000000F8   0x5411             STRB     R1,[R2, R0]
   \   000000FA   0x8C28             LDRH     R0,[R5, #+32]
   \   000000FC   0x69E9             LDR      R1,[R5, #+28]
   \   000000FE   0x1C40             ADDS     R0,R0,#+1
   \   00000100   0x4288             CMP      R0,R1
   \   00000102   0xBF1A             ITTE     NE 
   \   00000104   0x8C28             LDRHNE   R0,[R5, #+32]
   \   00000106   0x1C40             ADDNE    R0,R0,#+1
   \   00000108   0x2000             MOVEQ    R0,#+0
   \   0000010A   0xE7CF             B.N      ??UART_HandleIRQ_10
   \                     ??UART_HandleIRQ_8: (+1)
   \   0000010C   0x....             LDR.N    R0,??DataTable7_3  ;; 0x4006b000
   \   0000010E   0x4284             CMP      R4,R0
   \   00000110   0xBF1B             ITTET    NE 
   \   00000112   0x....             LDRNE.N  R0,??DataTable7_4  ;; 0x4006c000
   \   00000114   0x4284             CMPNE    R4,R0
   \   00000116   0x2001             MOVEQ    R0,#+1
   \   00000118   0x20FF             MOVNE    R0,#+255
   \                     ??UART_HandleIRQ_9: (+1)
   \   0000011A   0x7D21             LDRB     R1,[R4, #+20]
   \   0000011C   0x1A47             SUBS     R7,R0,R1
   \   0000011E   0xE01D             B.N      ??UART_HandleIRQ_13
    917          #else
    918                  count = 1;
    919          #endif
    920          
    921                  while ((count) && (handle->txDataSize))
    922                  {
   \                     ??UART_HandleIRQ_14: (+1)
   \   00000120   0x5C8B             LDRB     R3,[R1, R2]
   \   00000122   0x71E3             STRB     R3,[R4, #+7]
   \   00000124   0x1C52             ADDS     R2,R2,#+1
   \                     ??UART_HandleIRQ_15: (+1)
   \   00000126   0x4282             CMP      R2,R0
   \   00000128   0xD3FA             BCC.N    ??UART_HandleIRQ_14
    923          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    924                      tempCount = MIN(handle->txDataSize, count);
    925          #else
    926                      tempCount = 1;
    927          #endif
    928          
    929                      /* Using non block API to write the data to the registers. */
    930                      UART_WriteNonBlocking(base, handle->txData, tempCount);
    931                      handle->txData += tempCount;
   \   0000012A   0x6829             LDR      R1,[R5, #+0]
   \   0000012C   0x4401             ADD      R1,R1,R0
   \   0000012E   0x6029             STR      R1,[R5, #+0]
    932                      handle->txDataSize -= tempCount;
    933                      count -= tempCount;
   \   00000130   0x1A3F             SUBS     R7,R7,R0
   \   00000132   0x6869             LDR      R1,[R5, #+4]
   \   00000134   0x1A09             SUBS     R1,R1,R0
   \   00000136   0x6069             STR      R1,[R5, #+4]
    934          
    935                      /* If all the data are written to data register, TX finished. */
    936                      if (!handle->txDataSize)
   \   00000138   0x6868             LDR      R0,[R5, #+4]
   \   0000013A   0xB978             CBNZ.N   R0,??UART_HandleIRQ_13
    937                      {
    938                          handle->txState = kUART_TxIdle;
   \   0000013C   0x7030             STRB     R0,[R6, #+0]
    939          
    940                          /* Disable TX register empty interrupt. */
    941                          base->C2 = (base->C2 & ~UART_C2_TIE_MASK);
   \   0000013E   0x78E0             LDRB     R0,[R4, #+3]
   \   00000140   0xF000 0x007F      AND      R0,R0,#0x7F
   \   00000144   0x70E0             STRB     R0,[R4, #+3]
    942          
    943                          /* Trigger callback. */
    944                          if (handle->callback)
   \   00000146   0xF8D5 0xC024      LDR      R12,[R5, #+36]
   \   0000014A   0xF1BC 0x0F00      CMP      R12,#+0
   \   0000014E   0xD005             BEQ.N    ??UART_HandleIRQ_13
    945                          {
    946                              handle->callback(base, handle, kStatus_UART_TxIdle, handle->userData);
   \   00000150   0x6AAB             LDR      R3,[R5, #+40]
   \   00000152   0xF240 0x32EA      MOVW     R2,#+1002
   \   00000156   0x4629             MOV      R1,R5
   \   00000158   0x4620             MOV      R0,R4
   \   0000015A   0x47E0             BLX      R12
    947                          }
    948                      }
   \                     ??UART_HandleIRQ_13: (+1)
   \   0000015C   0xB2F8             UXTB     R0,R7
   \   0000015E   0xB158             CBZ.N    R0,??UART_HandleIRQ_7
   \   00000160   0x6868             LDR      R0,[R5, #+4]
   \   00000162   0xB148             CBZ.N    R0,??UART_HandleIRQ_7
   \   00000164   0xB2FF             UXTB     R7,R7
   \   00000166   0x6869             LDR      R1,[R5, #+4]
   \   00000168   0x4638             MOV      R0,R7
   \   0000016A   0x4281             CMP      R1,R0
   \   0000016C   0xBF3C             ITT      CC 
   \   0000016E   0x6868             LDRCC    R0,[R5, #+4]
   \   00000170   0xB2C0             UXTBCC   R0,R0
   \   00000172   0x6829             LDR      R1,[R5, #+0]
   \   00000174   0x2200             MOVS     R2,#+0
   \   00000176   0xE7D6             B.N      ??UART_HandleIRQ_15
    949                  }
    950              }
    951          }
   \                     ??UART_HandleIRQ_7: (+1)
   \   00000178   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    952          

   \                                 In section .text, align 2, keep-with-next
    953          void UART_HandleErrorIRQ(UART_Type *base, uart_handle_t *handle)
    954          {
    955              /* TODO: To be implemented. */
    956          }
   \                     UART_HandleErrorIRQ: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    957          
    958          #if defined(UART0)
    959          #if ((!(defined(FSL_FEATURE_SOC_LPSCI_COUNT))) || \
    960               ((defined(FSL_FEATURE_SOC_LPSCI_COUNT)) && (FSL_FEATURE_SOC_LPSCI_COUNT == 0)))

   \                                 In section .text, align 2, keep-with-next
    961          void UART0_DriverIRQHandler(void)
    962          {
    963              assert(s_uartHandle[0]);
    964          
    965              UART_HandleIRQ(UART0, s_uartHandle[0]);
   \                     UART0_DriverIRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable7
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x....             LDR.N    R0,??DataTable7_2  ;; 0x4006a000
   \   00000006   0x....             B.N      UART_HandleIRQ
    966          }
    967          

   \                                 In section .text, align 2, keep-with-next
    968          void UART0_RX_TX_DriverIRQHandler(void)
    969          {
    970              UART0_DriverIRQHandler();
   \                     UART0_RX_TX_DriverIRQHandler: (+1)
   \   00000000   0x....             B.N      UART0_DriverIRQHandler
    971          }
    972          #endif
    973          #endif
    974          
    975          #if defined(UART1)

   \                                 In section .text, align 2, keep-with-next
    976          void UART1_DriverIRQHandler(void)
    977          {
    978              assert(s_uartHandle[1]);
    979          
    980              UART_HandleIRQ(UART1, s_uartHandle[1]);
   \                     UART1_DriverIRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable7
   \   00000002   0x6841             LDR      R1,[R0, #+4]
   \   00000004   0x....             LDR.N    R0,??DataTable7_3  ;; 0x4006b000
   \   00000006   0x....             B.N      UART_HandleIRQ
    981          }
    982          

   \                                 In section .text, align 2, keep-with-next
    983          void UART1_RX_TX_DriverIRQHandler(void)
    984          {
    985              UART1_DriverIRQHandler();
   \                     UART1_RX_TX_DriverIRQHandler: (+1)
   \   00000000   0x....             B.N      UART1_DriverIRQHandler
    986          }
    987          #endif
    988          
    989          #if defined(UART2)

   \                                 In section .text, align 2, keep-with-next
    990          void UART2_DriverIRQHandler(void)
    991          {
    992              assert(s_uartHandle[2]);
    993          
    994              UART_HandleIRQ(UART2, s_uartHandle[2]);
   \                     UART2_DriverIRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable7
   \   00000002   0x6881             LDR      R1,[R0, #+8]
   \   00000004   0x....             LDR.N    R0,??DataTable7_4  ;; 0x4006c000
   \   00000006   0x....             B.N      UART_HandleIRQ
    995          }
    996          

   \                                 In section .text, align 2, keep-with-next
    997          void UART2_RX_TX_DriverIRQHandler(void)
    998          {
    999              UART2_DriverIRQHandler();
   \                     UART2_RX_TX_DriverIRQHandler: (+1)
   \   00000000   0x....             B.N      UART2_DriverIRQHandler
   1000          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     s_uartHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x4006A000         DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x4006B000         DC32     0x4006b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x4006C000         DC32     0x4006c000
   1001          
   1002          #endif
   1003          
   1004          #if defined(UART3)
   1005          void UART3_DriverIRQHandler(void)
   1006          {
   1007              assert(s_uartHandle[3]);
   1008          
   1009              UART_HandleIRQ(UART3, s_uartHandle[3]);
   1010          }
   1011          
   1012          void UART3_RX_TX_DriverIRQHandler(void)
   1013          {
   1014              UART3_DriverIRQHandler();
   1015          }
   1016          #endif
   1017          
   1018          #if defined(UART4)
   1019          void UART4_DriverIRQHandler(void)
   1020          {
   1021              assert(s_uartHandle[4]);
   1022          
   1023              UART_HandleIRQ(UART4, s_uartHandle[4]);
   1024          }
   1025          
   1026          void UART4_RX_TX_DriverIRQHandler(void)
   1027          {
   1028              UART4_DriverIRQHandler();
   1029          }
   1030          #endif
   1031          
   1032          #if defined(UART5)
   1033          void UART5_DriverIRQHandler(void)
   1034          {
   1035              assert(s_uartHandle[5]);
   1036          
   1037              UART_HandleIRQ(UART5, s_uartHandle[5]);
   1038          }
   1039          
   1040          void UART5_RX_TX_DriverIRQHandler(void)
   1041          {
   1042              UART5_DriverIRQHandler();
   1043          }
   1044          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   UART0_DriverIRQHandler
         0   -> UART_HandleIRQ
       0   UART0_RX_TX_DriverIRQHandler
         0   -> UART0_DriverIRQHandler
       0   UART1_DriverIRQHandler
         0   -> UART_HandleIRQ
       0   UART1_RX_TX_DriverIRQHandler
         0   -> UART1_DriverIRQHandler
       0   UART2_DriverIRQHandler
         0   -> UART_HandleIRQ
       0   UART2_RX_TX_DriverIRQHandler
         0   -> UART2_DriverIRQHandler
       8   UART_AbortReceive
         8   -> UART_DisableInterrupts
       8   UART_AbortSend
         8   -> UART_DisableInterrupts
       8   UART_ClearStatusFlags
         8   -> UART_GetStatusFlags
      24   UART_CreateHandle
        24   -> UART_GetInstance
        24   -> __aeabi_memclr4
       8   UART_Deinit
         8   -> UART_GetInstance
       0   UART_DisableInterrupts
       0   UART_EnableInterrupts
       0   UART_GetDefaultConfig
       0   UART_GetEnabledInterrupts
       0   UART_GetInstance
       0   UART_GetReceiveCount
       0   UART_GetRxRingBufferLength
       0   UART_GetSendCount
       0   UART_GetStatusFlags
       0   UART_HandleErrorIRQ
      24   UART_HandleIRQ
        24   -- Indirect call
        24   -> UART_DisableInterrupts
        24   -> UART_IsRxRingBufferFull
      24   UART_Init
        24   -> UART_GetInstance
       8   UART_IsRxRingBufferFull
         8   -> UART_GetRxRingBufferLength
       0   UART_ReadBlocking
      32   UART_ReceiveNonBlocking
        32   -> UART_EnableInterrupts
        32   -> UART_GetRxRingBufferLength
       8   UART_SendNonBlocking
         8   -> UART_EnableInterrupts
      16   UART_SetBaudRate
       0   UART_StartRingBuffer
         0   -> UART_EnableInterrupts
       8   UART_StopRingBuffer
         8   -> UART_DisableInterrupts
       0   UART_WriteBlocking


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
      12  ?Subroutine0
      10  ?Subroutine1
      28  ?Subroutine2
       8  UART0_DriverIRQHandler
       2  UART0_RX_TX_DriverIRQHandler
       8  UART1_DriverIRQHandler
       2  UART1_RX_TX_DriverIRQHandler
       8  UART2_DriverIRQHandler
       2  UART2_RX_TX_DriverIRQHandler
      28  UART_AbortReceive
      22  UART_AbortSend
      44  UART_ClearStatusFlags
      74  UART_CreateHandle
      34  UART_Deinit
      32  UART_DisableInterrupts
      32  UART_EnableInterrupts
      24  UART_GetDefaultConfig
      14  UART_GetEnabledInterrupts
      24  UART_GetInstance
      20  UART_GetReceiveCount
      20  UART_GetRxRingBufferLength
      20  UART_GetSendCount
      12  UART_GetStatusFlags
       2  UART_HandleErrorIRQ
     378  UART_HandleIRQ
     174  UART_Init
      22  UART_IsRxRingBufferFull
      24  UART_ReadBlocking
     162  UART_ReceiveNonBlocking
      46  UART_SendNonBlocking
     102  UART_SetBaudRate
      20  UART_StartRingBuffer
      32  UART_StopRingBuffer
      24  UART_WriteBlocking
      12  s_uartBases
      12  s_uartClock
      12  s_uartHandle
       4  s_uartIRQ

 
    12 bytes in section .bss
 1 514 bytes in section .text
 
 1 514 bytes of CODE memory
    12 bytes of DATA memory

Errors: none
Warnings: none
