###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Aug/2016  15:48:55
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\src\hardware_init_K22F512.c
#    Command line =  
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\src\hardware_init_K22F512.c"
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN512VDC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -lC
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\obj"
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform/devices/MK22F51212\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/osa\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/device\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/device/class\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/bm_usb\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform/devices\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/common\"
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\list\hardware_init_K22F512.lst
#    Object file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\obj\hardware_init_K22F512.o
#
###############################################################################

C:\Users\cwati\Documents\My Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\src\hardware_init_K22F512.c
      1          /*
      2           * Copyright (c) 2013-2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "bootloader_common.h"
     32          #include "bootloader/bl_context.h"
     33          #include "fsl_device_registers.h"
     34          #include "uart/fsl_uart.h"
     35          #include "utilities/kinetis_family.h"
     36          #include "smc/smc.h"
     37          
     38          ////////////////////////////////////////////////////////////////////////////////
     39          // Definitions
     40          ////////////////////////////////////////////////////////////////////////////////
     41          
     42          #ifdef TOWER
     43          #define BOOT_PIN_NUMBER 7
     44          #define BOOT_PIN_PORT PORTC
     45          #define BOOT_PIN_GPIO GPIOC
     46          #define BOOT_PIN_ALT_MODE 1
     47          #endif
     48          
     49          #ifdef FREEDOM
     50          #define BOOT_PIN_NUMBER 17
     51          #define BOOT_PIN_PORT PORTB
     52          #define BOOT_PIN_GPIO GPIOB
     53          #define BOOT_PIN_ALT_MODE 1
     54          #endif
     55          
     56          #define BOOT_PIN_DEBOUNCE_READ_COUNT 500
     57          
     58          ////////////////////////////////////////////////////////////////////////////////
     59          // Variables
     60          ////////////////////////////////////////////////////////////////////////////////
     61          
     62          ////////////////////////////////////////////////////////////////////////////////
     63          // Code
     64          ////////////////////////////////////////////////////////////////////////////////
     65          

   \                                 In section .text, align 2, keep-with-next
     66          void init_hardware(void)
     67          {
   \                     init_hardware: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     68              exit_vlpr();
   \   00000002   0x.... 0x....      BL       exit_vlpr
     69          
     70              // Enable all the ports
     71              SIM->SCGC5 |= (SIM_SCGC5_PORTA_MASK | SIM_SCGC5_PORTB_MASK | SIM_SCGC5_PORTC_MASK | SIM_SCGC5_PORTD_MASK |
     72                             SIM_SCGC5_PORTE_MASK);
   \   00000006   0x....             LDR.N    R0,??DataTable5  ;; 0x40048004
   \   00000008   0x6B41             LDR      R1,[R0, #+52]
   \   0000000A   0xF441 0x5178      ORR      R1,R1,#0x3E00
   \   0000000E   0x6341             STR      R1,[R0, #+52]
     73          
     74              SIM->SOPT2 |= SIM_SOPT2_PLLFLLSEL_MASK; // set PLLFLLSEL to select the IRC48M for this clock source
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0xF441 0x3140      ORR      R1,R1,#0x30000
   \   00000016   0x6001             STR      R1,[R0, #+0]
     75          }
   \   00000018   0xBD01             POP      {R0,PC}          ;; return
     76          

   \                                 In section .text, align 2, keep-with-next
     77          void deinit_hardware(void)
     78          {
     79              SIM->SCGC5 &= (uint32_t) ~(SIM_SCGC5_PORTA_MASK | SIM_SCGC5_PORTB_MASK | SIM_SCGC5_PORTC_MASK |
     80                                         SIM_SCGC5_PORTD_MASK | SIM_SCGC5_PORTE_MASK);
   \                     deinit_hardware: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable5  ;; 0x40048004
   \   00000002   0x6B41             LDR      R1,[R0, #+52]
   \   00000004   0xF421 0x5178      BIC      R1,R1,#0x3E00
   \   00000008   0x6341             STR      R1,[R0, #+52]
     81          
     82              // Restore SIM_SOPTx related bits being changed
     83              SIM->SOPT2 &= (uint32_t) ~(SIM_SOPT2_USBSRC_MASK | SIM_SOPT2_PLLFLLSEL_MASK);
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0xF421 0x21E0      BIC      R1,R1,#0x70000
   \   00000010   0x6001             STR      R1,[R0, #+0]
     84          }
   \   00000012   0x4770             BX       LR               ;; return
     85          
     86          // Note: Keep this function here to ensure compatibility, all usb related clock
     87          // configuration is maintained by USB stack itself.

   \                                 In section .text, align 2, keep-with-next
     88          bool usb_clock_init(void)
     89          {
     90              // Enable USB-OTG IP clocking
     91              SIM->SCGC4 |= (SIM_SCGC4_USBOTG_MASK);
   \                     usb_clock_init: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable5  ;; 0x40048004
   \   00000002   0x6B01             LDR      R1,[R0, #+48]
   \   00000004   0xF441 0x2180      ORR      R1,R1,#0x40000
   \   00000008   0x6301             STR      R1,[R0, #+48]
     92          
     93              // If clock of usb module cannot be enabled, return false
     94              if (!(SIM->SCGC4 & SIM_SCGC4_USBOTG_MASK))
   \   0000000A   0x6B01             LDR      R1,[R0, #+48]
   \   0000000C   0x0349             LSLS     R1,R1,#+13
   \   0000000E   0xD401             BMI.N    ??usb_clock_init_0
     95              {
     96                  return false;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR
     97              }
     98          
     99              // Reset the USB peripheral, this must be done here instead of USB driver due to silicon errata
    100              // for at least KL25 and K22
    101              USB0->USBTRC0 |= USB_USBTRC0_USBRESET_MASK;
   \                     ??usb_clock_init_0: (+1)
   \   00000014   0x....             LDR.N    R1,??DataTable5_1  ;; 0x4007210c
   \   00000016   0x780A             LDRB     R2,[R1, #+0]
   \   00000018   0xF042 0x0280      ORR      R2,R2,#0x80
   \   0000001C   0x700A             STRB     R2,[R1, #+0]
    102              while (USB0->USBTRC0 & USB_USBTRC0_USBRESET_MASK)
   \                     ??usb_clock_init_1: (+1)
   \   0000001E   0x780A             LDRB     R2,[R1, #+0]
   \   00000020   0x0612             LSLS     R2,R2,#+24
   \   00000022   0xD4FC             BMI.N    ??usb_clock_init_1
    103                  ;
    104          
    105              // Select IRC48M clock, SIM_SOPT2_USBSRC_MASK selects internal clock,
    106              // 0x30000 = SIM_SOPT2_PLLFLLSEL_MASK, selects IRC48MHz clock
    107              SIM->SOPT2 |= (SIM_SOPT2_USBSRC_MASK | SIM_SOPT2_PLLFLLSEL_MASK);
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0xF441 0x21E0      ORR      R1,R1,#0x70000
   \   0000002A   0x6001             STR      R1,[R0, #+0]
    108          
    109              // need to set the clock_recover_en and irc_en register
    110              USB0->CLK_RECOVER_CTRL |= USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_MASK;
   \   0000002C   0x....             LDR.N    R0,??DataTable5_2  ;; 0x40072140
   \   0000002E   0x7801             LDRB     R1,[R0, #+0]
   \   00000030   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000034   0x7001             STRB     R1,[R0, #+0]
    111              USB0->CLK_RECOVER_IRC_EN |= USB_CLK_RECOVER_IRC_EN_IRC_EN_MASK;
   \   00000036   0x7901             LDRB     R1,[R0, #+4]
   \   00000038   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000003C   0x7101             STRB     R1,[R0, #+4]
    112          
    113              return true;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x4770             BX       LR               ;; return
    114          }
    115          

   \                                 In section .text, align 2, keep-with-next
    116          uint32_t get_bus_clock(void)
    117          {
    118              uint32_t busClockDivider = ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> SIM_CLKDIV1_OUTDIV2_SHIFT) + 1;
   \                     get_bus_clock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable5_3  ;; 0x40048044
    119              return (SystemCoreClock / busClockDivider);
   \   00000002   0x....             LDR.N    R1,??DataTable5_4
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0xF3C0 0x6003      UBFX     R0,R0,#+24,#+4
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   \   0000000E   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \   00000012   0x4770             BX       LR               ;; return
    120          }
    121          

   \                                 In section .text, align 2, keep-with-next
    122          uint32_t get_uart_clock(uint32_t instance)
    123          {
    124              switch (instance)
   \                     get_uart_clock: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xBF9A             ITTE     LS 
   \   00000004   0x....             LDRLS.N  R0,??DataTable5_4
   \   00000006   0x6800             LDRLS    R0,[R0, #+0]
   \   00000008   0x2000             MOVHI    R0,#+0
    125              {
    126                  case 0:
    127                  case 1:
    128                      // UART0 and UART1 always use the system clock
    129                      return SystemCoreClock;
    130                  case 2:
    131                  case 3:
    132                  case 4:
    133                  case 5:
    134                  default:
    135                      return 0;
   \   0000000A   0x4770             BX       LR
    136              }
    137          }
    138          

   \                                 In section .text, align 2, keep-with-next
    139          bool is_boot_pin_asserted(void)
    140          {
    141          #ifdef BL_TARGET_FLASH
    142              // Initialize boot pin for GPIO
    143              BOOT_PIN_PORT->PCR[BOOT_PIN_NUMBER] |= PORT_PCR_MUX(BOOT_PIN_ALT_MODE);
   \                     is_boot_pin_asserted: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable5_5  ;; 0x4004a044
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000008   0x6001             STR      R1,[R0, #+0]
    144          
    145              // Set boot pin as an input
    146              BOOT_PIN_GPIO->PDDR &= (uint32_t) ~(1 << BOOT_PIN_NUMBER);
   \   0000000A   0x....             LDR.N    R1,??DataTable5_6  ;; 0x400ff050
   \   0000000C   0x684A             LDR      R2,[R1, #+4]
   \   0000000E   0xF422 0x3200      BIC      R2,R2,#0x20000
   \   00000012   0x604A             STR      R2,[R1, #+4]
    147              // Set boot pin pullup enabled, pullup select, filter enable
    148              BOOT_PIN_PORT->PCR[BOOT_PIN_NUMBER] |= (PORT_PCR_PE_MASK | PORT_PCR_PS_MASK | PORT_PCR_PFE_MASK);
   \   00000014   0x6802             LDR      R2,[R0, #+0]
   \   00000016   0xF042 0x0213      ORR      R2,R2,#0x13
   \   0000001A   0x6002             STR      R2,[R0, #+0]
    149          
    150              uint32_t readCount = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
    151          
    152              // Sample the pin a number of times
    153              for (uint32_t i = 0; i < BOOT_PIN_DEBOUNCE_READ_COUNT; i++)
   \   0000001E   0xF44F 0x72FA      MOV      R2,#+500
    154              {
    155                  readCount += ((BOOT_PIN_GPIO->PDIR) >> BOOT_PIN_NUMBER) & 1;
   \                     ??is_boot_pin_asserted_0: (+1)
   \   00000022   0x680B             LDR      R3,[R1, #+0]
   \   00000024   0xF3C3 0x4340      UBFX     R3,R3,#+17,#+1
   \   00000028   0x1818             ADDS     R0,R3,R0
    156              }
   \   0000002A   0x1E52             SUBS     R2,R2,#+1
   \   0000002C   0xD1F9             BNE.N    ??is_boot_pin_asserted_0
    157          
    158              // boot pin is pulled high so we are measuring lows, make sure most of our measurements
    159              // registered as low
    160              return (readCount < (BOOT_PIN_DEBOUNCE_READ_COUNT / 2));
   \   0000002E   0x28FA             CMP      R0,#+250
   \   00000030   0x4180             SBCS     R0,R0,R0
   \   00000032   0x0FC0             LSRS     R0,R0,#+31
   \   00000034   0x4770             BX       LR               ;; return
    161          #else
    162              // Boot pin for Flash only target
    163              return false;
    164          #endif
    165          }
    166          

   \                                 In section .text, align 2, keep-with-next
    167          void debug_init(void)
    168          {
    169          }
   \                     debug_init: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    170          
    171          #if __ICCARM__
    172          

   \                                 In section .text, align 2, keep-with-next
    173          size_t __write(int handle, const unsigned char *buf, size_t size)
    174          {
    175              return size;
   \                     __write: (+1)
   \   00000000   0x4610             MOV      R0,R2
   \   00000002   0x4770             BX       LR               ;; return
    176          }
    177          
    178          #endif // __ICCARM__
    179          

   \                                 In section .text, align 2, keep-with-next
    180          void update_available_peripherals()
    181          {
    182          }
   \                     update_available_peripherals: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x40048004         DC32     0x40048004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x4007210C         DC32     0x4007210c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x40072140         DC32     0x40072140

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x40048044         DC32     0x40048044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x4004A044         DC32     0x4004a044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x400FF050         DC32     0x400ff050
    183          
    184          ////////////////////////////////////////////////////////////////////////////////
    185          // EOF
    186          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   __write
       0   debug_init
       0   deinit_hardware
       0   get_bus_clock
       0   get_uart_clock
       8   init_hardware
         8   -> exit_vlpr
       0   is_boot_pin_asserted
       0   update_available_peripherals
       0   usb_clock_init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  __write
       2  debug_init
      20  deinit_hardware
      20  get_bus_clock
      12  get_uart_clock
      26  init_hardware
      54  is_boot_pin_asserted
       2  update_available_peripherals
      66  usb_clock_init

 
 234 bytes in section .text
 
 234 bytes of CODE memory

Errors: none
Warnings: none
