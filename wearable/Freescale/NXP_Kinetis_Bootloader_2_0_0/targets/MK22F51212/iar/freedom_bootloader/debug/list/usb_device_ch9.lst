###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Aug/2016  15:48:59
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\usb_device_ch9.c
#    Command line =  
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\usb_device_ch9.c"
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN512VDC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -lC
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\obj"
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform/devices/MK22F51212\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/autobaud\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/osa\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/device\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/usb/device/class\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/bm_usb\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform/devices\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader/../../../../src/drivers/common\"
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\list\usb_device_ch9.lst
#    Object file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F51212\iar\freedom_bootloader\debug\obj\usb_device_ch9.o
#
###############################################################################

C:\Users\cwati\Documents\My Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\usb_device_ch9.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "usb_device_config.h"
     32          #include "usb.h"
     33          
     34          #include "usb_device.h"
     35          #include "usb_device_dci.h"
     36          #include "usb_device_class.h"
     37          #include "usb_device_ch9.h"
     38          #if ((defined(USB_DEVICE_CONFIG_NUM)) && (USB_DEVICE_CONFIG_NUM > 0U))
     39          /*******************************************************************************
     40           * Definitions
     41           ******************************************************************************/
     42          
     43          /*!
     44           * @brief Standard request callback function typedef.
     45           *
     46           * This function is used to handle the standard request.
     47           *
     48           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
     49           * @param setup           The pointer of the setup packet.
     50           * @param buffer          It is an out parameter, is used to save the buffer address to response the host's request.
     51           * @param length          It is an out parameter, the data length.
     52           *
     53           * @return A USB error code or kStatus_USB_Success.
     54           */
     55          typedef usb_status_t (*usb_standard_request_callback_t)(usb_device_common_class_struct_t *classHandle,
     56                                                                  usb_setup_struct_t *setup,
     57                                                                  uint8_t **buffer,
     58                                                                  uint32_t *length);
     59          
     60          /*******************************************************************************
     61           * Prototypes
     62           ******************************************************************************/
     63          
     64          static usb_status_t USB_DeviceCh9GetStatus(usb_device_common_class_struct_t *classHandle,
     65                                                     usb_setup_struct_t *setup,
     66                                                     uint8_t **buffer,
     67                                                     uint32_t *length);
     68          static usb_status_t USB_DeviceCh9SetClearFeature(usb_device_common_class_struct_t *classHandle,
     69                                                           usb_setup_struct_t *setup,
     70                                                           uint8_t **buffer,
     71                                                           uint32_t *length);
     72          
     73          static usb_status_t USB_DeviceCh9SetAddress(usb_device_common_class_struct_t *classHandle,
     74                                                      usb_setup_struct_t *setup,
     75                                                      uint8_t **buffer,
     76                                                      uint32_t *length);
     77          static usb_status_t USB_DeviceCh9GetDescriptor(usb_device_common_class_struct_t *classHandle,
     78                                                         usb_setup_struct_t *setup,
     79                                                         uint8_t **buffer,
     80                                                         uint32_t *length);
     81          static usb_status_t USB_DeviceCh9GetConfiguration(usb_device_common_class_struct_t *classHandle,
     82                                                            usb_setup_struct_t *setup,
     83                                                            uint8_t **buffer,
     84                                                            uint32_t *length);
     85          static usb_status_t USB_DeviceCh9SetConfiguration(usb_device_common_class_struct_t *classHandle,
     86                                                            usb_setup_struct_t *setup,
     87                                                            uint8_t **buffer,
     88                                                            uint32_t *length);
     89          static usb_status_t USB_DeviceCh9GetInterface(usb_device_common_class_struct_t *classHandle,
     90                                                        usb_setup_struct_t *setup,
     91                                                        uint8_t **buffer,
     92                                                        uint32_t *length);
     93          static usb_status_t USB_DeviceCh9SetInterface(usb_device_common_class_struct_t *classHandle,
     94                                                        usb_setup_struct_t *setup,
     95                                                        uint8_t **buffer,
     96                                                        uint32_t *length);
     97          static usb_status_t USB_DeviceCh9SynchFrame(usb_device_common_class_struct_t *classHandle,
     98                                                      usb_setup_struct_t *setup,
     99                                                      uint8_t **buffer,
    100                                                      uint32_t *length);
    101          
    102          /*******************************************************************************
    103           * Variables
    104           ******************************************************************************/
    105          
    106          /* The function list to handle the standard request. */

   \                                 In section .text, align 4, keep-with-next
    107          static const usb_standard_request_callback_t s_UsbDeviceStandardRequest[] = {
   \                     s_UsbDeviceStandardRequest:
   \   00000000   0x........         DC32 USB_DeviceCh9GetStatus, USB_DeviceCh9SetClearFeature, 0H
   \              0x........   
   \              0x00000000   
   \   0000000C   0x........         DC32 USB_DeviceCh9SetClearFeature, 0H, USB_DeviceCh9SetAddress
   \              0x00000000   
   \              0x........   
   \   00000018   0x........         DC32 USB_DeviceCh9GetDescriptor, 0H, USB_DeviceCh9GetConfiguration
   \              0x00000000   
   \              0x........   
   \   00000024   0x........         DC32 USB_DeviceCh9SetConfiguration, USB_DeviceCh9GetInterface
   \              0x........   
   \   0000002C   0x........         DC32 USB_DeviceCh9SetInterface, USB_DeviceCh9SynchFrame
   \              0x........   
    108              USB_DeviceCh9GetStatus,
    109              USB_DeviceCh9SetClearFeature,
    110              (usb_standard_request_callback_t)NULL,
    111              USB_DeviceCh9SetClearFeature,
    112              (usb_standard_request_callback_t)NULL,
    113              USB_DeviceCh9SetAddress,
    114              USB_DeviceCh9GetDescriptor,
    115              (usb_standard_request_callback_t)NULL,
    116              USB_DeviceCh9GetConfiguration,
    117              USB_DeviceCh9SetConfiguration,
    118              USB_DeviceCh9GetInterface,
    119              USB_DeviceCh9SetInterface,
    120              USB_DeviceCh9SynchFrame,
    121          };
    122          
    123          /*******************************************************************************
    124           * Code
    125           ******************************************************************************/
    126          
    127          /*!
    128           * @brief Handle get status request.
    129           *
    130           * This function is used to handle get status request.
    131           *
    132           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    133           * @param setup           The pointer of the setup packet.
    134           * @param buffer          It is an out parameter, is used to save the buffer address to response the host's request.
    135           * @param length          It is an out parameter, the data length.
    136           *
    137           * @retval kStatus_USB_Success              The requst is handled successfully.
    138           * @retval kStatus_USB_InvalidRequest       The request can not be handle in current device state,
    139           *                                          or, the request is unsupported.
    140           */

   \                                 In section .text, align 2, keep-with-next
    141          static usb_status_t USB_DeviceCh9GetStatus(usb_device_common_class_struct_t *classHandle,
    142                                                     usb_setup_struct_t *setup,
    143                                                     uint8_t **buffer,
    144                                                     uint32_t *length)
    145          {
   \                     USB_DeviceCh9GetStatus: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4690             MOV      R8,R2
    146              usb_status_t error = kStatus_USB_InvalidRequest;
    147              uint8_t state;
    148          
    149              USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x461E             MOV      R6,R3
   \   0000000E   0xAA01             ADD      R2,SP,#+4
   \   00000010   0x2106             MOVS     R1,#+6
   \   00000012   0x.... 0x....      BL       USB_DeviceGetStatus
    150          
    151              if ((kUSB_DeviceStateAddress != state) && (kUSB_DeviceStateConfigured != state))
   \   00000016   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000001A   0x2505             MOVS     R5,#+5
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xBF18             IT       NE 
   \   00000020   0x2800             CMPNE    R0,#+0
   \   00000022   0xD12E             BNE.N    ??USB_DeviceCh9GetStatus_0
    152              {
    153                  return error;
    154              }
    155          
    156              if ((setup->bmRequestType & USB_REQUEST_TYPE_RECIPIENT_MASK) == USB_REQUEST_TYPE_RECIPIENT_DEVICE)
   \   00000024   0x7838             LDRB     R0,[R7, #+0]
   \   00000026   0x211F             MOVS     R1,#+31
   \   00000028   0x4208             TST      R0,R1
   \   0000002A   0xD108             BNE.N    ??USB_DeviceCh9GetStatus_1
    157              {
    158                  /* Get the device status */
    159                  error =
    160                      USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusDevice, &classHandle->standardTranscationBuffer);
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0xF104 0x0210      ADD      R2,R4,#+16
   \   00000032   0x2104             MOVS     R1,#+4
   \   00000034   0x.... 0x....      BL       USB_DeviceGetStatus
   \   00000038   0x4605             MOV      R5,R0
    161                  classHandle->standardTranscationBuffer = classHandle->standardTranscationBuffer & USB_GET_STATUS_DEVICE_MASK;
    162                  classHandle->standardTranscationBuffer = USB_SHORT_TO_LITTLE_ENDIAN(classHandle->standardTranscationBuffer);
   \   0000003A   0x7C20             LDRB     R0,[R4, #+16]
   \   0000003C   0xE018             B.N      ??USB_DeviceCh9GetStatus_2
    163                  /* The device status length must be USB_DEVICE_STATUS_SIZE. */
    164                  *length = USB_DEVICE_STATUS_SIZE;
    165              }
    166              else if ((setup->bmRequestType & USB_REQUEST_TYPE_RECIPIENT_MASK) == USB_REQUEST_TYPE_RECIPIENT_INTERFACE)
   \                     ??USB_DeviceCh9GetStatus_1: (+1)
   \   0000003E   0xF000 0x011F      AND      R1,R0,#0x1F
   \   00000042   0x2901             CMP      R1,#+1
   \   00000044   0xD102             BNE.N    ??USB_DeviceCh9GetStatus_3
    167              {
    168                  /* Get the interface status */
    169                  error = kStatus_USB_Success;
   \   00000046   0x2500             MOVS     R5,#+0
    170                  classHandle->standardTranscationBuffer = 0U;
   \   00000048   0x8225             STRH     R5,[R4, #+16]
    171                  /* The interface status length must be USB_INTERFACE_STATUS_SIZE. */
    172                  *length = USB_INTERFACE_STATUS_SIZE;
   \   0000004A   0xE014             B.N      ??USB_DeviceCh9GetStatus_4
    173              }
    174              else if ((setup->bmRequestType & USB_REQUEST_TYPE_RECIPIENT_MASK) == USB_REQUEST_TYPE_RECIPIENT_ENDPOINT)
   \                     ??USB_DeviceCh9GetStatus_3: (+1)
   \   0000004C   0xF000 0x001F      AND      R0,R0,#0x1F
   \   00000050   0x2802             CMP      R0,#+2
   \   00000052   0xD112             BNE.N    ??USB_DeviceCh9GetStatus_5
    175              {
    176                  /* Get the endpoint status */
    177                  usb_device_endpoint_status_struct_t endpointStatus;
    178                  endpointStatus.endpointAddress = (uint8_t)setup->wIndex;
   \   00000054   0x88B8             LDRH     R0,[R7, #+4]
   \   00000056   0xF88D 0x0000      STRB     R0,[SP, #+0]
    179                  endpointStatus.endpointStatus = kUSB_DeviceEndpointStateIdle;
    180                  error = USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusEndpoint, &endpointStatus);
   \   0000005A   0x466A             MOV      R2,SP
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   \   00000062   0x2105             MOVS     R1,#+5
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x.... 0x....      BL       USB_DeviceGetStatus
   \   0000006A   0x4605             MOV      R5,R0
    181                  classHandle->standardTranscationBuffer = endpointStatus.endpointStatus & USB_GET_STATUS_ENDPOINT_MASK;
    182                  classHandle->standardTranscationBuffer = USB_SHORT_TO_LITTLE_ENDIAN(classHandle->standardTranscationBuffer);
   \   0000006C   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \                     ??USB_DeviceCh9GetStatus_2: (+1)
   \   00000070   0xF000 0x0003      AND      R0,R0,#0x3
   \   00000074   0x8220             STRH     R0,[R4, #+16]
    183                  /* The endpoint status length must be USB_INTERFACE_STATUS_SIZE. */
    184                  *length = USB_ENDPOINT_STATUS_SIZE;
   \                     ??USB_DeviceCh9GetStatus_4: (+1)
   \   00000076   0x2002             MOVS     R0,#+2
   \   00000078   0x6030             STR      R0,[R6, #+0]
    185              }
    186              else
    187              {
    188              }
    189              *buffer = (uint8_t *)&classHandle->standardTranscationBuffer;
   \                     ??USB_DeviceCh9GetStatus_5: (+1)
   \   0000007A   0xF104 0x0010      ADD      R0,R4,#+16
   \   0000007E   0xF8C8 0x0000      STR      R0,[R8, #+0]
    190          
    191              return error;
   \                     ??USB_DeviceCh9GetStatus_0: (+1)
   \   00000082   0x4628             MOV      R0,R5
   \   00000084   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    192          }
    193          
    194          /*!
    195           * @brief Handle set or clear device feature request.
    196           *
    197           * This function is used to handle set or clear device feature request.
    198           *
    199           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    200           * @param setup           The pointer of the setup packet.
    201           * @param buffer          It is an out parameter, is used to save the buffer address to response the host's request.
    202           * @param length          It is an out parameter, the data length.
    203           *
    204           * @retval kStatus_USB_Success              The requst is handled successfully.
    205           * @retval kStatus_USB_InvalidRequest       The request can not be handle in current device state,
    206           *                                          or, the request is unsupported.
    207           */

   \                                 In section .text, align 2, keep-with-next
    208          static usb_status_t USB_DeviceCh9SetClearFeature(usb_device_common_class_struct_t *classHandle,
    209                                                           usb_setup_struct_t *setup,
    210                                                           uint8_t **buffer,
    211                                                           uint32_t *length)
    212          {
   \                     USB_DeviceCh9SetClearFeature: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4605             MOV      R5,R0
    213              usb_status_t error = kStatus_USB_InvalidRequest;
    214              uint8_t state;
    215              uint8_t isSet = 0U;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000000C   0x460C             MOV      R4,R1
    216          
    217              USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
   \   0000000E   0x6828             LDR      R0,[R5, #+0]
   \   00000010   0xF10D 0x0201      ADD      R2,SP,#+1
   \   00000014   0x2106             MOVS     R1,#+6
   \   00000016   0x.... 0x....      BL       USB_DeviceGetStatus
    218          
    219              if ((kUSB_DeviceStateAddress != state) && (kUSB_DeviceStateConfigured != state))
   \   0000001A   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000001E   0x2605             MOVS     R6,#+5
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xBF18             IT       NE 
   \   00000024   0x2800             CMPNE    R0,#+0
   \   00000026   0xD001             BEQ.N    ??USB_DeviceCh9SetClearFeature_0
    220              {
    221                  return error;
   \   00000028   0x2005             MOVS     R0,#+5
   \   0000002A   0xBD76             POP      {R1,R2,R4-R6,PC}
    222              }
    223          
    224              /* Identify the request is set or clear the feature. */
    225              if (USB_REQUSET_STANDARD_SET_FEATURE == setup->bRequest)
   \                     ??USB_DeviceCh9SetClearFeature_0: (+1)
   \   0000002C   0x7860             LDRB     R0,[R4, #+1]
   \   0000002E   0x2803             CMP      R0,#+3
   \   00000030   0xBF04             ITT      EQ 
   \   00000032   0x2001             MOVEQ    R0,#+1
   \   00000034   0xF88D 0x0000      STRBEQ   R0,[SP, #+0]
    226              {
    227                  isSet = 1U;
    228              }
    229          
    230              if ((setup->bmRequestType & USB_REQUEST_TYPE_RECIPIENT_MASK) == USB_REQUEST_TYPE_RECIPIENT_DEVICE)
   \   00000038   0x7820             LDRB     R0,[R4, #+0]
   \   0000003A   0x211F             MOVS     R1,#+31
   \   0000003C   0x4208             TST      R0,R1
   \   0000003E   0xD108             BNE.N    ??USB_DeviceCh9SetClearFeature_1
    231              {
    232                  /* Set or Clear the device featrue. */
    233                  if (USB_REQUSET_STANDARD_FEATURE_SELECTOR_DEVICE_REMOTE_WAKEUP == setup->wValue)
   \   00000040   0x8860             LDRH     R0,[R4, #+2]
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xD12B             BNE.N    ??USB_DeviceCh9SetClearFeature_2
    234                  {
    235                      /* Set or Clear the device remote wakeup featrue. */
    236                      error = USB_DeviceClassCallback(classHandle->handle, kUSB_DeviceEventSetRemoteWakeup, &isSet);
   \   00000046   0x6828             LDR      R0,[R5, #+0]
   \   00000048   0x466A             MOV      R2,SP
   \   0000004A   0x2110             MOVS     R1,#+16
   \   0000004C   0x.... 0x....      BL       USB_DeviceClassCallback
   \   00000050   0xE024             B.N      ??USB_DeviceCh9SetClearFeature_3
    237                  }
    238          #if (defined(USB_DEVICE_CONFIG_EHCI) && (USB_DEVICE_CONFIG_EHCI > 0U)) && \
    239              (defined(USB_DEVICE_CONFIG_EHCI_TEST_MODE) && (USB_DEVICE_CONFIG_EHCI_TEST_MODE > 0U))
    240                  else if (USB_REQUSET_STANDARD_FEATURE_SELECTOR_DEVICE_TEST_MODE == setup->wValue)
    241                  {
    242                      state = kUSB_DeviceStateTestMode;
    243                      error = USB_DeviceSetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
    244                  }
    245          #endif
    246                  else
    247                  {
    248                  }
    249              }
    250              else if ((setup->bmRequestType & USB_REQUEST_TYPE_RECIPIENT_MASK) == USB_REQUEST_TYPE_RECIPIENT_ENDPOINT)
   \                     ??USB_DeviceCh9SetClearFeature_1: (+1)
   \   00000052   0xF000 0x001F      AND      R0,R0,#0x1F
   \   00000056   0x2802             CMP      R0,#+2
   \   00000058   0xBF04             ITT      EQ 
   \   0000005A   0x8860             LDRHEQ   R0,[R4, #+2]
   \   0000005C   0x2800             CMPEQ    R0,#+0
    251              {
    252                  /* Set or Clear the endpoint featrue. */
    253                  if (USB_REQUSET_STANDARD_FEATURE_SELECTOR_ENDPOINT_HALT == setup->wValue)
   \   0000005E   0xD11E             BNE.N    ??USB_DeviceCh9SetClearFeature_2
    254                  {
    255                      if (USB_CONTROL_ENDPOINT == (setup->wIndex & USB_ENDPOINT_NUMBER_MASK))
   \   00000060   0x88A0             LDRH     R0,[R4, #+4]
   \   00000062   0x210F             MOVS     R1,#+15
   \   00000064   0x4208             TST      R0,R1
   \   00000066   0xD10E             BNE.N    ??USB_DeviceCh9SetClearFeature_4
    256                      {
    257                          /* Set or Clear the control endpoint status(halt or not). */
    258                          if (isSet)
   \   00000068   0xF000 0x010F      AND      R1,R0,#0xF
   \   0000006C   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000070   0xEA41 0x11D0      ORR      R1,R1,R0, LSR #+7
   \   00000074   0x6828             LDR      R0,[R5, #+0]
   \   00000076   0x2A00             CMP      R2,#+0
   \   00000078   0xB2C9             UXTB     R1,R1
   \   0000007A   0xD002             BEQ.N    ??USB_DeviceCh9SetClearFeature_5
    259                          {
    260                              USB_DeviceStallEndpoint(
    261                                  classHandle->handle,
    262                                  (setup->wIndex & USB_ENDPOINT_NUMBER_MASK) |
    263                                      (uint8_t)(setup->wIndex >> USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT));
   \   0000007C   0x.... 0x....      BL       USB_DeviceStallEndpoint
   \   00000080   0xE001             B.N      ??USB_DeviceCh9SetClearFeature_4
    264                          }
    265                          else
    266                          {
    267                              USB_DeviceUnstallEndpoint(
    268                                  classHandle->handle,
    269                                  (setup->wIndex & USB_ENDPOINT_NUMBER_MASK) |
    270                                      (uint8_t)(setup->wIndex >> USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT));
   \                     ??USB_DeviceCh9SetClearFeature_5: (+1)
   \   00000082   0x.... 0x....      BL       USB_DeviceUnstallEndpoint
    271                          }
    272                      }
    273          
    274                      /* Set or Clear the endpoint status featrue. */
    275                      if (isSet)
   \                     ??USB_DeviceCh9SetClearFeature_4: (+1)
   \   00000086   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000008A   0x6828             LDR      R0,[R5, #+0]
   \   0000008C   0x2900             CMP      R1,#+0
   \   0000008E   0xBF19             ITTEE    NE 
   \   00000090   0x1D22             ADDNE    R2,R4,#+4
   \   00000092   0x2105             MOVNE    R1,#+5
   \   00000094   0x1D22             ADDEQ    R2,R4,#+4
   \   00000096   0x2106             MOVEQ    R1,#+6
    276                      {
    277                          error = USB_DeviceClassEvent(classHandle->handle, kUSB_DeviceClassEventSetEndpointHalt, &setup->wIndex);
    278                      }
    279                      else
    280                      {
    281                          error =
    282                              USB_DeviceClassEvent(classHandle->handle, kUSB_DeviceClassEventClearEndpointHalt, &setup->wIndex);
   \   00000098   0x.... 0x....      BL       USB_DeviceClassEvent
   \                     ??USB_DeviceCh9SetClearFeature_3: (+1)
   \   0000009C   0x4606             MOV      R6,R0
    283                      }
    284                  }
    285                  else
    286                  {
    287                  }
    288              }
    289              else
    290              {
    291              }
    292          
    293              return error;
   \                     ??USB_DeviceCh9SetClearFeature_2: (+1)
   \   0000009E   0x4630             MOV      R0,R6
   \   000000A0   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    294          }
    295          
    296          /*!
    297           * @brief Handle set address request.
    298           *
    299           * This function is used to handle set address request.
    300           *
    301           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    302           * @param setup           The pointer of the setup packet.
    303           * @param buffer          It is an out parameter, is used to save the buffer address to response the host's request.
    304           * @param length          It is an out parameter, the data length.
    305           *
    306           * @retval kStatus_USB_Success              The requst is handled successfully.
    307           * @retval kStatus_USB_InvalidRequest       The request can not be handle in current device state.
    308           */

   \                                 In section .text, align 2, keep-with-next
    309          static usb_status_t USB_DeviceCh9SetAddress(usb_device_common_class_struct_t *classHandle,
    310                                                      usb_setup_struct_t *setup,
    311                                                      uint8_t **buffer,
    312                                                      uint32_t *length)
    313          {
   \                     USB_DeviceCh9SetAddress: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine1
    314              usb_status_t error = kStatus_USB_InvalidRequest;
    315              uint8_t state;
    316          
    317              USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
    318          
    319              if ((kUSB_DeviceStateAddressing != state) && (kUSB_DeviceStateAddress != state) &&
    320                  (kUSB_DeviceStateDefault != state))
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000006   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000000A   0x2803             CMP      R0,#+3
   \   0000000C   0xD00B             BEQ.N    ??USB_DeviceCh9SetAddress_0
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xBF18             IT       NE 
   \   00000012   0x2802             CMPNE    R0,#+2
   \   00000014   0xD001             BEQ.N    ??USB_DeviceCh9SetAddress_1
    321              {
    322                  return error;
   \   00000016   0x2005             MOVS     R0,#+5
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}
    323              }
    324          
    325              if (kUSB_DeviceStateAddressing != state)
    326              {
    327                  /* If the device address is not setting, pass the address and the device state will change to
    328                   * kUSB_DeviceStateAddressing internally. */
    329                  state = setup->wValue & 0xFFU;
   \                     ??USB_DeviceCh9SetAddress_1: (+1)
   \   0000001A   0x8868             LDRH     R0,[R5, #+2]
   \   0000001C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    330                  error = USB_DeviceSetStatus(classHandle->handle, kUSB_DeviceStatusAddress, &state);
   \   00000020   0x466A             MOV      R2,SP
   \   00000022   0x2107             MOVS     R1,#+7
   \   00000024   0xE00B             B.N      ??USB_DeviceCh9SetAddress_2
    331              }
    332              else
    333              {
    334                  /* If the device address is setting, set device address and the address will be write into the controller
    335                   * internally. */
    336                  error = USB_DeviceSetStatus(classHandle->handle, kUSB_DeviceStatusAddress, NULL);
   \                     ??USB_DeviceCh9SetAddress_0: (+1)
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x2107             MOVS     R1,#+7
   \   0000002C   0x.... 0x....      BL       USB_DeviceSetStatus
    337                  /* And then change the device state to kUSB_DeviceStateAddress. */
    338                  if (kStatus_USB_Success == error)
   \   00000030   0x0001             MOVS     R1,R0
   \   00000032   0xD107             BNE.N    ??USB_DeviceCh9SetAddress_3
    339                  {
    340                      state = kUSB_DeviceStateAddress;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xF88D 0x0000      STRB     R0,[SP, #+0]
    341                      error = USB_DeviceSetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
   \   0000003A   0x466A             MOV      R2,SP
   \   0000003C   0x2106             MOVS     R1,#+6
   \                     ??USB_DeviceCh9SetAddress_2: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x.... 0x....      BL       USB_DeviceSetStatus
    342                  }
    343              }
    344          
    345              return error;
   \                     ??USB_DeviceCh9SetAddress_3: (+1)
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    346          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x466A             MOV      R2,SP
   \   00000008   0x2106             MOVS     R1,#+6
   \   0000000A   0x.... 0x....      B.W      USB_DeviceGetStatus
    347          
    348          /*!
    349           * @brief Handle get descriptor request.
    350           *
    351           * This function is used to handle get descriptor request.
    352           *
    353           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    354           * @param setup           The pointer of the setup packet.
    355           * @param buffer          It is an out parameter, is used to save the buffer address to response the host's request.
    356           * @param length          It is an out parameter, the data length.
    357           *
    358           * @retval kStatus_USB_Success              The requst is handled successfully.
    359           * @retval kStatus_USB_InvalidRequest       The request can not be handle in current device state,
    360           *                                          or, the request is unsupported.
    361           */

   \                                 In section .text, align 2, keep-with-next
    362          static usb_status_t USB_DeviceCh9GetDescriptor(usb_device_common_class_struct_t *classHandle,
    363                                                         usb_setup_struct_t *setup,
    364                                                         uint8_t **buffer,
    365                                                         uint32_t *length)
    366          {
   \                     USB_DeviceCh9GetDescriptor: (+1)
   \   00000000   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x4690             MOV      R8,R2
    367              usb_device_get_descriptor_common_union_t commonDescriptor;
    368              usb_status_t error = kStatus_USB_InvalidRequest;
    369              uint8_t state;
    370              uint8_t descriptorType = (uint8_t)((setup->wValue & 0xFF00U) >> 8U);
    371              uint8_t descriptorIndex = (uint8_t)((setup->wValue & 0x00FFU));
    372          
    373              USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
   \   00000008   0x6830             LDR      R0,[R6, #+0]
   \   0000000A   0x460C             MOV      R4,R1
   \   0000000C   0x469A             MOV      R10,R3
   \   0000000E   0xAA03             ADD      R2,SP,#+12
   \   00000010   0x2106             MOVS     R1,#+6
   \   00000012   0x8867             LDRH     R7,[R4, #+2]
   \   00000014   0x.... 0x....      BL       USB_DeviceGetStatus
    374          
    375              if ((kUSB_DeviceStateAddress != state) && (kUSB_DeviceStateConfigured != state) &&
    376                  (kUSB_DeviceStateDefault != state))
   \   00000018   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   0000001C   0x0A3D             LSRS     R5,R7,#+8
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xF04F 0x0905      MOV      R9,#+5
   \   00000024   0xD003             BEQ.N    ??USB_DeviceCh9GetDescriptor_0
   \   00000026   0x0001             MOVS     R1,R0
   \   00000028   0xBF18             IT       NE 
   \   0000002A   0x2802             CMPNE    R0,#+2
   \   0000002C   0xD13A             BNE.N    ??USB_DeviceCh9GetDescriptor_1
    377              {
    378                  return error;
    379              }
    380              commonDescriptor.commonDescriptor.length = setup->wLength;
   \                     ??USB_DeviceCh9GetDescriptor_0: (+1)
   \   0000002E   0x88E0             LDRH     R0,[R4, #+6]
   \   00000030   0x9001             STR      R0,[SP, #+4]
    381              if (USB_DESCRIPTOR_TYPE_DEVICE == descriptorType)
   \   00000032   0x2D01             CMP      R5,#+1
   \   00000034   0xD102             BNE.N    ??USB_DeviceCh9GetDescriptor_2
    382              {
    383                  /* Get the device descriptor */
    384                  error = USB_DeviceClassCallback(classHandle->handle, kUSB_DeviceEventGetDeviceDescriptor,
    385                                                  &commonDescriptor.deviceDescriptor);
   \   00000036   0x466A             MOV      R2,SP
   \   00000038   0x2109             MOVS     R1,#+9
   \   0000003A   0xE029             B.N      ??USB_DeviceCh9GetDescriptor_3
    386              }
    387              else if (USB_DESCRIPTOR_TYPE_CONFIGURE == descriptorType)
   \                     ??USB_DeviceCh9GetDescriptor_2: (+1)
   \   0000003C   0x2D02             CMP      R5,#+2
   \   0000003E   0xD104             BNE.N    ??USB_DeviceCh9GetDescriptor_4
    388              {
    389                  /* Get the configuration descriptor */
    390                  commonDescriptor.configurationDescriptor.configuration = descriptorIndex;
   \   00000040   0xF88D 0x7008      STRB     R7,[SP, #+8]
    391                  error = USB_DeviceClassCallback(classHandle->handle, kUSB_DeviceEventGetConfigurationDescriptor,
    392                                                  &commonDescriptor.configurationDescriptor);
   \   00000044   0x466A             MOV      R2,SP
   \   00000046   0x210A             MOVS     R1,#+10
   \   00000048   0xE022             B.N      ??USB_DeviceCh9GetDescriptor_3
    393              }
    394              else if (USB_DESCRIPTOR_TYPE_STRING == descriptorType)
   \                     ??USB_DeviceCh9GetDescriptor_4: (+1)
   \   0000004A   0x2D03             CMP      R5,#+3
   \   0000004C   0xD107             BNE.N    ??USB_DeviceCh9GetDescriptor_5
    395              {
    396                  /* Get the string descriptor */
    397                  commonDescriptor.stringDescriptor.stringIndex = descriptorIndex;
   \   0000004E   0xF88D 0x700A      STRB     R7,[SP, #+10]
    398                  commonDescriptor.stringDescriptor.languageId = setup->wIndex;
    399                  error = USB_DeviceClassCallback(classHandle->handle, kUSB_DeviceEventGetStringDescriptor,
    400                                                  &commonDescriptor.stringDescriptor);
   \   00000052   0x466A             MOV      R2,SP
   \   00000054   0x88A0             LDRH     R0,[R4, #+4]
   \   00000056   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   \   0000005A   0x210B             MOVS     R1,#+11
   \   0000005C   0xE018             B.N      ??USB_DeviceCh9GetDescriptor_3
    401              }
    402          #if (defined(USB_DEVICE_CONFIG_HID) && (USB_DEVICE_CONFIG_HID > 0U))
    403              else if (USB_DESCRIPTOR_TYPE_HID == descriptorType)
   \                     ??USB_DeviceCh9GetDescriptor_5: (+1)
   \   0000005E   0x2D21             CMP      R5,#+33
   \   00000060   0xD105             BNE.N    ??USB_DeviceCh9GetDescriptor_6
    404              {
    405                  /* Get the hid descriptor */
    406                  commonDescriptor.hidDescriptor.interfaceNumber = setup->wIndex;
   \   00000062   0x88A0             LDRH     R0,[R4, #+4]
   \   00000064   0xF88D 0x0008      STRB     R0,[SP, #+8]
    407                  error = USB_DeviceClassCallback(classHandle->handle, kUSB_DeviceEventGetHidDescriptor,
    408                                                  &commonDescriptor.hidDescriptor);
   \   00000068   0x466A             MOV      R2,SP
   \   0000006A   0x210C             MOVS     R1,#+12
   \   0000006C   0xE010             B.N      ??USB_DeviceCh9GetDescriptor_3
    409              }
    410              else if (USB_DESCRIPTOR_TYPE_HID_REPORT == descriptorType)
   \                     ??USB_DeviceCh9GetDescriptor_6: (+1)
   \   0000006E   0x2D22             CMP      R5,#+34
   \   00000070   0xD105             BNE.N    ??USB_DeviceCh9GetDescriptor_7
    411              {
    412                  /* Get the hid report descriptor */
    413                  commonDescriptor.hidReportDescriptor.interfaceNumber = setup->wIndex;
   \   00000072   0x88A0             LDRH     R0,[R4, #+4]
   \   00000074   0xF88D 0x0008      STRB     R0,[SP, #+8]
    414                  error = USB_DeviceClassCallback(classHandle->handle, kUSB_DeviceEventGetHidReportDescriptor,
    415                                                  &commonDescriptor.hidReportDescriptor);
   \   00000078   0x466A             MOV      R2,SP
   \   0000007A   0x210D             MOVS     R1,#+13
   \   0000007C   0xE008             B.N      ??USB_DeviceCh9GetDescriptor_3
    416              }
    417              else if (USB_DESCRIPTOR_TYPE_HID_PHYSICAL == descriptorType)
   \                     ??USB_DeviceCh9GetDescriptor_7: (+1)
   \   0000007E   0x2D23             CMP      R5,#+35
   \   00000080   0xD10A             BNE.N    ??USB_DeviceCh9GetDescriptor_8
    418              {
    419                  /* Get the hid physical descriptor */
    420                  commonDescriptor.hidPhysicalDescriptor.index = descriptorIndex;
   \   00000082   0xF88D 0x7008      STRB     R7,[SP, #+8]
    421                  commonDescriptor.hidPhysicalDescriptor.interfaceNumber = setup->wIndex;
    422                  error = USB_DeviceClassCallback(classHandle->handle, kUSB_DeviceEventGetHidPhysicalDescriptor,
    423                                                  &commonDescriptor.hidPhysicalDescriptor);
   \   00000086   0x466A             MOV      R2,SP
   \   00000088   0x88A0             LDRH     R0,[R4, #+4]
   \   0000008A   0xF88D 0x0009      STRB     R0,[SP, #+9]
   \   0000008E   0x210E             MOVS     R1,#+14
   \                     ??USB_DeviceCh9GetDescriptor_3: (+1)
   \   00000090   0x6830             LDR      R0,[R6, #+0]
   \   00000092   0x.... 0x....      BL       USB_DeviceClassCallback
   \   00000096   0x4681             MOV      R9,R0
    424              }
    425          #endif
    426              else
    427              {
    428              }
    429              *buffer = commonDescriptor.commonDescriptor.buffer;
   \                     ??USB_DeviceCh9GetDescriptor_8: (+1)
   \   00000098   0x9800             LDR      R0,[SP, #+0]
   \   0000009A   0xF8C8 0x0000      STR      R0,[R8, #+0]
    430              *length = commonDescriptor.commonDescriptor.length;
   \   0000009E   0x9801             LDR      R0,[SP, #+4]
   \   000000A0   0xF8CA 0x0000      STR      R0,[R10, #+0]
    431              return error;
   \                     ??USB_DeviceCh9GetDescriptor_1: (+1)
   \   000000A4   0x4648             MOV      R0,R9
   \   000000A6   0xB004             ADD      SP,SP,#+16
   \   000000A8   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    432          }
    433          
    434          /*!
    435           * @brief Handle get current configuration request.
    436           *
    437           * This function is used to handle get current configuration request.
    438           *
    439           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    440           * @param setup           The pointer of the setup packet.
    441           * @param buffer          It is an out parameter, is used to save the buffer address to response the host's request.
    442           * @param length          It is an out parameter, the data length.
    443           *
    444           * @retval kStatus_USB_Success              The requst is handled successfully.
    445           * @retval kStatus_USB_InvalidRequest       The request can not be handle in current device state,
    446           *                                          or, the request is unsupported.
    447           */

   \                                 In section .text, align 2, keep-with-next
    448          static usb_status_t USB_DeviceCh9GetConfiguration(usb_device_common_class_struct_t *classHandle,
    449                                                            usb_setup_struct_t *setup,
    450                                                            uint8_t **buffer,
    451                                                            uint32_t *length)
    452          {
   \                     USB_DeviceCh9GetConfiguration: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4615             MOV      R5,R2
    453              uint8_t state;
    454          
    455              USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x461E             MOV      R6,R3
   \   0000000C   0x466A             MOV      R2,SP
   \   0000000E   0x2106             MOVS     R1,#+6
   \   00000010   0x.... 0x....      BL       USB_DeviceGetStatus
    456          
    457              if ((kUSB_DeviceStateAddress != state) && ((kUSB_DeviceStateConfigured != state)))
   \   00000014   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0x2800             CMPNE    R0,#+0
   \   0000001E   0xD001             BEQ.N    ??USB_DeviceCh9GetConfiguration_0
    458              {
    459                  return kStatus_USB_InvalidRequest;
   \   00000020   0x2005             MOVS     R0,#+5
   \   00000022   0xBD76             POP      {R1,R2,R4-R6,PC}
    460              }
    461          
    462              *length = USB_CONFIGURE_SIZE;
   \                     ??USB_DeviceCh9GetConfiguration_0: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x6030             STR      R0,[R6, #+0]
    463              *buffer = (uint8_t *)&classHandle->standardTranscationBuffer;
    464              return USB_DeviceClassCallback(classHandle->handle, kUSB_DeviceEventGetConfiguration,
    465                                             &classHandle->standardTranscationBuffer);
   \   00000028   0xF104 0x0210      ADD      R2,R4,#+16
   \   0000002C   0xF104 0x0010      ADD      R0,R4,#+16
   \   00000030   0x6028             STR      R0,[R5, #+0]
   \   00000032   0x2111             MOVS     R1,#+17
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       USB_DeviceClassCallback
   \   0000003A   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    466          }
    467          
    468          /*!
    469           * @brief Handle set current configuration request.
    470           *
    471           * This function is used to handle set current configuration request.
    472           *
    473           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    474           * @param setup           The pointer of the setup packet.
    475           * @param buffer          It is an out parameter, is used to save the buffer address to response the host's request.
    476           * @param length          It is an out parameter, the data length.
    477           *
    478           * @retval kStatus_USB_Success              The requst is handled successfully.
    479           * @retval kStatus_USB_InvalidRequest       The request can not be handle in current device state,
    480           *                                          or, the request is unsupported.
    481           */

   \                                 In section .text, align 2, keep-with-next
    482          static usb_status_t USB_DeviceCh9SetConfiguration(usb_device_common_class_struct_t *classHandle,
    483                                                            usb_setup_struct_t *setup,
    484                                                            uint8_t **buffer,
    485                                                            uint32_t *length)
    486          {
   \                     USB_DeviceCh9SetConfiguration: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine1
    487              uint8_t state;
    488          
    489              USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
    490          
    491              if ((kUSB_DeviceStateAddress != state) && (kUSB_DeviceStateConfigured != state))
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000006   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xBF18             IT       NE 
   \   0000000E   0x2800             CMPNE    R0,#+0
   \   00000010   0xD001             BEQ.N    ??USB_DeviceCh9SetConfiguration_0
    492              {
    493                  return kStatus_USB_InvalidRequest;
   \   00000012   0x2005             MOVS     R0,#+5
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}
    494              }
    495          
    496              /* The device state is changed to kUSB_DeviceStateConfigured */
    497              state = kUSB_DeviceStateConfigured;
   \                     ??USB_DeviceCh9SetConfiguration_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      BL       ?Subroutine5
    498              USB_DeviceSetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
    499              if (!setup->wValue)
   \                     ??CrossCallReturnLabel_10: (+1)
   \   0000001C   0x8868             LDRH     R0,[R5, #+2]
   \   0000001E   0xB910             CBNZ.N   R0,??CrossCallReturnLabel_9
    500              {
    501                  /* If the new configuration is zero, the device state is changed to kUSB_DeviceStateAddress */
    502                  state = kUSB_DeviceStateAddress;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      BL       ?Subroutine5
    503                  USB_DeviceSetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
    504              }
    505          
    506              /* Notify the class layer the configuration is changed */
    507              USB_DeviceClassEvent(classHandle->handle, kUSB_DeviceClassEventSetConfiguration, &setup->wValue);
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x1CAA             ADDS     R2,R5,#+2
   \   0000002A   0x2103             MOVS     R1,#+3
   \   0000002C   0x.... 0x....      BL       USB_DeviceClassEvent
    508              /* Notify the application the configuration is changed */
    509              return USB_DeviceClassCallback(classHandle->handle, kUSB_DeviceEventSetConfiguration, &setup->wValue);
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x1CAA             ADDS     R2,R5,#+2
   \   00000034   0x2107             MOVS     R1,#+7
   \   00000036   0x....             B.N      ?Subroutine0
    510          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000004   0x466A             MOV      R2,SP
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x2106             MOVS     R1,#+6
   \   0000000A   0x.... 0x....      B.W      USB_DeviceSetStatus

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x.... 0x....      BL       USB_DeviceClassCallback
   \   00000004   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    511          
    512          /*!
    513           * @brief Handle get the alternate setting of a interface request.
    514           *
    515           * This function is used to handle get the alternate setting of a interface request.
    516           *
    517           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    518           * @param setup           The pointer of the setup packet.
    519           * @param buffer          It is an out parameter, is used to save the buffer address to response the host's request.
    520           * @param length          It is an out parameter, the data length.
    521           *
    522           * @retval kStatus_USB_Success              The requst is handled successfully.
    523           * @retval kStatus_USB_InvalidRequest       The request can not be handle in current device state,
    524           *                                          or, the request is unsupported.
    525           */

   \                                 In section .text, align 2, keep-with-next
    526          static usb_status_t USB_DeviceCh9GetInterface(usb_device_common_class_struct_t *classHandle,
    527                                                        usb_setup_struct_t *setup,
    528                                                        uint8_t **buffer,
    529                                                        uint32_t *length)
    530          {
   \                     USB_DeviceCh9GetInterface: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine2
    531              usb_status_t error = kStatus_USB_InvalidRequest;
    532              uint8_t state;
    533          
    534              USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
    535          
    536              if (state != kUSB_DeviceStateConfigured)
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000006   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000000A   0xB108             CBZ.N    R0,??USB_DeviceCh9GetInterface_0
    537              {
    538                  return error;
   \   0000000C   0x2005             MOVS     R0,#+5
   \   0000000E   0xBDF2             POP      {R1,R4-R7,PC}
    539              }
    540              *length = USB_INTERFACE_SIZE;
   \                     ??USB_DeviceCh9GetInterface_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x6038             STR      R0,[R7, #+0]
    541              *buffer = (uint8_t *)&classHandle->standardTranscationBuffer;
    542              classHandle->standardTranscationBuffer = setup->wIndex & 0xFFU;
    543              /* The Bit[15~8] is used to save the interface index, and the alternate setting will be saved in Bit[7~0] by
    544               * application. */
    545              return USB_DeviceClassCallback(classHandle->handle, kUSB_DeviceEventGetInterface,
    546                                             &classHandle->standardTranscationBuffer);
   \   00000014   0xF104 0x0210      ADD      R2,R4,#+16
   \   00000018   0xF104 0x0010      ADD      R0,R4,#+16
   \   0000001C   0x6030             STR      R0,[R6, #+0]
   \   0000001E   0x2112             MOVS     R1,#+18
   \   00000020   0x7928             LDRB     R0,[R5, #+4]
   \   00000022   0x8220             STRH     R0,[R4, #+16]
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x.... 0x....      BL       USB_DeviceClassCallback
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    547          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4616             MOV      R6,R2
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x461F             MOV      R7,R3
   \   0000000A   0x466A             MOV      R2,SP
   \   0000000C   0x2106             MOVS     R1,#+6
   \   0000000E   0x.... 0x....      B.W      USB_DeviceGetStatus
    548          
    549          /*!
    550           * @brief Handle set the alternate setting of a interface request.
    551           *
    552           * This function is used to handle set the alternate setting of a interface request.
    553           *
    554           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    555           * @param setup           The pointer of the setup packet.
    556           * @param buffer          It is an out parameter, is used to save the buffer address to response the host's request.
    557           * @param length          It is an out parameter, the data length.
    558           *
    559           * @retval kStatus_USB_Success              The requst is handled successfully.
    560           * @retval kStatus_USB_InvalidRequest       The request can not be handle in current device state,
    561           *                                          or, the request is unsupported.
    562           */

   \                                 In section .text, align 2, keep-with-next
    563          static usb_status_t USB_DeviceCh9SetInterface(usb_device_common_class_struct_t *classHandle,
    564                                                        usb_setup_struct_t *setup,
    565                                                        uint8_t **buffer,
    566                                                        uint32_t *length)
    567          {
   \                     USB_DeviceCh9SetInterface: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine1
    568              uint8_t state;
    569          
    570              USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
    571          
    572              if (state != kUSB_DeviceStateConfigured)
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000006   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000000A   0xB108             CBZ.N    R0,??USB_DeviceCh9SetInterface_0
    573              {
    574                  return kStatus_USB_InvalidRequest;
   \   0000000C   0x2005             MOVS     R0,#+5
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
    575              }
    576              classHandle->standardTranscationBuffer = ((setup->wIndex & 0xFFU) << 8U) | (setup->wValue & 0xFFU);
   \                     ??USB_DeviceCh9SetInterface_0: (+1)
   \   00000010   0x88A8             LDRH     R0,[R5, #+4]
   \   00000012   0x78A9             LDRB     R1,[R5, #+2]
   \   00000014   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   00000018   0x8220             STRH     R0,[R4, #+16]
    577              /* Notify the class driver the alternate setting of the interface is changed. */
    578              /* The Bit[15~8] is used to save the interface index, and the alternate setting is saved in Bit[7~0]. */
    579              USB_DeviceClassEvent(classHandle->handle, kUSB_DeviceClassEventSetInterface,
    580                                   &classHandle->standardTranscationBuffer);
   \   0000001A   0xF104 0x0210      ADD      R2,R4,#+16
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x2104             MOVS     R1,#+4
   \   00000022   0x.... 0x....      BL       USB_DeviceClassEvent
    581              /* Notify the application the alternate setting of the interface is changed. */
    582              /* The Bit[15~8] is used to save the interface index, and the alternate setting will is saved in Bit[7~0]. */
    583              return USB_DeviceClassCallback(classHandle->handle, kUSB_DeviceEventSetInterface,
    584                                             &classHandle->standardTranscationBuffer);
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0xF104 0x0210      ADD      R2,R4,#+16
   \   0000002C   0x2108             MOVS     R1,#+8
   \   0000002E                      REQUIRE ?Subroutine0
   \   0000002E                      ;; // Fall through to label ?Subroutine0
    585          }
    586          
    587          /*!
    588           * @brief Handle get sync frame request.
    589           *
    590           * This function is used to handle get sync frame request.
    591           *
    592           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    593           * @param setup           The pointer of the setup packet.
    594           * @param buffer          It is an out parameter, is used to save the buffer address to response the host's request.
    595           * @param length          It is an out parameter, the data length.
    596           *
    597           * @retval kStatus_USB_Success              The requst is handled successfully.
    598           * @retval kStatus_USB_InvalidRequest       The request can not be handle in current device state,
    599           *                                          or, the request is unsupported.
    600           */

   \                                 In section .text, align 2, keep-with-next
    601          static usb_status_t USB_DeviceCh9SynchFrame(usb_device_common_class_struct_t *classHandle,
    602                                                      usb_setup_struct_t *setup,
    603                                                      uint8_t **buffer,
    604                                                      uint32_t *length)
    605          {
   \                     USB_DeviceCh9SynchFrame: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine2
    606              usb_status_t error = kStatus_USB_InvalidRequest;
    607              uint8_t state;
    608          
    609              USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
    610          
    611              if (state != kUSB_DeviceStateConfigured)
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000006   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000000A   0xB108             CBZ.N    R0,??USB_DeviceCh9SynchFrame_0
    612              {
    613                  return error;
   \   0000000C   0x2005             MOVS     R0,#+5
   \   0000000E   0xBDF2             POP      {R1,R4-R7,PC}
    614              }
    615          
    616              classHandle->standardTranscationBuffer = setup->wIndex;
   \                     ??USB_DeviceCh9SynchFrame_0: (+1)
   \   00000010   0x88A8             LDRH     R0,[R5, #+4]
   \   00000012   0x8220             STRH     R0,[R4, #+16]
    617              /* Get the sync frame value */
    618              error =
    619                  USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusSynchFrame, &classHandle->standardTranscationBuffer);
   \   00000014   0xF104 0x0210      ADD      R2,R4,#+16
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x2108             MOVS     R1,#+8
   \   0000001C   0x.... 0x....      BL       USB_DeviceGetStatus
    620              *buffer = (uint8_t *)&classHandle->standardTranscationBuffer;
   \   00000020   0xF104 0x0110      ADD      R1,R4,#+16
   \   00000024   0x6031             STR      R1,[R6, #+0]
    621              *length = sizeof(classHandle->standardTranscationBuffer);
   \   00000026   0x2102             MOVS     R1,#+2
   \   00000028   0x6039             STR      R1,[R7, #+0]
    622          
    623              return error;
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    624          }
    625          
    626          /*!
    627           * @brief Send the reponse to the host.
    628           *
    629           * This function is used to send the reponse to the host.
    630           *
    631           * There are two cases this function will be called.
    632           * Case one when a setup packet is received in control endpoint callback function:
    633           *        1. If there is not data phase in the setup transfer, the function will prime an IN transfer with the data
    634           * length is zero for status phase.
    635           *        2. If there is an IN data phase, the function will prime an OUT transfer with the actual length to need to
    636           * send for data phase. And then prime an IN transfer with the data length is zero for status phase.
    637           *        3. If there is an OUT data phase, the function will prime an IN transfer with the actual length to want to
    638           * receive for data phase.
    639           *
    640           * Case two when is not a setup packet received in control endpoint callback function:
    641           *        1. The function will prime an IN transfer with data length is zero for status phase.
    642           *
    643           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    644           * @param setup           The pointer of the setup packet.
    645           * @param error           The error code returned from the standard request fucntion.
    646           * @param stage           The stage of the control transfer.
    647           * @param buffer          It is an out parameter, is used to save the buffer address to response the host's request.
    648           * @param length          It is an out parameter, the data length.
    649           *
    650           * @return A USB error code or kStatus_USB_Success.
    651           */

   \                                 In section .text, align 2, keep-with-next
    652          static usb_status_t USB_DeviceControlCallbackFeedback(usb_device_handle handle,
    653                                                                usb_setup_struct_t *setup,
    654                                                                usb_status_t error,
    655                                                                usb_device_control_read_write_sequence_t stage,
    656                                                                uint8_t **buffer,
    657                                                                uint32_t *length)
    658          {
   \                     USB_DeviceControlCallbackFeedback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460D             MOV      R5,R1
    659              usb_status_t errorCode = kStatus_USB_Error;
    660              uint8_t direction = USB_IN;
   \   00000004   0x2180             MOVS     R1,#+128
    661          
    662              if (kStatus_USB_InvalidRequest == error)
   \   00000006   0x2A05             CMP      R2,#+5
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0xD10E             BNE.N    ??USB_DeviceControlCallbackFeedback_0
    663              {
    664                  /* Stall the control pipe when the request is unsupported. */
    665                  if ((!((setup->bmRequestType & USB_REQUEST_TYPE_TYPE_MASK) == USB_REQUEST_TYPE_TYPE_STANDARD)) &&
    666                      ((setup->bmRequestType & USB_REQUSET_TYPE_DIR_MASK) == USB_REQUEST_TYPE_DIR_OUT) && (setup->wLength) &&
    667                      (kUSB_DeviceControlPipeSetupStage == stage))
   \   0000000C   0x7828             LDRB     R0,[R5, #+0]
   \   0000000E   0x2260             MOVS     R2,#+96
   \   00000010   0x4210             TST      R0,R2
   \   00000012   0xD005             BEQ.N    ??USB_DeviceControlCallbackFeedback_1
   \   00000014   0x0600             LSLS     R0,R0,#+24
   \   00000016   0xD403             BMI.N    ??USB_DeviceControlCallbackFeedback_1
   \   00000018   0x88E8             LDRH     R0,[R5, #+6]
   \   0000001A   0xB108             CBZ.N    R0,??USB_DeviceControlCallbackFeedback_1
   \   0000001C   0xB903             CBNZ.N   R3,??USB_DeviceControlCallbackFeedback_1
    668                  {
    669                      direction = USB_OUT;
   \   0000001E   0x2100             MOVS     R1,#+0
    670                  }
    671                  errorCode = USB_DeviceStallEndpoint(
    672                      handle,
    673                      (USB_CONTROL_ENDPOINT) | (uint8_t)((uint32_t)direction << USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT));
   \                     ??USB_DeviceControlCallbackFeedback_1: (+1)
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000026   0x.... 0x....      B.W      USB_DeviceStallEndpoint
    674              }
   \                     ??USB_DeviceControlCallbackFeedback_0: (+1)
   \   0000002A   0x9805             LDR      R0,[SP, #+20]
   \   0000002C   0x88E9             LDRH     R1,[R5, #+6]
   \   0000002E   0x6802             LDR      R2,[R0, #+0]
   \   00000030   0x4291             CMP      R1,R2
   \   00000032   0xBF38             IT       CC 
   \   00000034   0x6001             STRCC    R1,[R0, #+0]
    675              else
    676              {
    677                  if (*length > setup->wLength)
    678                  {
    679                      *length = setup->wLength;
    680                  }
    681                  errorCode = USB_DeviceSendRequest(handle, (USB_CONTROL_ENDPOINT), *buffer, *length);
   \   00000036   0x6803             LDR      R3,[R0, #+0]
   \   00000038   0x9804             LDR      R0,[SP, #+16]
   \   0000003A   0x6802             LDR      R2,[R0, #+0]
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       USB_DeviceSendRequest
    682          
    683                  if ((kStatus_USB_Success == errorCode) &&
    684                      (USB_REQUEST_TYPE_DIR_IN == (setup->bmRequestType & USB_REQUSET_TYPE_DIR_MASK)))
   \   00000044   0x0001             MOVS     R1,R0
   \   00000046   0xD10B             BNE.N    ??USB_DeviceControlCallbackFeedback_2
   \   00000048   0x7829             LDRB     R1,[R5, #+0]
   \   0000004A   0x0609             LSLS     R1,R1,#+24
   \   0000004C   0xD508             BPL.N    ??USB_DeviceControlCallbackFeedback_2
    685                  {
    686                      errorCode = USB_DeviceRecvRequest(handle, (USB_CONTROL_ENDPOINT), (uint8_t *)NULL, 0U);
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0xB001             ADD      SP,SP,#+4
   \   00000052   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   00000056   0x2300             MOVS     R3,#+0
   \   00000058   0x2200             MOVS     R2,#+0
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0x.... 0x....      B.W      USB_DeviceRecvRequest
    687                  }
    688              }
    689              return errorCode;
   \                     ??USB_DeviceControlCallbackFeedback_2: (+1)
   \   00000060   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    690          }
    691          
    692          /*!
    693           * @brief Control endpoint callback function.
    694           *
    695           * This callback function is used to notify uplayer the tranfser result of a transfer.
    696           * This callback pointer is passed when a sepcified endpoint initialied by calling API USB_DeviceInitEndpoint.
    697           *
    698           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    699           * @param message         The result of a transfer, includes transfer buffer, transfer length and whether is in setup
    700           * phase for control pipe.
    701           * @param callbackParam  The paramter for this callback. It is same with
    702           * usb_device_endpoint_callback_struct_t::callbackParam.
    703           *
    704           * @return A USB error code or kStatus_USB_Success.
    705           */

   \                                 In section .text, align 2, keep-with-next
    706          usb_status_t USB_DeviceControlCallback(usb_device_handle handle,
    707                                                 usb_device_endpoint_callback_message_struct_t *message,
    708                                                 void *callbackParam)
    709          {
   \                     USB_DeviceControlCallback: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x4604             MOV      R4,R0
    710              usb_setup_struct_t *deviceSetup;
    711              usb_device_common_class_struct_t *classHandle;
    712              uint8_t *buffer = (uint8_t *)NULL;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x9003             STR      R0,[SP, #+12]
    713              uint32_t length = 0U;
   \   0000000C   0x9004             STR      R0,[SP, #+16]
    714              usb_status_t error = kStatus_USB_InvalidRequest;
   \   0000000E   0x2705             MOVS     R7,#+5
    715              uint8_t state;
    716          
    717              if ((0xFFFFFFFFU == message->length) || (NULL == callbackParam))
   \   00000010   0x6868             LDR      R0,[R5, #+4]
   \   00000012   0x4616             MOV      R6,R2
   \   00000014   0xF110 0x0F01      CMN      R0,#+1
   \   00000018   0xBF18             IT       NE 
   \   0000001A   0x2E00             CMPNE    R6,#+0
   \   0000001C   0xD00E             BEQ.N    ??USB_DeviceControlCallback_0
    718              {
    719                  return error;
    720              }
    721          
    722              classHandle = (usb_device_common_class_struct_t *)callbackParam;
    723              deviceSetup = (usb_setup_struct_t *)&classHandle->setupBuffer[0];
    724              USB_DeviceGetStatus(handle, kUSB_DeviceStatusDeviceState, &state);
   \   0000001E   0xAA02             ADD      R2,SP,#+8
   \   00000020   0x2106             MOVS     R1,#+6
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       USB_DeviceGetStatus
    725          
    726              if (message->isSetup)
   \   00000028   0x7A28             LDRB     R0,[R5, #+8]
   \   0000002A   0x.... 0x....      ADR.W    R12,s_UsbDeviceStandardRequest
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD044             BEQ.N    ??USB_DeviceControlCallback_1
    727              {
    728                  if ((USB_SETUP_PACKET_SIZE != message->length) || (NULL == message->buffer))
   \   00000032   0x6868             LDR      R0,[R5, #+4]
   \   00000034   0x2808             CMP      R0,#+8
   \   00000036   0xD101             BNE.N    ??USB_DeviceControlCallback_0
   \   00000038   0x6828             LDR      R0,[R5, #+0]
   \   0000003A   0xB908             CBNZ.N   R0,??USB_DeviceControlCallback_2
    729                  {
    730                      /* If a invalid setup is received, the control pipes should be de-init and init again.
    731                       * Due to the IP can not meet this require, it is revesed for feature.
    732                       */
    733                      /*
    734                      USB_DeviceDeinitEndpoint(handle,
    735                                   USB_CONTROL_ENDPOINT | (USB_IN << USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT));
    736                      USB_DeviceDeinitEndpoint(handle,
    737                                   USB_CONTROL_ENDPOINT | (USB_OUT << USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT));
    738                      USB_DeviceControlPipeInit(handle, callbackParam);
    739                      */
    740                      return error;
   \                     ??USB_DeviceControlCallback_0: (+1)
   \   0000003C   0x2005             MOVS     R0,#+5
   \   0000003E   0xE072             B.N      ??USB_DeviceControlCallback_3
    741                  }
    742                  /* Receive a setup request */
    743                  usb_setup_struct_t *setup = (usb_setup_struct_t *)(message->buffer);
    744          
    745                  /* Copy the setup packet to the application buffer */
    746                  deviceSetup->wValue = USB_SHORT_FROM_LITTLE_ENDIAN(setup->wValue);
   \                     ??USB_DeviceControlCallback_2: (+1)
   \   00000040   0x8841             LDRH     R1,[R0, #+2]
   \   00000042   0x8171             STRH     R1,[R6, #+10]
    747                  deviceSetup->wIndex = USB_SHORT_FROM_LITTLE_ENDIAN(setup->wIndex);
   \   00000044   0x8881             LDRH     R1,[R0, #+4]
   \   00000046   0x81B1             STRH     R1,[R6, #+12]
    748                  deviceSetup->wLength = USB_SHORT_FROM_LITTLE_ENDIAN(setup->wLength);
   \   00000048   0x88C1             LDRH     R1,[R0, #+6]
   \   0000004A   0x81F1             STRH     R1,[R6, #+14]
    749                  deviceSetup->bRequest = setup->bRequest;
   \   0000004C   0x7841             LDRB     R1,[R0, #+1]
   \   0000004E   0x7271             STRB     R1,[R6, #+9]
    750                  deviceSetup->bmRequestType = setup->bmRequestType;
    751          
    752                  if ((deviceSetup->bmRequestType & USB_REQUEST_TYPE_TYPE_MASK) == USB_REQUEST_TYPE_TYPE_STANDARD)
   \   00000050   0x2160             MOVS     R1,#+96
   \   00000052   0x7800             LDRB     R0,[R0, #+0]
   \   00000054   0x7230             STRB     R0,[R6, #+8]
   \   00000056   0x4208             TST      R0,R1
   \   00000058   0xD109             BNE.N    ??USB_DeviceControlCallback_4
   \   0000005A   0x7A70             LDRB     R0,[R6, #+9]
   \   0000005C   0xF85C 0x5020      LDR      R5,[R12, R0, LSL #+2]
   \   00000060   0x0028             MOVS     R0,R5
   \   00000062   0xD027             BEQ.N    ??CrossCallReturnLabel_16
    753                  {
    754                      /* Handle the standard request */
    755                      if (s_UsbDeviceStandardRequest[deviceSetup->bRequest] != (usb_standard_request_callback_t)NULL)
    756                      {
    757                          error = s_UsbDeviceStandardRequest[deviceSetup->bRequest](classHandle, deviceSetup, &buffer, &length);
   \   00000064   0x.... 0x....      BL       ?Subroutine7
    758                      }
    759                  }
   \                     ??CrossCallReturnLabel_13: (+1)
   \   00000068   0x47A8             BLX      R5
   \   0000006A   0x4607             MOV      R7,R0
   \   0000006C   0xE022             B.N      ??CrossCallReturnLabel_16
    760                  else
    761                  {
    762                      if ((deviceSetup->wLength) &&
    763                          ((deviceSetup->bmRequestType & USB_REQUSET_TYPE_DIR_MASK) == USB_REQUEST_TYPE_DIR_OUT))
   \                     ??USB_DeviceControlCallback_4: (+1)
   \   0000006E   0x89F1             LDRH     R1,[R6, #+14]
   \   00000070   0xB1A9             CBZ.N    R1,??USB_DeviceControlCallback_5
   \   00000072   0x0601             LSLS     R1,R0,#+24
   \   00000074   0xD413             BMI.N    ??USB_DeviceControlCallback_5
    764                      {
    765                          /* Class or vendor request with the OUT data phase. */
    766                          if ((deviceSetup->wLength) &&
    767                              ((deviceSetup->bmRequestType & USB_REQUEST_TYPE_TYPE_CLASS) == USB_REQUEST_TYPE_TYPE_CLASS))
   \   00000076   0x0681             LSLS     R1,R0,#+26
   \   00000078   0xD502             BPL.N    ??USB_DeviceControlCallback_6
    768                          {
    769                              /* Get data buffer to receive the data from the host. */
    770                              usb_device_control_request_struct_t controlRequest;
    771                              controlRequest.buffer = (uint8_t *)NULL;
   \   0000007A   0x.... 0x....      BL       ?Subroutine3
    772                              controlRequest.isSetup = 1U;
    773                              controlRequest.setup = deviceSetup;
    774                              controlRequest.length = deviceSetup->wLength;
    775                              error = USB_DeviceClassEvent(handle, kUSB_DeviceClassEventClassRequest, &controlRequest);
    776                              length = controlRequest.length;
    777                              buffer = controlRequest.buffer;
    778                          }
   \                     ??CrossCallReturnLabel_6: (+1)
   \   0000007E   0xE003             B.N      ??CrossCallReturnLabel_8
    779                          else if ((deviceSetup->wLength) &&
    780                                   ((deviceSetup->bmRequestType & USB_REQUEST_TYPE_TYPE_VENDOR) == USB_REQUEST_TYPE_TYPE_VENDOR))
   \                     ??USB_DeviceControlCallback_6: (+1)
   \   00000080   0x0640             LSLS     R0,R0,#+25
   \   00000082   0xD517             BPL.N    ??CrossCallReturnLabel_16
    781                          {
    782                              /* Get data buffer to receive the data from the host. */
    783                              usb_device_control_request_struct_t controlRequest;
    784                              controlRequest.buffer = (uint8_t *)NULL;
   \   00000084   0x.... 0x....      BL       ?Subroutine4
    785                              controlRequest.isSetup = 1U;
    786                              controlRequest.setup = deviceSetup;
    787                              controlRequest.length = deviceSetup->wLength;
    788                              error = USB_DeviceClassCallback(handle, kUSB_DeviceEventVendorRequest, &controlRequest);
    789                              length = controlRequest.length;
    790                              buffer = controlRequest.buffer;
    791                          }
   \                     ??CrossCallReturnLabel_8: (+1)
   \   00000088   0x.... 0x....      BL       ?Subroutine8
    792                          else
    793                          {
    794                          }
    795                          if (kStatus_USB_Success == error)
   \                     ??CrossCallReturnLabel_15: (+1)
   \   0000008C   0x0038             MOVS     R0,R7
   \   0000008E   0xD111             BNE.N    ??CrossCallReturnLabel_16
    796                          {
    797                              /* Prime an OUT transfer */
    798                              error = USB_DeviceRecvRequest(handle, USB_CONTROL_ENDPOINT, buffer, deviceSetup->wLength);
    799                              return error;
   \   00000090   0x89F3             LDRH     R3,[R6, #+14]
   \   00000092   0x9A03             LDR      R2,[SP, #+12]
   \   00000094   0x2100             MOVS     R1,#+0
   \   00000096   0x4620             MOV      R0,R4
   \   00000098   0x.... 0x....      BL       USB_DeviceRecvRequest
   \   0000009C   0xE043             B.N      ??USB_DeviceControlCallback_3
    800                          }
    801                      }
    802                      else
    803                      {
    804                          /* Class or vendor request with the IN data phase. */
    805                          if (((deviceSetup->bmRequestType & USB_REQUEST_TYPE_TYPE_CLASS) == USB_REQUEST_TYPE_TYPE_CLASS))
   \                     ??USB_DeviceControlCallback_5: (+1)
   \   0000009E   0x0681             LSLS     R1,R0,#+26
   \   000000A0   0xD502             BPL.N    ??USB_DeviceControlCallback_7
    806                          {
    807                              /* Get data buffer to response the host. */
    808                              usb_device_control_request_struct_t controlRequest;
    809                              controlRequest.buffer = (uint8_t *)NULL;
   \   000000A2   0x.... 0x....      BL       ?Subroutine3
    810                              controlRequest.isSetup = 1U;
    811                              controlRequest.setup = deviceSetup;
    812                              controlRequest.length = deviceSetup->wLength;
    813                              error = USB_DeviceClassEvent(handle, kUSB_DeviceClassEventClassRequest, &controlRequest);
    814                              length = controlRequest.length;
    815                              buffer = controlRequest.buffer;
    816                          }
   \                     ??CrossCallReturnLabel_5: (+1)
   \   000000A6   0xE003             B.N      ??CrossCallReturnLabel_7
    817                          else if (((deviceSetup->bmRequestType & USB_REQUEST_TYPE_TYPE_VENDOR) == USB_REQUEST_TYPE_TYPE_VENDOR))
   \                     ??USB_DeviceControlCallback_7: (+1)
   \   000000A8   0x0640             LSLS     R0,R0,#+25
   \   000000AA   0xD503             BPL.N    ??CrossCallReturnLabel_16
    818                          {
    819                              /* Get data buffer to response the host. */
    820                              usb_device_control_request_struct_t controlRequest;
    821                              controlRequest.buffer = (uint8_t *)NULL;
   \   000000AC   0x.... 0x....      BL       ?Subroutine4
    822                              controlRequest.isSetup = 1U;
    823                              controlRequest.setup = deviceSetup;
    824                              controlRequest.length = deviceSetup->wLength;
    825                              error = USB_DeviceClassCallback(handle, kUSB_DeviceEventVendorRequest, &controlRequest);
    826                              length = controlRequest.length;
    827                              buffer = controlRequest.buffer;
    828                          }
    829                          else
    830                          {
    831                          }
    832                      }
    833                  }
   \                     ??CrossCallReturnLabel_7: (+1)
   \   000000B0   0x.... 0x....      BL       ?Subroutine8
    834                  /* Send the reponse to the host. */
    835                  error = USB_DeviceControlCallbackFeedback(handle, deviceSetup, error, kUSB_DeviceControlPipeSetupStage, &buffer,
    836                                                            &length);
   \                     ??CrossCallReturnLabel_16: (+1)
   \   000000B4   0xA804             ADD      R0,SP,#+16
   \   000000B6   0x9001             STR      R0,[SP, #+4]
   \   000000B8   0x2300             MOVS     R3,#+0
   \   000000BA   0xE02A             B.N      ??USB_DeviceControlCallback_8
    837              }
    838              else if (kUSB_DeviceStateAddressing == state)
   \                     ??USB_DeviceControlCallback_1: (+1)
   \   000000BC   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000C0   0x2803             CMP      R0,#+3
   \   000000C2   0xD106             BNE.N    ??USB_DeviceControlCallback_9
    839              {
    840                  /* Set the device address to controller. */
    841                  error = s_UsbDeviceStandardRequest[deviceSetup->bRequest](classHandle, deviceSetup, &buffer, &length);
   \   000000C4   0x7A74             LDRB     R4,[R6, #+9]
   \   000000C6   0xF85C 0x4024      LDR      R4,[R12, R4, LSL #+2]
   \   000000CA   0x.... 0x....      BL       ?Subroutine7
    842              }
   \                     ??CrossCallReturnLabel_14: (+1)
   \   000000CE   0x47A0             BLX      R4
   \   000000D0   0xE027             B.N      ??USB_DeviceControlCallback_10
    843          #if (defined(USB_DEVICE_CONFIG_EHCI) && (USB_DEVICE_CONFIG_EHCI > 0U)) && \
    844              (defined(USB_DEVICE_CONFIG_EHCI_TEST_MODE) && (USB_DEVICE_CONFIG_EHCI_TEST_MODE > 0U))
    845              else if (kUSB_DeviceStateTestMode == state)
    846              {
    847                  uint8_t portTestControl = (uint8_t)(deviceSetup->wIndex >> 8);
    848                  /* Set the controller.into test mode. */
    849                  error = USB_DeviceSetStatus(handle, kUSB_DeviceStatusTestMode, &portTestControl);
    850              }
    851          #endif
    852              else if ((message->length) && (deviceSetup->wLength) &&
    853                       ((deviceSetup->bmRequestType & USB_REQUSET_TYPE_DIR_MASK) == USB_REQUEST_TYPE_DIR_OUT))
   \                     ??USB_DeviceControlCallback_9: (+1)
   \   000000D2   0x6868             LDR      R0,[R5, #+4]
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xBF1C             ITT      NE 
   \   000000D8   0x89F0             LDRHNE   R0,[R6, #+14]
   \   000000DA   0x2800             CMPNE    R0,#+0
   \   000000DC   0xD022             BEQ.N    ??USB_DeviceControlCallback_11
   \   000000DE   0x7A30             LDRB     R0,[R6, #+8]
   \   000000E0   0x0601             LSLS     R1,R0,#+24
   \   000000E2   0xD41F             BMI.N    ??USB_DeviceControlCallback_11
    854              {
    855                  if (((deviceSetup->bmRequestType & USB_REQUEST_TYPE_TYPE_CLASS) == USB_REQUEST_TYPE_TYPE_CLASS))
   \   000000E4   0x0681             LSLS     R1,R0,#+26
   \   000000E6   0xD507             BPL.N    ??USB_DeviceControlCallback_12
    856                  {
    857                      /* Data received in OUT phase, and notify the class driver. */
    858                      usb_device_control_request_struct_t controlRequest;
    859                      controlRequest.buffer = message->buffer;
   \   000000E8   0x.... 0x....      BL       ?Subroutine6
    860                      controlRequest.isSetup = 0U;
    861                      controlRequest.setup = deviceSetup;
    862                      controlRequest.length = message->length;
    863                      error = USB_DeviceClassEvent(handle, kUSB_DeviceClassEventClassRequest, &controlRequest);
    864                  }
   \                     ??CrossCallReturnLabel_11: (+1)
   \   000000EC   0x2101             MOVS     R1,#+1
   \   000000EE   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_17: (+1)
   \   000000F2   0x.... 0x....      BL       USB_DeviceClassEvent
   \   000000F6   0xE008             B.N      ??USB_DeviceControlCallback_13
    865                  else if (((deviceSetup->bmRequestType & USB_REQUEST_TYPE_TYPE_VENDOR) == USB_REQUEST_TYPE_TYPE_VENDOR))
   \                     ??USB_DeviceControlCallback_12: (+1)
   \   000000F8   0x0640             LSLS     R0,R0,#+25
   \   000000FA   0xD507             BPL.N    ??USB_DeviceControlCallback_14
    866                  {
    867                      /* Data received in OUT phase, and notify the application. */
    868                      usb_device_control_request_struct_t controlRequest;
    869                      controlRequest.buffer = message->buffer;
   \   000000FC   0x.... 0x....      BL       ?Subroutine6
    870                      controlRequest.isSetup = 0U;
    871                      controlRequest.setup = deviceSetup;
    872                      controlRequest.length = message->length;
    873                      error = USB_DeviceClassCallback(handle, kUSB_DeviceEventVendorRequest, &controlRequest);
    874                  }
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000100   0x210F             MOVS     R1,#+15
   \   00000102   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_18: (+1)
   \   00000106   0x.... 0x....      BL       USB_DeviceClassCallback
   \                     ??USB_DeviceControlCallback_13: (+1)
   \   0000010A   0x4607             MOV      R7,R0
    875                  else
    876                  {
    877                  }
    878                  /* Send the reponse to the host. */
    879                  error = USB_DeviceControlCallbackFeedback(handle, deviceSetup, error, kUSB_DeviceControlPipeDataStage, &buffer,
    880                                                            &length);
   \                     ??USB_DeviceControlCallback_14: (+1)
   \   0000010C   0xA804             ADD      R0,SP,#+16
   \   0000010E   0x9001             STR      R0,[SP, #+4]
   \   00000110   0x2301             MOVS     R3,#+1
   \                     ??USB_DeviceControlCallback_8: (+1)
   \   00000112   0xA803             ADD      R0,SP,#+12
   \   00000114   0x9000             STR      R0,[SP, #+0]
   \   00000116   0x463A             MOV      R2,R7
   \   00000118   0xF106 0x0108      ADD      R1,R6,#+8
   \   0000011C   0x4620             MOV      R0,R4
   \   0000011E   0x.... 0x....      BL       USB_DeviceControlCallbackFeedback
   \                     ??USB_DeviceControlCallback_10: (+1)
   \   00000122   0x4607             MOV      R7,R0
    881              }
    882              else
    883              {
    884              }
    885              return error;
   \                     ??USB_DeviceControlCallback_11: (+1)
   \   00000124   0x4638             MOV      R0,R7
   \                     ??USB_DeviceControlCallback_3: (+1)
   \   00000126   0xB009             ADD      SP,SP,#+36
   \   00000128   0xBDF0             POP      {R4-R7,PC}       ;; return
    886          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \   00000000   0xF106 0x0008      ADD      R0,R6,#+8
   \   00000004   0x9005             STR      R0,[SP, #+20]
   \   00000006   0x6868             LDR      R0,[R5, #+4]
   \   00000008   0x9007             STR      R0,[SP, #+28]
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \   00000000   0x4607             MOV      R7,R0
   \   00000002   0x9807             LDR      R0,[SP, #+28]
   \   00000004   0x9004             STR      R0,[SP, #+16]
   \   00000006   0x9806             LDR      R0,[SP, #+24]
   \   00000008   0x9003             STR      R0,[SP, #+12]
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0xAB04             ADD      R3,SP,#+16
   \   00000002   0xAA03             ADD      R2,SP,#+12
   \   00000004   0xF106 0x0108      ADD      R1,R6,#+8
   \   00000008   0x4630             MOV      R0,R6
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x6828             LDR      R0,[R5, #+0]
   \   00000002   0x9006             STR      R0,[SP, #+24]
   \   00000004   0xAA05             ADD      R2,SP,#+20
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF88D 0x0020      STRB     R0,[SP, #+32]
   \   0000000C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x9006             STR      R0,[SP, #+24]
   \   00000004   0xAA05             ADD      R2,SP,#+20
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xF88D 0x0020      STRB     R0,[SP, #+32]
   \   0000000C   0x210F             MOVS     R1,#+15
   \   0000000E   0xF106 0x0008      ADD      R0,R6,#+8
   \   00000012   0x9005             STR      R0,[SP, #+20]
   \   00000014   0x89F0             LDRH     R0,[R6, #+14]
   \   00000016   0x9007             STR      R0,[SP, #+28]
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      B.W      USB_DeviceClassCallback

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x9006             STR      R0,[SP, #+24]
   \   00000004   0xAA05             ADD      R2,SP,#+20
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xF88D 0x0020      STRB     R0,[SP, #+32]
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF106 0x0008      ADD      R0,R6,#+8
   \   00000012   0x9005             STR      R0,[SP, #+20]
   \   00000014   0x89F0             LDRH     R0,[R6, #+14]
   \   00000016   0x9007             STR      R0,[SP, #+28]
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      B.W      USB_DeviceClassEvent
    887          
    888          /*!
    889           * @brief Control endpoint initialization function.
    890           *
    891           * This callback function is used to initialize the control pipes.
    892           *
    893           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    894           * @param param           The up layer handle.
    895           *
    896           * @return A USB error code or kStatus_USB_Success.
    897           */

   \                                 In section .text, align 2, keep-with-next
    898          usb_status_t USB_DeviceControlPipeInit(usb_device_handle handle, void *param)
    899          {
   \                     USB_DeviceControlPipeInit: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
    900              usb_device_endpoint_init_struct_t epInitStruct;
    901              usb_device_endpoint_callback_struct_t endpointCallback;
    902              usb_status_t error;
    903          
    904              endpointCallback.callbackFn = USB_DeviceControlCallback;
   \   00000006   0x....             LDR.N    R0,??DataTable1
   \   00000008   0x9002             STR      R0,[SP, #+8]
    905              endpointCallback.callbackParam = param;
   \   0000000A   0x9103             STR      R1,[SP, #+12]
    906          
    907              epInitStruct.zlt = 1U;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xF88D 0x0004      STRB     R0,[SP, #+4]
    908              epInitStruct.transferType = USB_ENDPOINT_CONTROL;
    909              epInitStruct.endpointAddress = USB_CONTROL_ENDPOINT | (USB_IN << USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT);
    910              epInitStruct.maxPacketSize = USB_CONTROL_MAX_PACKET_SIZE;
    911              /* Initialize the control IN pipe */
    912              error = USB_DeviceInitEndpoint(handle, &epInitStruct, &endpointCallback);
   \   00000012   0xAA02             ADD      R2,SP,#+8
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   0000001A   0x4669             MOV      R1,SP
   \   0000001C   0x2080             MOVS     R0,#+128
   \   0000001E   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   00000022   0x2040             MOVS     R0,#+64
   \   00000024   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       USB_DeviceInitEndpoint
   \   0000002E   0x0005             MOVS     R5,R0
    913          
    914              if (kStatus_USB_Success != error)
   \   00000030   0xD110             BNE.N    ??USB_DeviceControlPipeInit_0
    915              {
    916                  return error;
    917              }
    918              epInitStruct.endpointAddress = USB_CONTROL_ENDPOINT | (USB_OUT << USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT);
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF88D 0x0002      STRB     R0,[SP, #+2]
    919              /* Initialize the control OUT pipe */
    920              error = USB_DeviceInitEndpoint(handle, &epInitStruct, &endpointCallback);
   \   00000038   0xAA02             ADD      R2,SP,#+8
   \   0000003A   0x4669             MOV      R1,SP
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       USB_DeviceInitEndpoint
   \   00000042   0x0005             MOVS     R5,R0
    921          
    922              if (kStatus_USB_Success != error)
   \   00000044   0xD005             BEQ.N    ??USB_DeviceControlPipeInit_1
    923              {
    924                  USB_DeviceDeinitEndpoint(handle,
    925                                           USB_CONTROL_ENDPOINT | (USB_IN << USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT));
   \   00000046   0x2180             MOVS     R1,#+128
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       USB_DeviceDeinitEndpoint
    926                  return error;
   \   0000004E   0x4628             MOV      R0,R5
   \   00000050   0xE000             B.N      ??USB_DeviceControlPipeInit_0
    927              }
    928          
    929              return kStatus_USB_Success;
   \                     ??USB_DeviceControlPipeInit_1: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??USB_DeviceControlPipeInit_0: (+1)
   \   00000054   0xB005             ADD      SP,SP,#+20
   \   00000056   0xBD30             POP      {R4,R5,PC}       ;; return
    930          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     USB_DeviceControlCallback
    931          #endif /* USB_DEVICE_CONFIG_NUM */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   USB_DeviceCh9GetConfiguration
        24   -> USB_DeviceClassCallback
        24   -> USB_DeviceGetStatus
      48   USB_DeviceCh9GetDescriptor
        48   -> USB_DeviceClassCallback
        48   -> USB_DeviceGetStatus
      24   USB_DeviceCh9GetInterface
        24   -> USB_DeviceClassCallback
        24   -> USB_DeviceGetStatus
      32   USB_DeviceCh9GetStatus
        32   -> USB_DeviceGetStatus
      16   USB_DeviceCh9SetAddress
        16   -> USB_DeviceGetStatus
        16   -> USB_DeviceSetStatus
      24   USB_DeviceCh9SetClearFeature
        24   -> USB_DeviceClassCallback
        24   -> USB_DeviceClassEvent
        24   -> USB_DeviceGetStatus
        24   -> USB_DeviceStallEndpoint
        24   -> USB_DeviceUnstallEndpoint
      16   USB_DeviceCh9SetConfiguration
        16   -> USB_DeviceClassCallback
        16   -> USB_DeviceClassEvent
        16   -> USB_DeviceGetStatus
        16   -> USB_DeviceSetStatus
      16   USB_DeviceCh9SetInterface
        16   -> USB_DeviceClassCallback
        16   -> USB_DeviceClassEvent
        16   -> USB_DeviceGetStatus
      24   USB_DeviceCh9SynchFrame
        24   -> USB_DeviceGetStatus
      56   USB_DeviceControlCallback
        56   -- Indirect call
        56   -> USB_DeviceClassCallback
        56   -> USB_DeviceClassEvent
        56   -> USB_DeviceControlCallbackFeedback
        56   -> USB_DeviceGetStatus
        56   -> USB_DeviceRecvRequest
      16   USB_DeviceControlCallbackFeedback
         0   -> USB_DeviceRecvRequest
        16   -> USB_DeviceSendRequest
         0   -> USB_DeviceStallEndpoint
      32   USB_DeviceControlPipeInit
        32   -> USB_DeviceDeinitEndpoint
        32   -> USB_DeviceInitEndpoint


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       6  ?Subroutine0
      14  ?Subroutine1
      18  ?Subroutine2
      30  ?Subroutine3
      30  ?Subroutine4
      14  ?Subroutine5
      14  ?Subroutine6
      12  ?Subroutine7
      12  ?Subroutine8
      14  ?Subroutine9
      60  USB_DeviceCh9GetConfiguration
     172  USB_DeviceCh9GetDescriptor
      44  USB_DeviceCh9GetInterface
     136  USB_DeviceCh9GetStatus
      70  USB_DeviceCh9SetAddress
     162  USB_DeviceCh9SetClearFeature
      56  USB_DeviceCh9SetConfiguration
      46  USB_DeviceCh9SetInterface
      44  USB_DeviceCh9SynchFrame
     298  USB_DeviceControlCallback
      98  USB_DeviceControlCallbackFeedback
      88  USB_DeviceControlPipeInit
      52  s_UsbDeviceStandardRequest

 
 1 494 bytes in section .text
 
 1 494 bytes of CODE memory

Errors: none
Warnings: none
