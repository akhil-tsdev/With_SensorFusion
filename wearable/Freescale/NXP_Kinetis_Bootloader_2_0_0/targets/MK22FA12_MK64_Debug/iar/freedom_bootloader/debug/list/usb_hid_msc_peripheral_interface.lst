###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:15
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\usb_hid_msc_peripheral_interface.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\usb_hid_msc_peripheral_interface.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\usb_hid_msc_peripheral_interface.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\usb_hid_msc_peripheral_interface.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\usb_hid_msc_peripheral_interface.c
      1          /*
      2           * Copyright (c) 2013, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "bootloader/bl_context.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable12  ;; 0xe000e100
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable12_1  ;; 0xe000e180
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_ClearPendingIRQ(IRQn_Type)
   \                     NVIC_ClearPendingIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable12_2  ;; 0xe000e280
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_SetPriority(IRQn_Type, uint32_t)
   \                     NVIC_SetPriority: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD509             BPL.N    ??NVIC_SetPriority_0
   \   00000008   0x010A             LSLS     R2,R1,#+4
   \   0000000A   0x.... 0x....      LDR.W    R3,??DataTable12_3  ;; 0xe000ed18
   \   0000000E   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000010   0xF010 0x040F      ANDS     R4,R0,#0xF
   \   00000014   0x4423             ADD      R3,R3,R4
   \   00000016   0xF803 0x2C04      STRB     R2,[R3, #-4]
   \   0000001A   0xE004             B.N      ??NVIC_SetPriority_1
   \                     ??NVIC_SetPriority_0: (+1)
   \   0000001C   0x010A             LSLS     R2,R1,#+4
   \   0000001E   0x.... 0x....      LDR.W    R3,??DataTable12_4  ;; 0xe000e400
   \   00000022   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000024   0x541A             STRB     R2,[R3, R0]
   \                     ??NVIC_SetPriority_1: (+1)
   \   00000026   0xBC10             POP      {R4}
   \   00000028   0x4770             BX       LR               ;; return
     32          #include "bootloader/bootloader.h"
     33          #include "bootloader_common.h"
     34          #include "fsl_device_registers.h"
     35          #include "bootloader_core.h"
     36          #include "sbloader/sbloader.h"
     37          #include "sbloader/sb_file_format.h"
     38          #include "bootloader_hid_report_ids.h"
     39          #include "utilities/fsl_rtos_abstraction.h"
     40          #include <string.h>
     41          #include "property/property.h"
     42          #include "usb_descriptor.h"
     43          
     44          #include "usb_device_config.h"
     45          #include "usb.h"
     46          #include "usb_device.h"
     47          
     48          #include "usb_device_class.h"
     49          #include "usb_device_msc.h"
     50          #include "usb_device_hid.h"
     51          #include "usb_device_ch9.h"
     52          #include "usb_descriptor.h"
     53          
     54          #include "composite.h"
     55          
     56          #include <stdio.h>
     57          #include <stdlib.h>
     58          
     59          #if defined(K65F18_SERIES)
     60          #include "MK65F18_INV.h"
     61          #endif
     62          
     63          #if (BL_CONFIG_USB_HID || BL_CONFIG_HS_USB_HID || BL_CONFIG_USB_MSC || BL_CONFIG_HS_USB_MSC)
     64          
     65          //! @addtogroup usb_hid_peripheral
     66          //! @{
     67          
     68          ////////////////////////////////////////////////////////////////////////////////
     69          // Definitions
     70          ////////////////////////////////////////////////////////////////////////////////
     71          #define REQ_DATA_SIZE (1)
     72          
     73          #define USB_HID_INDEX (0)
     74          #define USB_MSC_INDEX (1)
     75          
     76          ////////////////////////////////////////////////////////////////////////////////
     77          // Prototypes
     78          ////////////////////////////////////////////////////////////////////////////////
     79          
     80          static bool usb_hid_poll_for_activity(const peripheral_descriptor_t *self);
     81          static status_t usb_device_full_init(const peripheral_descriptor_t *self, serial_byte_receive_func_t function);
     82          static void usb_device_full_shutdown(const peripheral_descriptor_t *self);
     83          static void usb_msc_pump(const peripheral_descriptor_t *self);
     84          
     85          static status_t usb_hid_packet_init(const peripheral_descriptor_t *self);
     86          static status_t usb_hid_packet_read(const peripheral_descriptor_t *self,
     87                                              uint8_t **packet,
     88                                              uint32_t *packetLength,
     89                                              packet_type_t packetType);
     90          static status_t usb_hid_packet_write(const peripheral_descriptor_t *self,
     91                                               const uint8_t *packet,
     92                                               uint32_t byteCount,
     93                                               packet_type_t packetType);
     94          static void usb_hid_packet_abort_data_phase(const peripheral_descriptor_t *self);
     95          static status_t usb_hid_packet_finalize(const peripheral_descriptor_t *self);
     96          static uint32_t usb_hid_packet_get_max_packet_size(const peripheral_descriptor_t *self);
     97          
     98          // static bool s_dHidMscActivity[USB_COMPOSITE_INTERFACE_COUNT] = {false};

   \                                 In section .bss, align 2
     99          static bool s_dHidMscActivity[2] = { false };
   \                     s_dHidMscActivity:
   \   00000000                      DS8 2
    100          
    101          ////////////////////////////////////////////////////////////////////////////////
    102          // Variables
    103          ////////////////////////////////////////////////////////////////////////////////
    104          

   \                                 In section .rodata, align 4
    105          const peripheral_control_interface_t g_usbHidControlInterface = {.pollForActivity = usb_hid_poll_for_activity,
   \                     g_usbHidControlInterface:
   \   00000000   0x........         DC32 usb_hid_poll_for_activity, usb_device_full_init
   \              0x........   
   \   00000008   0x........         DC32 usb_device_full_shutdown, usb_msc_pump
   \              0x........   
    106                                                                           .init = usb_device_full_init,
    107                                                                           .shutdown = usb_device_full_shutdown,
    108                                                                           .pump = usb_msc_pump };
    109          

   \                                 In section .rodata, align 4
    110          const peripheral_packet_interface_t g_usbHidPacketInterface = {.init = usb_hid_packet_init,
   \                     g_usbHidPacketInterface:
   \   00000000   0x........         DC32 usb_hid_packet_init, usb_hid_packet_read, usb_hid_packet_write
   \              0x........   
   \              0x........   
   \   0000000C   0x........         DC32 usb_hid_packet_abort_data_phase, usb_hid_packet_finalize
   \              0x........   
   \   00000014   0x........         DC32 usb_hid_packet_get_max_packet_size, 0H
   \              0x00000000   
    111                                                                         .readPacket = usb_hid_packet_read,
    112                                                                         .writePacket = usb_hid_packet_write,
    113                                                                         .abortDataPhase = usb_hid_packet_abort_data_phase,
    114                                                                         .finalize = usb_hid_packet_finalize,
    115                                                                         .getMaxPacketSize = usb_hid_packet_get_max_packet_size,
    116                                                                         .byteReceivedCallback = 0 };
    117          

   \                                 In section .bss, align 4
    118          static usb_device_composite_struct_t g_device_composite;
   \                     g_device_composite:
   \   00000000                      DS8 1152
    119          
    120          usb_status_t usb_device_callback(usb_device_handle handle, uint32_t event, void *param);
    121          
    122          extern usb_status_t usb_device_msc_callback(class_handle_t handle, uint32_t event, void *param);
    123          
    124          ////////////////////////////////////////////////////////////////////////////////
    125          // Code
    126          ////////////////////////////////////////////////////////////////////////////////
    127          

   \                                 In section .text, align 2, keep-with-next
    128          bool usb_hid_poll_for_activity(const peripheral_descriptor_t *self)
    129          {
    130              //    uint32_t hidInfoIndex = self->instance / 2;
    131              bool hid_active = false;
   \                     usb_hid_poll_for_activity: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    132              bool msc_active = false;
   \   00000002   0x2200             MOVS     R2,#+0
    133          #if USB_DEVICE_CONFIG_HID
    134              hid_active = g_device_composite.hid_generic.hid_packet.didReceiveFirstReport;
   \   00000004   0x.... 0x....      LDR.W    R3,??DataTable12_5
   \   00000008   0x7B1B             LDRB     R3,[R3, #+12]
   \   0000000A   0x0019             MOVS     R1,R3
    135          #endif //  USB_DEVICE_CONFIG_HID
    136          #if USB_DEVICE_CONFIG_MSC
    137              msc_active = g_device_composite.msc_disk.msc_state.isActive;
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable12_5
   \   00000010   0xF893 0x345A      LDRB     R3,[R3, #+1114]
   \   00000014   0x2B00             CMP      R3,#+0
   \   00000016   0xD001             BEQ.N    ??usb_hid_poll_for_activity_0
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0xE000             B.N      ??usb_hid_poll_for_activity_1
   \                     ??usb_hid_poll_for_activity_0: (+1)
   \   0000001C   0x2200             MOVS     R2,#+0
    138          #endif //  USB_DEVICE_CONFIG_HID
    139          
    140              s_dHidMscActivity[0] = hid_active;
   \                     ??usb_hid_poll_for_activity_1: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R3,??DataTable12_6
   \   00000022   0x7019             STRB     R1,[R3, #+0]
    141              s_dHidMscActivity[1] = msc_active;
   \   00000024   0x.... 0x....      LDR.W    R3,??DataTable12_6
   \   00000028   0x705A             STRB     R2,[R3, #+1]
    142              return (g_device_composite.attach && (hid_active || msc_active));
   \   0000002A   0x.... 0x....      LDR.W    R3,??DataTable12_5
   \   0000002E   0xF893 0x3479      LDRB     R3,[R3, #+1145]
   \   00000032   0x2B00             CMP      R3,#+0
   \   00000034   0xD002             BEQ.N    ??usb_hid_poll_for_activity_2
   \   00000036   0xEA52 0x0001      ORRS     R0,R2,R1
   \   0000003A   0xE000             B.N      ??usb_hid_poll_for_activity_3
   \                     ??usb_hid_poll_for_activity_2: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \                     ??usb_hid_poll_for_activity_3: (+1)
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0x4770             BX       LR               ;; return
    143          }
    144          

   \                                 In section .text, align 2, keep-with-next
    145          usb_status_t usb_device_callback(usb_device_handle handle, uint32_t event, void *param)
    146          {
   \                     usb_device_callback: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    147              usb_status_t error = kStatus_USB_Success;
   \   0000000A   0x2700             MOVS     R7,#+0
    148              uint16_t *temp16 = (uint16_t *)param;
   \   0000000C   0x46B0             MOV      R8,R6
    149              uint8_t *temp8 = (uint8_t *)param;
   \   0000000E   0x46B1             MOV      R9,R6
    150          
    151              switch (event)
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD01A             BEQ.N    ??usb_device_callback_0
   \   00000016   0x2807             CMP      R0,#+7
   \   00000018   0xD01E             BEQ.N    ??usb_device_callback_1
   \   0000001A   0x2808             CMP      R0,#+8
   \   0000001C   0xD03B             BEQ.N    ??usb_device_callback_2
   \   0000001E   0x2809             CMP      R0,#+9
   \   00000020   0xF000 0x8084      BEQ.W    ??usb_device_callback_3
   \   00000024   0x280A             CMP      R0,#+10
   \   00000026   0xF000 0x8089      BEQ.W    ??usb_device_callback_4
   \   0000002A   0x280B             CMP      R0,#+11
   \   0000002C   0xF000 0x808E      BEQ.W    ??usb_device_callback_5
   \   00000030   0x280C             CMP      R0,#+12
   \   00000032   0xF000 0x8093      BEQ.W    ??usb_device_callback_6
   \   00000036   0x280D             CMP      R0,#+13
   \   00000038   0xF000 0x8098      BEQ.W    ??usb_device_callback_7
   \   0000003C   0x280E             CMP      R0,#+14
   \   0000003E   0xF000 0x809D      BEQ.W    ??usb_device_callback_8
   \   00000042   0x2811             CMP      R0,#+17
   \   00000044   0xD04B             BEQ.N    ??usb_device_callback_9
   \   00000046   0x2812             CMP      R0,#+18
   \   00000048   0xD054             BEQ.N    ??usb_device_callback_10
   \   0000004A   0xE09E             B.N      ??usb_device_callback_11
    152              {
    153                  case kUSB_DeviceEventBusReset:
    154                  {
    155                      g_device_composite.attach = 0;
   \                     ??usb_device_callback_0: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   00000052   0xF881 0x0479      STRB     R0,[R1, #+1145]
    156          #if defined(USB_DEVICE_CONFIG_EHCI) && (USB_DEVICE_CONFIG_EHCI > 0)
    157                      if (kStatus_USB_Success == USB_DeviceClassGetSpeed(CONTROLLER_ID, &g_device_composite.speed))
    158                      {
    159                          usb_device_set_speed(handle, g_device_composite.speed);
    160                      }
    161          #endif
    162                  }
    163                  break;
   \   00000056   0xE098             B.N      ??usb_device_callback_11
    164                  case kUSB_DeviceEventSetConfiguration:
    165                      if (param)
   \                     ??usb_device_callback_1: (+1)
   \   00000058   0x2E00             CMP      R6,#+0
   \   0000005A   0xD01B             BEQ.N    ??usb_device_callback_12
    166                      {
    167                          g_device_composite.attach = 1;
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   00000062   0xF881 0x0479      STRB     R0,[R1, #+1145]
    168                          g_device_composite.current_configuration = *temp8;
   \   00000066   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   0000006E   0xF881 0x047A      STRB     R0,[R1, #+1146]
    169          #if USB_DEVICE_CONFIG_HID
    170                          error = usb_device_hid_generic_set_configure(g_device_composite.hid_generic.hid_handle, *temp8);
   \   00000072   0xF899 0x1000      LDRB     R1,[R9, #+0]
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable12_5
   \   0000007A   0x6880             LDR      R0,[R0, #+8]
   \   0000007C   0x.... 0x....      BL       usb_device_hid_generic_set_configure
   \   00000080   0x0007             MOVS     R7,R0
    171          #endif // USB_DEVICE_CONFIG_HID
    172          #if USB_DEVICE_CONFIG_MSC
    173                          usb_device_msc_disk_set_configure(g_device_composite.msc_disk.msc_handle, *temp8);
   \   00000082   0xF899 0x1000      LDRB     R1,[R9, #+0]
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable12_5
   \   0000008A   0x6D00             LDR      R0,[R0, #+80]
   \   0000008C   0x.... 0x....      BL       usb_device_msc_disk_set_configure
    174          #endif // USB_DEVICE_CONFIG_MSC
    175                          error = kStatus_USB_Success;
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x0007             MOVS     R7,R0
    176                      }
    177                      break;
   \                     ??usb_device_callback_12: (+1)
   \   00000094   0xE079             B.N      ??usb_device_callback_11
    178                  case kUSB_DeviceEventSetInterface:
    179                      if (g_device_composite.attach)
   \                     ??usb_device_callback_2: (+1)
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable12_5
   \   0000009A   0xF890 0x0479      LDRB     R0,[R0, #+1145]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD01C             BEQ.N    ??usb_device_callback_13
    180                      {
    181                          uint8_t interface = (uint8_t)((*temp16 & 0xFF00U) >> 0x08U);
   \   000000A2   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   000000A6   0xEA5F 0x2A10      LSRS     R10,R0,#+8
    182                          uint8_t alternate_setting = (uint8_t)(*temp16 & 0x00FFU);
   \   000000AA   0xF8B8 0xB000      LDRH     R11,[R8, #+0]
    183                          if (interface < USB_COMPOSITE_INTERFACE_COUNT)
   \   000000AE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000B2   0xF1BA 0x0F02      CMP      R10,#+2
   \   000000B6   0xDA11             BGE.N    ??usb_device_callback_13
    184                          {
    185                              g_device_composite.current_interface_alternate_setting[interface] = alternate_setting;
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable12_5
   \   000000BC   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000C0   0x4450             ADD      R0,R0,R10
   \   000000C2   0xF880 0xB47B      STRB     R11,[R0, #+1147]
    186          #if USB_DEVICE_CONFIG_HID
    187                              usb_device_hid_generic_set_interface(g_device_composite.hid_generic.hid_handle, interface,
    188                                                                   alternate_setting);
   \   000000C6   0x465A             MOV      R2,R11
   \   000000C8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000CA   0x4651             MOV      R1,R10
   \   000000CC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable12_5
   \   000000D2   0x6880             LDR      R0,[R0, #+8]
   \   000000D4   0x.... 0x....      BL       usb_device_hid_generic_set_interface
    189          #endif
    190                              error = kStatus_USB_Success;
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x0007             MOVS     R7,R0
    191                          }
    192                      }
    193                      break;
   \                     ??usb_device_callback_13: (+1)
   \   000000DC   0xE055             B.N      ??usb_device_callback_11
    194                  case kUSB_DeviceEventGetConfiguration:
    195                      if (param)
   \                     ??usb_device_callback_9: (+1)
   \   000000DE   0x2E00             CMP      R6,#+0
   \   000000E0   0xD007             BEQ.N    ??usb_device_callback_14
    196                      {
    197                          *temp8 = g_device_composite.current_configuration;
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable12_5
   \   000000E6   0xF890 0x047A      LDRB     R0,[R0, #+1146]
   \   000000EA   0xF889 0x0000      STRB     R0,[R9, #+0]
    198                          error = kStatus_USB_Success;
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x0007             MOVS     R7,R0
    199                      }
    200                      break;
   \                     ??usb_device_callback_14: (+1)
   \   000000F2   0xE04A             B.N      ??usb_device_callback_11
    201                  case kUSB_DeviceEventGetInterface:
    202                      if (param)
   \                     ??usb_device_callback_10: (+1)
   \   000000F4   0x2E00             CMP      R6,#+0
   \   000000F6   0xD018             BEQ.N    ??usb_device_callback_15
    203                      {
    204                          uint8_t interface = (uint8_t)((*temp16 & 0xFF00) >> 0x08);
   \   000000F8   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   000000FC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000FE   0x0A00             LSRS     R0,R0,#+8
    205                          if (interface < USB_COMPOSITE_INTERFACE_COUNT)
   \   00000100   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000102   0x2802             CMP      R0,#+2
   \   00000104   0xDA0F             BGE.N    ??usb_device_callback_16
    206                          {
    207                              *temp16 = (*temp16 & 0xFF00) | g_device_composite.current_interface_alternate_setting[interface];
   \   00000106   0xF8B8 0x1000      LDRH     R1,[R8, #+0]
   \   0000010A   0xF411 0x417F      ANDS     R1,R1,#0xFF00
   \   0000010E   0x.... 0x....      LDR.W    R2,??DataTable12_5
   \   00000112   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000114   0x4402             ADD      R2,R2,R0
   \   00000116   0xF892 0x247B      LDRB     R2,[R2, #+1147]
   \   0000011A   0x4311             ORRS     R1,R2,R1
   \   0000011C   0xF8A8 0x1000      STRH     R1,[R8, #+0]
    208                              error = kStatus_USB_Success;
   \   00000120   0x2100             MOVS     R1,#+0
   \   00000122   0x000F             MOVS     R7,R1
   \   00000124   0xE001             B.N      ??usb_device_callback_15
    209                          }
    210                          else
    211                          {
    212                              error = kStatus_USB_InvalidRequest;
   \                     ??usb_device_callback_16: (+1)
   \   00000126   0x2105             MOVS     R1,#+5
   \   00000128   0x000F             MOVS     R7,R1
    213                          }
    214                      }
    215                      break;
   \                     ??usb_device_callback_15: (+1)
   \   0000012A   0xE02E             B.N      ??usb_device_callback_11
    216                  case kUSB_DeviceEventGetDeviceDescriptor:
    217                      if (param)
   \                     ??usb_device_callback_3: (+1)
   \   0000012C   0x2E00             CMP      R6,#+0
   \   0000012E   0xD004             BEQ.N    ??usb_device_callback_17
    218                      {
    219                          error = usb_device_get_device_descriptor(handle, (usb_device_get_device_descriptor_struct_t *)param);
   \   00000130   0x0031             MOVS     R1,R6
   \   00000132   0x0020             MOVS     R0,R4
   \   00000134   0x.... 0x....      BL       usb_device_get_device_descriptor
   \   00000138   0x0007             MOVS     R7,R0
    220                      }
    221                      break;
   \                     ??usb_device_callback_17: (+1)
   \   0000013A   0xE026             B.N      ??usb_device_callback_11
    222                  case kUSB_DeviceEventGetConfigurationDescriptor:
    223                      if (param)
   \                     ??usb_device_callback_4: (+1)
   \   0000013C   0x2E00             CMP      R6,#+0
   \   0000013E   0xD004             BEQ.N    ??usb_device_callback_18
    224                      {
    225                          error = usb_device_get_configuration_descriptor(
    226                              handle, (usb_device_get_configuration_descriptor_struct_t *)param);
   \   00000140   0x0031             MOVS     R1,R6
   \   00000142   0x0020             MOVS     R0,R4
   \   00000144   0x.... 0x....      BL       usb_device_get_configuration_descriptor
   \   00000148   0x0007             MOVS     R7,R0
    227                      }
    228                      break;
   \                     ??usb_device_callback_18: (+1)
   \   0000014A   0xE01E             B.N      ??usb_device_callback_11
    229                  case kUSB_DeviceEventGetStringDescriptor:
    230                      if (param)
   \                     ??usb_device_callback_5: (+1)
   \   0000014C   0x2E00             CMP      R6,#+0
   \   0000014E   0xD004             BEQ.N    ??usb_device_callback_19
    231                      {
    232                          error = usb_device_get_string_descriptor(handle, (usb_device_get_string_descriptor_struct_t *)param);
   \   00000150   0x0031             MOVS     R1,R6
   \   00000152   0x0020             MOVS     R0,R4
   \   00000154   0x.... 0x....      BL       usb_device_get_string_descriptor
   \   00000158   0x0007             MOVS     R7,R0
    233                      }
    234                      break;
   \                     ??usb_device_callback_19: (+1)
   \   0000015A   0xE016             B.N      ??usb_device_callback_11
    235                  case kUSB_DeviceEventGetHidDescriptor:
    236                      if (param)
   \                     ??usb_device_callback_6: (+1)
   \   0000015C   0x2E00             CMP      R6,#+0
   \   0000015E   0xD004             BEQ.N    ??usb_device_callback_20
    237                      {
    238                          error = usb_device_get_hid_descriptor(handle, (usb_device_get_hid_descriptor_struct_t *)param);
   \   00000160   0x0031             MOVS     R1,R6
   \   00000162   0x0020             MOVS     R0,R4
   \   00000164   0x.... 0x....      BL       usb_device_get_hid_descriptor
   \   00000168   0x0007             MOVS     R7,R0
    239                      }
    240                      break;
   \                     ??usb_device_callback_20: (+1)
   \   0000016A   0xE00E             B.N      ??usb_device_callback_11
    241                  case kUSB_DeviceEventGetHidReportDescriptor:
    242                      if (param)
   \                     ??usb_device_callback_7: (+1)
   \   0000016C   0x2E00             CMP      R6,#+0
   \   0000016E   0xD004             BEQ.N    ??usb_device_callback_21
    243                      {
    244                          error = usb_device_get_hid_report_descriptor(handle,
    245                                                                       (usb_device_get_hid_report_descriptor_struct_t *)param);
   \   00000170   0x0031             MOVS     R1,R6
   \   00000172   0x0020             MOVS     R0,R4
   \   00000174   0x.... 0x....      BL       usb_device_get_hid_report_descriptor
   \   00000178   0x0007             MOVS     R7,R0
    246                      }
    247                      break;
   \                     ??usb_device_callback_21: (+1)
   \   0000017A   0xE006             B.N      ??usb_device_callback_11
    248                  case kUSB_DeviceEventGetHidPhysicalDescriptor:
    249                      if (param)
   \                     ??usb_device_callback_8: (+1)
   \   0000017C   0x2E00             CMP      R6,#+0
   \   0000017E   0xD004             BEQ.N    ??usb_device_callback_22
    250                      {
    251                          error = usb_device_get_hid_physical_descriptor(
    252                              handle, (usb_device_get_hid_physical_descriptor_struct_t *)param);
   \   00000180   0x0031             MOVS     R1,R6
   \   00000182   0x0020             MOVS     R0,R4
   \   00000184   0x.... 0x....      BL       usb_device_get_hid_physical_descriptor
   \   00000188   0x0007             MOVS     R7,R0
    253                      }
    254                      break;
    255              }
    256          
    257              return error;
   \                     ??usb_device_callback_22: (+1)
   \                     ??usb_device_callback_11: (+1)
   \   0000018A   0x0038             MOVS     R0,R7
   \   0000018C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000018E   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    258          }
    259          

   \                                 In section .text, align 2, keep-with-next
    260          status_t usb_device_full_init(const peripheral_descriptor_t *self, serial_byte_receive_func_t function)
    261          {
   \                     usb_device_full_init: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    262              // Not used for USB
    263              (void)function;
    264          
    265              uint8_t irqNumber;
    266          #if defined(USB_DEVICE_CONFIG_EHCI) && (USB_DEVICE_CONFIG_EHCI > 0U)
    267              uint8_t usbDeviceEhciIrq[] = USBHS_IRQS;
    268              irqNumber = usbDeviceEhciIrq[CONTROLLER_ID - kUSB_ControllerEhci0];
    269          #endif
    270          #if defined(USB_DEVICE_CONFIG_KHCI) && (USB_DEVICE_CONFIG_KHCI > 0U)
    271              uint8_t usbDeviceKhciIrq[] = USB_IRQS;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable12_7
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    272              irqNumber = usbDeviceKhciIrq[CONTROLLER_ID - kUSB_ControllerKhci0];
   \   00000012   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000016   0x0006             MOVS     R6,R0
    273          #endif
    274          
    275              // Init the state info.
    276              memset(&g_device_composite, 0, sizeof(g_device_composite));
   \   00000018   0xF44F 0x6790      MOV      R7,#+1152
   \   0000001C   0xF05F 0x0800      MOVS     R8,#+0
   \   00000020   0x.... 0x....      LDR.W    R9,??DataTable12_5
   \   00000024   0x4642             MOV      R2,R8
   \   00000026   0x0039             MOVS     R1,R7
   \   00000028   0x4648             MOV      R0,R9
   \   0000002A   0x.... 0x....      BL       __aeabi_memset
    277          
    278              // Init the usb clock, if usb clock cannot be enabled, clear corresponding bit even it is enabled by user.
    279              if (!usb_clock_init())
   \   0000002E   0x.... 0x....      BL       usb_clock_init
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD11C             BNE.N    ??usb_device_full_init_0
    280              {
    281                  g_bootloaderContext.propertyInterface->store->configurationData.enabledPeripherals &= ~kPeripheralType_USB_HID;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable12_8
   \   0000003A   0x6880             LDR      R0,[R0, #+8]
   \   0000003C   0x6900             LDR      R0,[R0, #+16]
   \   0000003E   0xF890 0x007C      LDRB     R0,[R0, #+124]
   \   00000042   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   0000004A   0x6889             LDR      R1,[R1, #+8]
   \   0000004C   0x6909             LDR      R1,[R1, #+16]
   \   0000004E   0xF881 0x007C      STRB     R0,[R1, #+124]
    282                  g_bootloaderContext.propertyInterface->store->availablePeripherals &= ~kPeripheralType_USB_HID;
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable12_8
   \   00000056   0x6880             LDR      R0,[R0, #+8]
   \   00000058   0x6900             LDR      R0,[R0, #+16]
   \   0000005A   0x68C0             LDR      R0,[R0, #+12]
   \   0000005C   0xF07F 0x0110      MVNS     R1,#+16
   \   00000060   0x4008             ANDS     R0,R1,R0
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   00000066   0x6889             LDR      R1,[R1, #+8]
   \   00000068   0x6909             LDR      R1,[R1, #+16]
   \   0000006A   0x60C8             STR      R0,[R1, #+12]
    283                  return kStatus_Fail;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xE06C             B.N      ??usb_device_full_init_1
    284              }
    285          
    286              property_store_t *propertyStore = g_bootloaderContext.propertyInterface->store;
   \                     ??usb_device_full_init_0: (+1)
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable12_8
   \   00000074   0x6880             LDR      R0,[R0, #+8]
   \   00000076   0x6907             LDR      R7,[R0, #+16]
    287          
    288              if ((propertyStore->configurationData.usbPid != (uint16_t)0xFFFF) ||
    289                  (propertyStore->configurationData.usbVid != (uint16_t)0xFFFF))
   \   00000078   0xF8B7 0x0082      LDRH     R0,[R7, #+130]
   \   0000007C   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000080   0x4288             CMP      R0,R1
   \   00000082   0xD105             BNE.N    ??usb_device_full_init_2
   \   00000084   0xF8B7 0x0080      LDRH     R0,[R7, #+128]
   \   00000088   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000008C   0x4288             CMP      R0,R1
   \   0000008E   0xD017             BEQ.N    ??usb_device_full_init_3
    290              {
    291                  g_device_descriptor[kUsbDescriptorIndex_VidLow] = ((propertyStore->configurationData.usbVid) & 0xFF);
   \                     ??usb_device_full_init_2: (+1)
   \   00000090   0xF8B7 0x0080      LDRH     R0,[R7, #+128]
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable12_9
   \   00000098   0x7208             STRB     R0,[R1, #+8]
    292                  g_device_descriptor[kUsbDescriptorIndex_VidHigh] = ((propertyStore->configurationData.usbVid) & 0xFF00) >> 8;
   \   0000009A   0xF8B7 0x0080      LDRH     R0,[R7, #+128]
   \   0000009E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A0   0x0A00             LSRS     R0,R0,#+8
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable12_9
   \   000000A6   0x7248             STRB     R0,[R1, #+9]
    293                  g_device_descriptor[kUsbDescriptorIndex_PidLow] = ((propertyStore->configurationData.usbPid) & 0xFF);
   \   000000A8   0xF8B7 0x0082      LDRH     R0,[R7, #+130]
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable12_9
   \   000000B0   0x7288             STRB     R0,[R1, #+10]
    294                  g_device_descriptor[kUsbDescriptorIndex_PidHigh] = ((propertyStore->configurationData.usbPid) & 0xFF00) >> 8;
   \   000000B2   0xF8B7 0x0082      LDRH     R0,[R7, #+130]
   \   000000B6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B8   0x0A00             LSRS     R0,R0,#+8
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable12_9
   \   000000BE   0x72C8             STRB     R0,[R1, #+11]
    295              }
    296          
    297              if (propertyStore->configurationData.usbStringsPointer != 0xFFFFFFFF)
   \                     ??usb_device_full_init_3: (+1)
   \   000000C0   0xF8D7 0x0084      LDR      R0,[R7, #+132]
   \   000000C4   0xF110 0x0F01      CMN      R0,#+1
   \   000000C8   0xD004             BEQ.N    ??usb_device_full_init_4
    298              {
    299          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    300                  // Make sure the usb string isn't in execute-only region.
    301                  if (is_in_execute_only_region(propertyStore->configurationData.usbStringsPointer, sizeof(usb_language_list_t)))
    302                  {
    303                      g_language_ptr = &g_language_list;
    304                  }
    305                  else
    306          #endif // #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    307                  {
    308                      g_language_ptr = (usb_language_list_t *)propertyStore->configurationData.usbStringsPointer;
   \   000000CA   0xF8D7 0x0084      LDR      R0,[R7, #+132]
   \   000000CE   0x....             LDR.N    R1,??DataTable12_10
   \   000000D0   0x6008             STR      R0,[R1, #+0]
   \   000000D2   0xE002             B.N      ??usb_device_full_init_5
    309                  }
    310              }
    311              else
    312              {
    313                  g_language_ptr = &g_language_list;
   \                     ??usb_device_full_init_4: (+1)
   \   000000D4   0x....             LDR.N    R0,??DataTable12_11
   \   000000D6   0x....             LDR.N    R1,??DataTable12_10
   \   000000D8   0x6008             STR      R0,[R1, #+0]
    314              }
    315          
    316              g_device_composite.speed = USB_SPEED_FULL;
   \                     ??usb_device_full_init_5: (+1)
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0x....             LDR.N    R1,??DataTable12_5
   \   000000DE   0xF881 0x0478      STRB     R0,[R1, #+1144]
    317              g_device_composite.attach = 0;
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0x....             LDR.N    R1,??DataTable12_5
   \   000000E6   0xF881 0x0479      STRB     R0,[R1, #+1145]
    318          #if USB_DEVICE_CONFIG_HID
    319              g_device_composite.hid_generic.hid_handle = (class_handle_t)NULL;
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0x....             LDR.N    R1,??DataTable12_5
   \   000000EE   0x6088             STR      R0,[R1, #+8]
    320          #endif // USB_DEVICE_CONFIG_HID
    321          #if USB_DEVICE_CONFIG_MSC
    322              g_device_composite.msc_disk.msc_handle = (class_handle_t)NULL;
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0x....             LDR.N    R1,??DataTable12_5
   \   000000F4   0x6508             STR      R0,[R1, #+80]
    323          #endif // USB_DEVICE_CONFIG_MSC
    324              g_device_composite.device_handle = NULL;
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0x....             LDR.N    R1,??DataTable12_5
   \   000000FA   0x6008             STR      R0,[R1, #+0]
    325          
    326              if (kStatus_USB_Success !=
    327                  USB_DeviceClassInit(CONTROLLER_ID, &g_composite_device_config_list, &g_device_composite.device_handle))
   \   000000FC   0x....             LDR.N    R2,??DataTable12_5
   \   000000FE   0x....             LDR.N    R1,??DataTable12_12
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x.... 0x....      BL       USB_DeviceClassInit
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xD001             BEQ.N    ??usb_device_full_init_6
    328              {
    329                  return kStatus_Fail;
   \   0000010A   0x2001             MOVS     R0,#+1
   \   0000010C   0xE01D             B.N      ??usb_device_full_init_1
    330              }
    331              else
    332              {
    333          #if ((USB_DEVICE_CONFIG_HID == 1) && (USB_DEVICE_CONFIG_MSC == 1))
    334                  g_device_composite.msc_disk.msc_handle = g_composite_device_config_list.config[1].classHandle;
   \                     ??usb_device_full_init_6: (+1)
   \   0000010E   0x....             LDR.N    R0,??DataTable12_12
   \   00000110   0x6800             LDR      R0,[R0, #+0]
   \   00000112   0x6900             LDR      R0,[R0, #+16]
   \   00000114   0x....             LDR.N    R1,??DataTable12_5
   \   00000116   0x6508             STR      R0,[R1, #+80]
    335                  usb_device_msc_disk_init(&g_device_composite);
   \   00000118   0x....             LDR.N    R0,??DataTable12_5
   \   0000011A   0x.... 0x....      BL       usb_device_msc_disk_init
    336                  g_device_composite.hid_generic.hid_handle = g_composite_device_config_list.config[0].classHandle;
   \   0000011E   0x....             LDR.N    R0,??DataTable12_12
   \   00000120   0x6800             LDR      R0,[R0, #+0]
   \   00000122   0x6840             LDR      R0,[R0, #+4]
   \   00000124   0x....             LDR.N    R1,??DataTable12_5
   \   00000126   0x6088             STR      R0,[R1, #+8]
    337                  usb_device_hid_generic_init(&g_device_composite);
   \   00000128   0x....             LDR.N    R0,??DataTable12_5
   \   0000012A   0x.... 0x....      BL       usb_device_hid_generic_init
    338          #endif
    339          #if ((USB_DEVICE_CONFIG_MSC == 1) && (USB_DEVICE_CONFIG_HID == 0))
    340                  g_device_composite.msc_disk.msc_handle = g_composite_device_config_list.config[0].classHandle;
    341                  usb_device_msc_disk_init(&g_device_composite);
    342          #endif // USB_DEVICE_CONFIG_MSC
    343          #if ((USB_DEVICE_CONFIG_HID == 1) && (USB_DEVICE_CONFIG_MSC == 0))
    344                  g_device_composite.hid_generic.hid_handle = g_composite_device_config_list.config[0].classHandle;
    345                  usb_device_hid_generic_init(&g_device_composite);
    346          #endif // USB_DEVICE_CONFIG_HID
    347              }
    348          
    349              /* Install isr, set priority, and enable IRQ. */
    350              NVIC_SetPriority((IRQn_Type)irqNumber, USB_DEVICE_INTERRUPT_PRIORITY);
   \   0000012E   0x2104             MOVS     R1,#+4
   \   00000130   0x0030             MOVS     R0,R6
   \   00000132   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000134   0x.... 0x....      BL       NVIC_SetPriority
    351              NVIC_EnableIRQ((IRQn_Type)irqNumber);
   \   00000138   0x0030             MOVS     R0,R6
   \   0000013A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000013C   0x.... 0x....      BL       NVIC_EnableIRQ
    352          
    353              USB_DeviceRun(g_device_composite.device_handle);
   \   00000140   0x....             LDR.N    R0,??DataTable12_5
   \   00000142   0x6800             LDR      R0,[R0, #+0]
   \   00000144   0x.... 0x....      BL       USB_DeviceRun
    354          
    355              return kStatus_Success;
   \   00000148   0x2000             MOVS     R0,#+0
   \                     ??usb_device_full_init_1: (+1)
   \   0000014A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    356          }
    357          

   \                                 In section .text, align 2, keep-with-next
    358          void usb_device_full_shutdown(const peripheral_descriptor_t *self)
    359          {
   \                     usb_device_full_shutdown: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    360              if (kStatus_USB_Success != USB_DeviceClassDeinit(CONTROLLER_ID))
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       USB_DeviceClassDeinit
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD115             BNE.N    ??usb_device_full_shutdown_0
    361              {
    362                  return;
    363              }
    364              else
    365              {
    366          // Shutdown class driver
    367          #if USB_DEVICE_CONFIG_MSC
    368                  usb_device_msc_disk_deinit(&g_device_composite);
   \                     ??usb_device_full_shutdown_1: (+1)
   \   0000000E   0x....             LDR.N    R0,??DataTable12_5
   \   00000010   0x.... 0x....      BL       usb_device_msc_disk_deinit
    369          #endif // USB_DEVICE_CONFIG_MSC
    370          #if USB_DEVICE_CONFIG_HID
    371                  usb_device_hid_generic_deinit(&g_device_composite);
   \   00000014   0x....             LDR.N    R0,??DataTable12_5
   \   00000016   0x.... 0x....      BL       usb_device_hid_generic_deinit
    372          #endif // USB_DEVICE_CONFIG_MSC
    373              }
    374          
    375          // Make sure we are clocking to the peripheral to ensure there
    376          // are no bus errors
    377          #if defined(PCC_BASE_ADDRS)
    378              if ((self->instance == kUSB_ControllerEhci0) && ((*(volatile uint32_t *)kCLOCK_Usbfs0) & PCC_CLKCFG_CGC_MASK))
    379              {
    380                  // Disable the USB interrupt
    381                  NVIC_DisableIRQ(USB0_IRQn);
    382          
    383                  // Clear any pending interrupts on USB
    384                  NVIC_ClearPendingIRQ(USB0_IRQn);
    385          
    386                  // Turn off clocking to USB
    387                  CLOCK_DisableClock(kCLOCK_Usbfs0);
    388              }
    389          #else
    390              if ((CONTROLLER_ID == kUSB_ControllerKhci0) && (SIM->SCGC4 & SIM_SCGC4_USBOTG_MASK))
   \   0000001A   0x....             LDR.N    R0,??DataTable12_13  ;; 0x40048034
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x0340             LSLS     R0,R0,#+13
   \   00000020   0xD50B             BPL.N    ??usb_device_full_shutdown_2
    391              {
    392                  // Disable the USB interrupt
    393                  NVIC_DisableIRQ(USB0_IRQn);
   \   00000022   0x2035             MOVS     R0,#+53
   \   00000024   0x.... 0x....      BL       NVIC_DisableIRQ
    394          
    395                  // Clear any pending interrupts on USB
    396                  NVIC_ClearPendingIRQ(USB0_IRQn);
   \   00000028   0x2035             MOVS     R0,#+53
   \   0000002A   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    397          
    398                  // Turn off clocking to USB
    399                  SIM->SCGC4 &= ~SIM_SCGC4_USBOTG_MASK;
   \   0000002E   0x....             LDR.N    R0,??DataTable12_13  ;; 0x40048034
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   00000036   0x....             LDR.N    R1,??DataTable12_13  ;; 0x40048034
   \   00000038   0x6008             STR      R0,[R1, #+0]
    400              }
    401          #endif // defined(PCC_BASE_ADDRS)
    402          #if USB_DEVICE_CONFIG_EHCI
    403              else if ((CONTROLLER_ID == kUSB_ControllerEhci0) && (SIM->SCGC3 & SIM_SCGC3_USBHS_MASK))
    404              {
    405                  // Disable the USB interrupt
    406                  NVIC_DisableIRQ(USBHS_IRQn);
    407          
    408                  // Clear any pending interrupts on USB
    409                  NVIC_ClearPendingIRQ(USBHS_IRQn);
    410          
    411                  // Turn off HS USB PHY clock gate
    412                  SIM->SCGC3 &= ~(SIM_SCGC3_USBHS_MASK | SIM_SCGC3_USBHSPHY_MASK);
    413              }
    414          #endif
    415          }
   \                     ??usb_device_full_shutdown_2: (+1)
   \                     ??usb_device_full_shutdown_0: (+1)
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    416          
    417          //! @brief Run the sbloader state machine.
    418          //!
    419          //! This function is called repeatedly by the main application loop. We use it
    420          //! to run the sbloader state machine from non-interrupt context.

   \                                 In section .text, align 2, keep-with-next
    421          void usb_msc_pump(const peripheral_descriptor_t *self)
    422          {
   \                     usb_msc_pump: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    423              s_dHidMscActivity[USB_HID_INDEX] = false;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x....             LDR.N    R1,??DataTable12_6
   \   00000008   0x7008             STRB     R0,[R1, #+0]
    424              s_dHidMscActivity[USB_MSC_INDEX] = true;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x....             LDR.N    R1,??DataTable12_6
   \   0000000E   0x7048             STRB     R0,[R1, #+1]
    425          
    426          //#if (USB_DEVICE_CONFIG_MSC)
    427          #if (BL_CONFIG_USB_MSC || BL_CONFIG_HS_USB_MSC)
    428              lock_acquire();
   \   00000010   0x.... 0x....      BL       lock_acquire
    429              usb_device_msc_disk_pump();
   \   00000014   0x.... 0x....      BL       usb_device_msc_disk_pump
    430          
    431              if (g_device_composite.msc_disk.msc_state.sbLoaderStatus == kSbLoaderFinal)
   \   00000018   0x....             LDR.N    R0,??DataTable12_5
   \   0000001A   0xF890 0x045C      LDRB     R0,[R0, #+1116]
   \   0000001E   0x2803             CMP      R0,#+3
   \   00000020   0xD105             BNE.N    ??usb_msc_pump_0
    432              {
    433                  g_device_composite.msc_disk.msc_state.sbLoaderStatus = kSbLoaderFree;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR.N    R1,??DataTable12_5
   \   00000026   0xF881 0x045C      STRB     R0,[R1, #+1116]
    434                  sbloader_finalize();
   \   0000002A   0x.... 0x....      BL       sbloader_finalize
    435              }
    436              lock_release();
   \                     ??usb_msc_pump_0: (+1)
   \   0000002E   0x.... 0x....      BL       lock_release
    437          
    438              s_dHidMscActivity[USB_MSC_INDEX] = g_device_composite.msc_disk.msc_state.isActive;
   \   00000032   0x....             LDR.N    R0,??DataTable12_5
   \   00000034   0xF890 0x045A      LDRB     R0,[R0, #+1114]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD001             BEQ.N    ??usb_msc_pump_1
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xE000             B.N      ??usb_msc_pump_2
   \                     ??usb_msc_pump_1: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??usb_msc_pump_2: (+1)
   \   00000042   0x....             LDR.N    R1,??DataTable12_6
   \   00000044   0x7048             STRB     R0,[R1, #+1]
    439          #endif // BL_CONFIG_USB_MSC
    440          
    441              s_dHidMscActivity[USB_HID_INDEX] = true;
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x....             LDR.N    R1,??DataTable12_6
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
    442          }
   \   0000004C   0xBD10             POP      {R4,PC}          ;; return
    443          

   \                                 In section .text, align 2, keep-with-next
    444          static status_t usb_hid_packet_init(const peripheral_descriptor_t *self)
    445          {
   \                     usb_hid_packet_init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    446          #if USB_DEVICE_CONFIG_HID
    447              sync_init(&g_device_composite.hid_generic.hid_packet.receiveSync, false);
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x....             LDR.N    R0,??DataTable12_14
   \   00000008   0x.... 0x....      BL       sync_init
    448              sync_init(&g_device_composite.hid_generic.hid_packet.sendSync, false);
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x....             LDR.N    R0,??DataTable12_15
   \   00000010   0x.... 0x....      BL       sync_init
    449          
    450              // Check for any received data that may be pending
    451              sync_signal(&g_device_composite.hid_generic.hid_packet.receiveSync);
   \   00000014   0x....             LDR.N    R0,??DataTable12_14
   \   00000016   0x.... 0x....      BL       sync_signal
    452          #endif
    453              return kStatus_Success;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    454          }
    455          

   \                                 In section .text, align 2, keep-with-next
    456          static status_t usb_hid_packet_read(const peripheral_descriptor_t *self,
    457                                              uint8_t **packet,
    458                                              uint32_t *packetLength,
    459                                              packet_type_t packetType)
    460          {
   \                     usb_hid_packet_read: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    461              if (!packet || !packetLength)
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xD001             BEQ.N    ??usb_hid_packet_read_0
   \   00000010   0x2E00             CMP      R6,#+0
   \   00000012   0xD101             BNE.N    ??usb_hid_packet_read_1
    462              {
    463                  //        debug_printf("Error: invalid packet\r\n");
    464                  return kStatus_InvalidArgument;
   \                     ??usb_hid_packet_read_0: (+1)
   \   00000014   0x2004             MOVS     R0,#+4
   \   00000016   0xE051             B.N      ??usb_hid_packet_read_2
    465              }
    466              *packetLength = 0;
   \                     ??usb_hid_packet_read_1: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6030             STR      R0,[R6, #+0]
    467          
    468              // Determine report ID based on packet type.
    469              uint8_t reportID;
    470              switch (packetType)
   \   0000001C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000001E   0x2F00             CMP      R7,#+0
   \   00000020   0xD002             BEQ.N    ??usb_hid_packet_read_3
   \   00000022   0x2F01             CMP      R7,#+1
   \   00000024   0xD003             BEQ.N    ??usb_hid_packet_read_4
   \   00000026   0xE005             B.N      ??usb_hid_packet_read_5
    471              {
    472                  case kPacketType_Command:
    473                      reportID = kBootloaderReportID_CommandOut;
   \                     ??usb_hid_packet_read_3: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x4680             MOV      R8,R0
    474                      break;
   \   0000002C   0xE004             B.N      ??usb_hid_packet_read_6
    475                  case kPacketType_Data:
    476                      reportID = kBootloaderReportID_DataOut;
   \                     ??usb_hid_packet_read_4: (+1)
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0x4680             MOV      R8,R0
    477                      break;
   \   00000032   0xE001             B.N      ??usb_hid_packet_read_6
    478                  default:
    479                      //            debug_printf("usbhid: unsupported packet type %d\r\n", (int)packetType);
    480                      return kStatus_Fail;
   \                     ??usb_hid_packet_read_5: (+1)
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xE041             B.N      ??usb_hid_packet_read_2
    481              };
    482          #if USB_DEVICE_CONFIG_HID
    483              if (s_dHidMscActivity[USB_HID_INDEX])
   \                     ??usb_hid_packet_read_6: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable12_6
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD03C             BEQ.N    ??usb_hid_packet_read_7
    484              {
    485                  // The first receive data request was initiated after enumeration.
    486                  // After that we wait until we are ready to read data before
    487                  // we request more. This mechanism prevents data loss
    488                  // by allowing the USB controller to hold off the host with NAKs
    489                  // on the interrupt out pipe until we are ready.
    490                  if (g_device_composite.hid_generic.hid_packet.isReceiveDataRequestRequired)
   \   00000040   0x....             LDR.N    R0,??DataTable12_5
   \   00000042   0x7B80             LDRB     R0,[R0, #+14]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD006             BEQ.N    ??usb_hid_packet_read_8
    491                  {
    492                      // Initiate receive on interrupt out pipe.
    493                      USB_DeviceHidRecv(g_device_composite.hid_generic.hid_handle, USB_HID_GENERIC_ENDPOINT_OUT,
    494                                        (uint8_t *)&g_device_composite.hid_generic.hid_packet.report.header,
    495                                        sizeof(g_device_composite.hid_generic.hid_packet.report));
   \   00000048   0x2324             MOVS     R3,#+36
   \   0000004A   0x....             LDR.N    R2,??DataTable12_16
   \   0000004C   0x2102             MOVS     R1,#+2
   \   0000004E   0x....             LDR.N    R0,??DataTable12_5
   \   00000050   0x6880             LDR      R0,[R0, #+8]
   \   00000052   0x.... 0x....      BL       USB_DeviceHidRecv
    496                  }
    497          
    498                  g_device_composite.hid_generic.hid_packet.isReceiveDataRequestRequired = true;
   \                     ??usb_hid_packet_read_8: (+1)
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x....             LDR.N    R1,??DataTable12_5
   \   0000005A   0x7388             STRB     R0,[R1, #+14]
    499          
    500                  // Wait until we have received a report.
    501          
    502                  sync_wait(&g_device_composite.hid_generic.hid_packet.receiveSync, kSyncWaitForever);
   \   0000005C   0xF05F 0x31FF      MOVS     R1,#-1
   \   00000060   0x....             LDR.N    R0,??DataTable12_14
   \   00000062   0x.... 0x....      BL       sync_wait
    503          
    504                  // Check the report ID, the first byte of the report buffer.
    505                  if (g_device_composite.hid_generic.hid_packet.report.header.reportID != reportID)
   \   00000066   0x....             LDR.N    R0,??DataTable12_5
   \   00000068   0xF890 0x0020      LDRB     R0,[R0, #+32]
   \   0000006C   0x4641             MOV      R1,R8
   \   0000006E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000070   0x4288             CMP      R0,R1
   \   00000072   0xD00E             BEQ.N    ??usb_hid_packet_read_9
    506                  {
    507                      // If waiting for a command but get data, this is a flush after a data abort.
    508                      if ((reportID == kBootloaderReportID_CommandOut) &&
    509                          (g_device_composite.hid_generic.hid_packet.report.header.reportID == kBootloaderReportID_DataOut))
   \   00000074   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000078   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000007C   0xD107             BNE.N    ??usb_hid_packet_read_10
   \   0000007E   0x....             LDR.N    R0,??DataTable12_5
   \   00000080   0xF890 0x0020      LDRB     R0,[R0, #+32]
   \   00000084   0x2802             CMP      R0,#+2
   \   00000086   0xD102             BNE.N    ??usb_hid_packet_read_10
    510                      {
    511                          return kStatus_AbortDataPhase;
   \   00000088   0xF242 0x7012      MOVW     R0,#+10002
   \   0000008C   0xE016             B.N      ??usb_hid_packet_read_2
    512                      }
    513                      //        debug_printf("usbhid: received unexpected report=%x\r\n",
    514                      //        g_device_composite.hid_generic.hid_packet.report.header.reportID);
    515                      return kStatus_Fail;
   \                     ??usb_hid_packet_read_10: (+1)
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xE014             B.N      ??usb_hid_packet_read_2
    516                  }
    517          
    518                  // Extract the packet length encoded as bytes 1 and 2 of the report. The packet length
    519                  // is transferred in little endian byte order.
    520                  uint16_t lengthOfPacket = g_device_composite.hid_generic.hid_packet.report.header.packetLengthLsb |
    521                                            (g_device_composite.hid_generic.hid_packet.report.header.packetLengthMsb << 8);
   \                     ??usb_hid_packet_read_9: (+1)
   \   00000092   0x....             LDR.N    R0,??DataTable12_5
   \   00000094   0xF890 0x0022      LDRB     R0,[R0, #+34]
   \   00000098   0x....             LDR.N    R1,??DataTable12_5
   \   0000009A   0xF891 0x1023      LDRB     R1,[R1, #+35]
   \   0000009E   0xEA50 0x2101      ORRS     R1,R0,R1, LSL #+8
    522          
    523                  // Make sure we got all of the packet. Some hosts (Windows) may send up to the maximum
    524                  // report size, so there may be extra trailing bytes.
    525                  if ((g_device_composite.hid_generic.hid_packet.reportSize -
    526                       sizeof(g_device_composite.hid_generic.hid_packet.report.header)) < lengthOfPacket)
   \   000000A2   0x....             LDR.N    R0,??DataTable12_5
   \   000000A4   0x69C0             LDR      R0,[R0, #+28]
   \   000000A6   0x1F00             SUBS     R0,R0,#+4
   \   000000A8   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000AA   0x4288             CMP      R0,R1
   \   000000AC   0xD201             BCS.N    ??usb_hid_packet_read_11
    527                  {
    528                      //        debug_printf("usbhid: received only %d bytes of packet with length %d\r\n",
    529                      //        s_hidInfo[hidInfoIndex].reportSize - 3, lengthOfPacket);
    530                      return kStatus_Fail;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xE004             B.N      ??usb_hid_packet_read_2
    531                  }
    532          
    533                  // Return packet to caller.
    534                  *packet = g_device_composite.hid_generic.hid_packet.report.packet;
   \                     ??usb_hid_packet_read_11: (+1)
   \   000000B2   0x....             LDR.N    R0,??DataTable12_17
   \   000000B4   0x6028             STR      R0,[R5, #+0]
    535                  *packetLength = lengthOfPacket;
   \   000000B6   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000B8   0x6031             STR      R1,[R6, #+0]
    536              }
    537          #endif // USB_DEVICE_CONFIG_HID
    538              return kStatus_Success;
   \                     ??usb_hid_packet_read_7: (+1)
   \   000000BA   0x2000             MOVS     R0,#+0
   \                     ??usb_hid_packet_read_2: (+1)
   \   000000BC   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    539          }
    540          

   \                                 In section .text, align 2, keep-with-next
    541          static status_t usb_hid_packet_write(const peripheral_descriptor_t *self,
    542                                               const uint8_t *packet,
    543                                               uint32_t byteCount,
    544                                               packet_type_t packetType)
    545          {
   \                     usb_hid_packet_write: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    546          #if USB_DEVICE_CONFIG_HID
    547              if (s_dHidMscActivity[USB_HID_INDEX])
   \   0000000C   0x....             LDR.N    R0,??DataTable12_6
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD04B             BEQ.N    ??usb_hid_packet_write_0
    548              {
    549                  if (byteCount > kMinPacketBufferSize)
   \   00000014   0x2E21             CMP      R6,#+33
   \   00000016   0xD301             BCC.N    ??usb_hid_packet_write_1
    550                  {
    551                      debug_printf("Error: invalid packet size %d\r\n", byteCount);
    552                      return kStatus_InvalidArgument;
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0xE048             B.N      ??usb_hid_packet_write_2
    553                  }
    554          
    555                  // Determine report ID based on packet type.
    556                  uint8_t reportID;
    557                  switch (packetType)
   \                     ??usb_hid_packet_write_1: (+1)
   \   0000001C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000001E   0x2F00             CMP      R7,#+0
   \   00000020   0xD002             BEQ.N    ??usb_hid_packet_write_3
   \   00000022   0x2F01             CMP      R7,#+1
   \   00000024   0xD003             BEQ.N    ??usb_hid_packet_write_4
   \   00000026   0xE005             B.N      ??usb_hid_packet_write_5
    558                  {
    559                      case kPacketType_Command:
    560                          reportID = kBootloaderReportID_CommandIn;
   \                     ??usb_hid_packet_write_3: (+1)
   \   00000028   0x2003             MOVS     R0,#+3
   \   0000002A   0x4680             MOV      R8,R0
    561                          break;
   \   0000002C   0xE004             B.N      ??usb_hid_packet_write_6
    562                      case kPacketType_Data:
    563                          reportID = kBootloaderReportID_DataIn;
   \                     ??usb_hid_packet_write_4: (+1)
   \   0000002E   0x2004             MOVS     R0,#+4
   \   00000030   0x4680             MOV      R8,R0
    564                          break;
   \   00000032   0xE001             B.N      ??usb_hid_packet_write_6
    565                      default:
    566                          debug_printf("usbhid: unsupported packet type %d\r\n", (int)packetType);
    567                          return kStatus_Fail;
   \                     ??usb_hid_packet_write_5: (+1)
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xE03A             B.N      ??usb_hid_packet_write_2
    568                  };
    569          
    570                  // Check for data phase aborted by receiver.
    571                  lock_acquire();
   \                     ??usb_hid_packet_write_6: (+1)
   \   00000038   0x.... 0x....      BL       lock_acquire
    572                  if (g_device_composite.hid_generic.hid_packet.didReceiveDataPhaseAbort)
   \   0000003C   0x....             LDR.N    R0,??DataTable12_5
   \   0000003E   0x7B40             LDRB     R0,[R0, #+13]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD007             BEQ.N    ??usb_hid_packet_write_7
    573                  {
    574                      g_device_composite.hid_generic.hid_packet.didReceiveDataPhaseAbort = false;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x....             LDR.N    R1,??DataTable12_5
   \   00000048   0x7348             STRB     R0,[R1, #+13]
    575                      lock_release();
   \   0000004A   0x.... 0x....      BL       lock_release
    576                      return kStatus_AbortDataPhase;
   \   0000004E   0xF242 0x7012      MOVW     R0,#+10002
   \   00000052   0xE02C             B.N      ??usb_hid_packet_write_2
    577                  }
    578                  lock_release();
   \                     ??usb_hid_packet_write_7: (+1)
   \   00000054   0x.... 0x....      BL       lock_release
    579          
    580                  // Construct report contents.
    581                  g_device_composite.hid_generic.hid_packet.report.header.reportID = reportID;
   \   00000058   0x....             LDR.N    R0,??DataTable12_5
   \   0000005A   0xF880 0x8020      STRB     R8,[R0, #+32]
    582                  g_device_composite.hid_generic.hid_packet.report.header._padding = 0;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x....             LDR.N    R1,??DataTable12_5
   \   00000062   0xF881 0x0021      STRB     R0,[R1, #+33]
    583                  g_device_composite.hid_generic.hid_packet.report.header.packetLengthLsb = byteCount & 0xff;
   \   00000066   0x....             LDR.N    R0,??DataTable12_5
   \   00000068   0xF880 0x6022      STRB     R6,[R0, #+34]
    584                  g_device_composite.hid_generic.hid_packet.report.header.packetLengthMsb = (byteCount >> 8) & 0xff;
   \   0000006C   0x0A30             LSRS     R0,R6,#+8
   \   0000006E   0x....             LDR.N    R1,??DataTable12_5
   \   00000070   0xF881 0x0023      STRB     R0,[R1, #+35]
    585                  if (packet && byteCount > 0)
   \   00000074   0x2D00             CMP      R5,#+0
   \   00000076   0xD008             BEQ.N    ??usb_hid_packet_write_8
   \   00000078   0x2E00             CMP      R6,#+0
   \   0000007A   0xD006             BEQ.N    ??usb_hid_packet_write_8
    586                  {
    587                      memcpy(&g_device_composite.hid_generic.hid_packet.report.packet, packet, byteCount);
   \   0000007C   0x.... 0x....      LDR.W    R9,??DataTable12_17
   \   00000080   0x0032             MOVS     R2,R6
   \   00000082   0x0029             MOVS     R1,R5
   \   00000084   0x4648             MOV      R0,R9
   \   00000086   0x.... 0x....      BL       __aeabi_memcpy
    588                  }
    589                  if (g_device_composite.hid_generic.attach == 1)
   \                     ??usb_hid_packet_write_8: (+1)
   \   0000008A   0x....             LDR.N    R0,??DataTable12_5
   \   0000008C   0xF890 0x0046      LDRB     R0,[R0, #+70]
   \   00000090   0x2801             CMP      R0,#+1
   \   00000092   0xD10B             BNE.N    ??usb_hid_packet_write_0
    590                  {
    591                      // Send the maximum report size since that's what the host expects.
    592                      // There may be extra trailing bytes.
    593                      USB_DeviceHidSend(g_device_composite.hid_generic.hid_handle, USB_HID_GENERIC_ENDPOINT_IN,
    594                                        (uint8_t *)&g_device_composite.hid_generic.hid_packet.report.header,
    595                                        sizeof(g_device_composite.hid_generic.hid_packet.report));
   \   00000094   0x2324             MOVS     R3,#+36
   \   00000096   0x....             LDR.N    R2,??DataTable12_16
   \   00000098   0x2101             MOVS     R1,#+1
   \   0000009A   0x....             LDR.N    R0,??DataTable12_5
   \   0000009C   0x6880             LDR      R0,[R0, #+8]
   \   0000009E   0x.... 0x....      BL       USB_DeviceHidSend
    596                      sync_wait(&g_device_composite.hid_generic.hid_packet.sendSync, kSyncWaitForever);
   \   000000A2   0xF05F 0x31FF      MOVS     R1,#-1
   \   000000A6   0x....             LDR.N    R0,??DataTable12_15
   \   000000A8   0x.... 0x....      BL       sync_wait
    597                  }
    598              }
    599          #endif // USB_DEVICE_CONFIG_HID
    600              return kStatus_Success;
   \                     ??usb_hid_packet_write_0: (+1)
   \   000000AC   0x2000             MOVS     R0,#+0
   \                     ??usb_hid_packet_write_2: (+1)
   \   000000AE   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    601          }
    602          

   \                                 In section .text, align 2, keep-with-next
    603          static void usb_hid_packet_abort_data_phase(const peripheral_descriptor_t *self)
    604          {
   \                     usb_hid_packet_abort_data_phase: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    605              status_t status = self->packetInterface->writePacket(self, NULL, 0, kPacketType_Command);
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x6965             LDR      R5,[R4, #+20]
   \   0000000E   0x68AD             LDR      R5,[R5, #+8]
   \   00000010   0x47A8             BLX      R5
    606              if (status != kStatus_Success)
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD1FF             BNE.N    ??usb_hid_packet_abort_data_phase_0
    607              {
    608                  debug_printf("Error: usb_hid_packet_abort write packet returned status 0x%x\r\n", status);
    609                  return;
    610              }
    611          }
   \                     ??usb_hid_packet_abort_data_phase_1: (+1)
   \                     ??usb_hid_packet_abort_data_phase_0: (+1)
   \   00000016   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    612          

   \                                 In section .text, align 2, keep-with-next
    613          static status_t usb_hid_packet_finalize(const peripheral_descriptor_t *self)
    614          {
   \                     usb_hid_packet_finalize: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    615              return kStatus_Success;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
    616          }
    617          

   \                                 In section .text, align 2, keep-with-next
    618          static uint32_t usb_hid_packet_get_max_packet_size(const peripheral_descriptor_t *self)
    619          {
   \                     usb_hid_packet_get_max_packet_size: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    620              return kMinPacketBufferSize;
   \   00000002   0x2020             MOVS     R0,#+32
   \   00000004   0x4770             BX       LR               ;; return
    621          }
    622          
    623          #if defined(USB_DEVICE_CONFIG_EHCI) && (USB_DEVICE_CONFIG_EHCI > 0)
    624          void USBHS_IRQHandler(void)
    625          {
    626          #if USB_DEVICE_CONFIG_MSC
    627              if ((g_device_composite.msc_disk.msc_state.sbLoaderStatus == kSbLoaderLoading) ||
    628                  (g_device_composite.msc_disk.msc_state.sbLoaderStatus == kSbLoaderFinal))
    629              {
    630          #if USB_DEVICE_CONFIG_HID
    631                  sync_reset(&g_device_composite.hid_generic.hid_packet.receiveSync);
    632                  sync_reset(&g_device_composite.hid_generic.hid_packet.sendSync);
    633          #endif //#if USB_DEVICE_CONFIG_HID
    634              }
    635          #endif // USB_DEVICE_CONFIG_MSC
    636              USB_DeviceEhciIsrFunction(g_device_composite.device_handle);
    637          }
    638          #endif
    639          
    640          #if defined(USB_DEVICE_CONFIG_KHCI) && (USB_DEVICE_CONFIG_KHCI > 0)

   \                                 In section .text, align 2, keep-with-next
    641          void USB0_IRQHandler(void)
    642          {
   \                     USB0_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    643          #if USB_DEVICE_CONFIG_MSC
    644              if ((g_device_composite.msc_disk.msc_state.sbLoaderStatus == kSbLoaderLoading) ||
    645                  (g_device_composite.msc_disk.msc_state.sbLoaderStatus == kSbLoaderFinal))
   \   00000002   0x....             LDR.N    R0,??DataTable12_5
   \   00000004   0xF890 0x045C      LDRB     R0,[R0, #+1116]
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD004             BEQ.N    ??USB0_IRQHandler_0
   \   0000000C   0x....             LDR.N    R0,??DataTable12_5
   \   0000000E   0xF890 0x045C      LDRB     R0,[R0, #+1116]
   \   00000012   0x2803             CMP      R0,#+3
   \   00000014   0xD105             BNE.N    ??USB0_IRQHandler_1
    646              {
    647          #if USB_DEVICE_CONFIG_HID
    648                  sync_reset(&g_device_composite.hid_generic.hid_packet.receiveSync);
   \                     ??USB0_IRQHandler_0: (+1)
   \   00000016   0x....             LDR.N    R0,??DataTable12_14
   \   00000018   0x.... 0x....      BL       sync_reset
    649                  sync_reset(&g_device_composite.hid_generic.hid_packet.sendSync);
   \   0000001C   0x....             LDR.N    R0,??DataTable12_15
   \   0000001E   0x.... 0x....      BL       sync_reset
    650          #endif //#if USB_DEVICE_CONFIG_HID
    651              }
    652          #endif // USB_DEVICE_CONFIG_MSC
    653              USB_DeviceKhciIsrFunction(g_device_composite.device_handle);
   \                     ??USB0_IRQHandler_1: (+1)
   \   00000022   0x....             LDR.N    R0,??DataTable12_5
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x.... 0x....      BL       USB_DeviceKhciIsrFunction
    654          }
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0xE000ED18         DC32     0xe000ed18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0xE000E400         DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x........         DC32     g_device_composite

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x........         DC32     s_dHidMscActivity

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \   00000000   0x........         DC32     g_bootloaderContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \   00000000   0x........         DC32     g_device_descriptor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \   00000000   0x........         DC32     g_language_ptr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \   00000000   0x........         DC32     g_language_list

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \   00000000   0x........         DC32     g_composite_device_config_list

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_13:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_14:
   \   00000000   0x........         DC32     g_device_composite+0x14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_15:
   \   00000000   0x........         DC32     g_device_composite+0x18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_16:
   \   00000000   0x........         DC32     g_device_composite+0x20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_17:
   \   00000000   0x........         DC32     g_device_composite+0x24

   \                                 In section .rodata, align 1
   \                     ?_0:
   \   00000000   0x35               DC8 53
    655          #endif
    656          
    657          //! @}
    658          
    659          #endif // (BL_CONFIG_USB_HID || BL_CONFIG_HS_USB_HID || BL_CONFIG_USB_MSC || BL_CONFIG_HS_USB_MSC)
    660          
    661          ////////////////////////////////////////////////////////////////////////////////
    662          // EOF
    663          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   NVIC_ClearPendingIRQ
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ
       4   NVIC_SetPriority
       8   USB0_IRQHandler
         8   -> USB_DeviceKhciIsrFunction
         8   -> sync_reset
      40   usb_device_callback
        40   -> usb_device_get_configuration_descriptor
        40   -> usb_device_get_device_descriptor
        40   -> usb_device_get_hid_descriptor
        40   -> usb_device_get_hid_physical_descriptor
        40   -> usb_device_get_hid_report_descriptor
        40   -> usb_device_get_string_descriptor
        40   -> usb_device_hid_generic_set_configure
        40   -> usb_device_hid_generic_set_interface
        40   -> usb_device_msc_disk_set_configure
      32   usb_device_full_init
        32   -> NVIC_EnableIRQ
        32   -> NVIC_SetPriority
        32   -> USB_DeviceClassInit
        32   -> USB_DeviceRun
        32   -> __aeabi_memset
        32   -> usb_clock_init
        32   -> usb_device_hid_generic_init
        32   -> usb_device_msc_disk_init
       8   usb_device_full_shutdown
         8   -> NVIC_ClearPendingIRQ
         8   -> NVIC_DisableIRQ
         8   -> USB_DeviceClassDeinit
         8   -> usb_device_hid_generic_deinit
         8   -> usb_device_msc_disk_deinit
      16   usb_hid_packet_abort_data_phase
        16   -- Indirect call
       0   usb_hid_packet_finalize
       0   usb_hid_packet_get_max_packet_size
       8   usb_hid_packet_init
         8   -> sync_init
         8   -> sync_signal
      24   usb_hid_packet_read
        24   -> USB_DeviceHidRecv
        24   -> sync_wait
      32   usb_hid_packet_write
        32   -> USB_DeviceHidSend
        32   -> __aeabi_memcpy
        32   -> lock_acquire
        32   -> lock_release
        32   -> sync_wait
       0   usb_hid_poll_for_activity
       8   usb_msc_pump
         8   -> lock_acquire
         8   -> lock_release
         8   -> sbloader_finalize
         8   -> usb_device_msc_disk_pump


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_13
       4  ??DataTable12_14
       4  ??DataTable12_15
       4  ??DataTable12_16
       4  ??DataTable12_17
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
       1  ?_0
      22  NVIC_ClearPendingIRQ
      22  NVIC_DisableIRQ
      22  NVIC_EnableIRQ
      42  NVIC_SetPriority
      44  USB0_IRQHandler
    1152  g_device_composite
      16  g_usbHidControlInterface
      28  g_usbHidPacketInterface
       2  s_dHidMscActivity
     402  usb_device_callback
     334  usb_device_full_init
      60  usb_device_full_shutdown
      24  usb_hid_packet_abort_data_phase
       6  usb_hid_packet_finalize
       6  usb_hid_packet_get_max_packet_size
      30  usb_hid_packet_init
     192  usb_hid_packet_read
     178  usb_hid_packet_write
      66  usb_hid_poll_for_activity
      78  usb_msc_pump

 
 1 154 bytes in section .bss
    45 bytes in section .rodata
 1 600 bytes in section .text
 
 1 600 bytes of CODE  memory
    45 bytes of CONST memory
 1 154 bytes of DATA  memory

Errors: none
Warnings: none
