###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:01
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\crc\fsl_crc.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\crc\fsl_crc.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\fsl_crc.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\fsl_crc.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\crc\fsl_crc.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          #include "fsl_crc.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_EnableClock(clock_ip_name_t)
   \                     CLOCK_EnableClock: (+1)
   \   00000000   0x0C01             LSRS     R1,R0,#+16
   \   00000002   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000006   0xF511 0x218E      ADDS     R1,R1,#+290816
   \   0000000A   0x680A             LDR      R2,[R1, #+0]
   \   0000000C   0x2301             MOVS     R3,#+1
   \   0000000E   0x4083             LSLS     R3,R3,R0
   \   00000010   0x431A             ORRS     R2,R3,R2
   \   00000012   0x600A             STR      R2,[R1, #+0]
   \   00000014   0x4770             BX       LR               ;; return
     31          
     32          /*******************************************************************************
     33           * Definitions
     34           ******************************************************************************/
     35          
     36          #if defined(CRC_DRIVER_USE_CRC16_CCIT_FALSE_AS_DEFAULT) && CRC_DRIVER_USE_CRC16_CCIT_FALSE_AS_DEFAULT
     37          /* @brief Default user configuration structure for CRC-16-CCITT */
     38          #define CRC_DRIVER_DEFAULT_POLYNOMIAL 0x1021U
     39          /*< CRC-16-CCIT polynomial x**16 + x**12 + x**5 + x**0 */
     40          #define CRC_DRIVER_DEFAULT_SEED 0xFFFFU
     41          /*< Default initial checksum */
     42          #define CRC_DRIVER_DEFAULT_REFLECT_IN false
     43          /*< Default is no transpose */
     44          #define CRC_DRIVER_DEFAULT_REFLECT_OUT false
     45          /*< Default is transpose bytes */
     46          #define CRC_DRIVER_DEFAULT_COMPLEMENT_CHECKSUM false
     47          /*< Default is without complement of CRC data register read data */
     48          #define CRC_DRIVER_DEFAULT_CRC_BITS kCrcBits16
     49          /*< Default is 16-bit CRC protocol */
     50          #define CRC_DRIVER_DEFAULT_CRC_RESULT kCrcFinalChecksum
     51          /*< Default is resutl type is final checksum */
     52          #endif /* CRC_DRIVER_USE_CRC16_CCIT_FALSE_AS_DEFAULT */
     53          
     54          /*! @brief CRC type of transpose of read write data */
     55          typedef enum _crc_transpose_type
     56          {
     57              kCrcTransposeNone = 0U,         /*! No transpose  */
     58              kCrcTransposeBits = 1U,         /*! Tranpose bits in bytes  */
     59              kCrcTransposeBitsAndBytes = 2U, /*! Transpose bytes and bits in bytes */
     60              kCrcTransposeBytes = 3U,        /*! Transpose bytes */
     61          } crc_transpose_type_t;
     62          
     63          /*!
     64          * @brief CRC module configuration.
     65          *
     66          * This structure holds the configuration for the CRC module.
     67          */
     68          typedef struct _crc_module_config
     69          {
     70              uint32_t polynomial;                 /*!< CRC Polynomial, MSBit first.@n
     71                                                        Example polynomial: 0x1021 = 1_0000_0010_0001 = x^12+x^5+1 */
     72              uint32_t seed;                       /*!< Starting checksum value */
     73              crc_transpose_type_t readTranspose;  /*!< Type of transpose when reading CRC result. */
     74              crc_transpose_type_t writeTranspose; /*!< Type of transpose when writing CRC input data. */
     75              bool complementChecksum;             /*!< True if the result shall be complement of the actual checksum. */
     76              crc_bits_t crcBits;                  /*!< Selects 16- or 32- bit CRC protocol. */
     77          } crc_module_config_t;
     78          
     79          /*******************************************************************************
     80           * Code
     81           ******************************************************************************/
     82          
     83          /*!
     84           * @brief Returns transpose type for CRC protocol reflect in parameter.
     85           *
     86           * This functions helps to set writeTranspose member of crc_config_t structure. Reflect in is CRC protocol parameter.
     87           *
     88           * @param enable True or false for the selected CRC protocol Reflect In (refin) parameter.
     89           */

   \                                 In section .text, align 2, keep-with-next
     90          static inline crc_transpose_type_t crc_GetTransposeTypeFromReflectIn(bool enable)
     91          {
     92              return ((enable) ? kCrcTransposeBitsAndBytes : kCrcTransposeBytes);
   \                     crc_GetTransposeTypeFromReflectIn: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD001             BEQ.N    ??crc_GetTransposeTypeFromReflectIn_0
   \   00000006   0x2002             MOVS     R0,#+2
   \   00000008   0xE000             B.N      ??crc_GetTransposeTypeFromReflectIn_1
   \                     ??crc_GetTransposeTypeFromReflectIn_0: (+1)
   \   0000000A   0x2003             MOVS     R0,#+3
   \                     ??crc_GetTransposeTypeFromReflectIn_1: (+1)
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x4770             BX       LR               ;; return
     93          }
     94          
     95          /*!
     96           * @brief Returns transpose type for CRC protocol reflect out parameter.
     97           *
     98           * This functions helps to set readTranspose member of crc_config_t structure. Reflect out is CRC protocol parameter.
     99           *
    100           * @param enable True or false for the selected CRC protocol Reflect Out (refout) parameter.
    101           */

   \                                 In section .text, align 2, keep-with-next
    102          static inline crc_transpose_type_t crc_GetTransposeTypeFromReflectOut(bool enable)
    103          {
    104              return ((enable) ? kCrcTransposeBitsAndBytes : kCrcTransposeNone);
   \                     crc_GetTransposeTypeFromReflectOut: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD001             BEQ.N    ??crc_GetTransposeTypeFromReflectOut_0
   \   00000006   0x2002             MOVS     R0,#+2
   \   00000008   0xE000             B.N      ??crc_GetTransposeTypeFromReflectOut_1
   \                     ??crc_GetTransposeTypeFromReflectOut_0: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \                     ??crc_GetTransposeTypeFromReflectOut_1: (+1)
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x4770             BX       LR               ;; return
    105          }
    106          
    107          /*!
    108           * @brief Starts checksum computation.
    109           *
    110           * Configures the CRC module for the specified CRC protocol. @n
    111           * Starts the checksum computation by writing the seed value
    112           *
    113           * @param base CRC peripheral address.
    114           * @param config Pointer to protocol configuration structure.
    115           */

   \                                 In section .text, align 2, keep-with-next
    116          static void crc_ConfigureAndStart(CRC_Type *base, const crc_module_config_t *config)
    117          {
   \                     crc_ConfigureAndStart: (+1)
   \   00000000   0xB410             PUSH     {R4}
    118              uint32_t crcControl;
    119          
    120              /* pre-compute value for CRC control registger based on user configuraton without WAS field */
    121              crcControl = 0 | CRC_CTRL_TOT(config->writeTranspose) | CRC_CTRL_TOTR(config->readTranspose) |
    122                           CRC_CTRL_FXOR(config->complementChecksum) | CRC_CTRL_TCRC(config->crcBits);
   \   00000002   0x7A4B             LDRB     R3,[R1, #+9]
   \   00000004   0x7A0C             LDRB     R4,[R1, #+8]
   \   00000006   0x0724             LSLS     R4,R4,#+28
   \   00000008   0xF014 0x5440      ANDS     R4,R4,#0x30000000
   \   0000000C   0xEA54 0x7383      ORRS     R3,R4,R3, LSL #+30
   \   00000010   0x7A8C             LDRB     R4,[R1, #+10]
   \   00000012   0xEA53 0x6384      ORRS     R3,R3,R4, LSL #+26
   \   00000016   0x7ACC             LDRB     R4,[R1, #+11]
   \   00000018   0x0624             LSLS     R4,R4,#+24
   \   0000001A   0xF014 0x7480      ANDS     R4,R4,#0x1000000
   \   0000001E   0x4323             ORRS     R3,R4,R3
   \   00000020   0x001A             MOVS     R2,R3
    123          
    124              /* make sure the control register is clear - WAS is deasserted, and protocol is set */
    125              base->CTRL = crcControl;
   \   00000022   0x6082             STR      R2,[R0, #+8]
    126          
    127              /* write polynomial register */
    128              base->GPOLY = config->polynomial;
   \   00000024   0x680B             LDR      R3,[R1, #+0]
   \   00000026   0x6043             STR      R3,[R0, #+4]
    129          
    130              /* write pre-computed control register value along with WAS to start checksum computation */
    131              base->CTRL = crcControl | CRC_CTRL_WAS(true);
   \   00000028   0xF052 0x7300      ORRS     R3,R2,#0x2000000
   \   0000002C   0x6083             STR      R3,[R0, #+8]
    132          
    133              /* write seed (initial checksum) */
    134              base->DATA = config->seed;
   \   0000002E   0x684B             LDR      R3,[R1, #+4]
   \   00000030   0x6003             STR      R3,[R0, #+0]
    135          
    136              /* deassert WAS by writing pre-computed CRC control register value */
    137              base->CTRL = crcControl;
   \   00000032   0x6082             STR      R2,[R0, #+8]
    138          }
   \   00000034   0xBC10             POP      {R4}
   \   00000036   0x4770             BX       LR               ;; return
    139          
    140          /*!
    141           * @brief Starts final checksum computation.
    142           *
    143           * Configures the CRC module for the specified CRC protocol. @n
    144           * Starts final checksum computation by writing the seed value.
    145           * @note CRC_Get16bitResult() or CRC_Get32bitResult() return final checksum
    146           *       (output reflection and xor functions are applied).
    147           *
    148           * @param base CRC peripheral address.
    149           * @param protocolConfig Pointer to protocol configuration structure.
    150           */

   \                                 In section .text, align 2, keep-with-next
    151          static void crc_SetProtocolConfig(CRC_Type *base, const crc_config_t *protocolConfig)
    152          {
   \                     crc_SetProtocolConfig: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    153              crc_module_config_t moduleConfig;
    154              /* convert protocol to CRC peripheral module configuration, prepare for final checksum */
    155              moduleConfig.polynomial = protocolConfig->polynomial;
   \   00000006   0x6828             LDR      R0,[R5, #+0]
   \   00000008   0x9000             STR      R0,[SP, #+0]
    156              moduleConfig.seed = protocolConfig->seed;
   \   0000000A   0x6868             LDR      R0,[R5, #+4]
   \   0000000C   0x9001             STR      R0,[SP, #+4]
    157              moduleConfig.readTranspose = crc_GetTransposeTypeFromReflectOut(protocolConfig->reflectOut);
   \   0000000E   0x7A68             LDRB     R0,[R5, #+9]
   \   00000010   0x.... 0x....      BL       crc_GetTransposeTypeFromReflectOut
   \   00000014   0xF88D 0x0008      STRB     R0,[SP, #+8]
    158              moduleConfig.writeTranspose = crc_GetTransposeTypeFromReflectIn(protocolConfig->reflectIn);
   \   00000018   0x7A28             LDRB     R0,[R5, #+8]
   \   0000001A   0x.... 0x....      BL       crc_GetTransposeTypeFromReflectIn
   \   0000001E   0xF88D 0x0009      STRB     R0,[SP, #+9]
    159              moduleConfig.complementChecksum = protocolConfig->complementChecksum;
   \   00000022   0x7AA8             LDRB     R0,[R5, #+10]
   \   00000024   0xF88D 0x000A      STRB     R0,[SP, #+10]
    160              moduleConfig.crcBits = protocolConfig->crcBits;
   \   00000028   0x7AE8             LDRB     R0,[R5, #+11]
   \   0000002A   0xF88D 0x000B      STRB     R0,[SP, #+11]
    161          
    162              crc_ConfigureAndStart(base, &moduleConfig);
   \   0000002E   0x4669             MOV      R1,SP
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       crc_ConfigureAndStart
    163          }
   \   00000036   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    164          
    165          /*!
    166           * @brief Starts intermediate checksum computation.
    167           *
    168           * Configures the CRC module for the specified CRC protocol. @n
    169           * Starts intermediate checksum computation by writing the seed value.
    170           * @note CRC_Get16bitResult() or CRC_Get32bitResult() return intermediate checksum (raw data register value).
    171           *
    172           * @param base CRC peripheral address.
    173           * @param protocolConfig Pointer to protocol configuration structure.
    174           */

   \                                 In section .text, align 2, keep-with-next
    175          static void crc_SetRawProtocolConfig(CRC_Type *base, const crc_config_t *protocolConfig)
    176          {
   \                     crc_SetRawProtocolConfig: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    177              crc_module_config_t moduleConfig;
    178              /* convert protocol to CRC peripheral module configuration, prepare for intermediate checksum */
    179              moduleConfig.polynomial = protocolConfig->polynomial;
   \   00000006   0x6828             LDR      R0,[R5, #+0]
   \   00000008   0x9000             STR      R0,[SP, #+0]
    180              moduleConfig.seed = protocolConfig->seed;
   \   0000000A   0x6868             LDR      R0,[R5, #+4]
   \   0000000C   0x9001             STR      R0,[SP, #+4]
    181              moduleConfig.readTranspose =
    182                  kCrcTransposeNone; /* intermediate checksum does no transpose of data register read value */
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF88D 0x0008      STRB     R0,[SP, #+8]
    183              moduleConfig.writeTranspose = crc_GetTransposeTypeFromReflectIn(protocolConfig->reflectIn);
   \   00000014   0x7A28             LDRB     R0,[R5, #+8]
   \   00000016   0x.... 0x....      BL       crc_GetTransposeTypeFromReflectIn
   \   0000001A   0xF88D 0x0009      STRB     R0,[SP, #+9]
    184              moduleConfig.complementChecksum = false; /* intermediate checksum does no xor of data register read value */
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF88D 0x000A      STRB     R0,[SP, #+10]
    185              moduleConfig.crcBits = protocolConfig->crcBits;
   \   00000024   0x7AE8             LDRB     R0,[R5, #+11]
   \   00000026   0xF88D 0x000B      STRB     R0,[SP, #+11]
    186          
    187              crc_ConfigureAndStart(base, &moduleConfig);
   \   0000002A   0x4669             MOV      R1,SP
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       crc_ConfigureAndStart
    188          }
   \   00000032   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    189          

   \                                 In section .text, align 2, keep-with-next
    190          void CRC_Init(CRC_Type *base, const crc_config_t *config)
    191          {
   \                     CRC_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    192              /* ungate clock */
    193              CLOCK_EnableClock(kCLOCK_Crc0);
   \   00000006   0x....             LDR.N    R0,??DataTable1  ;; 0x103c0012
   \   00000008   0x.... 0x....      BL       CLOCK_EnableClock
    194              /* configure CRC module and write the seed */
    195              if (config->crcResult == kCrcFinalChecksum)
   \   0000000C   0x7B28             LDRB     R0,[R5, #+12]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD104             BNE.N    ??CRC_Init_0
    196              {
    197                  crc_SetProtocolConfig(base, config);
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       crc_SetProtocolConfig
   \   0000001A   0xE003             B.N      ??CRC_Init_1
    198              }
    199              else
    200              {
    201                  crc_SetRawProtocolConfig(base, config);
   \                     ??CRC_Init_0: (+1)
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       crc_SetRawProtocolConfig
    202              }
    203          }
   \                     ??CRC_Init_1: (+1)
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    204          

   \                                 In section .text, align 2, keep-with-next
    205          void CRC_GetDefaultConfig(crc_config_t *config)
    206          {
   \                     CRC_GetDefaultConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0004             MOVS     R4,R0
    207              static const crc_config_t crc16ccit = {
    208                  CRC_DRIVER_DEFAULT_POLYNOMIAL,          CRC_DRIVER_DEFAULT_SEED,
    209                  CRC_DRIVER_DEFAULT_REFLECT_IN,          CRC_DRIVER_DEFAULT_REFLECT_OUT,
    210                  CRC_DRIVER_DEFAULT_COMPLEMENT_CHECKSUM, CRC_DRIVER_DEFAULT_CRC_BITS,
    211                  CRC_DRIVER_DEFAULT_CRC_RESULT,
    212              };
    213          
    214              *config = crc16ccit;
   \   00000004   0x....             LDR.N    R0,??DataTable1_1
   \   00000006   0xC80F             LDM      R0,{R0-R3}
   \   00000008   0x0025             MOVS     R5,R4
   \   0000000A   0xE885 0x000F      STM      R5,{R0-R3}
    215          }
   \   0000000E   0xBC30             POP      {R4,R5}
   \   00000010   0x4770             BX       LR               ;; return

   \                                 In section .rodata, align 4
   \                     `CRC_GetDefaultConfig::crc16ccit`:
   \   00000000   0x00001021         DC32 4129, 65535
   \              0x0000FFFF   
   \   00000008   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    216          

   \                                 In section .text, align 2, keep-with-next
    217          void CRC_WriteData(CRC_Type *base, const uint8_t *data, size_t dataSize)
    218          {
   \                     CRC_WriteData: (+1)
   \   00000000   0xB410             PUSH     {R4}
    219              const uint32_t *data32;
    220          
    221              /* 8-bit reads and writes till source address is aligned 4 bytes */
    222              while ((dataSize) && ((uint32_t)data & 3U))
   \                     ??CRC_WriteData_0: (+1)
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD008             BEQ.N    ??CRC_WriteData_1
   \   00000006   0xF011 0x0403      ANDS     R4,R1,#0x3
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD004             BEQ.N    ??CRC_WriteData_1
    223              {
    224                  base->ACCESS8BIT.DATALL = *data;
   \   0000000E   0x780C             LDRB     R4,[R1, #+0]
   \   00000010   0x7004             STRB     R4,[R0, #+0]
    225                  data++;
   \   00000012   0x1C49             ADDS     R1,R1,#+1
    226                  dataSize--;
   \   00000014   0x1E52             SUBS     R2,R2,#+1
   \   00000016   0xE7F4             B.N      ??CRC_WriteData_0
    227              }
    228          
    229              /* use 32-bit reads and writes as long as possible */
    230              data32 = (const uint32_t *)data;
   \                     ??CRC_WriteData_1: (+1)
   \   00000018   0x000B             MOVS     R3,R1
    231              while (dataSize >= sizeof(uint32_t))
   \                     ??CRC_WriteData_2: (+1)
   \   0000001A   0x2A04             CMP      R2,#+4
   \   0000001C   0xD304             BCC.N    ??CRC_WriteData_3
    232              {
    233                  base->DATA = *data32;
   \   0000001E   0x681C             LDR      R4,[R3, #+0]
   \   00000020   0x6004             STR      R4,[R0, #+0]
    234                  data32++;
   \   00000022   0x1D1B             ADDS     R3,R3,#+4
    235                  dataSize -= sizeof(uint32_t);
   \   00000024   0x1F12             SUBS     R2,R2,#+4
   \   00000026   0xE7F8             B.N      ??CRC_WriteData_2
    236              }
    237          
    238              data = (const uint8_t *)data32;
   \                     ??CRC_WriteData_3: (+1)
   \   00000028   0x0019             MOVS     R1,R3
    239          
    240              /* 8-bit reads and writes till end of data buffer */
    241              while (dataSize)
   \                     ??CRC_WriteData_4: (+1)
   \   0000002A   0x2A00             CMP      R2,#+0
   \   0000002C   0xD004             BEQ.N    ??CRC_WriteData_5
    242              {
    243                  base->ACCESS8BIT.DATALL = *data;
   \   0000002E   0x780C             LDRB     R4,[R1, #+0]
   \   00000030   0x7004             STRB     R4,[R0, #+0]
    244                  data++;
   \   00000032   0x1C49             ADDS     R1,R1,#+1
    245                  dataSize--;
   \   00000034   0x1E52             SUBS     R2,R2,#+1
   \   00000036   0xE7F8             B.N      ??CRC_WriteData_4
    246              }
    247          }
   \                     ??CRC_WriteData_5: (+1)
   \   00000038   0xBC10             POP      {R4}
   \   0000003A   0x4770             BX       LR               ;; return
    248          

   \                                 In section .text, align 2, keep-with-next
    249          uint16_t CRC_Get16bitResult(CRC_Type *base)
    250          {
   \                     CRC_Get16bitResult: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    251              uint32_t retval;
    252              uint32_t totr; /* type of transpose read bitfield */
    253          
    254              retval = base->DATA;
   \   00000002   0x680B             LDR      R3,[R1, #+0]
   \   00000004   0x0018             MOVS     R0,R3
    255              totr = (base->CTRL & CRC_CTRL_TOTR_MASK) >> CRC_CTRL_TOTR_SHIFT;
   \   00000006   0x688B             LDR      R3,[R1, #+8]
   \   00000008   0xF3C3 0x7301      UBFX     R3,R3,#+28,#+2
   \   0000000C   0x001A             MOVS     R2,R3
    256          
    257              /* check transpose type to get 16-bit out of 32-bit register */
    258              if (totr >= 2U)
   \   0000000E   0x2A02             CMP      R2,#+2
   \   00000010   0xD303             BCC.N    ??CRC_Get16bitResult_0
    259              {
    260                  /* transpose of bytes for read is set, the result CRC is in CRC_DATA[HU:HL] */
    261                  retval &= 0xFFFF0000U;
   \   00000012   0x0C00             LSRS     R0,R0,#+16
   \   00000014   0x0400             LSLS     R0,R0,#+16
    262                  retval = retval >> 16U;
   \   00000016   0x0C00             LSRS     R0,R0,#+16
   \   00000018   0xE000             B.N      ??CRC_Get16bitResult_1
    263              }
    264              else
    265              {
    266                  /* no transpose of bytes for read, the result CRC is in CRC_DATA[LU:LL] */
    267                  retval &= 0x0000FFFFU;
   \                     ??CRC_Get16bitResult_0: (+1)
   \   0000001A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
    268              }
    269              return (uint16_t)retval;
   \                     ??CRC_Get16bitResult_1: (+1)
   \   0000001C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001E   0x4770             BX       LR               ;; return
    270          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x103C0012         DC32     0x103c0012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     `CRC_GetDefaultConfig::crc16ccit`

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CLOCK_EnableClock
       0   CRC_Get16bitResult
       8   CRC_GetDefaultConfig
      16   CRC_Init
        16   -> CLOCK_EnableClock
        16   -> crc_SetProtocolConfig
        16   -> crc_SetRawProtocolConfig
       4   CRC_WriteData
       4   crc_ConfigureAndStart
       0   crc_GetTransposeTypeFromReflectIn
       0   crc_GetTransposeTypeFromReflectOut
      24   crc_SetProtocolConfig
        24   -> crc_ConfigureAndStart
        24   -> crc_GetTransposeTypeFromReflectIn
        24   -> crc_GetTransposeTypeFromReflectOut
      24   crc_SetRawProtocolConfig
        24   -> crc_ConfigureAndStart
        24   -> crc_GetTransposeTypeFromReflectIn


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
      22  CLOCK_EnableClock
      32  CRC_Get16bitResult
      18  CRC_GetDefaultConfig
      38  CRC_Init
      60  CRC_WriteData
      16  crc16ccit
      56  crc_ConfigureAndStart
      16  crc_GetTransposeTypeFromReflectIn
      16  crc_GetTransposeTypeFromReflectOut
      56  crc_SetProtocolConfig
      52  crc_SetRawProtocolConfig

 
  16 bytes in section .rodata
 374 bytes in section .text
 
 374 bytes of CODE  memory
  16 bytes of CONST memory

Errors: none
Warnings: none
