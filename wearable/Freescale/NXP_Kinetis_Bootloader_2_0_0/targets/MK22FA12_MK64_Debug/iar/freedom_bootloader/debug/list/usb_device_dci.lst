###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:14
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\usb_device_dci.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\usb_device_dci.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\usb_device_dci.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\usb_device_dci.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\usb_device_dci.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "usb_device_config.h"
     32          #include "usb.h"
     33          
     34          #include "usb_device.h"
     35          #include "usb_device_dci.h"
     36          
     37          #include "fsl_device_registers.h"
     38          
     39          #if ((defined(USB_DEVICE_CONFIG_NUM)) && (USB_DEVICE_CONFIG_NUM > 0U))
     40          
     41          #if ((defined(USB_DEVICE_CONFIG_KHCI)) && (USB_DEVICE_CONFIG_KHCI > 0U))
     42          #include "usb_device_khci.h"
     43          #endif
     44          
     45          #if ((defined(USB_DEVICE_CONFIG_EHCI)) && (USB_DEVICE_CONFIG_EHCI > 0U))
     46          #include "usb_device_ehci.h"
     47          #endif
     48          
     49          #include "usb_device_ch9.h"
     50          
     51          /*******************************************************************************
     52           * Definitions
     53           ******************************************************************************/
     54          
     55          /*******************************************************************************
     56           * Prototypes
     57           ******************************************************************************/
     58          static usb_status_t USB_DeviceAllocateHandle(uint8_t controllerId, usb_device_struct_t **handle);
     59          static usb_status_t USB_DeviceFreeHandle(usb_device_struct_t *handle);
     60          static usb_status_t USB_DeviceGetControllerInterface(
     61              uint8_t controllerId, const usb_device_controller_interface_struct_t **controllerInterface);
     62          static usb_status_t USB_DeviceTransfer(usb_device_handle handle,
     63                                                 uint8_t endpointAddress,
     64                                                 uint8_t *buffer,
     65                                                 uint32_t length);
     66          static usb_status_t USB_DeviceControl(usb_device_handle handle, usb_device_control_type_t type, void *param);
     67          static usb_status_t USB_DeviceResetNotification(usb_device_struct_t *handle,
     68                                                          usb_device_callback_message_struct_t *message);
     69          #if ((defined(USB_DEVICE_CONFIG_LOW_POWER_MODE) && (USB_DEVICE_CONFIG_LOW_POWER_MODE > 0U)) || \
     70               (defined(USB_DEVICE_CONFIG_REMOTE_WAKEUP) && (USB_DEVICE_CONFIG_REMOTE_WAKEUP > 0U)))
     71          static usb_status_t USB_DeviceSuspendNotification(usb_device_struct_t *handle,
     72                                                            usb_device_callback_message_struct_t *message);
     73          static usb_status_t USB_DeviceSuspendNotification(usb_device_struct_t *handle,
     74                                                            usb_device_callback_message_struct_t *message);
     75          #endif
     76          #if (defined(USB_DEVICE_CONFIG_DETACH_ENABLE) && (USB_DEVICE_CONFIG_DETACH_ENABLE > 0U))
     77          static usb_status_t USB_DeviceDetachNotification(usb_device_struct_t *handle,
     78                                                           usb_device_callback_message_struct_t *message);
     79          static usb_status_t USB_DeviceAttachNotification(usb_device_struct_t *handle,
     80                                                           usb_device_callback_message_struct_t *message);
     81          #endif
     82          static usb_status_t USB_DeviceNotification(usb_device_struct_t *handle, usb_device_callback_message_struct_t *message);
     83          
     84          /*******************************************************************************
     85           * Variables
     86           ******************************************************************************/
     87          

   \                                 In section m_usb_global, align 4
     88          USB_GLOBAL static usb_device_struct_t s_UsbDevice[USB_DEVICE_CONFIG_NUM];
   \                     s_UsbDevice:
   \   00000000                      DS8 144
     89          
     90          /*******************************************************************************
     91           * Code
     92           ******************************************************************************/
     93          
     94          /*!
     95           * @brief Allocate a device handle.
     96           *
     97           * This function allocates a device handle.
     98           *
     99           * @param controllerId   The controller id of the USB IP. Please refer to the enumeration usb_controller_index_t.
    100           * @param handle          It is out parameter, is used to return pointer of the device handle to the caller.
    101           *
    102           * @retval kStatus_USB_Success              Get a device handle successfully.
    103           * @retval kStatus_USB_Busy                 Cannot allocate a device handle.
    104           * @retval kStatus_USB_Error                The device has been initialized.
    105           */

   \                                 In section .text, align 2, keep-with-next
    106          static usb_status_t USB_DeviceAllocateHandle(uint8_t controllerId, usb_device_struct_t **handle)
    107          {
   \                     USB_DeviceAllocateHandle: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000C             MOVS     R4,R1
    108              uint32_t count;
    109              USB_OSA_SR_ALLOC();
    110          
    111              USB_OSA_ENTER_CRITICAL();
   \   00000006   0x.... 0x....      BL       USB_BmEnterCritical
    112              /* Check the controller is initialized or not. */
    113              for (count = 0U; count < USB_DEVICE_CONFIG_NUM; count++)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0005             MOVS     R5,R0
   \                     ??USB_DeviceAllocateHandle_0: (+1)
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD117             BNE.N    ??USB_DeviceAllocateHandle_1
    114              {
    115                  if ((NULL != s_UsbDevice[count].controllerHandle) && (controllerId == s_UsbDevice[count].controllerId))
   \   00000012   0x....             LDR.N    R0,??DataTable1
   \   00000014   0x2190             MOVS     R1,#+144
   \   00000016   0xFB01 0xF105      MUL      R1,R1,R5
   \   0000001A   0x5840             LDR      R0,[R0, R1]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD00E             BEQ.N    ??USB_DeviceAllocateHandle_2
   \   00000020   0x0030             MOVS     R0,R6
   \   00000022   0x....             LDR.N    R1,??DataTable1
   \   00000024   0x2290             MOVS     R2,#+144
   \   00000026   0xFB02 0xF205      MUL      R2,R2,R5
   \   0000002A   0x4411             ADD      R1,R1,R2
   \   0000002C   0xF891 0x108D      LDRB     R1,[R1, #+141]
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD103             BNE.N    ??USB_DeviceAllocateHandle_2
    116                  {
    117                      USB_OSA_EXIT_CRITICAL();
   \   00000036   0x.... 0x....      BL       USB_BmExitCritical
    118                      return kStatus_USB_Error;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xE022             B.N      ??USB_DeviceAllocateHandle_3
    119                  }
    120              }
   \                     ??USB_DeviceAllocateHandle_2: (+1)
   \   0000003E   0x1C6D             ADDS     R5,R5,#+1
   \   00000040   0xE7E5             B.N      ??USB_DeviceAllocateHandle_0
    121              /* Get a free device handle. */
    122              for (count = 0U; count < USB_DEVICE_CONFIG_NUM; count++)
   \                     ??USB_DeviceAllocateHandle_1: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x0005             MOVS     R5,R0
   \                     ??USB_DeviceAllocateHandle_4: (+1)
   \   00000046   0x2D00             CMP      R5,#+0
   \   00000048   0xD119             BNE.N    ??USB_DeviceAllocateHandle_5
    123              {
    124                  if (NULL == s_UsbDevice[count].controllerHandle)
   \   0000004A   0x....             LDR.N    R0,??DataTable1
   \   0000004C   0x2190             MOVS     R1,#+144
   \   0000004E   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000052   0x5840             LDR      R0,[R0, R1]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD110             BNE.N    ??USB_DeviceAllocateHandle_6
    125                  {
    126                      s_UsbDevice[count].controllerId = controllerId;
   \   00000058   0x....             LDR.N    R0,??DataTable1
   \   0000005A   0x2190             MOVS     R1,#+144
   \   0000005C   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000060   0x4408             ADD      R0,R0,R1
   \   00000062   0xF880 0x608D      STRB     R6,[R0, #+141]
    127                      *handle = &s_UsbDevice[count];
   \   00000066   0x....             LDR.N    R0,??DataTable1
   \   00000068   0x2190             MOVS     R1,#+144
   \   0000006A   0xFB01 0xF105      MUL      R1,R1,R5
   \   0000006E   0x4408             ADD      R0,R0,R1
   \   00000070   0x6020             STR      R0,[R4, #+0]
    128                      USB_OSA_EXIT_CRITICAL();
   \   00000072   0x.... 0x....      BL       USB_BmExitCritical
    129                      return kStatus_USB_Success;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xE004             B.N      ??USB_DeviceAllocateHandle_3
    130                  }
    131              }
   \                     ??USB_DeviceAllocateHandle_6: (+1)
   \   0000007A   0x1C6D             ADDS     R5,R5,#+1
   \   0000007C   0xE7E3             B.N      ??USB_DeviceAllocateHandle_4
    132              USB_OSA_EXIT_CRITICAL();
   \                     ??USB_DeviceAllocateHandle_5: (+1)
   \   0000007E   0x.... 0x....      BL       USB_BmExitCritical
    133              return kStatus_USB_Busy;
   \   00000082   0x2002             MOVS     R0,#+2
   \                     ??USB_DeviceAllocateHandle_3: (+1)
   \   00000084   0xBD70             POP      {R4-R6,PC}       ;; return
    134          }
    135          
    136          /*!
    137           * @brief Free a device handle.
    138           *
    139           * This function frees a device handle.
    140           *
    141           * @param handle          The device handle.
    142           *
    143           * @retval kStatus_USB_Success              Free device handle successfully.
    144           */

   \                                 In section .text, align 2, keep-with-next
    145          static usb_status_t USB_DeviceFreeHandle(usb_device_struct_t *handle)
    146          {
   \                     USB_DeviceFreeHandle: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    147              USB_OSA_SR_ALLOC();
    148          
    149              USB_OSA_ENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       USB_BmEnterCritical
    150              handle->controllerHandle = NULL;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x6020             STR      R0,[R4, #+0]
    151              handle->controllerId = 0U;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xF884 0x008D      STRB     R0,[R4, #+141]
    152              USB_OSA_EXIT_CRITICAL();
   \   00000012   0x.... 0x....      BL       USB_BmExitCritical
    153              return kStatus_USB_Success;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    154          }
    155          
    156          #if ((defined(USB_DEVICE_CONFIG_KHCI)) && (USB_DEVICE_CONFIG_KHCI > 0U))
    157          /* KHCI device driver interface */

   \                                 In section .rodata, align 4
    158          static const usb_device_controller_interface_struct_t s_UsbDeviceKhciInterface = {
   \                     s_UsbDeviceKhciInterface:
   \   00000000   0x........         DC32 USB_DeviceKhciInit, USB_DeviceKhciDeinit, USB_DeviceKhciSend
   \              0x........   
   \              0x........   
   \   0000000C   0x........         DC32 USB_DeviceKhciRecv, USB_DeviceKhciCancel, USB_DeviceKhciControl
   \              0x........   
   \              0x........   
    159              USB_DeviceKhciInit, USB_DeviceKhciDeinit, USB_DeviceKhciSend,
    160              USB_DeviceKhciRecv, USB_DeviceKhciCancel, USB_DeviceKhciControl};
    161          #endif
    162          
    163          #if ((defined(USB_DEVICE_CONFIG_EHCI)) && (USB_DEVICE_CONFIG_EHCI > 0U))
    164          /* EHCI device driver interface */
    165          static const usb_device_controller_interface_struct_t s_UsbDeviceEhciInterface = {
    166              USB_DeviceEhciInit, USB_DeviceEhciDeinit, USB_DeviceEhciSend,
    167              USB_DeviceEhciRecv, USB_DeviceEhciCancel, USB_DeviceEhciControl};
    168          #endif
    169          
    170          /*!
    171           * @brief Get the controller interface handle.
    172           *
    173           * This function is used to get the controller interface handle.
    174           *
    175           * @param controllerId          The controller id of the USB IP. Please refer to the enumeration usb_controller_index_t.
    176           * @param controllerInterface   It is out parameter, is used to return pointer of the device controller handle to the
    177           * caller.
    178           *
    179           * @retval kStatus_USB_Success              Get a device handle successfully.
    180           * @retval kStatus_USB_ControllerNotFound   The controller id is invalided.
    181           */

   \                                 In section .text, align 2, keep-with-next
    182          static usb_status_t USB_DeviceGetControllerInterface(
    183              uint8_t controllerId, const usb_device_controller_interface_struct_t **controllerInterface)
    184          {
   \                     USB_DeviceGetControllerInterface: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    185              usb_status_t error = kStatus_USB_ControllerNotFound;
   \   00000004   0x2006             MOVS     R0,#+6
    186              switch (controllerId)
   \   00000006   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0x0013             MOVS     R3,R2
   \   0000000A   0x2B00             CMP      R3,#+0
   \   0000000C   0x2B01             CMP      R3,#+1
   \   0000000E   0xD804             BHI.N    ??USB_DeviceGetControllerInterface_0
    187              {
    188          #if ((defined(USB_DEVICE_CONFIG_KHCI)) && (USB_DEVICE_CONFIG_KHCI > 0U))
    189                  /* Get the KHCI controller driver interface */
    190                  case kUSB_ControllerKhci0:
    191                  case kUSB_ControllerKhci1:
    192                      *controllerInterface = (const usb_device_controller_interface_struct_t *)&s_UsbDeviceKhciInterface;
   \                     ??USB_DeviceGetControllerInterface_1: (+1)
   \   00000010   0x....             LDR.N    R3,??DataTable1_1
   \   00000012   0x600B             STR      R3,[R1, #+0]
    193                      error = kStatus_USB_Success;
   \   00000014   0x2300             MOVS     R3,#+0
   \   00000016   0x0018             MOVS     R0,R3
    194                      break;
   \   00000018   0xE7FF             B.N      ??USB_DeviceGetControllerInterface_2
    195          #endif
    196          #if ((defined(USB_DEVICE_CONFIG_EHCI)) && (USB_DEVICE_CONFIG_EHCI > 0U))
    197                  /* Get the EHCI controller driver interface */
    198                  case kUSB_ControllerEhci0:
    199                  case kUSB_ControllerEhci1:
    200                      error = kStatus_USB_Success;
    201                      *controllerInterface = (const usb_device_controller_interface_struct_t *)&s_UsbDeviceEhciInterface;
    202                      break;
    203          #endif
    204                  default:
    205                      break;
    206              }
    207              return error;
   \                     ??USB_DeviceGetControllerInterface_0: (+1)
   \                     ??USB_DeviceGetControllerInterface_2: (+1)
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xBC10             POP      {R4}
   \   0000001E   0x4770             BX       LR               ;; return
    208          }
    209          
    210          /*!
    211           * @brief Start a new transfer.
    212           *
    213           * This function is used to start a new transfer.
    214           *
    215           * @param handle                 The device handle. It equals the value returned from USB_DeviceInit.
    216           * @param endpointAddress       Endpoint address. Bit7 is direction, 0U - USB_OUT, 1U - USB_IN.
    217           * @param buffer                 The memory address to be transferred, or the memory address to hold the data need to be
    218           * sent.
    219           * @param length                 The length of the data.
    220           *
    221           * @retval kStatus_USB_Success              Get a device handle successfully.
    222           * @retval kStatus_USB_InvalidHandle        The device handle is invalided.
    223           * @retval kStatus_USB_ControllerNotFound   The controller interface is not found.
    224           * @retval kStatus_USB_Error                The device is doing reset.
    225           */

   \                                 In section .text, align 2, keep-with-next
    226          static usb_status_t USB_DeviceTransfer(usb_device_handle handle,
    227                                                 uint8_t endpointAddress,
    228                                                 uint8_t *buffer,
    229                                                 uint32_t length)
    230          {
   \                     USB_DeviceTransfer: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    231              usb_device_struct_t *deviceHandle = (usb_device_struct_t *)handle;
   \   0000000C   0x46A0             MOV      R8,R4
    232              usb_status_t error = kStatus_USB_Error;
   \   0000000E   0xF05F 0x0901      MOVS     R9,#+1
    233          
    234              if (NULL == deviceHandle)
   \   00000012   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000016   0xD101             BNE.N    ??USB_DeviceTransfer_0
    235              {
    236                  return kStatus_USB_InvalidHandle;
   \   00000018   0x2003             MOVS     R0,#+3
   \   0000001A   0xE023             B.N      ??USB_DeviceTransfer_1
    237              }
    238          
    239              if (NULL != deviceHandle->controllerInterface)
   \                     ??USB_DeviceTransfer_0: (+1)
   \   0000001C   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD01B             BEQ.N    ??USB_DeviceTransfer_2
    240              {
    241                  if (endpointAddress & USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_MASK)
   \   00000024   0x0628             LSLS     R0,R5,#+24
   \   00000026   0xD50C             BPL.N    ??USB_DeviceTransfer_3
    242                  {
    243          #if (defined(USB_DEVICE_CONFIG_BUFFER_PROPERTY_CACHEABLE) && (USB_DEVICE_CONFIG_BUFFER_PROPERTY_CACHEABLE > 0U))
    244                      if (length)
    245                      {
    246                          USB_CacheFlushLines((void *)buffer, length);
    247                      }
    248          #endif
    249                      /* Call the controller send interface. */
    250                      error = deviceHandle->controllerInterface->deviceSend(deviceHandle->controllerHandle, endpointAddress,
    251                                                                            buffer, length);
   \   00000028   0x003B             MOVS     R3,R7
   \   0000002A   0x0032             MOVS     R2,R6
   \   0000002C   0x0029             MOVS     R1,R5
   \   0000002E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000030   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000034   0xF8D8 0xC004      LDR      R12,[R8, #+4]
   \   00000038   0xF8DC 0xC008      LDR      R12,[R12, #+8]
   \   0000003C   0x47E0             BLX      R12
   \   0000003E   0x4681             MOV      R9,R0
   \   00000040   0xE00E             B.N      ??USB_DeviceTransfer_4
    252                  }
    253                  else
    254                  {
    255          #if (defined(USB_DEVICE_CONFIG_BUFFER_PROPERTY_CACHEABLE) && (USB_DEVICE_CONFIG_BUFFER_PROPERTY_CACHEABLE > 0U))
    256                      if (length)
    257                      {
    258                          USB_CacheInvalidateLines((void *)buffer, length);
    259                      }
    260          #endif
    261                      /* Call the controller receive interface. */
    262                      error = deviceHandle->controllerInterface->deviceRecv(deviceHandle->controllerHandle, endpointAddress,
    263                                                                            buffer, length);
   \                     ??USB_DeviceTransfer_3: (+1)
   \   00000042   0x003B             MOVS     R3,R7
   \   00000044   0x0032             MOVS     R2,R6
   \   00000046   0x0029             MOVS     R1,R5
   \   00000048   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004A   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000004E   0xF8D8 0xC004      LDR      R12,[R8, #+4]
   \   00000052   0xF8DC 0xC00C      LDR      R12,[R12, #+12]
   \   00000056   0x47E0             BLX      R12
   \   00000058   0x4681             MOV      R9,R0
   \   0000005A   0xE001             B.N      ??USB_DeviceTransfer_4
    264                  }
    265              }
    266              else
    267              {
    268                  error = kStatus_USB_ControllerNotFound;
   \                     ??USB_DeviceTransfer_2: (+1)
   \   0000005C   0x2006             MOVS     R0,#+6
   \   0000005E   0x4681             MOV      R9,R0
    269              }
    270              return error;
   \                     ??USB_DeviceTransfer_4: (+1)
   \   00000060   0x4648             MOV      R0,R9
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceTransfer_1: (+1)
   \   00000064   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    271          }
    272          
    273          /*!
    274           * @brief Control the status of the selected item.
    275           *
    276           * This function is used to control the status of the selected item..
    277           *
    278           * @param handle                 The device handle. It equals the value returned from USB_DeviceInit.
    279           * @param type                   The control type, please refer to the enumeration usb_device_control_type_t.
    280           * @param param                  The param type is determined by the selected item.
    281           *
    282           * @retval kStatus_USB_Success              Get a device handle successfully.
    283           * @retval kStatus_USB_InvalidHandle        The device handle is invalided.
    284           * @retval kStatus_USB_ControllerNotFound   The controller interface is not found.
    285           * @retval kStatus_USB_Error                Unsupport type.
    286           *                                          Or, the param is NULL pointer.
    287           */

   \                                 In section .text, align 2, keep-with-next
    288          static usb_status_t USB_DeviceControl(usb_device_handle handle, usb_device_control_type_t type, void *param)
    289          {
   \                     USB_DeviceControl: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    290              usb_device_struct_t *deviceHandle = (usb_device_struct_t *)handle;
   \   0000000A   0x0027             MOVS     R7,R4
    291              usb_status_t error = kStatus_USB_Error;
   \   0000000C   0xF05F 0x0801      MOVS     R8,#+1
    292          
    293              if (NULL == deviceHandle)
   \   00000010   0x2F00             CMP      R7,#+0
   \   00000012   0xD101             BNE.N    ??USB_DeviceControl_0
    294              {
    295                  return kStatus_USB_InvalidHandle;
   \   00000014   0x2003             MOVS     R0,#+3
   \   00000016   0xE00F             B.N      ??USB_DeviceControl_1
    296              }
    297          
    298              if (NULL != deviceHandle->controllerInterface)
   \                     ??USB_DeviceControl_0: (+1)
   \   00000018   0x6878             LDR      R0,[R7, #+4]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD008             BEQ.N    ??USB_DeviceControl_2
    299              {
    300                  /* Call the controller control interface. */
    301                  error = deviceHandle->controllerInterface->deviceControl(deviceHandle->controllerHandle, type, param);
   \   0000001E   0x0032             MOVS     R2,R6
   \   00000020   0x0029             MOVS     R1,R5
   \   00000022   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000024   0x6838             LDR      R0,[R7, #+0]
   \   00000026   0x687B             LDR      R3,[R7, #+4]
   \   00000028   0x695B             LDR      R3,[R3, #+20]
   \   0000002A   0x4798             BLX      R3
   \   0000002C   0x4680             MOV      R8,R0
   \   0000002E   0xE001             B.N      ??USB_DeviceControl_3
    302              }
    303              else
    304              {
    305                  error = kStatus_USB_ControllerNotFound;
   \                     ??USB_DeviceControl_2: (+1)
   \   00000030   0x2006             MOVS     R0,#+6
   \   00000032   0x4680             MOV      R8,R0
    306              }
    307              return error;
   \                     ??USB_DeviceControl_3: (+1)
   \   00000034   0x4640             MOV      R0,R8
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceControl_1: (+1)
   \   00000038   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    308          }
    309          
    310          /*!
    311           * @brief Handle the reset notification.
    312           *
    313           * This function is used to handle the reset notification.
    314           *
    315           * @param handle                 The device handle. It equals the value returned from USB_DeviceInit.
    316           * @param message                The device callback message handle.
    317           *
    318           * @retval kStatus_USB_Success              Get a device handle successfully.
    319           */

   \                                 In section .text, align 2, keep-with-next
    320          static usb_status_t USB_DeviceResetNotification(usb_device_struct_t *handle,
    321                                                          usb_device_callback_message_struct_t *message)
    322          {
   \                     USB_DeviceResetNotification: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    323              /* Set the controller to default status. */
    324              USB_DeviceControl(handle, kUSB_DeviceControlSetDefaultStatus, NULL);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x210B             MOVS     R1,#+11
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       USB_DeviceControl
    325          
    326              handle->state = kUSB_DeviceStateDefault;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xF884 0x008E      STRB     R0,[R4, #+142]
    327              handle->deviceAddress = 0U;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF884 0x008C      STRB     R0,[R4, #+140]
    328          
    329              for (uint32_t count = 0U; count < (USB_DEVICE_CONFIG_ENDPOINTS * 2U); count++)
   \   0000001C   0x2000             MOVS     R0,#+0
   \                     ??USB_DeviceResetNotification_0: (+1)
   \   0000001E   0x2810             CMP      R0,#+16
   \   00000020   0xD209             BCS.N    ??USB_DeviceResetNotification_1
    330              {
    331                  handle->endpointCallback[count].callbackFn = (usb_device_endpoint_callback_t)NULL;
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0xEB04 0x02C0      ADD      R2,R4,R0, LSL #+3
   \   00000028   0x60D1             STR      R1,[R2, #+12]
    332                  handle->endpointCallback[count].callbackParam = NULL;
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0xEB04 0x02C0      ADD      R2,R4,R0, LSL #+3
   \   00000030   0x6111             STR      R1,[R2, #+16]
    333              }
   \   00000032   0x1C40             ADDS     R0,R0,#+1
   \   00000034   0xE7F3             B.N      ??USB_DeviceResetNotification_0
    334          
    335              /* Call device callback to notify the application that the USB bus reset signal detected. */
    336              handle->deviceCallback(handle, kUSB_DeviceEventBusReset, NULL);
   \                     ??USB_DeviceResetNotification_1: (+1)
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x68A3             LDR      R3,[R4, #+8]
   \   0000003E   0x4798             BLX      R3
    337          
    338              return kStatus_USB_Success;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    339          }
    340          
    341          #if ((defined(USB_DEVICE_CONFIG_LOW_POWER_MODE) && (USB_DEVICE_CONFIG_LOW_POWER_MODE > 0U)) || \
    342               (defined(USB_DEVICE_CONFIG_REMOTE_WAKEUP) && (USB_DEVICE_CONFIG_REMOTE_WAKEUP > 0U)))
    343          /*!
    344           * @brief Handle the suspend notification.
    345           *
    346           * This function is used to handle the suspend notification.
    347           *
    348           * @param handle                 The device handle. It equals the value returned from USB_DeviceInit.
    349           * @param message                The device callback message handle.
    350           *
    351           * @return A USB error code or kStatus_USB_Success.
    352           */
    353          static usb_status_t USB_DeviceSuspendNotification(usb_device_struct_t *handle,
    354                                                            usb_device_callback_message_struct_t *message)
    355          {
    356              /* Call device callback to notify the application that the USB bus suspend signal detected. */
    357              return handle->deviceCallback(handle, kUSB_DeviceEventSuspend, NULL);
    358          }
    359          
    360          /*!
    361           * @brief Handle the resume notification.
    362           *
    363           * This function is used to handle the resume notification.
    364           *
    365           * @param handle                 The device handle. It equals the value returned from USB_DeviceInit.
    366           * @param message                The device callback message handle.
    367           *
    368           * @return A USB error code or kStatus_USB_Success.
    369           */
    370          static usb_status_t USB_DeviceResumeNotification(usb_device_struct_t *handle,
    371                                                           usb_device_callback_message_struct_t *message)
    372          {
    373              /* Call device callback to notify the application that the USB bus resume signal detected. */
    374              return handle->deviceCallback(handle, kUSB_DeviceEventResume, NULL);
    375          }
    376          
    377          #endif
    378          
    379          #if (defined(USB_DEVICE_CONFIG_KHCI_ERROR_HANDLING) && USB_DEVICE_CONFIG_KHCI_ERROR_HANDLING) || \
    380              (defined(USB_DEVICE_CONFIG_EHCI_ERROR_HANDLING) && USB_DEVICE_CONFIG_EHCI_ERROR_HANDLING)
    381          usb_status_t USB_DeviceErrorNotification(usb_device_struct_t *handle, usb_device_callback_message_struct_t *message)
    382          {
    383              /* Call device callback to notify the application that the USB bus error signal detected. */
    384              return handle->deviceCallback(handle, kUSB_DeviceEventError, NULL);
    385          }
    386          #endif
    387          
    388          #if (defined(USB_DEVICE_CONFIG_DETACH_ENABLE) && (USB_DEVICE_CONFIG_DETACH_ENABLE > 0U))
    389          /*!
    390           * @brief Handle the detach notification.
    391           *
    392           * This function is used to handle the detach notification.
    393           *
    394           * @param handle                 The device handle. It equals the value returned from USB_DeviceInit.
    395           * @param message                The device callback message handle.
    396           *
    397           * @return A USB error code or kStatus_USB_Success.
    398           */
    399          static usb_status_t USB_DeviceDetachNotification(usb_device_struct_t *handle,
    400                                                           usb_device_callback_message_struct_t *message)
    401          {
    402              /* Call device callback to notify the application that the device is disconnected from a host. */
    403              return handle->deviceCallback(handle, kUSB_DeviceEventDetach, NULL);
    404          }
    405          
    406          /*!
    407           * @brief Handle the attach notification.
    408           *
    409           * This function is used to handle the attach notification.
    410           *
    411           * @param handle                 The device handle. It equals the value returned from USB_DeviceInit.
    412           * @param message                The device callback message handle.
    413           *
    414           * @return A USB error code or kStatus_USB_Success.
    415           */
    416          static usb_status_t USB_DeviceAttachNotification(usb_device_struct_t *handle,
    417                                                           usb_device_callback_message_struct_t *message)
    418          {
    419              /* Call device callback to notify the application that the device is connected to a host. */
    420              return handle->deviceCallback(handle, kUSB_DeviceEventAttach, NULL);
    421          }
    422          #endif
    423          
    424          /*!
    425           * @brief Handle the attach notification.
    426           *
    427           * This function is used to handle the attach notification.
    428           *
    429           * @param handle                 The device handle. It equals the value returned from USB_DeviceInit.
    430           * @param message                The device callback message handle.
    431           *
    432           * @return A USB error code or kStatus_USB_Success.
    433           */

   \                                 In section .text, align 2, keep-with-next
    434          static usb_status_t USB_DeviceNotification(usb_device_struct_t *handle, usb_device_callback_message_struct_t *message)
    435          {
   \                     USB_DeviceNotification: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    436              uint8_t endpoint = message->code & USB_ENDPOINT_NUMBER_MASK;
   \   0000000A   0x7A28             LDRB     R0,[R5, #+8]
   \   0000000C   0xF010 0x060F      ANDS     R6,R0,#0xF
    437              uint8_t direction = (message->code & USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_MASK) >>
    438                                  USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT;
   \   00000010   0x7A28             LDRB     R0,[R5, #+8]
   \   00000012   0x09C7             LSRS     R7,R0,#+7
    439              usb_status_t error = kStatus_USB_Error;
   \   00000014   0xF05F 0x0801      MOVS     R8,#+1
    440          
    441              switch (message->code)
   \   00000018   0x7A28             LDRB     R0,[R5, #+8]
   \   0000001A   0x2810             CMP      R0,#+16
   \   0000001C   0xD105             BNE.N    ??USB_DeviceNotification_0
    442              {
    443                  case kUSB_DeviceNotifyBusReset:
    444                      error = USB_DeviceResetNotification(handle, message);
   \   0000001E   0x0029             MOVS     R1,R5
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       USB_DeviceResetNotification
   \   00000026   0x4680             MOV      R8,R0
    445                      break;
   \   00000028   0xE024             B.N      ??USB_DeviceNotification_1
    446          #if ((USB_DEVICE_CONFIG_LOW_POWER_MODE) || (USB_DEVICE_CONFIG_REMOTE_WAKEUP))
    447                  case kUSB_DeviceNotifySuspend:
    448                      error = USB_DeviceSuspendNotification(handle, message);
    449                      break;
    450                  case kUSB_DeviceNotifyResume:
    451                      error = USB_DeviceResumeNotification(handle, message);
    452                      break;
    453          #endif
    454          
    455          #if (defined(USB_DEVICE_CONFIG_KHCI_ERROR_HANDLING) && USB_DEVICE_CONFIG_KHCI_ERROR_HANDLING) || \
    456              (defined(USB_DEVICE_CONFIG_EHCI_ERROR_HANDLING) && USB_DEVICE_CONFIG_EHCI_ERROR_HANDLING)
    457                  case kUSB_DeviceNotifyError:
    458                      error = USB_DeviceErrorNotification(handle, message);
    459                      break;
    460          #endif
    461          
    462          #if USB_DEVICE_CONFIG_DETACH_ENABLE
    463                  case kUSB_DeviceNotifyDetach:
    464                      error = USB_DeviceDetachNotification(handle, message);
    465                      break;
    466                  case kUSB_DeviceNotifyAttach:
    467                      error = USB_DeviceAttachNotification(handle, message);
    468                      break;
    469          #endif
    470                  default:
    471                      if (endpoint < USB_DEVICE_CONFIG_ENDPOINTS)
   \                     ??USB_DeviceNotification_0: (+1)
   \   0000002A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002C   0x2E08             CMP      R6,#+8
   \   0000002E   0xD221             BCS.N    ??USB_DeviceNotification_2
    472                      {
    473                          if (handle->endpointCallback[(uint8_t)((uint32_t)endpoint << 1U) | direction].callbackFn)
   \   00000030   0x0070             LSLS     R0,R6,#+1
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000036   0x4338             ORRS     R0,R7,R0
   \   00000038   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \   0000003C   0x68C0             LDR      R0,[R0, #+12]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD018             BEQ.N    ??USB_DeviceNotification_2
    474                          {
    475                              usb_device_endpoint_callback_message_struct_t endpointCallbackMessage;
    476                              endpointCallbackMessage.buffer = message->buffer;
   \   00000042   0x6828             LDR      R0,[R5, #+0]
   \   00000044   0x9000             STR      R0,[SP, #+0]
    477                              endpointCallbackMessage.length = message->length;
   \   00000046   0x6868             LDR      R0,[R5, #+4]
   \   00000048   0x9001             STR      R0,[SP, #+4]
    478                              endpointCallbackMessage.isSetup = message->isSetup;
   \   0000004A   0x7A68             LDRB     R0,[R5, #+9]
   \   0000004C   0xF88D 0x0008      STRB     R0,[SP, #+8]
    479                              /* Call endpoint callback */
    480                              error = handle->endpointCallback[(uint8_t)((uint32_t)endpoint << 1U) | direction].callbackFn(
    481                                  handle, &endpointCallbackMessage,
    482                                  handle->endpointCallback[(uint8_t)((uint32_t)endpoint << 1U) | direction].callbackParam);
   \   00000050   0x0070             LSLS     R0,R6,#+1
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000056   0x4338             ORRS     R0,R7,R0
   \   00000058   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \   0000005C   0x6902             LDR      R2,[R0, #+16]
   \   0000005E   0x4669             MOV      R1,SP
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x0073             LSLS     R3,R6,#+1
   \   00000064   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000066   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000068   0x433B             ORRS     R3,R7,R3
   \   0000006A   0xEB04 0x03C3      ADD      R3,R4,R3, LSL #+3
   \   0000006E   0x68DB             LDR      R3,[R3, #+12]
   \   00000070   0x4798             BLX      R3
   \   00000072   0x4680             MOV      R8,R0
    483                          }
    484                      }
    485                      break;
    486              }
    487              return error;
   \                     ??USB_DeviceNotification_2: (+1)
   \                     ??USB_DeviceNotification_1: (+1)
   \   00000074   0x4640             MOV      R0,R8
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0xB004             ADD      SP,SP,#+16
   \   0000007A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    488          }
    489          
    490          /*!
    491           * @brief Notify the device that the controller status changed.
    492           *
    493           * This function is used to notify the device that the controller status changed.
    494           *
    495           * @param handle                 The device handle. It equals the value returned from USB_DeviceInit.
    496           * @param message                The device callback message handle.
    497           *
    498           * @return A USB error code or kStatus_USB_Success.
    499           */

   \                                 In section .text, align 2, keep-with-next
    500          usb_status_t USB_DeviceNotificationTrigger(void *handle, void *msg)
    501          {
   \                     USB_DeviceNotificationTrigger: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    502              usb_device_struct_t *deviceHandle = (usb_device_struct_t *)handle;
   \   00000006   0x0026             MOVS     R6,R4
    503              usb_device_callback_message_struct_t *message = (usb_device_callback_message_struct_t *)msg;
   \   00000008   0x002F             MOVS     R7,R5
    504          
    505              if ((NULL == msg) || (NULL == handle))
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD001             BEQ.N    ??USB_DeviceNotificationTrigger_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD101             BNE.N    ??USB_DeviceNotificationTrigger_1
    506              {
    507                  return kStatus_USB_InvalidHandle;
   \                     ??USB_DeviceNotificationTrigger_0: (+1)
   \   00000012   0x2003             MOVS     R0,#+3
   \   00000014   0xE008             B.N      ??USB_DeviceNotificationTrigger_2
    508              }
    509          
    510              /* The device callback is invalid or not. */
    511              if (!deviceHandle->deviceCallback)
   \                     ??USB_DeviceNotificationTrigger_1: (+1)
   \   00000016   0x68B0             LDR      R0,[R6, #+8]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD101             BNE.N    ??USB_DeviceNotificationTrigger_3
    512              {
    513                  return kStatus_USB_Error;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE003             B.N      ??USB_DeviceNotificationTrigger_2
    514              }
    515          
    516          #if USB_DEVICE_CONFIG_USE_TASK
    517              /* Add the message to message queue when the device task is enabled. */
    518              if (kStatus_USB_OSA_Success != USB_OsaMsgqSend(deviceHandle->notificationQueue, (void *)message))
    519              {
    520                  return kStatus_USB_Busy;
    521              }
    522              return kStatus_USB_Success;
    523          #else
    524              /* Handle the notification by calling USB_DeviceNotification. */
    525              return USB_DeviceNotification(deviceHandle, message);
   \                     ??USB_DeviceNotificationTrigger_3: (+1)
   \   00000020   0x0039             MOVS     R1,R7
   \   00000022   0x0030             MOVS     R0,R6
   \   00000024   0x.... 0x....      BL       USB_DeviceNotification
   \                     ??USB_DeviceNotificationTrigger_2: (+1)
   \   00000028   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    526          #endif
    527          }
    528          
    529          /*!
    530           * @brief Initialize the USB device stack.
    531           *
    532           * This function initializes the USB device module specified by the controllerId.
    533           *
    534           * @param controllerId   The controller id of the USB IP. Please refer to the enumeration usb_controller_index_t.
    535           * @param deviceCallback Function pointer of the device callback.
    536           * @param handle          It is out parameter, is used to return pointer of the device handle to the caller.
    537           *
    538           * @retval kStatus_USB_Success              The device is initialized successfully.
    539           * @retval kStatus_USB_InvalidHandle        The handle is a NULL pointer.
    540           * @retval kStatus_USB_Busy                 Cannot allocate a device handle.
    541           * @retval kStatus_USB_ControllerNotFound   Cannot find the controller according to the controller id.
    542           * @retval kStatus_USB_InvalidControllerInterface  The controller driver interfaces is invaild, There is an empty
    543           * interface entity.
    544           * @retval kStatus_USB_Error                The macro USB_DEVICE_CONFIG_ENDPOINTS is more than IP's endpoint number.
    545           *                                          Or, the device has been initialized.
    546           *                                          Or, the message queue is created failed.
    547           */

   \                                 In section .text, align 2, keep-with-next
    548          usb_status_t USB_DeviceInit(uint8_t controllerId, usb_device_callback_t deviceCallback, usb_device_handle *handle)
    549          {
   \                     USB_DeviceInit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    550              usb_device_struct_t *deviceHandle = NULL;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    551              usb_status_t error;
    552              uint32_t count;
    553          
    554              if (NULL == handle)
   \   00000010   0x2E00             CMP      R6,#+0
   \   00000012   0xD101             BNE.N    ??USB_DeviceInit_0
    555              {
    556                  return kStatus_USB_InvalidHandle;
   \   00000014   0x2003             MOVS     R0,#+3
   \   00000016   0xE080             B.N      ??USB_DeviceInit_1
    557              }
    558          
    559              /* Allocate a device handle by using the controller id. */
    560              error = USB_DeviceAllocateHandle(controllerId, &deviceHandle);
   \                     ??USB_DeviceInit_0: (+1)
   \   00000018   0x4669             MOV      R1,SP
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x.... 0x....      BL       USB_DeviceAllocateHandle
   \   00000022   0x4680             MOV      R8,R0
    561          
    562              if (kStatus_USB_Success != error)
   \   00000024   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000028   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000002C   0xD002             BEQ.N    ??USB_DeviceInit_2
    563              {
    564                  return error;
   \   0000002E   0x4640             MOV      R0,R8
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0xE072             B.N      ??USB_DeviceInit_1
    565              }
    566          
    567              /* Save the device callback */
    568              deviceHandle->deviceCallback = deviceCallback;
   \                     ??USB_DeviceInit_2: (+1)
   \   00000034   0x9800             LDR      R0,[SP, #+0]
   \   00000036   0x6085             STR      R5,[R0, #+8]
    569              /* Save the controller id */
    570              deviceHandle->controllerId = controllerId;
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0xF880 0x408D      STRB     R4,[R0, #+141]
    571              /* Clear the device address */
    572              deviceHandle->deviceAddress = 0U;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x9900             LDR      R1,[SP, #+0]
   \   00000042   0xF881 0x008C      STRB     R0,[R1, #+140]
    573          
    574              /* Initialize the enpoints */
    575              for (count = 0U; count < (USB_DEVICE_CONFIG_ENDPOINTS * 2U); count++)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x0007             MOVS     R7,R0
   \                     ??USB_DeviceInit_3: (+1)
   \   0000004A   0x2F10             CMP      R7,#+16
   \   0000004C   0xD20B             BCS.N    ??USB_DeviceInit_4
    576              {
    577                  deviceHandle->endpointCallback[count].callbackFn = (usb_device_endpoint_callback_t)NULL;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x9900             LDR      R1,[SP, #+0]
   \   00000052   0xEB01 0x01C7      ADD      R1,R1,R7, LSL #+3
   \   00000056   0x60C8             STR      R0,[R1, #+12]
    578                  deviceHandle->endpointCallback[count].callbackParam = NULL;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x9900             LDR      R1,[SP, #+0]
   \   0000005C   0xEB01 0x01C7      ADD      R1,R1,R7, LSL #+3
   \   00000060   0x6108             STR      R0,[R1, #+16]
    579              }
   \   00000062   0x1C7F             ADDS     R7,R7,#+1
   \   00000064   0xE7F1             B.N      ??USB_DeviceInit_3
    580          
    581              /* Get the controller interface according to the controller id */
    582              error = USB_DeviceGetControllerInterface(controllerId, &deviceHandle->controllerInterface);
   \                     ??USB_DeviceInit_4: (+1)
   \   00000066   0x9800             LDR      R0,[SP, #+0]
   \   00000068   0x1D01             ADDS     R1,R0,#+4
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0x.... 0x....      BL       USB_DeviceGetControllerInterface
   \   00000072   0x4680             MOV      R8,R0
    583              if (kStatus_USB_Success != error)
   \   00000074   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000078   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000007C   0xD005             BEQ.N    ??USB_DeviceInit_5
    584              {
    585                  USB_DeviceFreeHandle(deviceHandle);
   \   0000007E   0x9800             LDR      R0,[SP, #+0]
   \   00000080   0x.... 0x....      BL       USB_DeviceFreeHandle
    586                  return error;
   \   00000084   0x4640             MOV      R0,R8
   \   00000086   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000088   0xE047             B.N      ??USB_DeviceInit_1
    587              }
    588              if (NULL == deviceHandle->controllerInterface)
   \                     ??USB_DeviceInit_5: (+1)
   \   0000008A   0x9800             LDR      R0,[SP, #+0]
   \   0000008C   0x6840             LDR      R0,[R0, #+4]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD104             BNE.N    ??USB_DeviceInit_6
    589              {
    590                  USB_DeviceFreeHandle(deviceHandle);
   \   00000092   0x9800             LDR      R0,[SP, #+0]
   \   00000094   0x.... 0x....      BL       USB_DeviceFreeHandle
    591                  return kStatus_USB_ControllerNotFound;
   \   00000098   0x2006             MOVS     R0,#+6
   \   0000009A   0xE03E             B.N      ??USB_DeviceInit_1
    592              }
    593              if (((usb_device_controller_init_t)NULL == deviceHandle->controllerInterface->deviceInit) ||
    594                  ((usb_device_controller_deinit_t)NULL == deviceHandle->controllerInterface->deviceDeinit) ||
    595                  ((usb_device_controller_send_t)NULL == deviceHandle->controllerInterface->deviceSend) ||
    596                  ((usb_device_controller_recv_t)NULL == deviceHandle->controllerInterface->deviceRecv) ||
    597                  ((usb_device_controller_cancel_t)NULL == deviceHandle->controllerInterface->deviceCancel) ||
    598                  ((usb_device_controller_control_t)NULL == deviceHandle->controllerInterface->deviceControl))
   \                     ??USB_DeviceInit_6: (+1)
   \   0000009C   0x9800             LDR      R0,[SP, #+0]
   \   0000009E   0x6840             LDR      R0,[R0, #+4]
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD018             BEQ.N    ??USB_DeviceInit_7
   \   000000A6   0x9800             LDR      R0,[SP, #+0]
   \   000000A8   0x6840             LDR      R0,[R0, #+4]
   \   000000AA   0x6840             LDR      R0,[R0, #+4]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD013             BEQ.N    ??USB_DeviceInit_7
   \   000000B0   0x9800             LDR      R0,[SP, #+0]
   \   000000B2   0x6840             LDR      R0,[R0, #+4]
   \   000000B4   0x6880             LDR      R0,[R0, #+8]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD00E             BEQ.N    ??USB_DeviceInit_7
   \   000000BA   0x9800             LDR      R0,[SP, #+0]
   \   000000BC   0x6840             LDR      R0,[R0, #+4]
   \   000000BE   0x68C0             LDR      R0,[R0, #+12]
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD009             BEQ.N    ??USB_DeviceInit_7
   \   000000C4   0x9800             LDR      R0,[SP, #+0]
   \   000000C6   0x6840             LDR      R0,[R0, #+4]
   \   000000C8   0x6900             LDR      R0,[R0, #+16]
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD004             BEQ.N    ??USB_DeviceInit_7
   \   000000CE   0x9800             LDR      R0,[SP, #+0]
   \   000000D0   0x6840             LDR      R0,[R0, #+4]
   \   000000D2   0x6940             LDR      R0,[R0, #+20]
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD104             BNE.N    ??USB_DeviceInit_8
    599              {
    600                  USB_DeviceFreeHandle(deviceHandle);
   \                     ??USB_DeviceInit_7: (+1)
   \   000000D8   0x9800             LDR      R0,[SP, #+0]
   \   000000DA   0x.... 0x....      BL       USB_DeviceFreeHandle
    601                  return kStatus_USB_InvalidControllerInterface;
   \   000000DE   0x2007             MOVS     R0,#+7
   \   000000E0   0xE01B             B.N      ??USB_DeviceInit_1
    602              }
    603          
    604          #if USB_DEVICE_CONFIG_USE_TASK
    605              /* Create a message queue when the device handle is enabled. */
    606              if (kStatus_USB_OSA_Success !=
    607                  USB_OsaMsgqCreate(&deviceHandle->notificationQueue, USB_DEVICE_CONFIG_MAX_MESSAGES,
    608                                    (1U + (sizeof(usb_device_callback_message_struct_t) - 1U) / sizeof(uint32_t))))
    609              {
    610                  USB_DeviceDeinit(deviceHandle);
    611                  return kStatus_USB_Error;
    612              }
    613          #endif
    614              /* Initialize the controller */
    615              error = deviceHandle->controllerInterface->deviceInit(controllerId, deviceHandle, &deviceHandle->controllerHandle);
   \                     ??USB_DeviceInit_8: (+1)
   \   000000E2   0x9A00             LDR      R2,[SP, #+0]
   \   000000E4   0x9900             LDR      R1,[SP, #+0]
   \   000000E6   0x0020             MOVS     R0,R4
   \   000000E8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EA   0x9B00             LDR      R3,[SP, #+0]
   \   000000EC   0x685B             LDR      R3,[R3, #+4]
   \   000000EE   0x681B             LDR      R3,[R3, #+0]
   \   000000F0   0x4798             BLX      R3
   \   000000F2   0x4680             MOV      R8,R0
    616              if (kStatus_USB_Success != error)
   \   000000F4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000F8   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000FC   0xD005             BEQ.N    ??USB_DeviceInit_9
    617              {
    618                  USB_DeviceDeinit(deviceHandle);
   \   000000FE   0x9800             LDR      R0,[SP, #+0]
   \   00000100   0x.... 0x....      BL       USB_DeviceDeinit
    619                  return error;
   \   00000104   0x4640             MOV      R0,R8
   \   00000106   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000108   0xE007             B.N      ??USB_DeviceInit_1
    620              }
    621              /* Set the device to deafult state */
    622              deviceHandle->state = kUSB_DeviceStateDefault;
   \                     ??USB_DeviceInit_9: (+1)
   \   0000010A   0x2002             MOVS     R0,#+2
   \   0000010C   0x9900             LDR      R1,[SP, #+0]
   \   0000010E   0xF881 0x008E      STRB     R0,[R1, #+142]
    623              *handle = deviceHandle;
   \   00000112   0x9800             LDR      R0,[SP, #+0]
   \   00000114   0x6030             STR      R0,[R6, #+0]
    624          
    625              return error;
   \   00000116   0x4640             MOV      R0,R8
   \   00000118   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceInit_1: (+1)
   \   0000011A   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    626          }
    627          
    628          /*!
    629           * @brief Enable the device functionality.
    630           *
    631           * The function enables the device functionality, so that the device can be recognized by the host when the device
    632           * detects that it has been connected to a host.
    633           *
    634           * @param handle The device handle got from USB_DeviceInit.
    635           *
    636           * @retval kStatus_USB_Success              The device is run successfully.
    637           * @retval kStatus_USB_ControllerNotFound   Cannot find the controller.
    638           * @retval kStatus_USB_InvalidHandle        The device handle is a NULL pointer. Or the controller handle is invalid.
    639           *
    640           */

   \                                 In section .text, align 2, keep-with-next
    641          usb_status_t USB_DeviceRun(usb_device_handle handle)
    642          {
   \                     USB_DeviceRun: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    643              return USB_DeviceControl(handle, kUSB_DeviceControlRun, NULL);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       USB_DeviceControl
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    644          }
    645          /*!
    646           * @brief Disable the device functionality.
    647           *
    648           * The function disables the device functionality, after this function called, even the device is detached to the host,
    649           * and the device can't work.
    650           *
    651           * @param handle The device handle got from USB_DeviceInit.
    652           *
    653           * @retval kStatus_USB_Success              The device is stopped successfully.
    654           * @retval kStatus_USB_ControllerNotFound   Cannot find the controller.
    655           * @retval kStatus_USB_InvalidHandle        The device handle is a NULL pointer. Or the controller handle is invalid.
    656           */

   \                                 In section .text, align 2, keep-with-next
    657          usb_status_t USB_DeviceStop(usb_device_handle handle)
    658          {
   \                     USB_DeviceStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    659              return USB_DeviceControl(handle, kUSB_DeviceControlStop, NULL);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       USB_DeviceControl
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    660          }
    661          /*!
    662           * @brief De-initialize the device controller.
    663           *
    664           * The function de-initializes the device controller specified by the handle.
    665           *
    666           * @param handle The device handle got from USB_DeviceInit.
    667           *
    668           * @retval kStatus_USB_Success              The device is stopped successfully.
    669           * @retval kStatus_USB_InvalidHandle        The device handle is a NULL pointer. Or the controller handle is invalid.
    670           */

   \                                 In section .text, align 2, keep-with-next
    671          usb_status_t USB_DeviceDeinit(usb_device_handle handle)
    672          {
   \                     USB_DeviceDeinit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    673              usb_device_struct_t *deviceHandle = (usb_device_struct_t *)handle;
   \   00000004   0x0025             MOVS     R5,R4
    674          
    675              if (NULL == deviceHandle)
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD101             BNE.N    ??USB_DeviceDeinit_0
    676              {
    677                  return kStatus_USB_InvalidHandle;
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0xE00C             B.N      ??USB_DeviceDeinit_1
    678              }
    679              /* De-initialize the controller */
    680              if (NULL != deviceHandle->controllerInterface)
   \                     ??USB_DeviceDeinit_0: (+1)
   \   0000000E   0x6868             LDR      R0,[R5, #+4]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD005             BEQ.N    ??USB_DeviceDeinit_2
    681              {
    682                  deviceHandle->controllerInterface->deviceDeinit(deviceHandle->controllerHandle);
   \   00000014   0x6828             LDR      R0,[R5, #+0]
   \   00000016   0x6869             LDR      R1,[R5, #+4]
   \   00000018   0x6849             LDR      R1,[R1, #+4]
   \   0000001A   0x4788             BLX      R1
    683                  deviceHandle->controllerInterface = (usb_device_controller_interface_struct_t *)NULL;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x6068             STR      R0,[R5, #+4]
    684              }
    685          
    686          #if USB_DEVICE_CONFIG_USE_TASK
    687              /* Destroy the message queue. */
    688              if (NULL != deviceHandle->notificationQueue)
    689              {
    690                  USB_OsaMsgqDestroy(deviceHandle->notificationQueue);
    691                  deviceHandle->notificationQueue = NULL;
    692              }
    693          #endif
    694          
    695              /* Free the device handle. */
    696              USB_DeviceFreeHandle(deviceHandle);
   \                     ??USB_DeviceDeinit_2: (+1)
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0x.... 0x....      BL       USB_DeviceFreeHandle
    697              return kStatus_USB_Success;
   \   00000026   0x2000             MOVS     R0,#+0
   \                     ??USB_DeviceDeinit_1: (+1)
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    698          }
    699          
    700          /*!
    701           * @brief Send data through a specified endpoint.
    702           *
    703           * The function is used to send data through a specified endpoint.
    704           *
    705           * @param handle The device handle got from USB_DeviceInit.
    706           * @param endpointAddress Endpoint index.
    707           * @param buffer The memory address to hold the data need to be sent.
    708           * @param length The data length need to be sent.
    709           *
    710           * @retval kStatus_USB_Success              The send request is sent successfully.
    711           * @retval kStatus_USB_InvalidHandle        The handle is a NULL pointer. Or the controller handle is invalid.
    712           * @retval kStatus_USB_Busy                 Cannot allocate dtds for current tansfer in EHCI driver.
    713           * @retval kStatus_USB_ControllerNotFound   Cannot find the controller.
    714           * @retval kStatus_USB_Error                The device is doing reset.
    715           *
    716           * @note The return value just means if the sending request is successful or not; the transfer done is notified by the
    717           * corresponding callback function.
    718           * Currently, only one transfer request can be supported for one specific endpoint.
    719           * If there is a specific requirement to support multiple transfer requests for one specific endpoint, the application
    720           * should implement a queue in the application level.
    721           * The subsequent transfer could begin only when the previous transfer is done (get notification through the endpoint
    722           * callback).
    723           */

   \                                 In section .text, align 2, keep-with-next
    724          usb_status_t USB_DeviceSendRequest(usb_device_handle handle, uint8_t endpointAddress, uint8_t *buffer, uint32_t length)
    725          {
   \                     USB_DeviceSendRequest: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    726              return USB_DeviceTransfer(handle, (endpointAddress & USB_ENDPOINT_NUMBER_MASK) |
    727                                                    (USB_IN << USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT),
    728                                        buffer, length);
   \   0000000A   0x003B             MOVS     R3,R7
   \   0000000C   0x0032             MOVS     R2,R6
   \   0000000E   0xF015 0x000F      ANDS     R0,R5,#0xF
   \   00000012   0xF050 0x0180      ORRS     R1,R0,#0x80
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       USB_DeviceTransfer
   \   0000001E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    729          }
    730          
    731          /*!
    732           * @brief Receive data through a specified endpoint.
    733           *
    734           * The function is used to receive data through a specified endpoint.
    735           *
    736           * @param handle The device handle got from USB_DeviceInit.
    737           * @param endpointAddress Endpoint index.
    738           * @param buffer The memory address to save the received data.
    739           * @param length The data length want to be received.
    740           *
    741           * @retval kStatus_USB_Success              The receive request is sent successfully.
    742           * @retval kStatus_USB_InvalidHandle        The handle is a NULL pointer. Or the controller handle is invalid.
    743           * @retval kStatus_USB_Busy                 Cannot allocate dtds for current tansfer in EHCI driver.
    744           * @retval kStatus_USB_ControllerNotFound   Cannot find the controller.
    745           * @retval kStatus_USB_Error                The device is doing reset.
    746           *
    747           * @note The return value just means if the receiving request is successful or not; the transfer done is notified by the
    748           * corresponding callback function.
    749           * Currently, only one transfer request can be supported for one specific endpoint.
    750           * If there is a specific requirement to support multiple transfer requests for one specific endpoint, the application
    751           * should implement a queue in the application level.
    752           * The subsequent transfer could begin only when the previous transfer is done (get notification through the endpoint
    753           * callback).
    754           */

   \                                 In section .text, align 2, keep-with-next
    755          usb_status_t USB_DeviceRecvRequest(usb_device_handle handle, uint8_t endpointAddress, uint8_t *buffer, uint32_t length)
    756          {
   \                     USB_DeviceRecvRequest: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    757              return USB_DeviceTransfer(handle, (endpointAddress & USB_ENDPOINT_NUMBER_MASK) |
    758                                                    (USB_OUT << USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT),
    759                                        buffer, length);
   \   0000000A   0x003B             MOVS     R3,R7
   \   0000000C   0x0032             MOVS     R2,R6
   \   0000000E   0xF015 0x010F      ANDS     R1,R5,#0xF
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       USB_DeviceTransfer
   \   00000018   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    760          }
    761          
    762          /*!
    763           * @brief Cancel the pending transfer in a specified endpoint.
    764           *
    765           * The function is used to cancel the pending transfer in a specified endpoint.
    766           *
    767           * @param handle The device handle got from USB_DeviceInit.
    768           * @param endpointAddress Endpoint address, bit7 is the direction of endpoint, 1U - IN, abd 0U - OUT.
    769           *
    770           * @retval kStatus_USB_Success              The transfer is cancelled.
    771           * @retval kStatus_USB_InvalidHandle        The handle is a NULL pointer. Or the controller handle is invalid.
    772           * @retval kStatus_USB_ControllerNotFound   Cannot find the controller.
    773           */

   \                                 In section .text, align 2, keep-with-next
    774          usb_status_t USB_DeviceCancel(usb_device_handle handle, uint8_t endpointAddress)
    775          {
   \                     USB_DeviceCancel: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    776              usb_device_struct_t *deviceHandle = (usb_device_struct_t *)handle;
   \   00000006   0x0026             MOVS     R6,R4
    777              usb_status_t error = kStatus_USB_Error;
   \   00000008   0x2701             MOVS     R7,#+1
    778          
    779              if (NULL == deviceHandle)
   \   0000000A   0x2E00             CMP      R6,#+0
   \   0000000C   0xD101             BNE.N    ??USB_DeviceCancel_0
    780              {
    781                  return kStatus_USB_InvalidHandle;
   \   0000000E   0x2003             MOVS     R0,#+3
   \   00000010   0xE00E             B.N      ??USB_DeviceCancel_1
    782              }
    783          
    784              if (NULL != deviceHandle->controllerInterface)
   \                     ??USB_DeviceCancel_0: (+1)
   \   00000012   0x6870             LDR      R0,[R6, #+4]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD007             BEQ.N    ??USB_DeviceCancel_2
    785              {
    786                  error = deviceHandle->controllerInterface->deviceCancel(deviceHandle->controllerHandle, endpointAddress);
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   0x6830             LDR      R0,[R6, #+0]
   \   0000001E   0x6872             LDR      R2,[R6, #+4]
   \   00000020   0x6912             LDR      R2,[R2, #+16]
   \   00000022   0x4790             BLX      R2
   \   00000024   0x0007             MOVS     R7,R0
   \   00000026   0xE001             B.N      ??USB_DeviceCancel_3
    787              }
    788              else
    789              {
    790                  error = kStatus_USB_ControllerNotFound;
   \                     ??USB_DeviceCancel_2: (+1)
   \   00000028   0x2006             MOVS     R0,#+6
   \   0000002A   0x0007             MOVS     R7,R0
    791              }
    792              return error;
   \                     ??USB_DeviceCancel_3: (+1)
   \   0000002C   0x0038             MOVS     R0,R7
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceCancel_1: (+1)
   \   00000030   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    793          }
    794          
    795          /*!
    796           * @brief Initialize a specified endpoint.
    797           *
    798           * The function is used to initialize a specified endpoint and the corresponding endpoint callback is also initialized.
    799           *
    800           * @param handle The device handle got from USB_DeviceInit.
    801           * @param epInit Endpoint initizlization structure. Please refer to the structure usb_device_endpoint_init_struct_t.
    802           * @param endpointCallback Endpoint callback structure. Please refer to the structure
    803           * usb_device_endpoint_callback_struct_t.
    804           *
    805           * @retval kStatus_USB_Success              The endpoint is initialized successfully.
    806           * @retval kStatus_USB_InvalidHandle        The handle is a NULL pointer. Or the controller handle is invalid.
    807           * @retval kStatus_USB_InvalidParameter     The epInit or endpointCallback is NULL pointer. Or the endpoint number is
    808           * more than USB_DEVICE_CONFIG_ENDPOINTS.
    809           * @retval kStatus_USB_Busy                 The endpoint is busy in EHCI driver.
    810           * @retval kStatus_USB_ControllerNotFound   Cannot find the controller.
    811           */

   \                                 In section .text, align 2, keep-with-next
    812          usb_status_t USB_DeviceInitEndpoint(usb_device_handle handle,
    813                                              usb_device_endpoint_init_struct_t *epInit,
    814                                              usb_device_endpoint_callback_struct_t *endpointCallback)
    815          {
   \                     USB_DeviceInitEndpoint: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    816              usb_device_struct_t *deviceHandle = (usb_device_struct_t *)handle;
   \   0000000A   0x0027             MOVS     R7,R4
    817              uint8_t endpoint;
    818              uint8_t direction;
    819          
    820              if (!deviceHandle)
   \   0000000C   0x2F00             CMP      R7,#+0
   \   0000000E   0xD101             BNE.N    ??USB_DeviceInitEndpoint_0
    821              {
    822                  return kStatus_USB_InvalidHandle;
   \   00000010   0x2003             MOVS     R0,#+3
   \   00000012   0xE02E             B.N      ??USB_DeviceInitEndpoint_1
    823              }
    824          
    825              if ((!epInit) || (!endpointCallback))
   \                     ??USB_DeviceInitEndpoint_0: (+1)
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD001             BEQ.N    ??USB_DeviceInitEndpoint_2
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD101             BNE.N    ??USB_DeviceInitEndpoint_3
    826              {
    827                  return kStatus_USB_InvalidParameter;
   \                     ??USB_DeviceInitEndpoint_2: (+1)
   \   0000001C   0x2004             MOVS     R0,#+4
   \   0000001E   0xE028             B.N      ??USB_DeviceInitEndpoint_1
    828              }
    829          
    830              endpoint = epInit->endpointAddress & USB_ENDPOINT_NUMBER_MASK;
   \                     ??USB_DeviceInitEndpoint_3: (+1)
   \   00000020   0x78A8             LDRB     R0,[R5, #+2]
   \   00000022   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000026   0x4680             MOV      R8,R0
    831              direction = (epInit->endpointAddress & USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_MASK) >>
    832                          USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT;
   \   00000028   0x78A8             LDRB     R0,[R5, #+2]
   \   0000002A   0x09C0             LSRS     R0,R0,#+7
   \   0000002C   0x4681             MOV      R9,R0
    833          
    834              if (endpoint < USB_DEVICE_CONFIG_ENDPOINTS)
   \   0000002E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000032   0xF1B8 0x0F08      CMP      R8,#+8
   \   00000036   0xD21B             BCS.N    ??USB_DeviceInitEndpoint_4
    835              {
    836                  deviceHandle->endpointCallback[(uint8_t)((uint32_t)endpoint << 1U) | direction].callbackFn =
    837                      endpointCallback->callbackFn;
   \   00000038   0xEA5F 0x0048      LSLS     R0,R8,#+1
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000042   0xEA59 0x0000      ORRS     R0,R9,R0
   \   00000046   0xEB07 0x00C0      ADD      R0,R7,R0, LSL #+3
   \   0000004A   0x6831             LDR      R1,[R6, #+0]
   \   0000004C   0x60C1             STR      R1,[R0, #+12]
    838                  deviceHandle->endpointCallback[(uint8_t)((uint32_t)endpoint << 1U) | direction].callbackParam =
    839                      endpointCallback->callbackParam;
   \   0000004E   0xEA5F 0x0048      LSLS     R0,R8,#+1
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000058   0xEA59 0x0000      ORRS     R0,R9,R0
   \   0000005C   0xEB07 0x00C0      ADD      R0,R7,R0, LSL #+3
   \   00000060   0x6871             LDR      R1,[R6, #+4]
   \   00000062   0x6101             STR      R1,[R0, #+16]
    840              }
    841              else
    842              {
    843                  return kStatus_USB_InvalidParameter;
    844              }
    845              return USB_DeviceControl(handle, kUSB_DeviceControlEndpointInit, epInit);
   \   00000064   0x002A             MOVS     R2,R5
   \   00000066   0x2102             MOVS     R1,#+2
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x.... 0x....      BL       USB_DeviceControl
   \   0000006E   0xE000             B.N      ??USB_DeviceInitEndpoint_1
   \                     ??USB_DeviceInitEndpoint_4: (+1)
   \   00000070   0x2004             MOVS     R0,#+4
   \                     ??USB_DeviceInitEndpoint_1: (+1)
   \   00000072   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    846          }
    847          
    848          /*!
    849           * @brief De-initizlize a specified endpoint.
    850           *
    851           * The function is used to de-initizlize a specified endpoint.
    852           *
    853           * @param handle The device handle got from USB_DeviceInit.
    854           * @param endpointAddress Endpoint address, bit7 is the direction of endpoint, 1U - IN, abd 0U - OUT.
    855           *
    856           * @retval kStatus_USB_Success              The endpoint is de-initialized successfully.
    857           * @retval kStatus_USB_InvalidHandle        The handle is a NULL pointer. Or the controller handle is invalid.
    858           * @retval kStatus_USB_InvalidParameter     The endpoint number is more than USB_DEVICE_CONFIG_ENDPOINTS.
    859           * @retval kStatus_USB_Busy                 The endpoint is busy in EHCI driver.
    860           * @retval kStatus_USB_ControllerNotFound   Cannot find the controller.
    861           */

   \                                 In section .text, align 2, keep-with-next
    862          usb_status_t USB_DeviceDeinitEndpoint(usb_device_handle handle, uint8_t endpointAddress)
    863          {
   \                     USB_DeviceDeinitEndpoint: (+1)
   \   00000000   0xE92D 0x41F3      PUSH     {R0,R1,R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    864              usb_device_struct_t *deviceHandle = (usb_device_struct_t *)handle;
   \   00000006   0x0025             MOVS     R5,R4
    865              uint8_t endpoint = endpointAddress & USB_ENDPOINT_NUMBER_MASK;
   \   00000008   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000000C   0xF010 0x060F      ANDS     R6,R0,#0xF
    866              uint8_t direction = (endpointAddress & USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_MASK) >>
    867                                  USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT;
   \   00000010   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000014   0x09C7             LSRS     R7,R0,#+7
    868              usb_status_t error = kStatus_USB_Error;
   \   00000016   0xF05F 0x0801      MOVS     R8,#+1
    869          
    870              if (!deviceHandle)
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD101             BNE.N    ??USB_DeviceDeinitEndpoint_0
    871              {
    872                  return kStatus_USB_InvalidHandle;
   \   0000001E   0x2003             MOVS     R0,#+3
   \   00000020   0xE01C             B.N      ??USB_DeviceDeinitEndpoint_1
    873              }
    874              error = USB_DeviceControl(handle, kUSB_DeviceControlEndpointDeinit, &endpointAddress);
   \                     ??USB_DeviceDeinitEndpoint_0: (+1)
   \   00000022   0xAA01             ADD      R2,SP,#+4
   \   00000024   0x2103             MOVS     R1,#+3
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       USB_DeviceControl
   \   0000002C   0x4680             MOV      R8,R0
    875              if (endpoint < USB_DEVICE_CONFIG_ENDPOINTS)
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x2E08             CMP      R6,#+8
   \   00000032   0xD212             BCS.N    ??USB_DeviceDeinitEndpoint_2
    876              {
    877                  deviceHandle->endpointCallback[(uint8_t)((uint32_t)endpoint << 1U) | direction].callbackFn =
    878                      (usb_device_endpoint_callback_t)NULL;
   \   00000034   0x0070             LSLS     R0,R6,#+1
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003A   0x4338             ORRS     R0,R7,R0
   \   0000003C   0xEB05 0x00C0      ADD      R0,R5,R0, LSL #+3
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x60C1             STR      R1,[R0, #+12]
    879                  deviceHandle->endpointCallback[(uint8_t)((uint32_t)endpoint << 1U) | direction].callbackParam = NULL;
   \   00000044   0x0070             LSLS     R0,R6,#+1
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000004A   0x4338             ORRS     R0,R7,R0
   \   0000004C   0xEB05 0x00C0      ADD      R0,R5,R0, LSL #+3
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x6101             STR      R1,[R0, #+16]
    880              }
    881              else
    882              {
    883                  return kStatus_USB_InvalidParameter;
    884              }
    885              return error;
   \   00000054   0x4640             MOV      R0,R8
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0xE000             B.N      ??USB_DeviceDeinitEndpoint_1
   \                     ??USB_DeviceDeinitEndpoint_2: (+1)
   \   0000005A   0x2004             MOVS     R0,#+4
   \                     ??USB_DeviceDeinitEndpoint_1: (+1)
   \   0000005C   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    886          }
    887          
    888          /*!
    889           * @brief Stall a specified endpoint.
    890           *
    891           * The function is used to stall a specified endpoint.
    892           *
    893           * @param handle The device handle got from USB_DeviceInit.
    894           * @param endpointAddress Endpoint address, bit7 is the direction of endpoint, 1U - IN, abd 0U - OUT.
    895           *
    896           * @retval kStatus_USB_Success              The endpoint is stalled successfully.
    897           * @retval kStatus_USB_InvalidHandle        The handle is a NULL pointer. Or the controller handle is invalid.
    898           * @retval kStatus_USB_InvalidParameter     The endpoint number is more than USB_DEVICE_CONFIG_ENDPOINTS.
    899           * @retval kStatus_USB_ControllerNotFound   Cannot find the controller.
    900           */

   \                                 In section .text, align 2, keep-with-next
    901          usb_status_t USB_DeviceStallEndpoint(usb_device_handle handle, uint8_t endpointAddress)
    902          {
   \                     USB_DeviceStallEndpoint: (+1)
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    903              if ((endpointAddress & USB_ENDPOINT_NUMBER_MASK) < USB_DEVICE_CONFIG_ENDPOINTS)
   \   00000004   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000008   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD205             BCS.N    ??USB_DeviceStallEndpoint_0
    904              {
    905                  return USB_DeviceControl(handle, kUSB_DeviceControlEndpointStall, &endpointAddress);
   \   00000010   0xAA01             ADD      R2,SP,#+4
   \   00000012   0x2104             MOVS     R1,#+4
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       USB_DeviceControl
   \   0000001A   0xE000             B.N      ??USB_DeviceStallEndpoint_1
    906              }
    907              else
    908              {
    909                  return kStatus_USB_InvalidParameter;
   \                     ??USB_DeviceStallEndpoint_0: (+1)
   \   0000001C   0x2004             MOVS     R0,#+4
   \                     ??USB_DeviceStallEndpoint_1: (+1)
   \   0000001E   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    910              }
    911          }
    912          
    913          /*!
    914           * @brief Un-stall a specified endpoint.
    915           *
    916           * The function is used to un-stall a specified endpoint.
    917           *
    918           * @param handle The device handle got from USB_DeviceInit.
    919           * @param endpointAddress Endpoint address, bit7 is the direction of endpoint, 1U - IN, abd 0U - OUT.
    920           *
    921           * @retval kStatus_USB_Success              The endpoint is un-stalled successfully.
    922           * @retval kStatus_USB_InvalidHandle        The handle is a NULL pointer. Or the controller handle is invalid.
    923           * @retval kStatus_USB_InvalidParameter     The endpoint number is more than USB_DEVICE_CONFIG_ENDPOINTS.
    924           * @retval kStatus_USB_ControllerNotFound   Cannot find the controller.
    925           */

   \                                 In section .text, align 2, keep-with-next
    926          usb_status_t USB_DeviceUnstallEndpoint(usb_device_handle handle, uint8_t endpointAddress)
    927          {
   \                     USB_DeviceUnstallEndpoint: (+1)
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    928              if ((endpointAddress & USB_ENDPOINT_NUMBER_MASK) < USB_DEVICE_CONFIG_ENDPOINTS)
   \   00000004   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000008   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD205             BCS.N    ??USB_DeviceUnstallEndpoint_0
    929              {
    930                  return USB_DeviceControl(handle, kUSB_DeviceControlEndpointUnstall, &endpointAddress);
   \   00000010   0xAA01             ADD      R2,SP,#+4
   \   00000012   0x2105             MOVS     R1,#+5
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       USB_DeviceControl
   \   0000001A   0xE000             B.N      ??USB_DeviceUnstallEndpoint_1
    931              }
    932              else
    933              {
    934                  return kStatus_USB_InvalidParameter;
   \                     ??USB_DeviceUnstallEndpoint_0: (+1)
   \   0000001C   0x2004             MOVS     R0,#+4
   \                     ??USB_DeviceUnstallEndpoint_1: (+1)
   \   0000001E   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    935              }
    936          }
    937          
    938          /*!
    939           * @brief Get the status of the selected item.
    940           *
    941           * The function is used to get the status of the selected item.
    942           *
    943           * @param handle The device handle got from USB_DeviceInit.
    944           * @param type   The selected item. Please refer to the structure usb_device_status_t.
    945           * @param param  The param type is determined by the selected item.
    946           *
    947           * @retval kStatus_USB_Success              Get status successfully.
    948           * @retval kStatus_USB_InvalidHandle        The handle is a NULL pointer. Or the controller handle is invalid.
    949           * @retval kStatus_USB_InvalidParameter     The param is NULL pointer.
    950           * @retval kStatus_USB_ControllerNotFound   Cannot find the controller.
    951           * @retval kStatus_USB_Error                Unsupported type.
    952           */

   \                                 In section .text, align 2, keep-with-next
    953          usb_status_t USB_DeviceGetStatus(usb_device_handle handle, usb_device_status_t type, void *param)
    954          {
   \                     USB_DeviceGetStatus: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    955              uint8_t *temp8;
    956              usb_status_t error = kStatus_USB_Error;
   \   0000000A   0xF05F 0x0801      MOVS     R8,#+1
    957          
    958              if (NULL == param)
   \   0000000E   0x2E00             CMP      R6,#+0
   \   00000010   0xD101             BNE.N    ??USB_DeviceGetStatus_0
    959              {
    960                  return kStatus_USB_InvalidParameter;
   \   00000012   0x2004             MOVS     R0,#+4
   \   00000014   0xE040             B.N      ??USB_DeviceGetStatus_1
    961              }
    962              switch (type)
   \                     ??USB_DeviceGetStatus_0: (+1)
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D02             CMP      R5,#+2
   \   0000001A   0xD00A             BEQ.N    ??USB_DeviceGetStatus_2
   \   0000001C   0xD33A             BCC.N    ??USB_DeviceGetStatus_3
   \   0000001E   0x2D04             CMP      R5,#+4
   \   00000020   0xD023             BEQ.N    ??USB_DeviceGetStatus_4
   \   00000022   0xD30D             BCC.N    ??USB_DeviceGetStatus_5
   \   00000024   0x2D06             CMP      R5,#+6
   \   00000026   0xD012             BEQ.N    ??USB_DeviceGetStatus_6
   \   00000028   0xD326             BCC.N    ??USB_DeviceGetStatus_7
   \   0000002A   0x2D08             CMP      R5,#+8
   \   0000002C   0xD02B             BEQ.N    ??USB_DeviceGetStatus_8
   \   0000002E   0xD315             BCC.N    ??USB_DeviceGetStatus_9
   \   00000030   0xE030             B.N      ??USB_DeviceGetStatus_3
    963              {
    964                  case kUSB_DeviceStatusSpeed:
    965                      error = USB_DeviceControl(handle, kUSB_DeviceControlGetSpeed, param);
   \                     ??USB_DeviceGetStatus_2: (+1)
   \   00000032   0x0032             MOVS     R2,R6
   \   00000034   0x210C             MOVS     R1,#+12
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       USB_DeviceControl
   \   0000003C   0x4680             MOV      R8,R0
    966                      break;
   \   0000003E   0xE029             B.N      ??USB_DeviceGetStatus_10
    967                  case kUSB_DeviceStatusOtg:
    968                      error = USB_DeviceControl(handle, kUSB_DeviceControlGetOtgStatus, param);
   \                     ??USB_DeviceGetStatus_5: (+1)
   \   00000040   0x0032             MOVS     R2,R6
   \   00000042   0x210D             MOVS     R1,#+13
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       USB_DeviceControl
   \   0000004A   0x4680             MOV      R8,R0
    969                      break;
   \   0000004C   0xE022             B.N      ??USB_DeviceGetStatus_10
    970                  case kUSB_DeviceStatusDeviceState:
    971                      temp8 = (uint8_t *)param;
   \                     ??USB_DeviceGetStatus_6: (+1)
   \   0000004E   0x0037             MOVS     R7,R6
    972                      error = kStatus_USB_Success;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x4680             MOV      R8,R0
    973                      *temp8 = ((usb_device_struct_t *)handle)->state;
   \   00000054   0xF894 0x008E      LDRB     R0,[R4, #+142]
   \   00000058   0x7038             STRB     R0,[R7, #+0]
    974                      break;
   \   0000005A   0xE01B             B.N      ??USB_DeviceGetStatus_10
    975                  case kUSB_DeviceStatusAddress:
    976                      temp8 = (uint8_t *)param;
   \                     ??USB_DeviceGetStatus_9: (+1)
   \   0000005C   0x0037             MOVS     R7,R6
    977                      error = kStatus_USB_Success;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x4680             MOV      R8,R0
    978                      *temp8 = ((usb_device_struct_t *)handle)->deviceAddress;
   \   00000062   0xF894 0x008C      LDRB     R0,[R4, #+140]
   \   00000066   0x7038             STRB     R0,[R7, #+0]
    979                      break;
   \   00000068   0xE014             B.N      ??USB_DeviceGetStatus_10
    980                  case kUSB_DeviceStatusDevice:
    981                      error = USB_DeviceControl(handle, kUSB_DeviceControlGetDeviceStatus, param);
   \                     ??USB_DeviceGetStatus_4: (+1)
   \   0000006A   0x0032             MOVS     R2,R6
   \   0000006C   0x2106             MOVS     R1,#+6
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x.... 0x....      BL       USB_DeviceControl
   \   00000074   0x4680             MOV      R8,R0
    982                      break;
   \   00000076   0xE00D             B.N      ??USB_DeviceGetStatus_10
    983                  case kUSB_DeviceStatusEndpoint:
    984                      error = USB_DeviceControl(handle, kUSB_DeviceControlGetEndpointStatus, param);
   \                     ??USB_DeviceGetStatus_7: (+1)
   \   00000078   0x0032             MOVS     R2,R6
   \   0000007A   0x2107             MOVS     R1,#+7
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0x.... 0x....      BL       USB_DeviceControl
   \   00000082   0x4680             MOV      R8,R0
    985                      break;
   \   00000084   0xE006             B.N      ??USB_DeviceGetStatus_10
    986                  case kUSB_DeviceStatusSynchFrame:
    987                      error = USB_DeviceControl(handle, kUSB_DeviceControlGetSynchFrame, param);
   \                     ??USB_DeviceGetStatus_8: (+1)
   \   00000086   0x0032             MOVS     R2,R6
   \   00000088   0x2109             MOVS     R1,#+9
   \   0000008A   0x0020             MOVS     R0,R4
   \   0000008C   0x.... 0x....      BL       USB_DeviceControl
   \   00000090   0x4680             MOV      R8,R0
    988                      break;
   \   00000092   0xE7FF             B.N      ??USB_DeviceGetStatus_10
    989                  default:
    990                      break;
    991              }
    992              return error;
   \                     ??USB_DeviceGetStatus_3: (+1)
   \                     ??USB_DeviceGetStatus_10: (+1)
   \   00000094   0x4640             MOV      R0,R8
   \   00000096   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceGetStatus_1: (+1)
   \   00000098   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    993          }
    994          
    995          /*!
    996           * @brief Set the status of the selected item.
    997           *
    998           * The function is used to set the status of the selected item.
    999           *
   1000           * @param handle The device handle got from USB_DeviceInit.
   1001           * @param type The selected item. Please refer to the structure usb_device_status_t.
   1002           * @param param The param type is determined by the selected item.
   1003           *
   1004           * @retval kStatus_USB_Success              Set status successfully.
   1005           * @retval kStatus_USB_InvalidHandle        The handle is a NULL pointer. Or the controller handle is invalid.
   1006           * @retval kStatus_USB_ControllerNotFound   Cannot find the controller.
   1007           * @retval kStatus_USB_Error                Unsupported type, or the param is NULL pointer.
   1008           */

   \                                 In section .text, align 2, keep-with-next
   1009          usb_status_t USB_DeviceSetStatus(usb_device_handle handle, usb_device_status_t type, void *param)
   1010          {
   \                     USB_DeviceSetStatus: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1011              usb_status_t error = kStatus_USB_Error;
   \   00000008   0x2701             MOVS     R7,#+1
   1012              switch (type)
   \   0000000A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x2803             CMP      R0,#+3
   \   00000010   0xD006             BEQ.N    ??USB_DeviceSetStatus_0
   \   00000012   0x2806             CMP      R0,#+6
   \   00000014   0xD00B             BEQ.N    ??USB_DeviceSetStatus_1
   \   00000016   0x2807             CMP      R0,#+7
   \   00000018   0xD011             BEQ.N    ??USB_DeviceSetStatus_2
   \   0000001A   0x2809             CMP      R0,#+9
   \   0000001C   0xD026             BEQ.N    ??USB_DeviceSetStatus_3
   \   0000001E   0xE02C             B.N      ??USB_DeviceSetStatus_4
   1013              {
   1014          #if (defined(USB_DEVICE_CONFIG_EHCI) && (USB_DEVICE_CONFIG_EHCI > 0U)) && \
   1015              (defined(USB_DEVICE_CONFIG_EHCI_TEST_MODE) && (USB_DEVICE_CONFIG_EHCI_TEST_MODE > 0U))
   1016                  case kUSB_DeviceStatusTestMode:
   1017                      error = USB_DeviceControl(handle, kUSB_DeviceControlSetTestMode, param);
   1018                      break;
   1019          #endif
   1020                  case kUSB_DeviceStatusOtg:
   1021                      error = USB_DeviceControl(handle, kUSB_DeviceControlSetOtgStatus, param);
   \                     ??USB_DeviceSetStatus_0: (+1)
   \   00000020   0x0032             MOVS     R2,R6
   \   00000022   0x210E             MOVS     R1,#+14
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       USB_DeviceControl
   \   0000002A   0x0007             MOVS     R7,R0
   1022                      break;
   \   0000002C   0xE025             B.N      ??USB_DeviceSetStatus_5
   1023                  case kUSB_DeviceStatusDeviceState:
   1024                      if (NULL != param)
   \                     ??USB_DeviceSetStatus_1: (+1)
   \   0000002E   0x2E00             CMP      R6,#+0
   \   00000030   0xD004             BEQ.N    ??USB_DeviceSetStatus_6
   1025                      {
   1026                          error = kStatus_USB_Success;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x0007             MOVS     R7,R0
   1027                          ((usb_device_struct_t *)handle)->state = (uint8_t)(*(uint8_t *)param);
   \   00000036   0x7830             LDRB     R0,[R6, #+0]
   \   00000038   0xF884 0x008E      STRB     R0,[R4, #+142]
   1028                      }
   1029                      break;
   \                     ??USB_DeviceSetStatus_6: (+1)
   \   0000003C   0xE01D             B.N      ??USB_DeviceSetStatus_5
   1030                  case kUSB_DeviceStatusAddress:
   1031                      if (kUSB_DeviceStateAddressing != ((usb_device_struct_t *)handle)->state)
   \                     ??USB_DeviceSetStatus_2: (+1)
   \   0000003E   0xF894 0x008E      LDRB     R0,[R4, #+142]
   \   00000042   0x2803             CMP      R0,#+3
   \   00000044   0xD00A             BEQ.N    ??USB_DeviceSetStatus_7
   1032                      {
   1033                          if (NULL != param)
   \   00000046   0x2E00             CMP      R6,#+0
   \   00000048   0xD00F             BEQ.N    ??USB_DeviceSetStatus_8
   1034                          {
   1035                              error = kStatus_USB_Success;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x0007             MOVS     R7,R0
   1036                              ((usb_device_struct_t *)handle)->deviceAddress = (uint8_t)(*(uint8_t *)param);
   \   0000004E   0x7830             LDRB     R0,[R6, #+0]
   \   00000050   0xF884 0x008C      STRB     R0,[R4, #+140]
   1037                              ((usb_device_struct_t *)handle)->state = kUSB_DeviceStateAddressing;
   \   00000054   0x2003             MOVS     R0,#+3
   \   00000056   0xF884 0x008E      STRB     R0,[R4, #+142]
   \   0000005A   0xE006             B.N      ??USB_DeviceSetStatus_8
   1038                          }
   1039                      }
   1040                      else
   1041                      {
   1042                          error = USB_DeviceControl(handle, kUSB_DeviceControlSetDeviceAddress,
   1043                                                    &((usb_device_struct_t *)handle)->deviceAddress);
   \                     ??USB_DeviceSetStatus_7: (+1)
   \   0000005C   0xF114 0x028C      ADDS     R2,R4,#+140
   \   00000060   0x2108             MOVS     R1,#+8
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0x.... 0x....      BL       USB_DeviceControl
   \   00000068   0x0007             MOVS     R7,R0
   1044                      }
   1045                      break;
   \                     ??USB_DeviceSetStatus_8: (+1)
   \   0000006A   0xE006             B.N      ??USB_DeviceSetStatus_5
   1046                  case kUSB_DeviceStatusBus:
   1047                      error = USB_DeviceControl(handle, kUSB_DeviceControlResume, param);
   \                     ??USB_DeviceSetStatus_3: (+1)
   \   0000006C   0x0032             MOVS     R2,R6
   \   0000006E   0x210A             MOVS     R1,#+10
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0x.... 0x....      BL       USB_DeviceControl
   \   00000076   0x0007             MOVS     R7,R0
   1048                      break;
   \   00000078   0xE7FF             B.N      ??USB_DeviceSetStatus_5
   1049                  default:
   1050                      break;
   1051              }
   1052              return error;
   \                     ??USB_DeviceSetStatus_4: (+1)
   \                     ??USB_DeviceSetStatus_5: (+1)
   \   0000007A   0x0038             MOVS     R0,R7
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1053          }
   1054          
   1055          #if USB_DEVICE_CONFIG_USE_TASK
   1056          /*!
   1057           * @brief Device task function.
   1058           *
   1059           * The function is used to handle controller message.
   1060           * This function should not be called in applicartion directly.
   1061           *
   1062           * @param handle The device handle got from USB_DeviceInit.
   1063           */
   1064          void USB_DeviceTaskFunction(void *deviceHandle)
   1065          {
   1066              usb_device_struct_t *handle = (usb_device_struct_t *)deviceHandle;
   1067              static usb_device_callback_message_struct_t message;
   1068          
   1069              if (deviceHandle)
   1070              {
   1071                  /* Get the message from the queue */
   1072                  if (kStatus_USB_OSA_Success == USB_OsaMsgqRecv(handle->notificationQueue, (uint32_t *)&message, 0U))
   1073                  {
   1074                      /* Handle the message */
   1075                      USB_DeviceNotification(handle, &message);
   1076                  }
   1077              }
   1078          }
   1079          #endif
   1080          
   1081          /*!
   1082           * @brief Get dvice stack version function.
   1083           *
   1084           * The function is used to get dvice stack version.
   1085           *
   1086           * @param[out] version The version structure pointer to keep the device stack version.
   1087           *
   1088           */

   \                                 In section .text, align 2, keep-with-next
   1089          void USB_DeviceGetVersion(uint32_t *version)
   1090          {
   1091              if (version)
   \                     USB_DeviceGetVersion: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD002             BEQ.N    ??USB_DeviceGetVersion_0
   1092              {
   1093                  *version =
   1094                      (uint32_t)USB_MAKE_VERSION(USB_STACK_VERSION_MAJOR, USB_STACK_VERSION_MINOR, USB_STACK_VERSION_BUGFIX);
   \   00000004   0xF45F 0x3180      MOVS     R1,#+65536
   \   00000008   0x6001             STR      R1,[R0, #+0]
   1095              }
   1096          }
   \                     ??USB_DeviceGetVersion_0: (+1)
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     s_UsbDevice

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     s_UsbDeviceKhciInterface
   1097          #endif /* USB_DEVICE_CONFIG_NUM */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   USB_DeviceAllocateHandle
        16   -> USB_BmEnterCritical
        16   -> USB_BmExitCritical
      24   USB_DeviceCancel
        24   -- Indirect call
      24   USB_DeviceControl
        24   -- Indirect call
      16   USB_DeviceDeinit
        16   -- Indirect call
        16   -> USB_DeviceFreeHandle
      32   USB_DeviceDeinitEndpoint
        32   -> USB_DeviceControl
       8   USB_DeviceFreeHandle
         8   -> USB_BmEnterCritical
         8   -> USB_BmExitCritical
       4   USB_DeviceGetControllerInterface
      24   USB_DeviceGetStatus
        24   -> USB_DeviceControl
       0   USB_DeviceGetVersion
      32   USB_DeviceInit
        32   -- Indirect call
        32   -> USB_DeviceAllocateHandle
        32   -> USB_DeviceDeinit
        32   -> USB_DeviceFreeHandle
        32   -> USB_DeviceGetControllerInterface
      32   USB_DeviceInitEndpoint
        32   -> USB_DeviceControl
      40   USB_DeviceNotification
        40   -- Indirect call
        40   -> USB_DeviceResetNotification
      24   USB_DeviceNotificationTrigger
        24   -> USB_DeviceNotification
      24   USB_DeviceRecvRequest
        24   -> USB_DeviceTransfer
      16   USB_DeviceResetNotification
        16   -- Indirect call
        16   -> USB_DeviceControl
       8   USB_DeviceRun
         8   -> USB_DeviceControl
      24   USB_DeviceSendRequest
        24   -> USB_DeviceTransfer
      24   USB_DeviceSetStatus
        24   -> USB_DeviceControl
      16   USB_DeviceStallEndpoint
        16   -> USB_DeviceControl
       8   USB_DeviceStop
         8   -> USB_DeviceControl
      32   USB_DeviceTransfer
        32   -- Indirect call
      16   USB_DeviceUnstallEndpoint
        16   -> USB_DeviceControl


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
     134  USB_DeviceAllocateHandle
      50  USB_DeviceCancel
      60  USB_DeviceControl
      42  USB_DeviceDeinit
      96  USB_DeviceDeinitEndpoint
      26  USB_DeviceFreeHandle
      32  USB_DeviceGetControllerInterface
     156  USB_DeviceGetStatus
      12  USB_DeviceGetVersion
     286  USB_DeviceInit
     118  USB_DeviceInitEndpoint
     126  USB_DeviceNotification
      42  USB_DeviceNotificationTrigger
      26  USB_DeviceRecvRequest
      68  USB_DeviceResetNotification
      16  USB_DeviceRun
      32  USB_DeviceSendRequest
     128  USB_DeviceSetStatus
      32  USB_DeviceStallEndpoint
      16  USB_DeviceStop
     104  USB_DeviceTransfer
      32  USB_DeviceUnstallEndpoint
     144  s_UsbDevice
      24  s_UsbDeviceKhciInterface

 
    24 bytes in section .rodata
 1 642 bytes in section .text
   144 bytes in section m_usb_global
 
 1 642 bytes of CODE  memory
    24 bytes of CONST memory
   144 bytes of DATA  memory

Errors: none
Warnings: none
