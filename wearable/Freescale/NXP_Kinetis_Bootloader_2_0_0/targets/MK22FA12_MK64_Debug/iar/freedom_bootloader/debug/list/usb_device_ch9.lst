###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:13
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\usb_device_ch9.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\usb_device_ch9.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\usb_device_ch9.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\usb_device_ch9.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\usb_device_ch9.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "usb_device_config.h"
     32          #include "usb.h"
     33          
     34          #include "usb_device.h"
     35          #include "usb_device_dci.h"
     36          #include "usb_device_class.h"
     37          #include "usb_device_ch9.h"
     38          #if ((defined(USB_DEVICE_CONFIG_NUM)) && (USB_DEVICE_CONFIG_NUM > 0U))
     39          /*******************************************************************************
     40           * Definitions
     41           ******************************************************************************/
     42          
     43          /*!
     44           * @brief Standard request callback function typedef.
     45           *
     46           * This function is used to handle the standard request.
     47           *
     48           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
     49           * @param setup           The pointer of the setup packet.
     50           * @param buffer          It is an out parameter, is used to save the buffer address to response the host's request.
     51           * @param length          It is an out parameter, the data length.
     52           *
     53           * @return A USB error code or kStatus_USB_Success.
     54           */
     55          typedef usb_status_t (*usb_standard_request_callback_t)(usb_device_common_class_struct_t *classHandle,
     56                                                                  usb_setup_struct_t *setup,
     57                                                                  uint8_t **buffer,
     58                                                                  uint32_t *length);
     59          
     60          /*******************************************************************************
     61           * Prototypes
     62           ******************************************************************************/
     63          
     64          static usb_status_t USB_DeviceCh9GetStatus(usb_device_common_class_struct_t *classHandle,
     65                                                     usb_setup_struct_t *setup,
     66                                                     uint8_t **buffer,
     67                                                     uint32_t *length);
     68          static usb_status_t USB_DeviceCh9SetClearFeature(usb_device_common_class_struct_t *classHandle,
     69                                                           usb_setup_struct_t *setup,
     70                                                           uint8_t **buffer,
     71                                                           uint32_t *length);
     72          
     73          static usb_status_t USB_DeviceCh9SetAddress(usb_device_common_class_struct_t *classHandle,
     74                                                      usb_setup_struct_t *setup,
     75                                                      uint8_t **buffer,
     76                                                      uint32_t *length);
     77          static usb_status_t USB_DeviceCh9GetDescriptor(usb_device_common_class_struct_t *classHandle,
     78                                                         usb_setup_struct_t *setup,
     79                                                         uint8_t **buffer,
     80                                                         uint32_t *length);
     81          static usb_status_t USB_DeviceCh9GetConfiguration(usb_device_common_class_struct_t *classHandle,
     82                                                            usb_setup_struct_t *setup,
     83                                                            uint8_t **buffer,
     84                                                            uint32_t *length);
     85          static usb_status_t USB_DeviceCh9SetConfiguration(usb_device_common_class_struct_t *classHandle,
     86                                                            usb_setup_struct_t *setup,
     87                                                            uint8_t **buffer,
     88                                                            uint32_t *length);
     89          static usb_status_t USB_DeviceCh9GetInterface(usb_device_common_class_struct_t *classHandle,
     90                                                        usb_setup_struct_t *setup,
     91                                                        uint8_t **buffer,
     92                                                        uint32_t *length);
     93          static usb_status_t USB_DeviceCh9SetInterface(usb_device_common_class_struct_t *classHandle,
     94                                                        usb_setup_struct_t *setup,
     95                                                        uint8_t **buffer,
     96                                                        uint32_t *length);
     97          static usb_status_t USB_DeviceCh9SynchFrame(usb_device_common_class_struct_t *classHandle,
     98                                                      usb_setup_struct_t *setup,
     99                                                      uint8_t **buffer,
    100                                                      uint32_t *length);
    101          
    102          /*******************************************************************************
    103           * Variables
    104           ******************************************************************************/
    105          
    106          /* The function list to handle the standard request. */

   \                                 In section .rodata, align 4
    107          static const usb_standard_request_callback_t s_UsbDeviceStandardRequest[] = {
   \                     s_UsbDeviceStandardRequest:
   \   00000000   0x........         DC32 USB_DeviceCh9GetStatus, USB_DeviceCh9SetClearFeature, 0H
   \              0x........   
   \              0x00000000   
   \   0000000C   0x........         DC32 USB_DeviceCh9SetClearFeature, 0H, USB_DeviceCh9SetAddress
   \              0x00000000   
   \              0x........   
   \   00000018   0x........         DC32 USB_DeviceCh9GetDescriptor, 0H, USB_DeviceCh9GetConfiguration
   \              0x00000000   
   \              0x........   
   \   00000024   0x........         DC32 USB_DeviceCh9SetConfiguration, USB_DeviceCh9GetInterface
   \              0x........   
   \   0000002C   0x........         DC32 USB_DeviceCh9SetInterface, USB_DeviceCh9SynchFrame
   \              0x........   
    108              USB_DeviceCh9GetStatus,
    109              USB_DeviceCh9SetClearFeature,
    110              (usb_standard_request_callback_t)NULL,
    111              USB_DeviceCh9SetClearFeature,
    112              (usb_standard_request_callback_t)NULL,
    113              USB_DeviceCh9SetAddress,
    114              USB_DeviceCh9GetDescriptor,
    115              (usb_standard_request_callback_t)NULL,
    116              USB_DeviceCh9GetConfiguration,
    117              USB_DeviceCh9SetConfiguration,
    118              USB_DeviceCh9GetInterface,
    119              USB_DeviceCh9SetInterface,
    120              USB_DeviceCh9SynchFrame,
    121          };
    122          
    123          /*******************************************************************************
    124           * Code
    125           ******************************************************************************/
    126          
    127          /*!
    128           * @brief Handle get status request.
    129           *
    130           * This function is used to handle get status request.
    131           *
    132           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    133           * @param setup           The pointer of the setup packet.
    134           * @param buffer          It is an out parameter, is used to save the buffer address to response the host's request.
    135           * @param length          It is an out parameter, the data length.
    136           *
    137           * @retval kStatus_USB_Success              The requst is handled successfully.
    138           * @retval kStatus_USB_InvalidRequest       The request can not be handle in current device state,
    139           *                                          or, the request is unsupported.
    140           */

   \                                 In section .text, align 2, keep-with-next
    141          static usb_status_t USB_DeviceCh9GetStatus(usb_device_common_class_struct_t *classHandle,
    142                                                     usb_setup_struct_t *setup,
    143                                                     uint8_t **buffer,
    144                                                     uint32_t *length)
    145          {
   \                     USB_DeviceCh9GetStatus: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    146              usb_status_t error = kStatus_USB_InvalidRequest;
   \   0000000C   0xF05F 0x0805      MOVS     R8,#+5
    147              uint8_t state;
    148          
    149              USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
   \   00000010   0xAA01             ADD      R2,SP,#+4
   \   00000012   0x2106             MOVS     R1,#+6
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x.... 0x....      BL       USB_DeviceGetStatus
    150          
    151              if ((kUSB_DeviceStateAddress != state) && (kUSB_DeviceStateConfigured != state))
   \   0000001A   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD006             BEQ.N    ??USB_DeviceCh9GetStatus_0
   \   00000022   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD002             BEQ.N    ??USB_DeviceCh9GetStatus_0
    152              {
    153                  return error;
   \   0000002A   0x4640             MOV      R0,R8
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0xE03E             B.N      ??USB_DeviceCh9GetStatus_1
    154              }
    155          
    156              if ((setup->bmRequestType & USB_REQUEST_TYPE_RECIPIENT_MASK) == USB_REQUEST_TYPE_RECIPIENT_DEVICE)
   \                     ??USB_DeviceCh9GetStatus_0: (+1)
   \   00000030   0x7828             LDRB     R0,[R5, #+0]
   \   00000032   0x211F             MOVS     R1,#+31
   \   00000034   0x4208             TST      R0,R1
   \   00000036   0xD10F             BNE.N    ??USB_DeviceCh9GetStatus_2
    157              {
    158                  /* Get the device status */
    159                  error =
    160                      USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusDevice, &classHandle->standardTranscationBuffer);
   \   00000038   0xF114 0x0210      ADDS     R2,R4,#+16
   \   0000003C   0x2104             MOVS     R1,#+4
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x.... 0x....      BL       USB_DeviceGetStatus
   \   00000044   0x4680             MOV      R8,R0
    161                  classHandle->standardTranscationBuffer = classHandle->standardTranscationBuffer & USB_GET_STATUS_DEVICE_MASK;
   \   00000046   0x7C20             LDRB     R0,[R4, #+16]
   \   00000048   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   0000004C   0x8220             STRH     R0,[R4, #+16]
    162                  classHandle->standardTranscationBuffer = USB_SHORT_TO_LITTLE_ENDIAN(classHandle->standardTranscationBuffer);
   \   0000004E   0x8A20             LDRH     R0,[R4, #+16]
   \   00000050   0x8220             STRH     R0,[R4, #+16]
    163                  /* The device status length must be USB_DEVICE_STATUS_SIZE. */
    164                  *length = USB_DEVICE_STATUS_SIZE;
   \   00000052   0x2002             MOVS     R0,#+2
   \   00000054   0x6038             STR      R0,[R7, #+0]
   \   00000056   0xE025             B.N      ??USB_DeviceCh9GetStatus_3
    165              }
    166              else if ((setup->bmRequestType & USB_REQUEST_TYPE_RECIPIENT_MASK) == USB_REQUEST_TYPE_RECIPIENT_INTERFACE)
   \                     ??USB_DeviceCh9GetStatus_2: (+1)
   \   00000058   0x7828             LDRB     R0,[R5, #+0]
   \   0000005A   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   0000005E   0x2801             CMP      R0,#+1
   \   00000060   0xD106             BNE.N    ??USB_DeviceCh9GetStatus_4
    167              {
    168                  /* Get the interface status */
    169                  error = kStatus_USB_Success;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x4680             MOV      R8,R0
    170                  classHandle->standardTranscationBuffer = 0U;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x8220             STRH     R0,[R4, #+16]
    171                  /* The interface status length must be USB_INTERFACE_STATUS_SIZE. */
    172                  *length = USB_INTERFACE_STATUS_SIZE;
   \   0000006A   0x2002             MOVS     R0,#+2
   \   0000006C   0x6038             STR      R0,[R7, #+0]
   \   0000006E   0xE019             B.N      ??USB_DeviceCh9GetStatus_3
    173              }
    174              else if ((setup->bmRequestType & USB_REQUEST_TYPE_RECIPIENT_MASK) == USB_REQUEST_TYPE_RECIPIENT_ENDPOINT)
   \                     ??USB_DeviceCh9GetStatus_4: (+1)
   \   00000070   0x7828             LDRB     R0,[R5, #+0]
   \   00000072   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000076   0x2802             CMP      R0,#+2
   \   00000078   0xD114             BNE.N    ??USB_DeviceCh9GetStatus_3
    175              {
    176                  /* Get the endpoint status */
    177                  usb_device_endpoint_status_struct_t endpointStatus;
    178                  endpointStatus.endpointAddress = (uint8_t)setup->wIndex;
   \   0000007A   0x88A8             LDRH     R0,[R5, #+4]
   \   0000007C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    179                  endpointStatus.endpointStatus = kUSB_DeviceEndpointStateIdle;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    180                  error = USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusEndpoint, &endpointStatus);
   \   00000086   0x466A             MOV      R2,SP
   \   00000088   0x2105             MOVS     R1,#+5
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x.... 0x....      BL       USB_DeviceGetStatus
   \   00000090   0x4680             MOV      R8,R0
    181                  classHandle->standardTranscationBuffer = endpointStatus.endpointStatus & USB_GET_STATUS_ENDPOINT_MASK;
   \   00000092   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000096   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   0000009A   0x8220             STRH     R0,[R4, #+16]
    182                  classHandle->standardTranscationBuffer = USB_SHORT_TO_LITTLE_ENDIAN(classHandle->standardTranscationBuffer);
   \   0000009C   0x8A20             LDRH     R0,[R4, #+16]
   \   0000009E   0x8220             STRH     R0,[R4, #+16]
    183                  /* The endpoint status length must be USB_INTERFACE_STATUS_SIZE. */
    184                  *length = USB_ENDPOINT_STATUS_SIZE;
   \   000000A0   0x2002             MOVS     R0,#+2
   \   000000A2   0x6038             STR      R0,[R7, #+0]
    185              }
    186              else
    187              {
    188              }
    189              *buffer = (uint8_t *)&classHandle->standardTranscationBuffer;
   \                     ??USB_DeviceCh9GetStatus_3: (+1)
   \   000000A4   0xF114 0x0010      ADDS     R0,R4,#+16
   \   000000A8   0x6030             STR      R0,[R6, #+0]
    190          
    191              return error;
   \   000000AA   0x4640             MOV      R0,R8
   \   000000AC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceCh9GetStatus_1: (+1)
   \   000000AE   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    192          }
    193          
    194          /*!
    195           * @brief Handle set or clear device feature request.
    196           *
    197           * This function is used to handle set or clear device feature request.
    198           *
    199           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    200           * @param setup           The pointer of the setup packet.
    201           * @param buffer          It is an out parameter, is used to save the buffer address to response the host's request.
    202           * @param length          It is an out parameter, the data length.
    203           *
    204           * @retval kStatus_USB_Success              The requst is handled successfully.
    205           * @retval kStatus_USB_InvalidRequest       The request can not be handle in current device state,
    206           *                                          or, the request is unsupported.
    207           */

   \                                 In section .text, align 2, keep-with-next
    208          static usb_status_t USB_DeviceCh9SetClearFeature(usb_device_common_class_struct_t *classHandle,
    209                                                           usb_setup_struct_t *setup,
    210                                                           uint8_t **buffer,
    211                                                           uint32_t *length)
    212          {
   \                     USB_DeviceCh9SetClearFeature: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    213              usb_status_t error = kStatus_USB_InvalidRequest;
   \   0000000E   0xF05F 0x0805      MOVS     R8,#+5
    214              uint8_t state;
    215              uint8_t isSet = 0U;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF88D 0x0000      STRB     R0,[SP, #+0]
    216          
    217              USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
   \   00000018   0xF10D 0x0201      ADD      R2,SP,#+1
   \   0000001C   0x2106             MOVS     R1,#+6
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x.... 0x....      BL       USB_DeviceGetStatus
    218          
    219              if ((kUSB_DeviceStateAddress != state) && (kUSB_DeviceStateConfigured != state))
   \   00000024   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD006             BEQ.N    ??USB_DeviceCh9SetClearFeature_0
   \   0000002C   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD002             BEQ.N    ??USB_DeviceCh9SetClearFeature_0
    220              {
    221                  return error;
   \   00000034   0x4640             MOV      R0,R8
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0xE04D             B.N      ??USB_DeviceCh9SetClearFeature_1
    222              }
    223          
    224              /* Identify the request is set or clear the feature. */
    225              if (USB_REQUSET_STANDARD_SET_FEATURE == setup->bRequest)
   \                     ??USB_DeviceCh9SetClearFeature_0: (+1)
   \   0000003A   0x7868             LDRB     R0,[R5, #+1]
   \   0000003C   0x2803             CMP      R0,#+3
   \   0000003E   0xD102             BNE.N    ??USB_DeviceCh9SetClearFeature_2
    226              {
    227                  isSet = 1U;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF88D 0x0000      STRB     R0,[SP, #+0]
    228              }
    229          
    230              if ((setup->bmRequestType & USB_REQUEST_TYPE_RECIPIENT_MASK) == USB_REQUEST_TYPE_RECIPIENT_DEVICE)
   \                     ??USB_DeviceCh9SetClearFeature_2: (+1)
   \   00000046   0x7828             LDRB     R0,[R5, #+0]
   \   00000048   0x211F             MOVS     R1,#+31
   \   0000004A   0x4208             TST      R0,R1
   \   0000004C   0xD109             BNE.N    ??USB_DeviceCh9SetClearFeature_3
    231              {
    232                  /* Set or Clear the device featrue. */
    233                  if (USB_REQUSET_STANDARD_FEATURE_SELECTOR_DEVICE_REMOTE_WAKEUP == setup->wValue)
   \   0000004E   0x8868             LDRH     R0,[R5, #+2]
   \   00000050   0x2801             CMP      R0,#+1
   \   00000052   0xD13E             BNE.N    ??USB_DeviceCh9SetClearFeature_4
    234                  {
    235                      /* Set or Clear the device remote wakeup featrue. */
    236                      error = USB_DeviceClassCallback(classHandle->handle, kUSB_DeviceEventSetRemoteWakeup, &isSet);
   \   00000054   0x466A             MOV      R2,SP
   \   00000056   0x2110             MOVS     R1,#+16
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x.... 0x....      BL       USB_DeviceClassCallback
   \   0000005E   0x4680             MOV      R8,R0
   \   00000060   0xE037             B.N      ??USB_DeviceCh9SetClearFeature_4
    237                  }
    238          #if (defined(USB_DEVICE_CONFIG_EHCI) && (USB_DEVICE_CONFIG_EHCI > 0U)) && \
    239              (defined(USB_DEVICE_CONFIG_EHCI_TEST_MODE) && (USB_DEVICE_CONFIG_EHCI_TEST_MODE > 0U))
    240                  else if (USB_REQUSET_STANDARD_FEATURE_SELECTOR_DEVICE_TEST_MODE == setup->wValue)
    241                  {
    242                      state = kUSB_DeviceStateTestMode;
    243                      error = USB_DeviceSetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
    244                  }
    245          #endif
    246                  else
    247                  {
    248                  }
    249              }
    250              else if ((setup->bmRequestType & USB_REQUEST_TYPE_RECIPIENT_MASK) == USB_REQUEST_TYPE_RECIPIENT_ENDPOINT)
   \                     ??USB_DeviceCh9SetClearFeature_3: (+1)
   \   00000062   0x7828             LDRB     R0,[R5, #+0]
   \   00000064   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000068   0x2802             CMP      R0,#+2
   \   0000006A   0xD132             BNE.N    ??USB_DeviceCh9SetClearFeature_4
    251              {
    252                  /* Set or Clear the endpoint featrue. */
    253                  if (USB_REQUSET_STANDARD_FEATURE_SELECTOR_ENDPOINT_HALT == setup->wValue)
   \   0000006C   0x8868             LDRH     R0,[R5, #+2]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD12F             BNE.N    ??USB_DeviceCh9SetClearFeature_4
    254                  {
    255                      if (USB_CONTROL_ENDPOINT == (setup->wIndex & USB_ENDPOINT_NUMBER_MASK))
   \   00000072   0x7928             LDRB     R0,[R5, #+4]
   \   00000074   0x210F             MOVS     R1,#+15
   \   00000076   0x4208             TST      R0,R1
   \   00000078   0xD11A             BNE.N    ??USB_DeviceCh9SetClearFeature_5
    256                      {
    257                          /* Set or Clear the control endpoint status(halt or not). */
    258                          if (isSet)
   \   0000007A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD00B             BEQ.N    ??USB_DeviceCh9SetClearFeature_6
    259                          {
    260                              USB_DeviceStallEndpoint(
    261                                  classHandle->handle,
    262                                  (setup->wIndex & USB_ENDPOINT_NUMBER_MASK) |
    263                                      (uint8_t)(setup->wIndex >> USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT));
   \   00000082   0x7928             LDRB     R0,[R5, #+4]
   \   00000084   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000088   0x88A9             LDRH     R1,[R5, #+4]
   \   0000008A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000008C   0x09C9             LSRS     R1,R1,#+7
   \   0000008E   0x4301             ORRS     R1,R1,R0
   \   00000090   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x.... 0x....      BL       USB_DeviceStallEndpoint
   \   00000098   0xE00A             B.N      ??USB_DeviceCh9SetClearFeature_5
    264                          }
    265                          else
    266                          {
    267                              USB_DeviceUnstallEndpoint(
    268                                  classHandle->handle,
    269                                  (setup->wIndex & USB_ENDPOINT_NUMBER_MASK) |
    270                                      (uint8_t)(setup->wIndex >> USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT));
   \                     ??USB_DeviceCh9SetClearFeature_6: (+1)
   \   0000009A   0x7928             LDRB     R0,[R5, #+4]
   \   0000009C   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   000000A0   0x88A9             LDRH     R1,[R5, #+4]
   \   000000A2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000A4   0x09C9             LSRS     R1,R1,#+7
   \   000000A6   0x4301             ORRS     R1,R1,R0
   \   000000A8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0x.... 0x....      BL       USB_DeviceUnstallEndpoint
    271                          }
    272                      }
    273          
    274                      /* Set or Clear the endpoint status featrue. */
    275                      if (isSet)
   \                     ??USB_DeviceCh9SetClearFeature_5: (+1)
   \   000000B0   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD006             BEQ.N    ??USB_DeviceCh9SetClearFeature_7
    276                      {
    277                          error = USB_DeviceClassEvent(classHandle->handle, kUSB_DeviceClassEventSetEndpointHalt, &setup->wIndex);
   \   000000B8   0x1D2A             ADDS     R2,R5,#+4
   \   000000BA   0x2105             MOVS     R1,#+5
   \   000000BC   0x6820             LDR      R0,[R4, #+0]
   \   000000BE   0x.... 0x....      BL       USB_DeviceClassEvent
   \   000000C2   0x4680             MOV      R8,R0
   \   000000C4   0xE005             B.N      ??USB_DeviceCh9SetClearFeature_4
    278                      }
    279                      else
    280                      {
    281                          error =
    282                              USB_DeviceClassEvent(classHandle->handle, kUSB_DeviceClassEventClearEndpointHalt, &setup->wIndex);
   \                     ??USB_DeviceCh9SetClearFeature_7: (+1)
   \   000000C6   0x1D2A             ADDS     R2,R5,#+4
   \   000000C8   0x2106             MOVS     R1,#+6
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x.... 0x....      BL       USB_DeviceClassEvent
   \   000000D0   0x4680             MOV      R8,R0
    283                      }
    284                  }
    285                  else
    286                  {
    287                  }
    288              }
    289              else
    290              {
    291              }
    292          
    293              return error;
   \                     ??USB_DeviceCh9SetClearFeature_4: (+1)
   \   000000D2   0x4640             MOV      R0,R8
   \   000000D4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceCh9SetClearFeature_1: (+1)
   \   000000D6   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    294          }
    295          
    296          /*!
    297           * @brief Handle set address request.
    298           *
    299           * This function is used to handle set address request.
    300           *
    301           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    302           * @param setup           The pointer of the setup packet.
    303           * @param buffer          It is an out parameter, is used to save the buffer address to response the host's request.
    304           * @param length          It is an out parameter, the data length.
    305           *
    306           * @retval kStatus_USB_Success              The requst is handled successfully.
    307           * @retval kStatus_USB_InvalidRequest       The request can not be handle in current device state.
    308           */

   \                                 In section .text, align 2, keep-with-next
    309          static usb_status_t USB_DeviceCh9SetAddress(usb_device_common_class_struct_t *classHandle,
    310                                                      usb_setup_struct_t *setup,
    311                                                      uint8_t **buffer,
    312                                                      uint32_t *length)
    313          {
   \                     USB_DeviceCh9SetAddress: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    314              usb_status_t error = kStatus_USB_InvalidRequest;
   \   0000000E   0xF05F 0x0805      MOVS     R8,#+5
    315              uint8_t state;
    316          
    317              USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
   \   00000012   0x466A             MOV      R2,SP
   \   00000014   0x2106             MOVS     R1,#+6
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_DeviceGetStatus
    318          
    319              if ((kUSB_DeviceStateAddressing != state) && (kUSB_DeviceStateAddress != state) &&
    320                  (kUSB_DeviceStateDefault != state))
   \   0000001C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000020   0x2803             CMP      R0,#+3
   \   00000022   0xD00A             BEQ.N    ??USB_DeviceCh9SetAddress_0
   \   00000024   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD006             BEQ.N    ??USB_DeviceCh9SetAddress_0
   \   0000002C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000030   0x2802             CMP      R0,#+2
   \   00000032   0xD002             BEQ.N    ??USB_DeviceCh9SetAddress_0
    321              {
    322                  return error;
   \   00000034   0x4640             MOV      R0,R8
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0xE023             B.N      ??USB_DeviceCh9SetAddress_1
    323              }
    324          
    325              if (kUSB_DeviceStateAddressing != state)
   \                     ??USB_DeviceCh9SetAddress_0: (+1)
   \   0000003A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003E   0x2803             CMP      R0,#+3
   \   00000040   0xD009             BEQ.N    ??USB_DeviceCh9SetAddress_2
    326              {
    327                  /* If the device address is not setting, pass the address and the device state will change to
    328                   * kUSB_DeviceStateAddressing internally. */
    329                  state = setup->wValue & 0xFFU;
   \   00000042   0x8868             LDRH     R0,[R5, #+2]
   \   00000044   0xF88D 0x0000      STRB     R0,[SP, #+0]
    330                  error = USB_DeviceSetStatus(classHandle->handle, kUSB_DeviceStatusAddress, &state);
   \   00000048   0x466A             MOV      R2,SP
   \   0000004A   0x2107             MOVS     R1,#+7
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      BL       USB_DeviceSetStatus
   \   00000052   0x4680             MOV      R8,R0
   \   00000054   0xE013             B.N      ??USB_DeviceCh9SetAddress_3
    331              }
    332              else
    333              {
    334                  /* If the device address is setting, set device address and the address will be write into the controller
    335                   * internally. */
    336                  error = USB_DeviceSetStatus(classHandle->handle, kUSB_DeviceStatusAddress, NULL);
   \                     ??USB_DeviceCh9SetAddress_2: (+1)
   \   00000056   0x2200             MOVS     R2,#+0
   \   00000058   0x2107             MOVS     R1,#+7
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x.... 0x....      BL       USB_DeviceSetStatus
   \   00000060   0x4680             MOV      R8,R0
    337                  /* And then change the device state to kUSB_DeviceStateAddress. */
    338                  if (kStatus_USB_Success == error)
   \   00000062   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000066   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000006A   0xD108             BNE.N    ??USB_DeviceCh9SetAddress_3
    339                  {
    340                      state = kUSB_DeviceStateAddress;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    341                      error = USB_DeviceSetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
   \   00000072   0x466A             MOV      R2,SP
   \   00000074   0x2106             MOVS     R1,#+6
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x.... 0x....      BL       USB_DeviceSetStatus
   \   0000007C   0x4680             MOV      R8,R0
    342                  }
    343              }
    344          
    345              return error;
   \                     ??USB_DeviceCh9SetAddress_3: (+1)
   \   0000007E   0x4640             MOV      R0,R8
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceCh9SetAddress_1: (+1)
   \   00000082   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    346          }
    347          
    348          /*!
    349           * @brief Handle get descriptor request.
    350           *
    351           * This function is used to handle get descriptor request.
    352           *
    353           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    354           * @param setup           The pointer of the setup packet.
    355           * @param buffer          It is an out parameter, is used to save the buffer address to response the host's request.
    356           * @param length          It is an out parameter, the data length.
    357           *
    358           * @retval kStatus_USB_Success              The requst is handled successfully.
    359           * @retval kStatus_USB_InvalidRequest       The request can not be handle in current device state,
    360           *                                          or, the request is unsupported.
    361           */

   \                                 In section .text, align 2, keep-with-next
    362          static usb_status_t USB_DeviceCh9GetDescriptor(usb_device_common_class_struct_t *classHandle,
    363                                                         usb_setup_struct_t *setup,
    364                                                         uint8_t **buffer,
    365                                                         uint32_t *length)
    366          {
   \                     USB_DeviceCh9GetDescriptor: (+1)
   \   00000000   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    367              usb_device_get_descriptor_common_union_t commonDescriptor;
    368              usb_status_t error = kStatus_USB_InvalidRequest;
   \   0000000C   0xF05F 0x0A05      MOVS     R10,#+5
    369              uint8_t state;
    370              uint8_t descriptorType = (uint8_t)((setup->wValue & 0xFF00U) >> 8U);
   \   00000010   0x8868             LDRH     R0,[R5, #+2]
   \   00000012   0xEA5F 0x2810      LSRS     R8,R0,#+8
    371              uint8_t descriptorIndex = (uint8_t)((setup->wValue & 0x00FFU));
   \   00000016   0xF8B5 0x9002      LDRH     R9,[R5, #+2]
    372          
    373              USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
   \   0000001A   0xAA03             ADD      R2,SP,#+12
   \   0000001C   0x2106             MOVS     R1,#+6
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x.... 0x....      BL       USB_DeviceGetStatus
    374          
    375              if ((kUSB_DeviceStateAddress != state) && (kUSB_DeviceStateConfigured != state) &&
    376                  (kUSB_DeviceStateDefault != state))
   \   00000024   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD00A             BEQ.N    ??USB_DeviceCh9GetDescriptor_0
   \   0000002C   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD006             BEQ.N    ??USB_DeviceCh9GetDescriptor_0
   \   00000034   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   00000038   0x2802             CMP      R0,#+2
   \   0000003A   0xD002             BEQ.N    ??USB_DeviceCh9GetDescriptor_0
    377              {
    378                  return error;
   \   0000003C   0x4650             MOV      R0,R10
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0xE060             B.N      ??USB_DeviceCh9GetDescriptor_1
    379              }
    380              commonDescriptor.commonDescriptor.length = setup->wLength;
   \                     ??USB_DeviceCh9GetDescriptor_0: (+1)
   \   00000042   0x88E8             LDRH     R0,[R5, #+6]
   \   00000044   0x9001             STR      R0,[SP, #+4]
    381              if (USB_DESCRIPTOR_TYPE_DEVICE == descriptorType)
   \   00000046   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000004A   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000004E   0xD106             BNE.N    ??USB_DeviceCh9GetDescriptor_2
    382              {
    383                  /* Get the device descriptor */
    384                  error = USB_DeviceClassCallback(classHandle->handle, kUSB_DeviceEventGetDeviceDescriptor,
    385                                                  &commonDescriptor.deviceDescriptor);
   \   00000050   0x466A             MOV      R2,SP
   \   00000052   0x2109             MOVS     R1,#+9
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x.... 0x....      BL       USB_DeviceClassCallback
   \   0000005A   0x4682             MOV      R10,R0
   \   0000005C   0xE04C             B.N      ??USB_DeviceCh9GetDescriptor_3
    386              }
    387              else if (USB_DESCRIPTOR_TYPE_CONFIGURE == descriptorType)
   \                     ??USB_DeviceCh9GetDescriptor_2: (+1)
   \   0000005E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000062   0xF1B8 0x0F02      CMP      R8,#+2
   \   00000066   0xD108             BNE.N    ??USB_DeviceCh9GetDescriptor_4
    388              {
    389                  /* Get the configuration descriptor */
    390                  commonDescriptor.configurationDescriptor.configuration = descriptorIndex;
   \   00000068   0xF88D 0x9008      STRB     R9,[SP, #+8]
    391                  error = USB_DeviceClassCallback(classHandle->handle, kUSB_DeviceEventGetConfigurationDescriptor,
    392                                                  &commonDescriptor.configurationDescriptor);
   \   0000006C   0x466A             MOV      R2,SP
   \   0000006E   0x210A             MOVS     R1,#+10
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x.... 0x....      BL       USB_DeviceClassCallback
   \   00000076   0x4682             MOV      R10,R0
   \   00000078   0xE03E             B.N      ??USB_DeviceCh9GetDescriptor_3
    393              }
    394              else if (USB_DESCRIPTOR_TYPE_STRING == descriptorType)
   \                     ??USB_DeviceCh9GetDescriptor_4: (+1)
   \   0000007A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000007E   0xF1B8 0x0F03      CMP      R8,#+3
   \   00000082   0xD10B             BNE.N    ??USB_DeviceCh9GetDescriptor_5
    395              {
    396                  /* Get the string descriptor */
    397                  commonDescriptor.stringDescriptor.stringIndex = descriptorIndex;
   \   00000084   0xF88D 0x900A      STRB     R9,[SP, #+10]
    398                  commonDescriptor.stringDescriptor.languageId = setup->wIndex;
   \   00000088   0x88A8             LDRH     R0,[R5, #+4]
   \   0000008A   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    399                  error = USB_DeviceClassCallback(classHandle->handle, kUSB_DeviceEventGetStringDescriptor,
    400                                                  &commonDescriptor.stringDescriptor);
   \   0000008E   0x466A             MOV      R2,SP
   \   00000090   0x210B             MOVS     R1,#+11
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x.... 0x....      BL       USB_DeviceClassCallback
   \   00000098   0x4682             MOV      R10,R0
   \   0000009A   0xE02D             B.N      ??USB_DeviceCh9GetDescriptor_3
    401              }
    402          #if (defined(USB_DEVICE_CONFIG_HID) && (USB_DEVICE_CONFIG_HID > 0U))
    403              else if (USB_DESCRIPTOR_TYPE_HID == descriptorType)
   \                     ??USB_DeviceCh9GetDescriptor_5: (+1)
   \   0000009C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000A0   0xF1B8 0x0F21      CMP      R8,#+33
   \   000000A4   0xD109             BNE.N    ??USB_DeviceCh9GetDescriptor_6
    404              {
    405                  /* Get the hid descriptor */
    406                  commonDescriptor.hidDescriptor.interfaceNumber = setup->wIndex;
   \   000000A6   0x88A8             LDRH     R0,[R5, #+4]
   \   000000A8   0xF88D 0x0008      STRB     R0,[SP, #+8]
    407                  error = USB_DeviceClassCallback(classHandle->handle, kUSB_DeviceEventGetHidDescriptor,
    408                                                  &commonDescriptor.hidDescriptor);
   \   000000AC   0x466A             MOV      R2,SP
   \   000000AE   0x210C             MOVS     R1,#+12
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x.... 0x....      BL       USB_DeviceClassCallback
   \   000000B6   0x4682             MOV      R10,R0
   \   000000B8   0xE01E             B.N      ??USB_DeviceCh9GetDescriptor_3
    409              }
    410              else if (USB_DESCRIPTOR_TYPE_HID_REPORT == descriptorType)
   \                     ??USB_DeviceCh9GetDescriptor_6: (+1)
   \   000000BA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000BE   0xF1B8 0x0F22      CMP      R8,#+34
   \   000000C2   0xD109             BNE.N    ??USB_DeviceCh9GetDescriptor_7
    411              {
    412                  /* Get the hid report descriptor */
    413                  commonDescriptor.hidReportDescriptor.interfaceNumber = setup->wIndex;
   \   000000C4   0x88A8             LDRH     R0,[R5, #+4]
   \   000000C6   0xF88D 0x0008      STRB     R0,[SP, #+8]
    414                  error = USB_DeviceClassCallback(classHandle->handle, kUSB_DeviceEventGetHidReportDescriptor,
    415                                                  &commonDescriptor.hidReportDescriptor);
   \   000000CA   0x466A             MOV      R2,SP
   \   000000CC   0x210D             MOVS     R1,#+13
   \   000000CE   0x6820             LDR      R0,[R4, #+0]
   \   000000D0   0x.... 0x....      BL       USB_DeviceClassCallback
   \   000000D4   0x4682             MOV      R10,R0
   \   000000D6   0xE00F             B.N      ??USB_DeviceCh9GetDescriptor_3
    416              }
    417              else if (USB_DESCRIPTOR_TYPE_HID_PHYSICAL == descriptorType)
   \                     ??USB_DeviceCh9GetDescriptor_7: (+1)
   \   000000D8   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000DC   0xF1B8 0x0F23      CMP      R8,#+35
   \   000000E0   0xD10A             BNE.N    ??USB_DeviceCh9GetDescriptor_3
    418              {
    419                  /* Get the hid physical descriptor */
    420                  commonDescriptor.hidPhysicalDescriptor.index = descriptorIndex;
   \   000000E2   0xF88D 0x9008      STRB     R9,[SP, #+8]
    421                  commonDescriptor.hidPhysicalDescriptor.interfaceNumber = setup->wIndex;
   \   000000E6   0x88A8             LDRH     R0,[R5, #+4]
   \   000000E8   0xF88D 0x0009      STRB     R0,[SP, #+9]
    422                  error = USB_DeviceClassCallback(classHandle->handle, kUSB_DeviceEventGetHidPhysicalDescriptor,
    423                                                  &commonDescriptor.hidPhysicalDescriptor);
   \   000000EC   0x466A             MOV      R2,SP
   \   000000EE   0x210E             MOVS     R1,#+14
   \   000000F0   0x6820             LDR      R0,[R4, #+0]
   \   000000F2   0x.... 0x....      BL       USB_DeviceClassCallback
   \   000000F6   0x4682             MOV      R10,R0
    424              }
    425          #endif
    426              else
    427              {
    428              }
    429              *buffer = commonDescriptor.commonDescriptor.buffer;
   \                     ??USB_DeviceCh9GetDescriptor_3: (+1)
   \   000000F8   0x9800             LDR      R0,[SP, #+0]
   \   000000FA   0x6030             STR      R0,[R6, #+0]
    430              *length = commonDescriptor.commonDescriptor.length;
   \   000000FC   0x9801             LDR      R0,[SP, #+4]
   \   000000FE   0x6038             STR      R0,[R7, #+0]
    431              return error;
   \   00000100   0x4650             MOV      R0,R10
   \   00000102   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceCh9GetDescriptor_1: (+1)
   \   00000104   0xB004             ADD      SP,SP,#+16
   \   00000106   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    432          }
    433          
    434          /*!
    435           * @brief Handle get current configuration request.
    436           *
    437           * This function is used to handle get current configuration request.
    438           *
    439           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    440           * @param setup           The pointer of the setup packet.
    441           * @param buffer          It is an out parameter, is used to save the buffer address to response the host's request.
    442           * @param length          It is an out parameter, the data length.
    443           *
    444           * @retval kStatus_USB_Success              The requst is handled successfully.
    445           * @retval kStatus_USB_InvalidRequest       The request can not be handle in current device state,
    446           *                                          or, the request is unsupported.
    447           */

   \                                 In section .text, align 2, keep-with-next
    448          static usb_status_t USB_DeviceCh9GetConfiguration(usb_device_common_class_struct_t *classHandle,
    449                                                            usb_setup_struct_t *setup,
    450                                                            uint8_t **buffer,
    451                                                            uint32_t *length)
    452          {
   \                     USB_DeviceCh9GetConfiguration: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    453              uint8_t state;
    454          
    455              USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
   \   0000000A   0x466A             MOV      R2,SP
   \   0000000C   0x2106             MOVS     R1,#+6
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x.... 0x....      BL       USB_DeviceGetStatus
    456          
    457              if ((kUSB_DeviceStateAddress != state) && ((kUSB_DeviceStateConfigured != state)))
   \   00000014   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD005             BEQ.N    ??USB_DeviceCh9GetConfiguration_0
   \   0000001C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD001             BEQ.N    ??USB_DeviceCh9GetConfiguration_0
    458              {
    459                  return kStatus_USB_InvalidRequest;
   \   00000024   0x2005             MOVS     R0,#+5
   \   00000026   0xE00A             B.N      ??USB_DeviceCh9GetConfiguration_1
    460              }
    461          
    462              *length = USB_CONFIGURE_SIZE;
   \                     ??USB_DeviceCh9GetConfiguration_0: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x6038             STR      R0,[R7, #+0]
    463              *buffer = (uint8_t *)&classHandle->standardTranscationBuffer;
   \   0000002C   0xF114 0x0010      ADDS     R0,R4,#+16
   \   00000030   0x6030             STR      R0,[R6, #+0]
    464              return USB_DeviceClassCallback(classHandle->handle, kUSB_DeviceEventGetConfiguration,
    465                                             &classHandle->standardTranscationBuffer);
   \   00000032   0xF114 0x0210      ADDS     R2,R4,#+16
   \   00000036   0x2111             MOVS     R1,#+17
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x.... 0x....      BL       USB_DeviceClassCallback
   \                     ??USB_DeviceCh9GetConfiguration_1: (+1)
   \   0000003E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    466          }
    467          
    468          /*!
    469           * @brief Handle set current configuration request.
    470           *
    471           * This function is used to handle set current configuration request.
    472           *
    473           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    474           * @param setup           The pointer of the setup packet.
    475           * @param buffer          It is an out parameter, is used to save the buffer address to response the host's request.
    476           * @param length          It is an out parameter, the data length.
    477           *
    478           * @retval kStatus_USB_Success              The requst is handled successfully.
    479           * @retval kStatus_USB_InvalidRequest       The request can not be handle in current device state,
    480           *                                          or, the request is unsupported.
    481           */

   \                                 In section .text, align 2, keep-with-next
    482          static usb_status_t USB_DeviceCh9SetConfiguration(usb_device_common_class_struct_t *classHandle,
    483                                                            usb_setup_struct_t *setup,
    484                                                            uint8_t **buffer,
    485                                                            uint32_t *length)
    486          {
   \                     USB_DeviceCh9SetConfiguration: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    487              uint8_t state;
    488          
    489              USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
   \   0000000A   0x466A             MOV      R2,SP
   \   0000000C   0x2106             MOVS     R1,#+6
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x.... 0x....      BL       USB_DeviceGetStatus
    490          
    491              if ((kUSB_DeviceStateAddress != state) && (kUSB_DeviceStateConfigured != state))
   \   00000014   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD005             BEQ.N    ??USB_DeviceCh9SetConfiguration_0
   \   0000001C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD001             BEQ.N    ??USB_DeviceCh9SetConfiguration_0
    492              {
    493                  return kStatus_USB_InvalidRequest;
   \   00000024   0x2005             MOVS     R0,#+5
   \   00000026   0xE01C             B.N      ??USB_DeviceCh9SetConfiguration_1
    494              }
    495          
    496              /* The device state is changed to kUSB_DeviceStateConfigured */
    497              state = kUSB_DeviceStateConfigured;
   \                     ??USB_DeviceCh9SetConfiguration_0: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    498              USB_DeviceSetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
   \   0000002E   0x466A             MOV      R2,SP
   \   00000030   0x2106             MOVS     R1,#+6
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x.... 0x....      BL       USB_DeviceSetStatus
    499              if (!setup->wValue)
   \   00000038   0x8868             LDRH     R0,[R5, #+2]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD107             BNE.N    ??USB_DeviceCh9SetConfiguration_2
    500              {
    501                  /* If the new configuration is zero, the device state is changed to kUSB_DeviceStateAddress */
    502                  state = kUSB_DeviceStateAddress;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xF88D 0x0000      STRB     R0,[SP, #+0]
    503                  USB_DeviceSetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
   \   00000044   0x466A             MOV      R2,SP
   \   00000046   0x2106             MOVS     R1,#+6
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x.... 0x....      BL       USB_DeviceSetStatus
    504              }
    505          
    506              /* Notify the class layer the configuration is changed */
    507              USB_DeviceClassEvent(classHandle->handle, kUSB_DeviceClassEventSetConfiguration, &setup->wValue);
   \                     ??USB_DeviceCh9SetConfiguration_2: (+1)
   \   0000004E   0x1CAA             ADDS     R2,R5,#+2
   \   00000050   0x2103             MOVS     R1,#+3
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x.... 0x....      BL       USB_DeviceClassEvent
    508              /* Notify the application the configuration is changed */
    509              return USB_DeviceClassCallback(classHandle->handle, kUSB_DeviceEventSetConfiguration, &setup->wValue);
   \   00000058   0x1CAA             ADDS     R2,R5,#+2
   \   0000005A   0x2107             MOVS     R1,#+7
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x.... 0x....      BL       USB_DeviceClassCallback
   \                     ??USB_DeviceCh9SetConfiguration_1: (+1)
   \   00000062   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    510          }
    511          
    512          /*!
    513           * @brief Handle get the alternate setting of a interface request.
    514           *
    515           * This function is used to handle get the alternate setting of a interface request.
    516           *
    517           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    518           * @param setup           The pointer of the setup packet.
    519           * @param buffer          It is an out parameter, is used to save the buffer address to response the host's request.
    520           * @param length          It is an out parameter, the data length.
    521           *
    522           * @retval kStatus_USB_Success              The requst is handled successfully.
    523           * @retval kStatus_USB_InvalidRequest       The request can not be handle in current device state,
    524           *                                          or, the request is unsupported.
    525           */

   \                                 In section .text, align 2, keep-with-next
    526          static usb_status_t USB_DeviceCh9GetInterface(usb_device_common_class_struct_t *classHandle,
    527                                                        usb_setup_struct_t *setup,
    528                                                        uint8_t **buffer,
    529                                                        uint32_t *length)
    530          {
   \                     USB_DeviceCh9GetInterface: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    531              usb_status_t error = kStatus_USB_InvalidRequest;
   \   0000000E   0xF05F 0x0805      MOVS     R8,#+5
    532              uint8_t state;
    533          
    534              USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
   \   00000012   0x466A             MOV      R2,SP
   \   00000014   0x2106             MOVS     R1,#+6
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_DeviceGetStatus
    535          
    536              if (state != kUSB_DeviceStateConfigured)
   \   0000001C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD002             BEQ.N    ??USB_DeviceCh9GetInterface_0
    537              {
    538                  return error;
   \   00000024   0x4640             MOV      R0,R8
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0xE00E             B.N      ??USB_DeviceCh9GetInterface_1
    539              }
    540              *length = USB_INTERFACE_SIZE;
   \                     ??USB_DeviceCh9GetInterface_0: (+1)
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x6038             STR      R0,[R7, #+0]
    541              *buffer = (uint8_t *)&classHandle->standardTranscationBuffer;
   \   0000002E   0xF114 0x0010      ADDS     R0,R4,#+16
   \   00000032   0x6030             STR      R0,[R6, #+0]
    542              classHandle->standardTranscationBuffer = setup->wIndex & 0xFFU;
   \   00000034   0x7928             LDRB     R0,[R5, #+4]
   \   00000036   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   0000003A   0x8220             STRH     R0,[R4, #+16]
    543              /* The Bit[15~8] is used to save the interface index, and the alternate setting will be saved in Bit[7~0] by
    544               * application. */
    545              return USB_DeviceClassCallback(classHandle->handle, kUSB_DeviceEventGetInterface,
    546                                             &classHandle->standardTranscationBuffer);
   \   0000003C   0xF114 0x0210      ADDS     R2,R4,#+16
   \   00000040   0x2112             MOVS     R1,#+18
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      BL       USB_DeviceClassCallback
   \                     ??USB_DeviceCh9GetInterface_1: (+1)
   \   00000048   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    547          }
    548          
    549          /*!
    550           * @brief Handle set the alternate setting of a interface request.
    551           *
    552           * This function is used to handle set the alternate setting of a interface request.
    553           *
    554           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    555           * @param setup           The pointer of the setup packet.
    556           * @param buffer          It is an out parameter, is used to save the buffer address to response the host's request.
    557           * @param length          It is an out parameter, the data length.
    558           *
    559           * @retval kStatus_USB_Success              The requst is handled successfully.
    560           * @retval kStatus_USB_InvalidRequest       The request can not be handle in current device state,
    561           *                                          or, the request is unsupported.
    562           */

   \                                 In section .text, align 2, keep-with-next
    563          static usb_status_t USB_DeviceCh9SetInterface(usb_device_common_class_struct_t *classHandle,
    564                                                        usb_setup_struct_t *setup,
    565                                                        uint8_t **buffer,
    566                                                        uint32_t *length)
    567          {
   \                     USB_DeviceCh9SetInterface: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    568              uint8_t state;
    569          
    570              USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
   \   0000000A   0x466A             MOV      R2,SP
   \   0000000C   0x2106             MOVS     R1,#+6
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x.... 0x....      BL       USB_DeviceGetStatus
    571          
    572              if (state != kUSB_DeviceStateConfigured)
   \   00000014   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD001             BEQ.N    ??USB_DeviceCh9SetInterface_0
    573              {
    574                  return kStatus_USB_InvalidRequest;
   \   0000001C   0x2005             MOVS     R0,#+5
   \   0000001E   0xE012             B.N      ??USB_DeviceCh9SetInterface_1
    575              }
    576              classHandle->standardTranscationBuffer = ((setup->wIndex & 0xFFU) << 8U) | (setup->wValue & 0xFFU);
   \                     ??USB_DeviceCh9SetInterface_0: (+1)
   \   00000020   0x88A8             LDRH     R0,[R5, #+4]
   \   00000022   0x78A9             LDRB     R1,[R5, #+2]
   \   00000024   0xF001 0x01FF      AND      R1,R1,#0xFF
   \   00000028   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000002C   0x8220             STRH     R0,[R4, #+16]
    577              /* Notify the class driver the alternate setting of the interface is changed. */
    578              /* The Bit[15~8] is used to save the interface index, and the alternate setting is saved in Bit[7~0]. */
    579              USB_DeviceClassEvent(classHandle->handle, kUSB_DeviceClassEventSetInterface,
    580                                   &classHandle->standardTranscationBuffer);
   \   0000002E   0xF114 0x0210      ADDS     R2,R4,#+16
   \   00000032   0x2104             MOVS     R1,#+4
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       USB_DeviceClassEvent
    581              /* Notify the application the alternate setting of the interface is changed. */
    582              /* The Bit[15~8] is used to save the interface index, and the alternate setting will is saved in Bit[7~0]. */
    583              return USB_DeviceClassCallback(classHandle->handle, kUSB_DeviceEventSetInterface,
    584                                             &classHandle->standardTranscationBuffer);
   \   0000003A   0xF114 0x0210      ADDS     R2,R4,#+16
   \   0000003E   0x2108             MOVS     R1,#+8
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x.... 0x....      BL       USB_DeviceClassCallback
   \                     ??USB_DeviceCh9SetInterface_1: (+1)
   \   00000046   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    585          }
    586          
    587          /*!
    588           * @brief Handle get sync frame request.
    589           *
    590           * This function is used to handle get sync frame request.
    591           *
    592           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    593           * @param setup           The pointer of the setup packet.
    594           * @param buffer          It is an out parameter, is used to save the buffer address to response the host's request.
    595           * @param length          It is an out parameter, the data length.
    596           *
    597           * @retval kStatus_USB_Success              The requst is handled successfully.
    598           * @retval kStatus_USB_InvalidRequest       The request can not be handle in current device state,
    599           *                                          or, the request is unsupported.
    600           */

   \                                 In section .text, align 2, keep-with-next
    601          static usb_status_t USB_DeviceCh9SynchFrame(usb_device_common_class_struct_t *classHandle,
    602                                                      usb_setup_struct_t *setup,
    603                                                      uint8_t **buffer,
    604                                                      uint32_t *length)
    605          {
   \                     USB_DeviceCh9SynchFrame: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    606              usb_status_t error = kStatus_USB_InvalidRequest;
   \   0000000E   0xF05F 0x0805      MOVS     R8,#+5
    607              uint8_t state;
    608          
    609              USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusDeviceState, &state);
   \   00000012   0x466A             MOV      R2,SP
   \   00000014   0x2106             MOVS     R1,#+6
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_DeviceGetStatus
    610          
    611              if (state != kUSB_DeviceStateConfigured)
   \   0000001C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD002             BEQ.N    ??USB_DeviceCh9SynchFrame_0
    612              {
    613                  return error;
   \   00000024   0x4640             MOV      R0,R8
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0xE00F             B.N      ??USB_DeviceCh9SynchFrame_1
    614              }
    615          
    616              classHandle->standardTranscationBuffer = setup->wIndex;
   \                     ??USB_DeviceCh9SynchFrame_0: (+1)
   \   0000002A   0x88A8             LDRH     R0,[R5, #+4]
   \   0000002C   0x8220             STRH     R0,[R4, #+16]
    617              /* Get the sync frame value */
    618              error =
    619                  USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusSynchFrame, &classHandle->standardTranscationBuffer);
   \   0000002E   0xF114 0x0210      ADDS     R2,R4,#+16
   \   00000032   0x2108             MOVS     R1,#+8
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       USB_DeviceGetStatus
   \   0000003A   0x4680             MOV      R8,R0
    620              *buffer = (uint8_t *)&classHandle->standardTranscationBuffer;
   \   0000003C   0xF114 0x0010      ADDS     R0,R4,#+16
   \   00000040   0x6030             STR      R0,[R6, #+0]
    621              *length = sizeof(classHandle->standardTranscationBuffer);
   \   00000042   0x2002             MOVS     R0,#+2
   \   00000044   0x6038             STR      R0,[R7, #+0]
    622          
    623              return error;
   \   00000046   0x4640             MOV      R0,R8
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceCh9SynchFrame_1: (+1)
   \   0000004A   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    624          }
    625          
    626          /*!
    627           * @brief Send the reponse to the host.
    628           *
    629           * This function is used to send the reponse to the host.
    630           *
    631           * There are two cases this function will be called.
    632           * Case one when a setup packet is received in control endpoint callback function:
    633           *        1. If there is not data phase in the setup transfer, the function will prime an IN transfer with the data
    634           * length is zero for status phase.
    635           *        2. If there is an IN data phase, the function will prime an OUT transfer with the actual length to need to
    636           * send for data phase. And then prime an IN transfer with the data length is zero for status phase.
    637           *        3. If there is an OUT data phase, the function will prime an IN transfer with the actual length to want to
    638           * receive for data phase.
    639           *
    640           * Case two when is not a setup packet received in control endpoint callback function:
    641           *        1. The function will prime an IN transfer with data length is zero for status phase.
    642           *
    643           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    644           * @param setup           The pointer of the setup packet.
    645           * @param error           The error code returned from the standard request fucntion.
    646           * @param stage           The stage of the control transfer.
    647           * @param buffer          It is an out parameter, is used to save the buffer address to response the host's request.
    648           * @param length          It is an out parameter, the data length.
    649           *
    650           * @return A USB error code or kStatus_USB_Success.
    651           */

   \                                 In section .text, align 2, keep-with-next
    652          static usb_status_t USB_DeviceControlCallbackFeedback(usb_device_handle handle,
    653                                                                usb_setup_struct_t *setup,
    654                                                                usb_status_t error,
    655                                                                usb_device_control_read_write_sequence_t stage,
    656                                                                uint8_t **buffer,
    657                                                                uint32_t *length)
    658          {
   \                     USB_DeviceControlCallbackFeedback: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x4693             MOV      R11,R2
   \   0000000A   0x001E             MOVS     R6,R3
   \   0000000C   0x9F0A             LDR      R7,[SP, #+40]
   \   0000000E   0xF8DD 0x802C      LDR      R8,[SP, #+44]
    659              usb_status_t errorCode = kStatus_USB_Error;
   \   00000012   0xF05F 0x0901      MOVS     R9,#+1
    660              uint8_t direction = USB_IN;
   \   00000016   0xF05F 0x0A01      MOVS     R10,#+1
    661          
    662              if (kStatus_USB_InvalidRequest == error)
   \   0000001A   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000001E   0xF1BB 0x0F05      CMP      R11,#+5
   \   00000022   0xD116             BNE.N    ??USB_DeviceControlCallbackFeedback_0
    663              {
    664                  /* Stall the control pipe when the request is unsupported. */
    665                  if ((!((setup->bmRequestType & USB_REQUEST_TYPE_TYPE_MASK) == USB_REQUEST_TYPE_TYPE_STANDARD)) &&
    666                      ((setup->bmRequestType & USB_REQUSET_TYPE_DIR_MASK) == USB_REQUEST_TYPE_DIR_OUT) && (setup->wLength) &&
    667                      (kUSB_DeviceControlPipeSetupStage == stage))
   \   00000024   0x7828             LDRB     R0,[R5, #+0]
   \   00000026   0x2160             MOVS     R1,#+96
   \   00000028   0x4208             TST      R0,R1
   \   0000002A   0xD00A             BEQ.N    ??USB_DeviceControlCallbackFeedback_1
   \   0000002C   0x7828             LDRB     R0,[R5, #+0]
   \   0000002E   0x0600             LSLS     R0,R0,#+24
   \   00000030   0xD407             BMI.N    ??USB_DeviceControlCallbackFeedback_1
   \   00000032   0x88E8             LDRH     R0,[R5, #+6]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD004             BEQ.N    ??USB_DeviceControlCallbackFeedback_1
   \   00000038   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003A   0x2E00             CMP      R6,#+0
   \   0000003C   0xD101             BNE.N    ??USB_DeviceControlCallbackFeedback_1
    668                  {
    669                      direction = USB_OUT;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x4682             MOV      R10,R0
    670                  }
    671                  errorCode = USB_DeviceStallEndpoint(
    672                      handle,
    673                      (USB_CONTROL_ENDPOINT) | (uint8_t)((uint32_t)direction << USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT));
   \                     ??USB_DeviceControlCallbackFeedback_1: (+1)
   \   00000042   0xEA5F 0x11CA      LSLS     R1,R10,#+7
   \   00000046   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       USB_DeviceStallEndpoint
   \   0000004E   0x4681             MOV      R9,R0
   \   00000050   0xE01E             B.N      ??USB_DeviceControlCallbackFeedback_2
    674              }
    675              else
    676              {
    677                  if (*length > setup->wLength)
   \                     ??USB_DeviceControlCallbackFeedback_0: (+1)
   \   00000052   0x88E8             LDRH     R0,[R5, #+6]
   \   00000054   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \   00000058   0x4288             CMP      R0,R1
   \   0000005A   0xD202             BCS.N    ??USB_DeviceControlCallbackFeedback_3
    678                  {
    679                      *length = setup->wLength;
   \   0000005C   0x88E8             LDRH     R0,[R5, #+6]
   \   0000005E   0xF8C8 0x0000      STR      R0,[R8, #+0]
    680                  }
    681                  errorCode = USB_DeviceSendRequest(handle, (USB_CONTROL_ENDPOINT), *buffer, *length);
   \                     ??USB_DeviceControlCallbackFeedback_3: (+1)
   \   00000062   0xF8D8 0x3000      LDR      R3,[R8, #+0]
   \   00000066   0x683A             LDR      R2,[R7, #+0]
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0x.... 0x....      BL       USB_DeviceSendRequest
   \   00000070   0x4681             MOV      R9,R0
    682          
    683                  if ((kStatus_USB_Success == errorCode) &&
    684                      (USB_REQUEST_TYPE_DIR_IN == (setup->bmRequestType & USB_REQUSET_TYPE_DIR_MASK)))
   \   00000072   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000076   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000007A   0xD109             BNE.N    ??USB_DeviceControlCallbackFeedback_2
   \   0000007C   0x7828             LDRB     R0,[R5, #+0]
   \   0000007E   0x0600             LSLS     R0,R0,#+24
   \   00000080   0xD506             BPL.N    ??USB_DeviceControlCallbackFeedback_2
    685                  {
    686                      errorCode = USB_DeviceRecvRequest(handle, (USB_CONTROL_ENDPOINT), (uint8_t *)NULL, 0U);
   \   00000082   0x2300             MOVS     R3,#+0
   \   00000084   0x2200             MOVS     R2,#+0
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x.... 0x....      BL       USB_DeviceRecvRequest
   \   0000008E   0x4681             MOV      R9,R0
    687                  }
    688              }
    689              return errorCode;
   \                     ??USB_DeviceControlCallbackFeedback_2: (+1)
   \   00000090   0x4648             MOV      R0,R9
   \   00000092   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000094   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    690          }
    691          
    692          /*!
    693           * @brief Control endpoint callback function.
    694           *
    695           * This callback function is used to notify uplayer the tranfser result of a transfer.
    696           * This callback pointer is passed when a sepcified endpoint initialied by calling API USB_DeviceInitEndpoint.
    697           *
    698           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    699           * @param message         The result of a transfer, includes transfer buffer, transfer length and whether is in setup
    700           * phase for control pipe.
    701           * @param callbackParam  The paramter for this callback. It is same with
    702           * usb_device_endpoint_callback_struct_t::callbackParam.
    703           *
    704           * @return A USB error code or kStatus_USB_Success.
    705           */

   \                                 In section .text, align 2, keep-with-next
    706          usb_status_t USB_DeviceControlCallback(usb_device_handle handle,
    707                                                 usb_device_endpoint_callback_message_struct_t *message,
    708                                                 void *callbackParam)
    709          {
   \                     USB_DeviceControlCallback: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB09E             SUB      SP,SP,#+120
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    710              usb_setup_struct_t *deviceSetup;
    711              usb_device_common_class_struct_t *classHandle;
    712              uint8_t *buffer = (uint8_t *)NULL;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9003             STR      R0,[SP, #+12]
    713              uint32_t length = 0U;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x9004             STR      R0,[SP, #+16]
    714              usb_status_t error = kStatus_USB_InvalidRequest;
   \   00000014   0xF05F 0x0805      MOVS     R8,#+5
    715              uint8_t state;
    716          
    717              if ((0xFFFFFFFFU == message->length) || (NULL == callbackParam))
   \   00000018   0x6868             LDR      R0,[R5, #+4]
   \   0000001A   0xF110 0x0F01      CMN      R0,#+1
   \   0000001E   0xD001             BEQ.N    ??USB_DeviceControlCallback_0
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD102             BNE.N    ??USB_DeviceControlCallback_1
    718              {
    719                  return error;
   \                     ??USB_DeviceControlCallback_0: (+1)
   \   00000024   0x4640             MOV      R0,R8
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0xE106             B.N      ??USB_DeviceControlCallback_2
    720              }
    721          
    722              classHandle = (usb_device_common_class_struct_t *)callbackParam;
   \                     ??USB_DeviceControlCallback_1: (+1)
   \   0000002A   0x46B2             MOV      R10,R6
    723              deviceSetup = (usb_setup_struct_t *)&classHandle->setupBuffer[0];
   \   0000002C   0xF11A 0x0008      ADDS     R0,R10,#+8
   \   00000030   0x0007             MOVS     R7,R0
    724              USB_DeviceGetStatus(handle, kUSB_DeviceStatusDeviceState, &state);
   \   00000032   0xAA02             ADD      R2,SP,#+8
   \   00000034   0x2106             MOVS     R1,#+6
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       USB_DeviceGetStatus
    725          
    726              if (message->isSetup)
   \   0000003C   0x7A28             LDRB     R0,[R5, #+8]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xF000 0x80AF      BEQ.W    ??USB_DeviceControlCallback_3
    727              {
    728                  if ((USB_SETUP_PACKET_SIZE != message->length) || (NULL == message->buffer))
   \   00000044   0x6868             LDR      R0,[R5, #+4]
   \   00000046   0x2808             CMP      R0,#+8
   \   00000048   0xD102             BNE.N    ??USB_DeviceControlCallback_4
   \   0000004A   0x6828             LDR      R0,[R5, #+0]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD102             BNE.N    ??USB_DeviceControlCallback_5
    729                  {
    730                      /* If a invalid setup is received, the control pipes should be de-init and init again.
    731                       * Due to the IP can not meet this require, it is revesed for feature.
    732                       */
    733                      /*
    734                      USB_DeviceDeinitEndpoint(handle,
    735                                   USB_CONTROL_ENDPOINT | (USB_IN << USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT));
    736                      USB_DeviceDeinitEndpoint(handle,
    737                                   USB_CONTROL_ENDPOINT | (USB_OUT << USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT));
    738                      USB_DeviceControlPipeInit(handle, callbackParam);
    739                      */
    740                      return error;
   \                     ??USB_DeviceControlCallback_4: (+1)
   \   00000050   0x4640             MOV      R0,R8
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   0xE0F0             B.N      ??USB_DeviceControlCallback_2
    741                  }
    742                  /* Receive a setup request */
    743                  usb_setup_struct_t *setup = (usb_setup_struct_t *)(message->buffer);
   \                     ??USB_DeviceControlCallback_5: (+1)
   \   00000056   0xF8D5 0x9000      LDR      R9,[R5, #+0]
    744          
    745                  /* Copy the setup packet to the application buffer */
    746                  deviceSetup->wValue = USB_SHORT_FROM_LITTLE_ENDIAN(setup->wValue);
   \   0000005A   0xF8B9 0x0002      LDRH     R0,[R9, #+2]
   \   0000005E   0x8078             STRH     R0,[R7, #+2]
    747                  deviceSetup->wIndex = USB_SHORT_FROM_LITTLE_ENDIAN(setup->wIndex);
   \   00000060   0xF8B9 0x0004      LDRH     R0,[R9, #+4]
   \   00000064   0x80B8             STRH     R0,[R7, #+4]
    748                  deviceSetup->wLength = USB_SHORT_FROM_LITTLE_ENDIAN(setup->wLength);
   \   00000066   0xF8B9 0x0006      LDRH     R0,[R9, #+6]
   \   0000006A   0x80F8             STRH     R0,[R7, #+6]
    749                  deviceSetup->bRequest = setup->bRequest;
   \   0000006C   0xF899 0x0001      LDRB     R0,[R9, #+1]
   \   00000070   0x7078             STRB     R0,[R7, #+1]
    750                  deviceSetup->bmRequestType = setup->bmRequestType;
   \   00000072   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000076   0x7038             STRB     R0,[R7, #+0]
    751          
    752                  if ((deviceSetup->bmRequestType & USB_REQUEST_TYPE_TYPE_MASK) == USB_REQUEST_TYPE_TYPE_STANDARD)
   \   00000078   0x7838             LDRB     R0,[R7, #+0]
   \   0000007A   0x2160             MOVS     R1,#+96
   \   0000007C   0x4208             TST      R0,R1
   \   0000007E   0xD112             BNE.N    ??USB_DeviceControlCallback_6
    753                  {
    754                      /* Handle the standard request */
    755                      if (s_UsbDeviceStandardRequest[deviceSetup->bRequest] != (usb_standard_request_callback_t)NULL)
   \   00000080   0x....             LDR.N    R0,??DataTable1
   \   00000082   0x7879             LDRB     R1,[R7, #+1]
   \   00000084   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD07D             BEQ.N    ??USB_DeviceControlCallback_7
    756                      {
    757                          error = s_UsbDeviceStandardRequest[deviceSetup->bRequest](classHandle, deviceSetup, &buffer, &length);
   \   0000008C   0xAB04             ADD      R3,SP,#+16
   \   0000008E   0xAA03             ADD      R2,SP,#+12
   \   00000090   0x0039             MOVS     R1,R7
   \   00000092   0x4650             MOV      R0,R10
   \   00000094   0x.... 0x....      LDR.W    R12,??DataTable1
   \   00000098   0xF897 0xE001      LDRB     LR,[R7, #+1]
   \   0000009C   0xF85C 0xC02E      LDR      R12,[R12, LR, LSL #+2]
   \   000000A0   0x47E0             BLX      R12
   \   000000A2   0x4680             MOV      R8,R0
   \   000000A4   0xE070             B.N      ??USB_DeviceControlCallback_7
    758                      }
    759                  }
    760                  else
    761                  {
    762                      if ((deviceSetup->wLength) &&
    763                          ((deviceSetup->bmRequestType & USB_REQUSET_TYPE_DIR_MASK) == USB_REQUEST_TYPE_DIR_OUT))
   \                     ??USB_DeviceControlCallback_6: (+1)
   \   000000A6   0x88F8             LDRH     R0,[R7, #+6]
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD042             BEQ.N    ??USB_DeviceControlCallback_8
   \   000000AC   0x7838             LDRB     R0,[R7, #+0]
   \   000000AE   0x0600             LSLS     R0,R0,#+24
   \   000000B0   0xD43F             BMI.N    ??USB_DeviceControlCallback_8
    764                      {
    765                          /* Class or vendor request with the OUT data phase. */
    766                          if ((deviceSetup->wLength) &&
    767                              ((deviceSetup->bmRequestType & USB_REQUEST_TYPE_TYPE_CLASS) == USB_REQUEST_TYPE_TYPE_CLASS))
   \   000000B2   0x88F8             LDRH     R0,[R7, #+6]
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD015             BEQ.N    ??USB_DeviceControlCallback_9
   \   000000B8   0x7838             LDRB     R0,[R7, #+0]
   \   000000BA   0x0680             LSLS     R0,R0,#+26
   \   000000BC   0xD512             BPL.N    ??USB_DeviceControlCallback_9
    768                          {
    769                              /* Get data buffer to receive the data from the host. */
    770                              usb_device_control_request_struct_t controlRequest;
    771                              controlRequest.buffer = (uint8_t *)NULL;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x9012             STR      R0,[SP, #+72]
    772                              controlRequest.isSetup = 1U;
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0xF88D 0x0050      STRB     R0,[SP, #+80]
    773                              controlRequest.setup = deviceSetup;
   \   000000C8   0x9711             STR      R7,[SP, #+68]
    774                              controlRequest.length = deviceSetup->wLength;
   \   000000CA   0x88F8             LDRH     R0,[R7, #+6]
   \   000000CC   0x9013             STR      R0,[SP, #+76]
    775                              error = USB_DeviceClassEvent(handle, kUSB_DeviceClassEventClassRequest, &controlRequest);
   \   000000CE   0xAA11             ADD      R2,SP,#+68
   \   000000D0   0x2101             MOVS     R1,#+1
   \   000000D2   0x0020             MOVS     R0,R4
   \   000000D4   0x.... 0x....      BL       USB_DeviceClassEvent
   \   000000D8   0x4680             MOV      R8,R0
    776                              length = controlRequest.length;
   \   000000DA   0x9813             LDR      R0,[SP, #+76]
   \   000000DC   0x9004             STR      R0,[SP, #+16]
    777                              buffer = controlRequest.buffer;
   \   000000DE   0x9812             LDR      R0,[SP, #+72]
   \   000000E0   0x9003             STR      R0,[SP, #+12]
   \   000000E2   0xE017             B.N      ??USB_DeviceControlCallback_10
    778                          }
    779                          else if ((deviceSetup->wLength) &&
    780                                   ((deviceSetup->bmRequestType & USB_REQUEST_TYPE_TYPE_VENDOR) == USB_REQUEST_TYPE_TYPE_VENDOR))
   \                     ??USB_DeviceControlCallback_9: (+1)
   \   000000E4   0x88F8             LDRH     R0,[R7, #+6]
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD014             BEQ.N    ??USB_DeviceControlCallback_10
   \   000000EA   0x7838             LDRB     R0,[R7, #+0]
   \   000000EC   0x0640             LSLS     R0,R0,#+25
   \   000000EE   0xD511             BPL.N    ??USB_DeviceControlCallback_10
    781                          {
    782                              /* Get data buffer to receive the data from the host. */
    783                              usb_device_control_request_struct_t controlRequest;
    784                              controlRequest.buffer = (uint8_t *)NULL;
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0x900E             STR      R0,[SP, #+56]
    785                              controlRequest.isSetup = 1U;
   \   000000F4   0x2001             MOVS     R0,#+1
   \   000000F6   0xF88D 0x0040      STRB     R0,[SP, #+64]
    786                              controlRequest.setup = deviceSetup;
   \   000000FA   0x970D             STR      R7,[SP, #+52]
    787                              controlRequest.length = deviceSetup->wLength;
   \   000000FC   0x88F8             LDRH     R0,[R7, #+6]
   \   000000FE   0x900F             STR      R0,[SP, #+60]
    788                              error = USB_DeviceClassCallback(handle, kUSB_DeviceEventVendorRequest, &controlRequest);
   \   00000100   0xAA0D             ADD      R2,SP,#+52
   \   00000102   0x210F             MOVS     R1,#+15
   \   00000104   0x0020             MOVS     R0,R4
   \   00000106   0x.... 0x....      BL       USB_DeviceClassCallback
   \   0000010A   0x4680             MOV      R8,R0
    789                              length = controlRequest.length;
   \   0000010C   0x980F             LDR      R0,[SP, #+60]
   \   0000010E   0x9004             STR      R0,[SP, #+16]
    790                              buffer = controlRequest.buffer;
   \   00000110   0x980E             LDR      R0,[SP, #+56]
   \   00000112   0x9003             STR      R0,[SP, #+12]
    791                          }
    792                          else
    793                          {
    794                          }
    795                          if (kStatus_USB_Success == error)
   \                     ??USB_DeviceControlCallback_10: (+1)
   \   00000114   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000118   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000011C   0xD134             BNE.N    ??USB_DeviceControlCallback_7
    796                          {
    797                              /* Prime an OUT transfer */
    798                              error = USB_DeviceRecvRequest(handle, USB_CONTROL_ENDPOINT, buffer, deviceSetup->wLength);
   \   0000011E   0x88FB             LDRH     R3,[R7, #+6]
   \   00000120   0x9A03             LDR      R2,[SP, #+12]
   \   00000122   0x2100             MOVS     R1,#+0
   \   00000124   0x0020             MOVS     R0,R4
   \   00000126   0x.... 0x....      BL       USB_DeviceRecvRequest
   \   0000012A   0x4680             MOV      R8,R0
    799                              return error;
   \   0000012C   0x4640             MOV      R0,R8
   \   0000012E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000130   0xE082             B.N      ??USB_DeviceControlCallback_2
    800                          }
    801                      }
    802                      else
    803                      {
    804                          /* Class or vendor request with the IN data phase. */
    805                          if (((deviceSetup->bmRequestType & USB_REQUEST_TYPE_TYPE_CLASS) == USB_REQUEST_TYPE_TYPE_CLASS))
   \                     ??USB_DeviceControlCallback_8: (+1)
   \   00000132   0x7838             LDRB     R0,[R7, #+0]
   \   00000134   0x0680             LSLS     R0,R0,#+26
   \   00000136   0xD512             BPL.N    ??USB_DeviceControlCallback_11
    806                          {
    807                              /* Get data buffer to response the host. */
    808                              usb_device_control_request_struct_t controlRequest;
    809                              controlRequest.buffer = (uint8_t *)NULL;
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0x900A             STR      R0,[SP, #+40]
    810                              controlRequest.isSetup = 1U;
   \   0000013C   0x2001             MOVS     R0,#+1
   \   0000013E   0xF88D 0x0030      STRB     R0,[SP, #+48]
    811                              controlRequest.setup = deviceSetup;
   \   00000142   0x9709             STR      R7,[SP, #+36]
    812                              controlRequest.length = deviceSetup->wLength;
   \   00000144   0x88F8             LDRH     R0,[R7, #+6]
   \   00000146   0x900B             STR      R0,[SP, #+44]
    813                              error = USB_DeviceClassEvent(handle, kUSB_DeviceClassEventClassRequest, &controlRequest);
   \   00000148   0xAA09             ADD      R2,SP,#+36
   \   0000014A   0x2101             MOVS     R1,#+1
   \   0000014C   0x0020             MOVS     R0,R4
   \   0000014E   0x.... 0x....      BL       USB_DeviceClassEvent
   \   00000152   0x4680             MOV      R8,R0
    814                              length = controlRequest.length;
   \   00000154   0x980B             LDR      R0,[SP, #+44]
   \   00000156   0x9004             STR      R0,[SP, #+16]
    815                              buffer = controlRequest.buffer;
   \   00000158   0x980A             LDR      R0,[SP, #+40]
   \   0000015A   0x9003             STR      R0,[SP, #+12]
   \   0000015C   0xE014             B.N      ??USB_DeviceControlCallback_7
    816                          }
    817                          else if (((deviceSetup->bmRequestType & USB_REQUEST_TYPE_TYPE_VENDOR) == USB_REQUEST_TYPE_TYPE_VENDOR))
   \                     ??USB_DeviceControlCallback_11: (+1)
   \   0000015E   0x7838             LDRB     R0,[R7, #+0]
   \   00000160   0x0640             LSLS     R0,R0,#+25
   \   00000162   0xD511             BPL.N    ??USB_DeviceControlCallback_7
    818                          {
    819                              /* Get data buffer to response the host. */
    820                              usb_device_control_request_struct_t controlRequest;
    821                              controlRequest.buffer = (uint8_t *)NULL;
   \   00000164   0x2000             MOVS     R0,#+0
   \   00000166   0x9006             STR      R0,[SP, #+24]
    822                              controlRequest.isSetup = 1U;
   \   00000168   0x2001             MOVS     R0,#+1
   \   0000016A   0xF88D 0x0020      STRB     R0,[SP, #+32]
    823                              controlRequest.setup = deviceSetup;
   \   0000016E   0x9705             STR      R7,[SP, #+20]
    824                              controlRequest.length = deviceSetup->wLength;
   \   00000170   0x88F8             LDRH     R0,[R7, #+6]
   \   00000172   0x9007             STR      R0,[SP, #+28]
    825                              error = USB_DeviceClassCallback(handle, kUSB_DeviceEventVendorRequest, &controlRequest);
   \   00000174   0xAA05             ADD      R2,SP,#+20
   \   00000176   0x210F             MOVS     R1,#+15
   \   00000178   0x0020             MOVS     R0,R4
   \   0000017A   0x.... 0x....      BL       USB_DeviceClassCallback
   \   0000017E   0x4680             MOV      R8,R0
    826                              length = controlRequest.length;
   \   00000180   0x9807             LDR      R0,[SP, #+28]
   \   00000182   0x9004             STR      R0,[SP, #+16]
    827                              buffer = controlRequest.buffer;
   \   00000184   0x9806             LDR      R0,[SP, #+24]
   \   00000186   0x9003             STR      R0,[SP, #+12]
    828                          }
    829                          else
    830                          {
    831                          }
    832                      }
    833                  }
    834                  /* Send the reponse to the host. */
    835                  error = USB_DeviceControlCallbackFeedback(handle, deviceSetup, error, kUSB_DeviceControlPipeSetupStage, &buffer,
    836                                                            &length);
   \                     ??USB_DeviceControlCallback_7: (+1)
   \   00000188   0xA804             ADD      R0,SP,#+16
   \   0000018A   0x9001             STR      R0,[SP, #+4]
   \   0000018C   0xA803             ADD      R0,SP,#+12
   \   0000018E   0x9000             STR      R0,[SP, #+0]
   \   00000190   0x2300             MOVS     R3,#+0
   \   00000192   0x4642             MOV      R2,R8
   \   00000194   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000196   0x0039             MOVS     R1,R7
   \   00000198   0x0020             MOVS     R0,R4
   \   0000019A   0x.... 0x....      BL       USB_DeviceControlCallbackFeedback
   \   0000019E   0x4680             MOV      R8,R0
   \   000001A0   0xE048             B.N      ??USB_DeviceControlCallback_12
    837              }
    838              else if (kUSB_DeviceStateAddressing == state)
   \                     ??USB_DeviceControlCallback_3: (+1)
   \   000001A2   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000001A6   0x2803             CMP      R0,#+3
   \   000001A8   0xD10C             BNE.N    ??USB_DeviceControlCallback_13
    839              {
    840                  /* Set the device address to controller. */
    841                  error = s_UsbDeviceStandardRequest[deviceSetup->bRequest](classHandle, deviceSetup, &buffer, &length);
   \   000001AA   0xAB04             ADD      R3,SP,#+16
   \   000001AC   0xAA03             ADD      R2,SP,#+12
   \   000001AE   0x0039             MOVS     R1,R7
   \   000001B0   0x4650             MOV      R0,R10
   \   000001B2   0x.... 0x....      LDR.W    R12,??DataTable1
   \   000001B6   0xF897 0xE001      LDRB     LR,[R7, #+1]
   \   000001BA   0xF85C 0xC02E      LDR      R12,[R12, LR, LSL #+2]
   \   000001BE   0x47E0             BLX      R12
   \   000001C0   0x4680             MOV      R8,R0
   \   000001C2   0xE037             B.N      ??USB_DeviceControlCallback_12
    842              }
    843          #if (defined(USB_DEVICE_CONFIG_EHCI) && (USB_DEVICE_CONFIG_EHCI > 0U)) && \
    844              (defined(USB_DEVICE_CONFIG_EHCI_TEST_MODE) && (USB_DEVICE_CONFIG_EHCI_TEST_MODE > 0U))
    845              else if (kUSB_DeviceStateTestMode == state)
    846              {
    847                  uint8_t portTestControl = (uint8_t)(deviceSetup->wIndex >> 8);
    848                  /* Set the controller.into test mode. */
    849                  error = USB_DeviceSetStatus(handle, kUSB_DeviceStatusTestMode, &portTestControl);
    850              }
    851          #endif
    852              else if ((message->length) && (deviceSetup->wLength) &&
    853                       ((deviceSetup->bmRequestType & USB_REQUSET_TYPE_DIR_MASK) == USB_REQUEST_TYPE_DIR_OUT))
   \                     ??USB_DeviceControlCallback_13: (+1)
   \   000001C4   0x6868             LDR      R0,[R5, #+4]
   \   000001C6   0x2800             CMP      R0,#+0
   \   000001C8   0xD034             BEQ.N    ??USB_DeviceControlCallback_12
   \   000001CA   0x88F8             LDRH     R0,[R7, #+6]
   \   000001CC   0x2800             CMP      R0,#+0
   \   000001CE   0xD031             BEQ.N    ??USB_DeviceControlCallback_12
   \   000001D0   0x7838             LDRB     R0,[R7, #+0]
   \   000001D2   0x0600             LSLS     R0,R0,#+24
   \   000001D4   0xD42E             BMI.N    ??USB_DeviceControlCallback_12
    854              {
    855                  if (((deviceSetup->bmRequestType & USB_REQUEST_TYPE_TYPE_CLASS) == USB_REQUEST_TYPE_TYPE_CLASS))
   \   000001D6   0x7838             LDRB     R0,[R7, #+0]
   \   000001D8   0x0680             LSLS     R0,R0,#+26
   \   000001DA   0xD50E             BPL.N    ??USB_DeviceControlCallback_14
    856                  {
    857                      /* Data received in OUT phase, and notify the class driver. */
    858                      usb_device_control_request_struct_t controlRequest;
    859                      controlRequest.buffer = message->buffer;
   \   000001DC   0x6828             LDR      R0,[R5, #+0]
   \   000001DE   0x901A             STR      R0,[SP, #+104]
    860                      controlRequest.isSetup = 0U;
   \   000001E0   0x2000             MOVS     R0,#+0
   \   000001E2   0xF88D 0x0070      STRB     R0,[SP, #+112]
    861                      controlRequest.setup = deviceSetup;
   \   000001E6   0x9719             STR      R7,[SP, #+100]
    862                      controlRequest.length = message->length;
   \   000001E8   0x6868             LDR      R0,[R5, #+4]
   \   000001EA   0x901B             STR      R0,[SP, #+108]
    863                      error = USB_DeviceClassEvent(handle, kUSB_DeviceClassEventClassRequest, &controlRequest);
   \   000001EC   0xAA19             ADD      R2,SP,#+100
   \   000001EE   0x2101             MOVS     R1,#+1
   \   000001F0   0x0020             MOVS     R0,R4
   \   000001F2   0x.... 0x....      BL       USB_DeviceClassEvent
   \   000001F6   0x4680             MOV      R8,R0
   \   000001F8   0xE010             B.N      ??USB_DeviceControlCallback_15
    864                  }
    865                  else if (((deviceSetup->bmRequestType & USB_REQUEST_TYPE_TYPE_VENDOR) == USB_REQUEST_TYPE_TYPE_VENDOR))
   \                     ??USB_DeviceControlCallback_14: (+1)
   \   000001FA   0x7838             LDRB     R0,[R7, #+0]
   \   000001FC   0x0640             LSLS     R0,R0,#+25
   \   000001FE   0xD50D             BPL.N    ??USB_DeviceControlCallback_15
    866                  {
    867                      /* Data received in OUT phase, and notify the application. */
    868                      usb_device_control_request_struct_t controlRequest;
    869                      controlRequest.buffer = message->buffer;
   \   00000200   0x6828             LDR      R0,[R5, #+0]
   \   00000202   0x9016             STR      R0,[SP, #+88]
    870                      controlRequest.isSetup = 0U;
   \   00000204   0x2000             MOVS     R0,#+0
   \   00000206   0xF88D 0x0060      STRB     R0,[SP, #+96]
    871                      controlRequest.setup = deviceSetup;
   \   0000020A   0x9715             STR      R7,[SP, #+84]
    872                      controlRequest.length = message->length;
   \   0000020C   0x6868             LDR      R0,[R5, #+4]
   \   0000020E   0x9017             STR      R0,[SP, #+92]
    873                      error = USB_DeviceClassCallback(handle, kUSB_DeviceEventVendorRequest, &controlRequest);
   \   00000210   0xAA15             ADD      R2,SP,#+84
   \   00000212   0x210F             MOVS     R1,#+15
   \   00000214   0x0020             MOVS     R0,R4
   \   00000216   0x.... 0x....      BL       USB_DeviceClassCallback
   \   0000021A   0x4680             MOV      R8,R0
    874                  }
    875                  else
    876                  {
    877                  }
    878                  /* Send the reponse to the host. */
    879                  error = USB_DeviceControlCallbackFeedback(handle, deviceSetup, error, kUSB_DeviceControlPipeDataStage, &buffer,
    880                                                            &length);
   \                     ??USB_DeviceControlCallback_15: (+1)
   \   0000021C   0xA804             ADD      R0,SP,#+16
   \   0000021E   0x9001             STR      R0,[SP, #+4]
   \   00000220   0xA803             ADD      R0,SP,#+12
   \   00000222   0x9000             STR      R0,[SP, #+0]
   \   00000224   0x2301             MOVS     R3,#+1
   \   00000226   0x4642             MOV      R2,R8
   \   00000228   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000022A   0x0039             MOVS     R1,R7
   \   0000022C   0x0020             MOVS     R0,R4
   \   0000022E   0x.... 0x....      BL       USB_DeviceControlCallbackFeedback
   \   00000232   0x4680             MOV      R8,R0
    881              }
    882              else
    883              {
    884              }
    885              return error;
   \                     ??USB_DeviceControlCallback_12: (+1)
   \   00000234   0x4640             MOV      R0,R8
   \   00000236   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceControlCallback_2: (+1)
   \   00000238   0xB01E             ADD      SP,SP,#+120
   \   0000023A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    886          }
    887          
    888          /*!
    889           * @brief Control endpoint initialization function.
    890           *
    891           * This callback function is used to initialize the control pipes.
    892           *
    893           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    894           * @param param           The up layer handle.
    895           *
    896           * @return A USB error code or kStatus_USB_Success.
    897           */

   \                                 In section .text, align 2, keep-with-next
    898          usb_status_t USB_DeviceControlPipeInit(usb_device_handle handle, void *param)
    899          {
   \                     USB_DeviceControlPipeInit: (+1)
   \   00000000   0xB57F             PUSH     {R0-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    900              usb_device_endpoint_init_struct_t epInitStruct;
    901              usb_device_endpoint_callback_struct_t endpointCallback;
    902              usb_status_t error;
    903          
    904              endpointCallback.callbackFn = USB_DeviceControlCallback;
   \   00000006   0x....             LDR.N    R0,??DataTable1_1
   \   00000008   0x9002             STR      R0,[SP, #+8]
    905              endpointCallback.callbackParam = param;
   \   0000000A   0x9503             STR      R5,[SP, #+12]
    906          
    907              epInitStruct.zlt = 1U;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xF88D 0x0004      STRB     R0,[SP, #+4]
    908              epInitStruct.transferType = USB_ENDPOINT_CONTROL;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF88D 0x0003      STRB     R0,[SP, #+3]
    909              epInitStruct.endpointAddress = USB_CONTROL_ENDPOINT | (USB_IN << USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT);
   \   00000018   0x2080             MOVS     R0,#+128
   \   0000001A   0xF88D 0x0002      STRB     R0,[SP, #+2]
    910              epInitStruct.maxPacketSize = USB_CONTROL_MAX_PACKET_SIZE;
   \   0000001E   0x2040             MOVS     R0,#+64
   \   00000020   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    911              /* Initialize the control IN pipe */
    912              error = USB_DeviceInitEndpoint(handle, &epInitStruct, &endpointCallback);
   \   00000024   0xAA02             ADD      R2,SP,#+8
   \   00000026   0x4669             MOV      R1,SP
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       USB_DeviceInitEndpoint
   \   0000002E   0x0006             MOVS     R6,R0
    913          
    914              if (kStatus_USB_Success != error)
   \   00000030   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD002             BEQ.N    ??USB_DeviceControlPipeInit_0
    915              {
    916                  return error;
   \   00000036   0x0030             MOVS     R0,R6
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0xE013             B.N      ??USB_DeviceControlPipeInit_1
    917              }
    918              epInitStruct.endpointAddress = USB_CONTROL_ENDPOINT | (USB_OUT << USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT);
   \                     ??USB_DeviceControlPipeInit_0: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    919              /* Initialize the control OUT pipe */
    920              error = USB_DeviceInitEndpoint(handle, &epInitStruct, &endpointCallback);
   \   00000042   0xAA02             ADD      R2,SP,#+8
   \   00000044   0x4669             MOV      R1,SP
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       USB_DeviceInitEndpoint
   \   0000004C   0x0006             MOVS     R6,R0
    921          
    922              if (kStatus_USB_Success != error)
   \   0000004E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000050   0x2E00             CMP      R6,#+0
   \   00000052   0xD006             BEQ.N    ??USB_DeviceControlPipeInit_2
    923              {
    924                  USB_DeviceDeinitEndpoint(handle,
    925                                           USB_CONTROL_ENDPOINT | (USB_IN << USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT));
   \   00000054   0x2180             MOVS     R1,#+128
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      BL       USB_DeviceDeinitEndpoint
    926                  return error;
   \   0000005C   0x0030             MOVS     R0,R6
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0xE000             B.N      ??USB_DeviceControlPipeInit_1
    927              }
    928          
    929              return kStatus_USB_Success;
   \                     ??USB_DeviceControlPipeInit_2: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \                     ??USB_DeviceControlPipeInit_1: (+1)
   \   00000064   0xB004             ADD      SP,SP,#+16
   \   00000066   0xBD70             POP      {R4-R6,PC}       ;; return
    930          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     s_UsbDeviceStandardRequest

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     USB_DeviceControlCallback
    931          #endif /* USB_DEVICE_CONFIG_NUM */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   USB_DeviceCh9GetConfiguration
        24   -> USB_DeviceClassCallback
        24   -> USB_DeviceGetStatus
      48   USB_DeviceCh9GetDescriptor
        48   -> USB_DeviceClassCallback
        48   -> USB_DeviceGetStatus
      32   USB_DeviceCh9GetInterface
        32   -> USB_DeviceClassCallback
        32   -> USB_DeviceGetStatus
      32   USB_DeviceCh9GetStatus
        32   -> USB_DeviceGetStatus
      32   USB_DeviceCh9SetAddress
        32   -> USB_DeviceGetStatus
        32   -> USB_DeviceSetStatus
      32   USB_DeviceCh9SetClearFeature
        32   -> USB_DeviceClassCallback
        32   -> USB_DeviceClassEvent
        32   -> USB_DeviceGetStatus
        32   -> USB_DeviceStallEndpoint
        32   -> USB_DeviceUnstallEndpoint
      24   USB_DeviceCh9SetConfiguration
        24   -> USB_DeviceClassCallback
        24   -> USB_DeviceClassEvent
        24   -> USB_DeviceGetStatus
        24   -> USB_DeviceSetStatus
      24   USB_DeviceCh9SetInterface
        24   -> USB_DeviceClassCallback
        24   -> USB_DeviceClassEvent
        24   -> USB_DeviceGetStatus
      32   USB_DeviceCh9SynchFrame
        32   -> USB_DeviceGetStatus
     152   USB_DeviceControlCallback
       152   -- Indirect call
       152   -> USB_DeviceClassCallback
       152   -> USB_DeviceClassEvent
       152   -> USB_DeviceControlCallbackFeedback
       152   -> USB_DeviceGetStatus
       152   -> USB_DeviceRecvRequest
      40   USB_DeviceControlCallbackFeedback
        40   -> USB_DeviceRecvRequest
        40   -> USB_DeviceSendRequest
        40   -> USB_DeviceStallEndpoint
      32   USB_DeviceControlPipeInit
        32   -> USB_DeviceDeinitEndpoint
        32   -> USB_DeviceInitEndpoint


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
      64  USB_DeviceCh9GetConfiguration
     266  USB_DeviceCh9GetDescriptor
      76  USB_DeviceCh9GetInterface
     178  USB_DeviceCh9GetStatus
     134  USB_DeviceCh9SetAddress
     218  USB_DeviceCh9SetClearFeature
     100  USB_DeviceCh9SetConfiguration
      72  USB_DeviceCh9SetInterface
      78  USB_DeviceCh9SynchFrame
     574  USB_DeviceControlCallback
     152  USB_DeviceControlCallbackFeedback
     104  USB_DeviceControlPipeInit
      52  s_UsbDeviceStandardRequest

 
    52 bytes in section .rodata
 2 024 bytes in section .text
 
 2 024 bytes of CODE  memory
    52 bytes of CONST memory

Errors: none
Warnings: none
