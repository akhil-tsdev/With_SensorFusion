###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:08
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\common\src\pinmux_utility_common.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\common\src\pinmux_utility_common.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\pinmux_utility_common.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\pinmux_utility_common.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\common\src\pinmux_utility_common.c
      1          /*
      2           * Copyright (c) 2014-2016, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          ////////////////////////////////////////////////////////////////////////////////
     32          // Variables
     33          ////////////////////////////////////////////////////////////////////////////////
     34          #include "bootloader_common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR.N    R2,??DataTable8  ;; 0xe000e100
   \   0000000A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000C   0x0943             LSRS     R3,R0,#+5
   \   0000000E   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR.N    R2,??DataTable8_1  ;; 0xe000e180
   \   0000000A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000C   0x0943             LSRS     R3,R0,#+5
   \   0000000E   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_SetPriority(IRQn_Type, uint32_t)
   \                     NVIC_SetPriority: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD508             BPL.N    ??NVIC_SetPriority_0
   \   00000008   0x010A             LSLS     R2,R1,#+4
   \   0000000A   0x....             LDR.N    R3,??DataTable8_2  ;; 0xe000ed18
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0xF010 0x040F      ANDS     R4,R0,#0xF
   \   00000012   0x4423             ADD      R3,R3,R4
   \   00000014   0xF803 0x2C04      STRB     R2,[R3, #-4]
   \   00000018   0xE003             B.N      ??NVIC_SetPriority_1
   \                     ??NVIC_SetPriority_0: (+1)
   \   0000001A   0x010A             LSLS     R2,R1,#+4
   \   0000001C   0x....             LDR.N    R3,??DataTable8_3  ;; 0xe000e400
   \   0000001E   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000020   0x541A             STRB     R2,[R3, R0]
   \                     ??NVIC_SetPriority_1: (+1)
   \   00000022   0xBC10             POP      {R4}
   \   00000024   0x4770             BX       LR               ;; return
     35          #include "bootloader/bl_context.h"
     36          #include "fsl_device_registers.h"
     37          #include "port/fsl_port.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void PORT_SetPinInterruptConfig(PORT_Type *, uint32_t, port_interrupt_t const)
   \                     PORT_SetPinInterruptConfig: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xF850 0x3021      LDR      R3,[R0, R1, LSL #+2]
   \   00000006   0xF433 0x2370      BICS     R3,R3,#0xF0000
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0x0414             LSLS     R4,R2,#+16
   \   0000000E   0xF414 0x2470      ANDS     R4,R4,#0xF0000
   \   00000012   0x4323             ORRS     R3,R4,R3
   \   00000014   0xF840 0x3021      STR      R3,[R0, R1, LSL #+2]
   \   00000018   0xBC10             POP      {R4}
   \   0000001A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void PORT_ClearPinsInterruptFlags(PORT_Type *, uint32_t)
   \                     PORT_ClearPinsInterruptFlags: (+1)
   \   00000000   0xF8C0 0x10A0      STR      R1,[R0, #+160]
   \   00000004   0x4770             BX       LR               ;; return
     38          #include "gpio/fsl_gpio.h"
     39          #include "peripherals_pinmux.h"
     40          
     41          #if (BL_CONFIG_LPUART || BL_CONFIG_SCUART || BL_CONFIG_UART)
     42          
     43          #if BL_ENABLE_PINMUX_UART4
     44          #define BL_ENABLED_MAX_UART_INSTANCE (4)
     45          #elif BL_ENABLE_PINMUX_UART3
     46          #define BL_ENABLED_MAX_UART_INSTANCE (3)
     47          #elif BL_ENABLE_PINMUX_UART2
     48          #define BL_ENABLED_MAX_UART_INSTANCE (2)
     49          #elif BL_ENABLE_PINMUX_UART1
     50          #define BL_ENABLED_MAX_UART_INSTANCE (1)
     51          #elif BL_ENABLE_PINMUX_UART0
     52          #define BL_ENABLED_MAX_UART_INSTANCE (0)
     53          #endif
     54          
     55          //! UART autobaud port irq configurations
     56          #define PORT_IRQC_INTERRUPT_ENABLED_PRIORITY 1
     57          #define PORT_IRQC_INTERRUPT_RESTORED_PRIORITY 0
     58          
     59          #define PORT_IRQC_INTERRUPT_FALLING_EDGE 0xA
     60          #define PORT_IRQC_INTERRUPT_DISABLE 0
     61          
     62          //! this is to store the function pointer for calling back to the function that wants
     63          //! the UART RX instance pin that triggered the interrupt. This only supports 1 pin
     64          //! for UART0 because UART1 is on PORTC which does not support interrupts :(
     65          

   \                                 In section .bss, align 4
     66          static pin_irq_callback_t s_pin_irq_func[BL_ENABLED_MAX_UART_INSTANCE + 1] = { 0 };
   \                     s_pin_irq_func:
   \   00000000                      DS8 4
     67          
     68          #endif // BL_CONFIG_LPUART
     69          
     70          ////////////////////////////////////////////////////////////////////////////////
     71          // Code
     72          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
     73          uint32_t PORT_GetPinIsf(PORT_Type *base, uint32_t pin)
     74          {
     75              return (base->PCR[pin] & PORT_PCR_ISF_MASK) >> PORT_PCR_ISF_SHIFT;
   \                     PORT_GetPinIsf: (+1)
   \   00000000   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000004   0xF3C0 0x6000      UBFX     R0,R0,#+24,#+1
   \   00000008   0x4770             BX       LR               ;; return
     76          }
     77          

   \                                 In section .text, align 2, keep-with-next
     78          static inline void PORT_RestoreDefault(PORT_Type *base, uint32_t pin)
     79          {
     80              base->PCR[pin] = 0;
   \                     PORT_RestoreDefault: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0xF840 0x2021      STR      R2,[R0, R1, LSL #+2]
     81          }
   \   00000006   0x4770             BX       LR               ;; return
     82          
     83          #if (BL_CONFIG_LPUART || BL_CONFIG_SCUART || BL_CONFIG_UART)
     84          //! @brief Configure the GPIO mode for auto baud detection.

   \                                 In section .text, align 2, keep-with-next
     85          static inline void PORT_SetUartAutoBaudPinMode(PORT_Type *portBase, GPIO_Type *gpioBase, uint32_t pin)
     86          {
   \                     PORT_SetUartAutoBaudPinMode: (+1)
   \   00000000   0xB410             PUSH     {R4}
     87          #if BL_FEATURE_UART_RX_PULLUP
     88              // Configure the UART RX pin to GPIO mode, with pull-up resistor enabled.
     89              portBase->PCR[pin] = PORT_PCR_MUX(1) | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK;
     90          #else
     91              // Configure the UART RX pin to GPIO mode
     92              portBase->PCR[pin] = PORT_PCR_MUX(1);
   \   00000002   0xF44F 0x7380      MOV      R3,#+256
   \   00000006   0xF840 0x3022      STR      R3,[R0, R2, LSL #+2]
     93          #endif // BL_FEATURE_UART_RX_PULLUP
     94          
     95              // Configure UART RX pin to digital input mode.
     96              gpioBase->PDDR &= (uint32_t) ~(1 << pin);
   \   0000000A   0x694B             LDR      R3,[R1, #+20]
   \   0000000C   0x2401             MOVS     R4,#+1
   \   0000000E   0x4094             LSLS     R4,R4,R2
   \   00000010   0x43A3             BICS     R3,R3,R4
   \   00000012   0x614B             STR      R3,[R1, #+20]
     97          }
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4770             BX       LR               ;; return
     98          

   \                                 In section .text, align 2, keep-with-next
     99          static inline void PORT_SetUartPinMode(PORT_Type *base, uint32_t pin, uint32_t mux)
    100          {
    101              base->PCR[pin] = PORT_PCR_MUX(mux);
   \                     PORT_SetUartPinMode: (+1)
   \   00000000   0x0213             LSLS     R3,R2,#+8
   \   00000002   0xF413 0x63E0      ANDS     R3,R3,#0x700
   \   00000006   0xF840 0x3021      STR      R3,[R0, R1, LSL #+2]
    102          }
   \   0000000A   0x4770             BX       LR               ;; return
    103          #endif
    104          
    105          #if (BL_CONFIG_I2C || BL_CONFIG_LPI2C)

   \                                 In section .text, align 2, keep-with-next
    106          static inline void PORT_SetI2cPinMode(PORT_Type *base, uint32_t pin, uint32_t mux)
    107          {
    108          #if defined(FSL_FEATURE_PORT_HAS_OPEN_DRAIN) && (FSL_FEATURE_PORT_HAS_OPEN_DRAIN > 0)
    109              base->PCR[pin] = PORT_PCR_MUX(mux) | PORT_PCR_ODE(1);
   \                     PORT_SetI2cPinMode: (+1)
   \   00000000   0x0213             LSLS     R3,R2,#+8
   \   00000002   0xF413 0x63E0      ANDS     R3,R3,#0x700
   \   00000006   0xF053 0x0320      ORRS     R3,R3,#0x20
   \   0000000A   0xF840 0x3021      STR      R3,[R0, R1, LSL #+2]
    110          #else
    111              base->PCR[pin] = PORT_PCR_MUX(mux);
    112          #endif // //#if defined(FSL_FEATURE_PORT_HAS_OPEN_DRAIN) && (FSL_FEATURE_PORT_HAS_OPEN_DRAIN > 0)
    113          }
   \   0000000E   0x4770             BX       LR               ;; return
    114          #endif
    115          
    116          #if (BL_CONFIG_DSPI || BL_CONFIG_SPI || BL_CONFIG_LPSPI)

   \                                 In section .text, align 2, keep-with-next
    117          static inline void PORT_SetSpiPinMode(PORT_Type *base, uint32_t pin, uint32_t mux)
    118          {
    119              base->PCR[pin] = PORT_PCR_MUX(mux);
   \                     PORT_SetSpiPinMode: (+1)
   \   00000000   0x0213             LSLS     R3,R2,#+8
   \   00000002   0xF413 0x63E0      ANDS     R3,R3,#0x700
   \   00000006   0xF840 0x3021      STR      R3,[R0, R1, LSL #+2]
    120          }
   \   0000000A   0x4770             BX       LR               ;; return
    121          #endif
    122          
    123          #if BL_CONFIG_CAN
    124          static inline void PORT_SetCanPinMode(PORT_Type *base, uint32_t pin, uint32_t mux)
    125          {
    126              base->PCR[pin] = PORT_PCR_MUX(mux);
    127          }
    128          #endif
    129          
    130          /*!
    131           * @brief Configure pinmux for uart module.
    132           *
    133           * This function only support switching default or gpio or fixed-ALTx mode on fixed pins
    134           * (Although there are many ALTx-pinmux configuration choices on various pins for the same
    135           * peripheral module)
    136           */

   \                                 In section .text, align 2, keep-with-next
    137          void uart_pinmux_config(uint32_t instance, pinmux_type_t pinmux)
    138          {
   \                     uart_pinmux_config: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    139              switch (instance)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD121             BNE.N    ??uart_pinmux_config_0
    140              {
    141          #if BL_ENABLE_PINMUX_UART0
    142                  case 0:
    143                      switch (pinmux)
   \   0000000A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xD003             BEQ.N    ??uart_pinmux_config_1
   \   00000010   0x2D02             CMP      R5,#+2
   \   00000012   0xD010             BEQ.N    ??uart_pinmux_config_2
   \   00000014   0xD309             BCC.N    ??uart_pinmux_config_3
   \   00000016   0xE019             B.N      ??uart_pinmux_config_4
    144                      {
    145                          case kPinmuxType_Default:
    146                              PORT_RestoreDefault(UART0_RX_PORT_BASE, UART0_RX_GPIO_PIN_NUM);
   \                     ??uart_pinmux_config_1: (+1)
   \   00000018   0x210F             MOVS     R1,#+15
   \   0000001A   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40049000
   \   0000001C   0x.... 0x....      BL       PORT_RestoreDefault
    147                              PORT_RestoreDefault(UART0_TX_PORT_BASE, UART0_TX_GPIO_PIN_NUM);
   \   00000020   0x210E             MOVS     R1,#+14
   \   00000022   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40049000
   \   00000024   0x.... 0x....      BL       PORT_RestoreDefault
    148                              break;
   \   00000028   0xE010             B.N      ??uart_pinmux_config_5
    149                          case kPinmuxType_GPIO:
    150                              PORT_SetUartAutoBaudPinMode(UART0_RX_PORT_BASE, UART0_RX_GPIO_BASE, UART0_RX_GPIO_PIN_NUM);
   \                     ??uart_pinmux_config_3: (+1)
   \   0000002A   0x220F             MOVS     R2,#+15
   \   0000002C   0x....             LDR.N    R1,??DataTable8_5  ;; 0x400ff000
   \   0000002E   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40049000
   \   00000030   0x.... 0x....      BL       PORT_SetUartAutoBaudPinMode
    151                              break;
   \   00000034   0xE00A             B.N      ??uart_pinmux_config_5
    152                          case kPinmuxType_Peripheral:
    153                              // Enable pins for UART0.
    154                              PORT_SetUartPinMode(UART0_RX_PORT_BASE, UART0_RX_GPIO_PIN_NUM,
    155                                                  UART0_RX_FUNC_ALT_MODE); // Set UART0_RX pin to UART0_RX functionality
   \                     ??uart_pinmux_config_2: (+1)
   \   00000036   0x2203             MOVS     R2,#+3
   \   00000038   0x210F             MOVS     R1,#+15
   \   0000003A   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40049000
   \   0000003C   0x.... 0x....      BL       PORT_SetUartPinMode
    156                              PORT_SetUartPinMode(UART0_TX_PORT_BASE, UART0_TX_GPIO_PIN_NUM,
    157                                                  UART0_TX_FUNC_ALT_MODE); // Set UART0_TX pin to UART0_TX functionality
   \   00000040   0x2203             MOVS     R2,#+3
   \   00000042   0x210E             MOVS     R1,#+14
   \   00000044   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40049000
   \   00000046   0x.... 0x....      BL       PORT_SetUartPinMode
    158                              break;
   \   0000004A   0xE7FF             B.N      ??uart_pinmux_config_5
    159                          default:
    160                              break;
    161                      }
    162                      break;
   \                     ??uart_pinmux_config_4: (+1)
   \                     ??uart_pinmux_config_5: (+1)
   \   0000004C   0xE7FF             B.N      ??uart_pinmux_config_6
    163          #endif // #if BL_ENABLE_PINMUX_UART0
    164          
    165          #if BL_ENABLE_PINMUX_UART1
    166                  case 1:
    167                      switch (pinmux)
    168                      {
    169                          case kPinmuxType_Default:
    170                              PORT_RestoreDefault(UART1_RX_PORT_BASE, UART1_RX_GPIO_PIN_NUM);
    171                              PORT_RestoreDefault(UART1_TX_PORT_BASE, UART1_TX_GPIO_PIN_NUM);
    172                              break;
    173                          case kPinmuxType_GPIO:
    174                              PORT_SetUartAutoBaudPinMode(UART1_RX_PORT_BASE, UART1_RX_GPIO_BASE, UART1_RX_GPIO_PIN_NUM);
    175                              break;
    176                          case kPinmuxType_Peripheral:
    177                              // Enable pins for UART1.
    178                              PORT_SetUartPinMode(UART1_RX_PORT_BASE, UART1_RX_GPIO_PIN_NUM,
    179                                                  UART1_RX_FUNC_ALT_MODE); // Set UART1_RX pin to UART1_RX functionality
    180                              PORT_SetUartPinMode(UART1_TX_PORT_BASE, UART1_TX_GPIO_PIN_NUM,
    181                                                  UART1_TX_FUNC_ALT_MODE); // Set UART1_TX pin to UART1_TX functionality
    182                              break;
    183                          default:
    184                              break;
    185                      }
    186                      break;
    187          #endif // #if BL_ENABLE_PINMUX_UART1
    188          
    189          #if BL_ENABLE_PINMUX_UART2
    190                  case 2:
    191                      switch (pinmux)
    192                      {
    193                          case kPinmuxType_Default:
    194                              PORT_RestoreDefault(UART2_RX_PORT_BASE, UART2_RX_GPIO_PIN_NUM);
    195                              PORT_RestoreDefault(UART2_TX_PORT_BASE, UART2_TX_GPIO_PIN_NUM);
    196                              break;
    197                          case kPinmuxType_GPIO:
    198                              PORT_SetUartAutoBaudPinMode(UART2_RX_PORT_BASE, UART2_RX_GPIO_BASE, UART2_RX_GPIO_PIN_NUM);
    199                              break;
    200                          case kPinmuxType_Peripheral:
    201                              // Enable pins for UART2.
    202                              PORT_SetUartPinMode(UART2_RX_PORT_BASE, UART2_RX_GPIO_PIN_NUM,
    203                                                  UART2_RX_FUNC_ALT_MODE); // Set UART2_RX pin to UART2_RX functionality
    204                              PORT_SetUartPinMode(UART2_TX_PORT_BASE, UART2_TX_GPIO_PIN_NUM,
    205                                                  UART2_TX_FUNC_ALT_MODE); // Set UART2_TX pin to UART2_TX functionality
    206                              break;
    207                          default:
    208                              break;
    209                      }
    210                      break;
    211          #endif // #if BL_ENABLE_PINMUX_UART2
    212          
    213          #if BL_ENABLE_PINMUX_UART3
    214                  case 3:
    215                      switch (pinmux)
    216                      {
    217                          case kPinmuxType_Default:
    218                              PORT_RestoreDefault(UART3_RX_PORT_BASE, UART3_RX_GPIO_PIN_NUM);
    219                              PORT_RestoreDefault(UART3_TX_PORT_BASE, UART3_TX_GPIO_PIN_NUM);
    220                              break;
    221                          case kPinmuxType_GPIO:
    222                              PORT_SetUartAutoBaudPinMode(UART3_RX_PORT_BASE, UART3_RX_GPIO_BASE, UART3_RX_GPIO_PIN_NUM);
    223                              break;
    224                          case kPinmuxType_Peripheral:
    225                              // Enable pins for UART3.
    226                              PORT_SetUartPinMode(UART3_RX_PORT_BASE, UART3_RX_GPIO_PIN_NUM,
    227                                                  UART3_RX_FUNC_ALT_MODE); // Set UART3_RX pin to UART3_RX functionality
    228                              PORT_SetUartPinMode(UART3_TX_PORT_BASE, UART3_TX_GPIO_PIN_NUM,
    229                                                  UART3_TX_FUNC_ALT_MODE); // Set UART3_TX pin to UART3_TX functionality
    230                              break;
    231                          default:
    232                              break;
    233                      }
    234                      break;
    235          #endif // #if BL_ENABLE_PINMUX_UART3
    236          
    237          #if BL_ENABLE_PINMUX_UART4
    238                  case 4:
    239                      switch (pinmux)
    240                      {
    241                          case kPinmuxType_Default:
    242                              PORT_RestoreDefault(UART4_RX_PORT_BASE, UART4_RX_GPIO_PIN_NUM);
    243                              PORT_RestoreDefault(UART4_TX_PORT_BASE, UART4_TX_GPIO_PIN_NUM);
    244                              break;
    245                          case kPinmuxType_GPIO:
    246                              PORT_SetUartAutoBaudPinMode(UART4_RX_PORT_BASE, UART4_RX_GPIO_BASE, UART4_RX_GPIO_PIN_NUM);
    247                              break;
    248                          case kPinmuxType_Peripheral:
    249                              // Enable pins for UART4.
    250                              PORT_SetUartPinMode(UART4_RX_PORT_BASE, UART4_RX_GPIO_PIN_NUM,
    251                                                  UART4_RX_FUNC_ALT_MODE); // Set UART4_RX pin to UART4_RX functionality
    252                              PORT_SetUartPinMode(UART4_TX_PORT_BASE, UART4_TX_GPIO_PIN_NUM,
    253                                                  UART4_TX_FUNC_ALT_MODE); // Set UART4_TX pin to UART4_TX functionality
    254                              break;
    255                          default:
    256                              break;
    257                      }
    258                      break;
    259          #endif // #if BL_ENABLE_PINMUX_UART4
    260          
    261                  default:
    262                      break;
    263              }
    264          }
   \                     ??uart_pinmux_config_0: (+1)
   \                     ??uart_pinmux_config_6: (+1)
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    265          
    266          /*!
    267           * @brief Configure pinmux for i2c module.
    268           *
    269           * This function only support switching default or gpio or fixed-ALTx mode on fixed pins
    270           * (Although there are many ALTx-pinmux configuration choices on various pins for the same
    271           * peripheral module)
    272           */

   \                                 In section .text, align 2, keep-with-next
    273          void i2c_pinmux_config(uint32_t instance, pinmux_type_t pinmux)
    274          {
   \                     i2c_pinmux_config: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    275              switch (instance)
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD11B             BNE.N    ??i2c_pinmux_config_0
    276              {
    277          #if BL_ENABLE_PINMUX_I2C0
    278                  case 0:
    279                      switch (pinmux)
    280                      {
    281                          case kPinmuxType_Default:
    282                              PORT_RestoreDefault(I2C0_SCL_PORT_BASE, I2C0_SCL_GPIO_PIN_NUM);
    283                              PORT_RestoreDefault(I2C0_SDA_PORT_BASE, I2C0_SDA_GPIO_PIN_NUM);
    284                              break;
    285                          case kPinmuxType_Peripheral:
    286                              // Enable pins for I2C0.
    287                              PORT_SetI2cPinMode(I2C0_SDA_PORT_BASE, I2C0_SDA_GPIO_PIN_NUM,
    288                                                 I2C0_SDA_FUNC_ALT_MODE); // Set I2C0_SDA pin to I2C0_SDA functionality
    289                              PORT_SetI2cPinMode(I2C0_SCL_PORT_BASE, I2C0_SCL_GPIO_PIN_NUM,
    290                                                 I2C0_SCL_FUNC_ALT_MODE); // Set I2C0_SCL pin to I2C0_SCL functionality
    291                              break;
    292                          default:
    293                              break;
    294                      }
    295                      break;
    296          #endif // #if BL_ENABLE_PINMUX_I2C0
    297          
    298          #if BL_ENABLE_PINMUX_I2C1
    299                  case 1:
    300                      switch (pinmux)
   \   0000000A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD002             BEQ.N    ??i2c_pinmux_config_1
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xD009             BEQ.N    ??i2c_pinmux_config_2
   \   00000016   0xE013             B.N      ??i2c_pinmux_config_3
    301                      {
    302                          case kPinmuxType_Default:
    303                              PORT_RestoreDefault(I2C1_SCL_PORT_BASE, I2C1_SCL_GPIO_PIN_NUM);
   \                     ??i2c_pinmux_config_1: (+1)
   \   00000018   0x210A             MOVS     R1,#+10
   \   0000001A   0x....             LDR.N    R0,??DataTable8_6  ;; 0x4004b000
   \   0000001C   0x.... 0x....      BL       PORT_RestoreDefault
    304                              PORT_RestoreDefault(I2C1_SDA_PORT_BASE, I2C1_SDA_GPIO_PIN_NUM);
   \   00000020   0x210B             MOVS     R1,#+11
   \   00000022   0x....             LDR.N    R0,??DataTable8_6  ;; 0x4004b000
   \   00000024   0x.... 0x....      BL       PORT_RestoreDefault
    305                              break;
   \   00000028   0xE00A             B.N      ??i2c_pinmux_config_4
    306                          case kPinmuxType_Peripheral:
    307                              // Enable pins for I2C1.
    308                              PORT_SetI2cPinMode(I2C1_SDA_PORT_BASE, I2C1_SDA_GPIO_PIN_NUM,
    309                                                 I2C1_SDA_FUNC_ALT_MODE); // Set I2C1_SDA pin to I2C1_SDA functionality
   \                     ??i2c_pinmux_config_2: (+1)
   \   0000002A   0x2202             MOVS     R2,#+2
   \   0000002C   0x210B             MOVS     R1,#+11
   \   0000002E   0x....             LDR.N    R0,??DataTable8_6  ;; 0x4004b000
   \   00000030   0x.... 0x....      BL       PORT_SetI2cPinMode
    310                              PORT_SetI2cPinMode(I2C1_SCL_PORT_BASE, I2C1_SCL_GPIO_PIN_NUM,
    311                                                 I2C1_SCL_FUNC_ALT_MODE); // Set I2C1_SCL pin to I2C1_SCL functionality
   \   00000034   0x2202             MOVS     R2,#+2
   \   00000036   0x210A             MOVS     R1,#+10
   \   00000038   0x....             LDR.N    R0,??DataTable8_6  ;; 0x4004b000
   \   0000003A   0x.... 0x....      BL       PORT_SetI2cPinMode
    312                              break;
   \   0000003E   0xE7FF             B.N      ??i2c_pinmux_config_4
    313                          default:
    314                              break;
    315                      }
    316                      break;
   \                     ??i2c_pinmux_config_3: (+1)
   \                     ??i2c_pinmux_config_4: (+1)
   \   00000040   0xE7FF             B.N      ??i2c_pinmux_config_5
    317          #endif // #if BL_ENABLE_PINMUX_I2C1
    318          
    319          #if BL_ENABLE_PINMUX_I2C2
    320                  case 2:
    321                      switch (pinmux)
    322                      {
    323                          case kPinmuxType_Default:
    324                              PORT_RestoreDefault(I2C2_SCL_PORT_BASE, I2C2_SCL_GPIO_PIN_NUM);
    325                              PORT_RestoreDefault(I2C2_SDA_PORT_BASE, I2C2_SDA_GPIO_PIN_NUM);
    326                              break;
    327                          case kPinmuxType_Peripheral:
    328                              // Enable pins for I2C2.
    329                              PORT_SetI2cPinMode(I2C2_SDA_PORT_BASE, I2C2_SDA_GPIO_PIN_NUM,
    330                                                 I2C2_SDA_FUNC_ALT_MODE); // Set I2C2_SDA pin to I2C2_SDA functionality
    331                              PORT_SetI2cPinMode(I2C2_SCL_PORT_BASE, I2C2_SCL_GPIO_PIN_NUM,
    332                                                 I2C2_SCL_FUNC_ALT_MODE); // Set I2C2_SCL pin to I2C2_SCL functionality
    333                              break;
    334                          default:
    335                              break;
    336                      }
    337          #endif // #if BL_ENABLE_PINMUX_I2C2
    338          
    339                  default:
    340                      break;
    341              }
    342          }
   \                     ??i2c_pinmux_config_0: (+1)
   \                     ??i2c_pinmux_config_5: (+1)
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    343          
    344          /*!
    345           * @brief Configure pinmux for SPI module.
    346           *
    347           * This function only support switching default or gpio or fixed-ALTx mode on fixed pins
    348           * (Although there are many ALTx-pinmux configuration choices on various pins for the same
    349           * peripheral module)
    350           */

   \                                 In section .text, align 2, keep-with-next
    351          void spi_pinmux_config(uint32_t instance, pinmux_type_t pinmux)
    352          {
   \                     spi_pinmux_config: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    353              switch (instance)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD12D             BNE.N    ??spi_pinmux_config_0
    354              {
    355          #if BL_ENABLE_PINMUX_SPI0
    356                  case 0:
    357                      switch (pinmux)
   \   0000000A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD002             BEQ.N    ??spi_pinmux_config_1
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xD011             BEQ.N    ??spi_pinmux_config_2
   \   00000016   0xE025             B.N      ??spi_pinmux_config_3
    358                      {
    359                          case kPinmuxType_Default:
    360                              PORT_RestoreDefault(SPI0_PCS_PORT_BASE, SPI0_PCS_GPIO_PIN_NUM);
   \                     ??spi_pinmux_config_1: (+1)
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x....             LDR.N    R0,??DataTable8_7  ;; 0x4004c000
   \   0000001C   0x.... 0x....      BL       PORT_RestoreDefault
    361                              PORT_RestoreDefault(SPI0_SCK_PORT_BASE, SPI0_SCK_GPIO_PIN_NUM);
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x....             LDR.N    R0,??DataTable8_7  ;; 0x4004c000
   \   00000024   0x.... 0x....      BL       PORT_RestoreDefault
    362                              PORT_RestoreDefault(SPI0_SOUT_PORT_BASE, SPI0_SOUT_GPIO_PIN_NUM);
   \   00000028   0x2102             MOVS     R1,#+2
   \   0000002A   0x....             LDR.N    R0,??DataTable8_7  ;; 0x4004c000
   \   0000002C   0x.... 0x....      BL       PORT_RestoreDefault
    363                              PORT_RestoreDefault(SPI0_SIN_PORT_BASE, SPI0_SIN_GPIO_PIN_NUM);
   \   00000030   0x2103             MOVS     R1,#+3
   \   00000032   0x....             LDR.N    R0,??DataTable8_7  ;; 0x4004c000
   \   00000034   0x.... 0x....      BL       PORT_RestoreDefault
    364                              break;
   \   00000038   0xE014             B.N      ??spi_pinmux_config_4
    365                          case kPinmuxType_Peripheral:
    366                              // Enable pins for SPI0
    367                              PORT_SetSpiPinMode(SPI0_PCS_PORT_BASE, SPI0_PCS_GPIO_PIN_NUM,
    368                                                 SPI0_PCS_FUNC_ALT_MODE); // Set SPI0_PCS pin to SPI0_PCS functionality
   \                     ??spi_pinmux_config_2: (+1)
   \   0000003A   0x2202             MOVS     R2,#+2
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x....             LDR.N    R0,??DataTable8_7  ;; 0x4004c000
   \   00000040   0x.... 0x....      BL       PORT_SetSpiPinMode
    369                              PORT_SetSpiPinMode(SPI0_SCK_PORT_BASE, SPI0_SCK_GPIO_PIN_NUM,
    370                                                 SPI0_SCK_FUNC_ALT_MODE); // Set SPI0_SCK pin to SPI0_SCK functionality
   \   00000044   0x2202             MOVS     R2,#+2
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0x....             LDR.N    R0,??DataTable8_7  ;; 0x4004c000
   \   0000004A   0x.... 0x....      BL       PORT_SetSpiPinMode
    371                              PORT_SetSpiPinMode(SPI0_SOUT_PORT_BASE, SPI0_SOUT_GPIO_PIN_NUM,
    372                                                 SPI0_SOUT_FUNC_ALT_MODE); // Set SPI0_SOUT pin to SPI0_SOUT functionality
   \   0000004E   0x2202             MOVS     R2,#+2
   \   00000050   0x2102             MOVS     R1,#+2
   \   00000052   0x....             LDR.N    R0,??DataTable8_7  ;; 0x4004c000
   \   00000054   0x.... 0x....      BL       PORT_SetSpiPinMode
    373                              PORT_SetSpiPinMode(SPI0_SIN_PORT_BASE, SPI0_SIN_GPIO_PIN_NUM,
    374                                                 SPI0_SIN_FUNC_ALT_MODE); // Set SPI0_SIN pin to SPI0_SIN functionality
   \   00000058   0x2202             MOVS     R2,#+2
   \   0000005A   0x2103             MOVS     R1,#+3
   \   0000005C   0x....             LDR.N    R0,??DataTable8_7  ;; 0x4004c000
   \   0000005E   0x.... 0x....      BL       PORT_SetSpiPinMode
    375                              break;
   \   00000062   0xE7FF             B.N      ??spi_pinmux_config_4
    376                          default:
    377                              break;
    378                      }
    379                      break;
   \                     ??spi_pinmux_config_3: (+1)
   \                     ??spi_pinmux_config_4: (+1)
   \   00000064   0xE7FF             B.N      ??spi_pinmux_config_5
    380          #endif // #if BL_ENABLE_PINMUX_SPI0
    381          
    382          #if BL_ENABLE_PINMUX_SPI1
    383                  case 1:
    384                      switch (pinmux)
    385                      {
    386                          case kPinmuxType_Default:
    387                              PORT_RestoreDefault(SPI1_PCS_PORT_BASE, SPI1_PCS_GPIO_PIN_NUM);
    388                              PORT_RestoreDefault(SPI1_SCK_PORT_BASE, SPI1_SCK_GPIO_PIN_NUM);
    389                              PORT_RestoreDefault(SPI1_SOUT_PORT_BASE, SPI1_SOUT_GPIO_PIN_NUM);
    390                              PORT_RestoreDefault(SPI1_SIN_PORT_BASE, SPI1_SIN_GPIO_PIN_NUM);
    391                              break;
    392                          case kPinmuxType_Peripheral:
    393                              // Enable pins for SPI1
    394                              PORT_SetSpiPinMode(SPI1_PCS_PORT_BASE, SPI1_PCS_GPIO_PIN_NUM,
    395                                                 SPI1_PCS_FUNC_ALT_MODE); // Set SPI1_PCS pin to SPI1_PCS functionality
    396                              PORT_SetSpiPinMode(SPI1_SCK_PORT_BASE, SPI1_SCK_GPIO_PIN_NUM,
    397                                                 SPI1_SCK_FUNC_ALT_MODE); // Set SPI1_SCK pin to SPI1_SCK functionality
    398                              PORT_SetSpiPinMode(SPI1_SOUT_PORT_BASE, SPI1_SOUT_GPIO_PIN_NUM,
    399                                                 SPI1_SOUT_FUNC_ALT_MODE); // Set SPI1_SOUT pin to SPI1_SOUT functionality
    400                              PORT_SetSpiPinMode(SPI1_SIN_PORT_BASE, SPI1_SIN_GPIO_PIN_NUM,
    401                                                 SPI1_SIN_FUNC_ALT_MODE); // Set SPI1_SIN pin to SPI1_SIN functionality
    402                              break;
    403                          default:
    404                              break;
    405                      }
    406                      break;
    407          #endif // #if BL_ENABLE_PINMUX_SPI1
    408          
    409          #if BL_ENABLE_PINMUX_SPI2
    410                  case 2:
    411                      switch (pinmux)
    412                      {
    413                          case kPinmuxType_Default:
    414                              PORT_RestoreDefault(SPI2_PCS_PORT_BASE, SPI2_PCS_GPIO_PIN_NUM);
    415                              PORT_RestoreDefault(SPI2_SCK_PORT_BASE, SPI2_SCK_GPIO_PIN_NUM);
    416                              PORT_RestoreDefault(SPI2_SOUT_PORT_BASE, SPI2_SOUT_GPIO_PIN_NUM);
    417                              PORT_RestoreDefault(SPI2_SIN_PORT_BASE, SPI2_SIN_GPIO_PIN_NUM);
    418                              break;
    419                          case kPinmuxType_Peripheral:
    420                              // Enable pins for SPI1
    421                              PORT_SetSpiPinMode(SPI2_PCS_PORT_BASE, SPI2_PCS_GPIO_PIN_NUM,
    422                                                 SPI2_PCS_FUNC_ALT_MODE); // Set SPI1_PCS pin to SPI1_PCS functionality
    423                              PORT_SetSpiPinMode(SPI2_SCK_PORT_BASE, SPI2_SCK_GPIO_PIN_NUM,
    424                                                 SPI2_SCK_FUNC_ALT_MODE); // Set SPI1_SCK pin to SPI1_SCK functionality
    425                              PORT_SetSpiPinMode(SPI2_SOUT_PORT_BASE, SPI2_SOUT_GPIO_PIN_NUM,
    426                                                 SPI2_SOUT_FUNC_ALT_MODE); // Set SPI1_SOUT pin to SPI1_SOUT functionality
    427                              PORT_SetSpiPinMode(SPI2_SIN_PORT_BASE, SPI2_SIN_GPIO_PIN_NUM,
    428                                                 SPI2_SIN_FUNC_ALT_MODE); // Set SPI1_SIN pin to SPI1_SIN functionality
    429                              break;
    430                          default:
    431                              break;
    432                      }
    433                      break;
    434          #endif // #if BL_ENABLE_PINMUX_SPI2
    435          
    436                  default:
    437                      break;
    438              }
    439          }
   \                     ??spi_pinmux_config_0: (+1)
   \                     ??spi_pinmux_config_5: (+1)
   \   00000066   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    440          
    441          /*!
    442           * @brief Configure pinmux for CAN module.
    443           *
    444           * This function only support switching default or gpio or fixed-ALTx mode on fixed pins
    445           * (Although there are many ALTx-pinmux configuration choices on various pins for the same
    446           * peripheral module)
    447           */

   \                                 In section .text, align 2, keep-with-next
    448          void can_pinmux_config(uint32_t instance, pinmux_type_t pinmux)
    449          {
    450              switch (instance)
    451              {
    452          #if BL_ENABLE_PINMUX_CAN0
    453                  case 0:
    454                      switch (pinmux)
    455                      {
    456                          case kPinmuxType_Default:
    457                              PORT_RestoreDefault(CAN0_RX_PORT_BASE, CAN0_RX_GPIO_PIN_NUM);
    458                              PORT_RestoreDefault(CAN0_TX_PORT_BASE, CAN0_TX_GPIO_PIN_NUM);
    459                              break;
    460                          case kPinmuxType_Peripheral:
    461                              // Enable pins for CAN0
    462                              PORT_SetCanPinMode(CAN0_RX_PORT_BASE, CAN0_RX_GPIO_PIN_NUM,
    463                                                 CAN0_RX_FUNC_ALT_MODE); // Set CAN0_RX pin to CAN0_RX functionality
    464                              PORT_SetCanPinMode(CAN0_TX_PORT_BASE, CAN0_TX_GPIO_PIN_NUM,
    465                                                 CAN0_TX_FUNC_ALT_MODE); // Set CAN0_TX pin to CAN0_TX functionality
    466                              break;
    467                          default:
    468                              break;
    469                      }
    470                      break;
    471          #endif // #if BL_ENABLE_PINMUX_CAN0
    472          
    473                  default:
    474                      break;
    475              }
    476          }
   \                     can_pinmux_config: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    477          
    478          //! @brief this is going to be used for autobaud IRQ handling for UART0
    479          #if BL_ENABLE_PINMUX_UART0

   \                                 In section .text, align 2, keep-with-next
    480          void UART0_RX_GPIO_IRQHandler(void)
    481          {
   \                     PORTA_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    482              // Check if the pin for UART0 is what triggered the RX PORT interrupt
    483              if (PORT_GetPinIsf(UART0_RX_PORT_BASE, UART0_RX_GPIO_PIN_NUM) && s_pin_irq_func[0])
   \   00000002   0x210F             MOVS     R1,#+15
   \   00000004   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40049000
   \   00000006   0x.... 0x....      BL       PORT_GetPinIsf
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD00C             BEQ.N    ??PORTA_IRQHandler_0
   \   0000000E   0x....             LDR.N    R0,??DataTable8_8
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD008             BEQ.N    ??PORTA_IRQHandler_0
    484              {
    485                  s_pin_irq_func[0](0);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x....             LDR.N    R1,??DataTable8_8
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0x4788             BLX      R1
    486                  PORT_ClearPinsInterruptFlags(UART0_RX_PORT_BASE, ~0U);
   \   0000001E   0xF05F 0x31FF      MOVS     R1,#-1
   \   00000022   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40049000
   \   00000024   0x.... 0x....      BL       PORT_ClearPinsInterruptFlags
    487              }
    488          }
   \                     ??PORTA_IRQHandler_0: (+1)
   \   00000028   0xBD01             POP      {R0,PC}          ;; return
    489          #endif // #if BL_ENABLE_PINMUX_UART0
    490          
    491          //! @brief this is going to be used for autobaud IRQ handling for UART1
    492          #if BL_ENABLE_PINMUX_UART1
    493          void UART1_RX_GPIO_IRQHandler(void)
    494          {
    495              // Check if the pin for UART1 is what triggered the RX PORT interrupt
    496              if (PORT_GetPinIsf(UART1_RX_PORT_BASE, UART1_RX_GPIO_PIN_NUM) && s_pin_irq_func[1])
    497              {
    498                  s_pin_irq_func[1](1);
    499                  PORT_ClearPinsInterruptFlags(UART1_RX_PORT_BASE, ~0U);
    500              }
    501          }
    502          #endif // #if BL_ENABLE_PINMUX_UART1
    503          
    504          //! @brief this is going to be used for autobaud IRQ handling for UART2
    505          #if BL_ENABLE_PINMUX_UART2
    506          void UART2_RX_GPIO_IRQHandler(void)
    507          {
    508              // Check if the pin for UART2 is what triggered the RX PORT interrupt
    509              if (PORT_GetPinIsf(UART2_RX_PORT_BASE, UART2_RX_GPIO_PIN_NUM) && s_pin_irq_func[2])
    510              {
    511                  s_pin_irq_func[2](2);
    512                  PORT_ClearPinsInterruptFlags(UART2_RX_PORT_BASE, ~0U);
    513              }
    514          }
    515          #endif // #if BL_ENABLE_PINMUX_UART2
    516          
    517          //! @brief this is going to be used for autobaud IRQ handling for UART3
    518          #if BL_ENABLE_PINMUX_UART3
    519          void UART3_RX_GPIO_IRQHandler(void)
    520          {
    521              // Check if the pin for UART3 is what triggered the RX PORT interrupt
    522              if (PORT_GetPinIsf(UART3_RX_PORT_BASE, UART3_RX_GPIO_PIN_NUM) && s_pin_irq_func[3])
    523              {
    524                  s_pin_irq_func[3](3);
    525                  PORT_ClearPinsInterruptFlags(UART3_RX_PORT_BASE, ~0U);
    526              }
    527          }
    528          #endif // #if BL_ENABLE_PINMUX_UART3
    529          
    530          //! @brief this is going to be used for autobaud IRQ handling for UART4
    531          #if BL_ENABLE_PINMUX_UART4
    532          void UART4_RX_GPIO_IRQHandler(void)
    533          {
    534              // Check if the pin for UART4 is what triggered the RX PORT interrupt
    535              if (PORT_GetPinIsf(UART4_RX_PORT_BASE, UART4_RX_GPIO_PIN_NUM) && s_pin_irq_func[4])
    536              {
    537                  s_pin_irq_func[4](4);
    538                  PORT_ClearPinsInterruptFlags(UART4_RX_PORT_BASE, ~0U);
    539              }
    540          }
    541          #endif // #if BL_ENABLE_PINMUX_UART4
    542          

   \                                 In section .text, align 2, keep-with-next
    543          void enable_autobaud_pin_irq(uint32_t instance, pin_irq_callback_t func)
    544          {
   \                     enable_autobaud_pin_irq: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    545              switch (instance)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD10E             BNE.N    ??enable_autobaud_pin_irq_0
    546              {
    547          #if BL_ENABLE_PINMUX_UART0
    548                  case 0:
    549                      NVIC_SetPriority(UART0_RX_GPIO_IRQn, PORT_IRQC_INTERRUPT_ENABLED_PRIORITY);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x203B             MOVS     R0,#+59
   \   0000000E   0x.... 0x....      BL       NVIC_SetPriority
    550                      NVIC_EnableIRQ(UART0_RX_GPIO_IRQn);
   \   00000012   0x203B             MOVS     R0,#+59
   \   00000014   0x.... 0x....      BL       NVIC_EnableIRQ
    551                      // Only look for a falling edge for our interrupts
    552                      PORT_SetPinInterruptConfig(UART0_RX_PORT_BASE, UART0_RX_GPIO_PIN_NUM, kPORT_InterruptFallingEdge);
   \   00000018   0x220A             MOVS     R2,#+10
   \   0000001A   0x210F             MOVS     R1,#+15
   \   0000001C   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40049000
   \   0000001E   0x.... 0x....      BL       PORT_SetPinInterruptConfig
    553                      s_pin_irq_func[0] = func;
   \   00000022   0x....             LDR.N    R0,??DataTable8_8
   \   00000024   0x6005             STR      R5,[R0, #+0]
    554                      break;
   \   00000026   0xE7FF             B.N      ??enable_autobaud_pin_irq_1
    555          #endif // #if BL_ENABLE_PINMUX_UART0
    556          
    557          #if BL_ENABLE_PINMUX_UART1
    558                  case 1:
    559                      NVIC_SetPriority(UART1_RX_GPIO_IRQn, PORT_IRQC_INTERRUPT_ENABLED_PRIORITY);
    560                      NVIC_EnableIRQ(UART1_RX_GPIO_IRQn);
    561                      // Only look for a falling edge for our interrupts
    562                      PORT_SetPinInterruptConfig(UART1_RX_PORT_BASE, UART1_RX_GPIO_PIN_NUM, kPORT_InterruptFallingEdge);
    563                      s_pin_irq_func[1] = func;
    564                      break;
    565          #endif // #if BL_ENABLE_PINMUX_UART1
    566          
    567          #if BL_ENABLE_PINMUX_UART2
    568                  case 2:
    569                      NVIC_SetPriority(UART2_RX_GPIO_IRQn, PORT_IRQC_INTERRUPT_ENABLED_PRIORITY);
    570                      NVIC_EnableIRQ(UART2_RX_GPIO_IRQn);
    571                      // Only look for a falling edge for our interrupts
    572                      PORT_SetPinInterruptConfig(UART2_RX_PORT_BASE, UART2_RX_GPIO_PIN_NUM, kPORT_InterruptFallingEdge);
    573                      s_pin_irq_func[2] = func;
    574                      break;
    575          #endif // #if BL_ENABLE_PINMUX_UART2
    576          
    577          #if BL_ENABLE_PINMUX_UART3
    578                  case 3:
    579                      NVIC_SetPriority(UART3_RX_GPIO_IRQn, PORT_IRQC_INTERRUPT_ENABLED_PRIORITY);
    580                      NVIC_EnableIRQ(UART3_RX_GPIO_IRQn);
    581                      // Only look for a falling edge for our interrupts
    582                      PORT_SetPinInterruptConfig(UART3_RX_PORT_BASE, UART3_RX_GPIO_PIN_NUM, kPORT_InterruptFallingEdge);
    583                      s_pin_irq_func[3] = func;
    584                      break;
    585          #endif // #if BL_ENABLE_PINMUX_UART3
    586          
    587          #if BL_ENABLE_PINMUX_UART4
    588                  case 4:
    589                      NVIC_SetPriority(UART4_RX_GPIO_IRQn, PORT_IRQC_INTERRUPT_ENABLED_PRIORITY);
    590                      NVIC_EnableIRQ(UART4_RX_GPIO_IRQn);
    591                      // Only look for a falling edge for our interrupts
    592                      PORT_SetPinInterruptConfig(UART4_RX_PORT_BASE, UART4_RX_GPIO_PIN_NUM, kPORT_InterruptFallingEdge);
    593                      s_pin_irq_func[4] = func;
    594                      break;
    595          #endif // #if BL_ENABLE_PINMUX_UART4
    596          
    597                  default:
    598                      break;
    599              }
    600          }
   \                     ??enable_autobaud_pin_irq_0: (+1)
   \                     ??enable_autobaud_pin_irq_1: (+1)
   \   00000028   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    601          

   \                                 In section .text, align 2, keep-with-next
    602          void disable_autobaud_pin_irq(uint32_t instance)
    603          {
   \                     disable_autobaud_pin_irq: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    604              switch (instance)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD10F             BNE.N    ??disable_autobaud_pin_irq_0
    605              {
    606          #if BL_ENABLE_PINMUX_UART0
    607                  case 0:
    608                      NVIC_DisableIRQ(UART0_RX_GPIO_IRQn);
   \   00000008   0x203B             MOVS     R0,#+59
   \   0000000A   0x.... 0x....      BL       NVIC_DisableIRQ
    609                      NVIC_SetPriority(UART0_RX_GPIO_IRQn, PORT_IRQC_INTERRUPT_RESTORED_PRIORITY);
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x203B             MOVS     R0,#+59
   \   00000012   0x.... 0x....      BL       NVIC_SetPriority
    610                      PORT_SetPinInterruptConfig(UART0_RX_PORT_BASE, UART0_RX_GPIO_PIN_NUM, kPORT_InterruptOrDMADisabled);
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x210F             MOVS     R1,#+15
   \   0000001A   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40049000
   \   0000001C   0x.... 0x....      BL       PORT_SetPinInterruptConfig
    611                      s_pin_irq_func[0] = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR.N    R1,??DataTable8_8
   \   00000024   0x6008             STR      R0,[R1, #+0]
    612                      break;
   \   00000026   0xE7FF             B.N      ??disable_autobaud_pin_irq_1
    613          #endif // #if BL_ENABLE_PINMUX_UART0
    614          
    615          #if BL_ENABLE_PINMUX_UART1
    616                  case 1:
    617                      NVIC_DisableIRQ(UART1_RX_GPIO_IRQn);
    618                      NVIC_SetPriority(UART1_RX_GPIO_IRQn, PORT_IRQC_INTERRUPT_RESTORED_PRIORITY);
    619                      PORT_SetPinInterruptConfig(UART1_RX_PORT_BASE, UART1_RX_GPIO_PIN_NUM, kPORT_InterruptOrDMADisabled);
    620                      s_pin_irq_func[1] = 0;
    621                      break;
    622          #endif // #if BL_ENABLE_PINMUX_UART1
    623          
    624          #if BL_ENABLE_PINMUX_UART2
    625                  case 2:
    626                      NVIC_DisableIRQ(UART2_RX_GPIO_IRQn);
    627                      NVIC_SetPriority(UART2_RX_GPIO_IRQn, PORT_IRQC_INTERRUPT_RESTORED_PRIORITY);
    628                      PORT_SetPinInterruptConfig(UART2_RX_PORT_BASE, UART2_RX_GPIO_PIN_NUM, kPORT_InterruptOrDMADisabled);
    629                      s_pin_irq_func[2] = 0;
    630                      break;
    631          #endif // #if BL_ENABLE_PINMUX_UART2
    632          
    633          #if BL_ENABLE_PINMUX_UART3
    634                  case 3:
    635                      NVIC_DisableIRQ(UART3_RX_GPIO_IRQn);
    636                      NVIC_SetPriority(UART3_RX_GPIO_IRQn, PORT_IRQC_INTERRUPT_RESTORED_PRIORITY);
    637                      PORT_SetPinInterruptConfig(UART3_RX_PORT_BASE, UART3_RX_GPIO_PIN_NUM, kPORT_InterruptOrDMADisabled);
    638                      s_pin_irq_func[3] = 0;
    639                      break;
    640          #endif // #if BL_ENABLE_PINMUX_UART3
    641          
    642          #if BL_ENABLE_PINMUX_UART4
    643                  case 4:
    644                      NVIC_DisableIRQ(UART4_RX_GPIO_IRQn);
    645                      NVIC_SetPriority(UART4_RX_GPIO_IRQn, PORT_IRQC_INTERRUPT_RESTORED_PRIORITY);
    646                      PORT_SetPinInterruptConfig(UART4_RX_PORT_BASE, UART4_RX_GPIO_PIN_NUM, kPORT_InterruptOrDMADisabled);
    647                      s_pin_irq_func[4] = 0;
    648                      break;
    649          #endif // #if BL_ENABLE_PINMUX_UART4
    650          
    651                  default:
    652                      break;
    653              }
    654          }
   \                     ??disable_autobaud_pin_irq_0: (+1)
   \                     ??disable_autobaud_pin_irq_1: (+1)
   \   00000028   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0xE000ED18         DC32     0xe000ed18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0xE000E400         DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x40049000         DC32     0x40049000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x400FF000         DC32     0x400ff000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x4004B000         DC32     0x4004b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x4004C000         DC32     0x4004c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x........         DC32     s_pin_irq_func
    655          
    656          ////////////////////////////////////////////////////////////////////////////////
    657          // EOF
    658          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ
       4   NVIC_SetPriority
       8   PORTA_IRQHandler
         8   -- Indirect call
         8   -> PORT_ClearPinsInterruptFlags
         8   -> PORT_GetPinIsf
       0   PORT_ClearPinsInterruptFlags
       0   PORT_GetPinIsf
       0   PORT_RestoreDefault
       0   PORT_SetI2cPinMode
       4   PORT_SetPinInterruptConfig
       0   PORT_SetSpiPinMode
       4   PORT_SetUartAutoBaudPinMode
       0   PORT_SetUartPinMode
       0   can_pinmux_config
       8   disable_autobaud_pin_irq
         8   -> NVIC_DisableIRQ
         8   -> NVIC_SetPriority
         8   -> PORT_SetPinInterruptConfig
      16   enable_autobaud_pin_irq
        16   -> NVIC_EnableIRQ
        16   -> NVIC_SetPriority
        16   -> PORT_SetPinInterruptConfig
      16   i2c_pinmux_config
        16   -> PORT_RestoreDefault
        16   -> PORT_SetI2cPinMode
      16   spi_pinmux_config
        16   -> PORT_RestoreDefault
        16   -> PORT_SetSpiPinMode
      16   uart_pinmux_config
        16   -> PORT_RestoreDefault
        16   -> PORT_SetUartAutoBaudPinMode
        16   -> PORT_SetUartPinMode


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
      20  NVIC_DisableIRQ
      20  NVIC_EnableIRQ
      38  NVIC_SetPriority
      42  PORTA_IRQHandler
       6  PORT_ClearPinsInterruptFlags
      10  PORT_GetPinIsf
       8  PORT_RestoreDefault
      16  PORT_SetI2cPinMode
      28  PORT_SetPinInterruptConfig
      12  PORT_SetSpiPinMode
      24  PORT_SetUartAutoBaudPinMode
      12  PORT_SetUartPinMode
       2  can_pinmux_config
      42  disable_autobaud_pin_irq
      42  enable_autobaud_pin_irq
      68  i2c_pinmux_config
       4  s_pin_irq_func
     104  spi_pinmux_config
      80  uart_pinmux_config

 
   4 bytes in section .bss
 610 bytes in section .text
 
 610 bytes of CODE memory
   4 bytes of DATA memory

Errors: none
Warnings: none
