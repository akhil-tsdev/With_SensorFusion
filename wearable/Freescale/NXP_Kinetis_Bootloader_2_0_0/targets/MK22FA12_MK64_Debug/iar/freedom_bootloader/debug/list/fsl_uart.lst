###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:04
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\uart\fsl_uart.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\uart\fsl_uart.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\fsl_uart.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\fsl_uart.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\uart\fsl_uart.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "fsl_uart.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable10  ;; 0xe000e100
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_EnableClock(clock_ip_name_t)
   \                     CLOCK_EnableClock: (+1)
   \   00000000   0x0C01             LSRS     R1,R0,#+16
   \   00000002   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000006   0xF511 0x218E      ADDS     R1,R1,#+290816
   \   0000000A   0x680A             LDR      R2,[R1, #+0]
   \   0000000C   0x2301             MOVS     R3,#+1
   \   0000000E   0x4083             LSLS     R3,R3,R0
   \   00000010   0x431A             ORRS     R2,R3,R2
   \   00000012   0x600A             STR      R2,[R1, #+0]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_DisableClock(clock_ip_name_t)
   \                     CLOCK_DisableClock: (+1)
   \   00000000   0x0C01             LSRS     R1,R0,#+16
   \   00000002   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000006   0xF511 0x218E      ADDS     R1,R1,#+290816
   \   0000000A   0x680A             LDR      R2,[R1, #+0]
   \   0000000C   0x2301             MOVS     R3,#+1
   \   0000000E   0x4083             LSLS     R3,R3,R0
   \   00000010   0x439A             BICS     R2,R2,R3
   \   00000012   0x600A             STR      R2,[R1, #+0]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void EnableIRQ(IRQn_Type)
   \                     EnableIRQ: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       NVIC_EnableIRQ
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
     32          
     33          /*******************************************************************************
     34           * Definitions
     35           ******************************************************************************/
     36          
     37          /* UART transfer state. */
     38          enum _uart_tansfer_states
     39          {
     40              kUART_TxIdle, /* TX idle. */
     41              kUART_TxBusy, /* TX busy. */
     42              kUART_RxIdle, /* RX idle. */
     43              kUART_RxBusy  /* RX busy. */
     44          };
     45          
     46          /*******************************************************************************
     47           * Prototypes
     48           ******************************************************************************/
     49          
     50          /*!
     51           * @brief Get the UART instance from peripheral base address.
     52           *
     53           * @param base UART peripheral base address.
     54           * @return UART instance.
     55           */
     56          uint32_t UART_GetInstance(UART_Type *base);
     57          
     58          /*!
     59           * @brief Get the length of received data in RX ring buffer.
     60           *
     61           * @param handle UART handle pointer.
     62           * @return Length of received data in RX ring buffer.
     63           */
     64          static size_t UART_GetRxRingBufferLength(uart_handle_t *handle);
     65          
     66          /*!
     67           * @brief Check whether the RX ring buffer is full.
     68           *
     69           * @param handle UART handle pointer.
     70           * @retval true  RX ring buffer is full.
     71           * @retval false RX ring buffer is not full.
     72           */
     73          static bool UART_IsRxRingBufferFull(uart_handle_t *handle);
     74          
     75          /*!
     76           * @brief Read RX register using non-blocking method.
     77           *
     78           * This function reads data from the TX register directly, upper layer must make
     79           * sure the RX register is full or TX FIFO has data before calling this function.
     80           *
     81           * @param base UART peripheral base address.
     82           * @param data Start addresss of the buffer to store the received data.
     83           * @param length Size of the buffer.
     84           */
     85          static void UART_ReadNonBlocking(UART_Type *base, uint8_t *data, size_t length);
     86          
     87          /*!
     88           * @brief Write to TX register using non-blocking method.
     89           *
     90           * This function writes data to the TX register directly, upper layer must make
     91           * sure the TX register is empty or TX FIFO has empty room before calling this function.
     92           *
     93           * @note This function does not check whether all the data has been sent out to bus,
     94           * so before disable TX, check kUART_TransmissionCompleteFlag to ensure the TX is
     95           * finished.
     96           *
     97           * @param base UART peripheral base address.
     98           * @param data Start addresss of the data to write.
     99           * @param length Size of the buffer to be sent.
    100           */
    101          static void UART_WriteNonBlocking(UART_Type *base, const uint8_t *data, size_t length);
    102          
    103          /*******************************************************************************
    104           * Variables
    105           ******************************************************************************/
    106          /* Array of UART handle. */
    107          #if (defined(UART5))
    108          #define UART_HANDLE_ARRAY_SIZE 6
    109          #else /* UART5 */
    110          #if (defined(UART4))
    111          #define UART_HANDLE_ARRAY_SIZE 5
    112          #else /* UART4 */
    113          #if (defined(UART3))
    114          #define UART_HANDLE_ARRAY_SIZE 4
    115          #else /* UART3 */
    116          #if (defined(UART2))
    117          #define UART_HANDLE_ARRAY_SIZE 3
    118          #else /* UART2 */
    119          #if (defined(UART1))
    120          #define UART_HANDLE_ARRAY_SIZE 2
    121          #else /* UART1 */
    122          #if (defined(UART0))
    123          #define UART_HANDLE_ARRAY_SIZE 1
    124          #else /* UART0 */
    125          #error No UART instance.
    126          #endif /* UART 0 */
    127          #endif /* UART 1 */
    128          #endif /* UART 2 */
    129          #endif /* UART 3 */
    130          #endif /* UART 4 */
    131          #endif /* UART 5 */

   \                                 In section .bss, align 4
    132          static uart_handle_t *s_uartHandle[UART_HANDLE_ARRAY_SIZE];
   \                     s_uartHandle:
   \   00000000                      DS8 24
    133          /* Array of UART peripheral base address. */

   \                                 In section .rodata, align 4
    134          static UART_Type *const s_uartBases[] = UART_BASE_PTRS;
   \                     s_uartBases:
   \   00000000   0x4006A000         DC32 4006A000H, 4006B000H, 4006C000H, 4006D000H, 400EA000H, 400EB000H
   \              0x4006B000   
   \              0x4006C000   
   \              0x4006D000   
   \              0x400EA000   
   \              0x400EB000   
    135          
    136          /* Array of UART IRQ number. */

   \                                 In section .rodata, align 4
    137          static const IRQn_Type s_uartIRQ[] = UART_RX_TX_IRQS;
   \                     s_uartIRQ:
   \   00000000   0x1F 0x21          DC8 31, 33, 35, 37, 66, 68, 0, 0
   \              0x23 0x25    
   \              0x42 0x44    
   \              0x00 0x00    
    138          /* Array of UART clock name. */

   \                                 In section .rodata, align 4
    139          static const clock_ip_name_t s_uartClock[] = UART_CLOCKS;
   \                     s_uartClock:
   \   00000000   0x1034000A         DC32 271843338, 271843339, 271843340, 271843341, 271056906, 271056907
   \              0x1034000B   
   \              0x1034000C   
   \              0x1034000D   
   \              0x1028000A   
   \              0x1028000B   
    140          
    141          /*******************************************************************************
    142           * Code
    143           ******************************************************************************/
    144          

   \                                 In section .text, align 2, keep-with-next
    145          uint32_t UART_GetInstance(UART_Type *base)
    146          {
   \                     UART_GetInstance: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    147              uint32_t instance;
    148              uint32_t uartArrayCount = (sizeof(s_uartBases) / sizeof(s_uartBases[0]));
   \   00000002   0x2206             MOVS     R2,#+6
    149          
    150              /* Find the instance index from base address mappings. */
    151              for (instance = 0; instance < uartArrayCount; instance++)
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x0018             MOVS     R0,R3
   \                     ??UART_GetInstance_0: (+1)
   \   00000008   0x4290             CMP      R0,R2
   \   0000000A   0xD207             BCS.N    ??UART_GetInstance_1
    152              {
    153                  if (s_uartBases[instance] == base)
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable10_1
   \   00000010   0xF853 0x3020      LDR      R3,[R3, R0, LSL #+2]
   \   00000014   0x428B             CMP      R3,R1
   \   00000016   0xD001             BEQ.N    ??UART_GetInstance_1
    154                  {
    155                      break;
    156                  }
    157              }
   \                     ??UART_GetInstance_2: (+1)
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \   0000001A   0xE7F5             B.N      ??UART_GetInstance_0
    158          
    159              assert(instance < uartArrayCount);
    160          
    161              return instance;
   \                     ??UART_GetInstance_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
    162          }
    163          

   \                                 In section .text, align 2, keep-with-next
    164          static size_t UART_GetRxRingBufferLength(uart_handle_t *handle)
    165          {
   \                     UART_GetRxRingBufferLength: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    166              size_t size;
    167          
    168              if (handle->rxRingBufferTail > handle->rxRingBufferHead)
   \   00000002   0x8C0A             LDRH     R2,[R1, #+32]
   \   00000004   0x8C4B             LDRH     R3,[R1, #+34]
   \   00000006   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000008   0x429A             CMP      R2,R3
   \   0000000A   0xD207             BCS.N    ??UART_GetRxRingBufferLength_0
    169              {
    170                  size = (size_t)(handle->rxRingBufferHead + handle->rxRingBufferSize - handle->rxRingBufferTail);
   \   0000000C   0x8C0A             LDRH     R2,[R1, #+32]
   \   0000000E   0x69CB             LDR      R3,[R1, #+28]
   \   00000010   0xFA13 0xF282      UXTAH    R2,R3,R2
   \   00000014   0x8C4B             LDRH     R3,[R1, #+34]
   \   00000016   0x1AD2             SUBS     R2,R2,R3
   \   00000018   0x0010             MOVS     R0,R2
   \   0000001A   0xE004             B.N      ??UART_GetRxRingBufferLength_1
    171              }
    172              else
    173              {
    174                  size = (size_t)(handle->rxRingBufferHead - handle->rxRingBufferTail);
   \                     ??UART_GetRxRingBufferLength_0: (+1)
   \   0000001C   0x8C0A             LDRH     R2,[R1, #+32]
   \   0000001E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000020   0x8C4B             LDRH     R3,[R1, #+34]
   \   00000022   0x1AD2             SUBS     R2,R2,R3
   \   00000024   0x0010             MOVS     R0,R2
    175              }
    176          
    177              return size;
   \                     ??UART_GetRxRingBufferLength_1: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    178          }
    179          

   \                                 In section .text, align 2, keep-with-next
    180          static bool UART_IsRxRingBufferFull(uart_handle_t *handle)
    181          {
   \                     UART_IsRxRingBufferFull: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    182              bool full;
    183          
    184              if (UART_GetRxRingBufferLength(handle) == (handle->rxRingBufferSize - 1U))
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       UART_GetRxRingBufferLength
   \   0000000A   0x69E1             LDR      R1,[R4, #+28]
   \   0000000C   0x1E49             SUBS     R1,R1,#+1
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xD102             BNE.N    ??UART_IsRxRingBufferFull_0
    185              {
    186                  full = true;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x0005             MOVS     R5,R0
   \   00000016   0xE001             B.N      ??UART_IsRxRingBufferFull_1
    187              }
    188              else
    189              {
    190                  full = false;
   \                     ??UART_IsRxRingBufferFull_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0005             MOVS     R5,R0
    191              }
    192          
    193              return full;
   \                     ??UART_IsRxRingBufferFull_1: (+1)
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    194          }
    195          

   \                                 In section .text, align 2, keep-with-next
    196          status_t UART_Init(UART_Type *base, const uart_config_t *config, uint32_t srcClock_Hz)
    197          {
   \                     UART_Init: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    198              assert(config);
    199              assert(config->baudRate_Bps);
    200          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    201              assert(FSL_FEATURE_UART_FIFO_SIZEn(base) >= config->txFifoWatermark);
    202              assert(FSL_FEATURE_UART_FIFO_SIZEn(base) >= config->rxFifoWatermark);
    203          #endif
    204          
    205              uint16_t sbr = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    206              uint8_t temp = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    207              uint32_t baudDiff = 0;
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
    208          
    209              /* Calculate the baud rate modulo divisor, sbr*/
    210              sbr = srcClock_Hz / (config->baudRate_Bps * 16);
   \   00000014   0x6828             LDR      R0,[R5, #+0]
   \   00000016   0x0100             LSLS     R0,R0,#+4
   \   00000018   0xFBB6 0xF0F0      UDIV     R0,R6,R0
   \   0000001C   0x0007             MOVS     R7,R0
    211              /* set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate */
    212              if (sbr == 0)
   \   0000001E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000020   0x2F00             CMP      R7,#+0
   \   00000022   0xD101             BNE.N    ??UART_Init_0
    213              {
    214                  sbr = 1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x0007             MOVS     R7,R0
    215              }
    216              
    217          #if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
    218              /* Determine if a fractional divider is needed to fine tune closer to the
    219               * desired baud, each value of brfa is in 1/32 increments,
    220               * hence the multiply-by-32. */
    221              uint16_t brfa = (32 * srcClock_Hz / (config->baudRate_Bps * 16)) - 32 * sbr;
   \                     ??UART_Init_0: (+1)
   \   00000028   0x0170             LSLS     R0,R6,#+5
   \   0000002A   0x6829             LDR      R1,[R5, #+0]
   \   0000002C   0x0109             LSLS     R1,R1,#+4
   \   0000002E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000032   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000034   0xEBB0 0x1A47      SUBS     R10,R0,R7, LSL #+5
    222          
    223              /* Calculate the baud rate based on the temporary SBR values and BRFA */
    224              baudDiff = (srcClock_Hz*2 / ((sbr*32 + brfa))) - config->baudRate_Bps;
   \   00000038   0x0070             LSLS     R0,R6,#+1
   \   0000003A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000003C   0x0179             LSLS     R1,R7,#+5
   \   0000003E   0xFA11 0xF18A      UXTAH    R1,R1,R10
   \   00000042   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000046   0x6829             LDR      R1,[R5, #+0]
   \   00000048   0x1A40             SUBS     R0,R0,R1
   \   0000004A   0x4681             MOV      R9,R0
    225          
    226          #else
    227              /* Calculate the baud rate based on the temporary SBR values */
    228              baudDiff = (srcClock_Hz / (sbr * 16)) - config->baudRate_Bps;
    229          
    230              /* Select the better value between sbr and (sbr + 1) */
    231              if (baudDiff > (config->baudRate_Bps - (srcClock_Hz / (16 * (sbr + 1)))))
    232              {
    233                  baudDiff = config->baudRate_Bps - (srcClock_Hz / (16 * (sbr + 1)));
    234                  sbr++;
    235              }
    236          #endif
    237              
    238              /* next, check to see if actual baud rate is within 3% of desired baud rate
    239               * based on the calculate SBR value */
    240              if (baudDiff > ((config->baudRate_Bps / 100) * 3))
   \   0000004C   0x6828             LDR      R0,[R5, #+0]
   \   0000004E   0x2164             MOVS     R1,#+100
   \   00000050   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000054   0x2103             MOVS     R1,#+3
   \   00000056   0x4348             MULS     R0,R1,R0
   \   00000058   0x4548             CMP      R0,R9
   \   0000005A   0xD202             BCS.N    ??UART_Init_1
    241              {
    242                  /* Unacceptable baud rate difference of more than 3%*/
    243                  return kStatus_UART_BaudrateNotSupport;
   \   0000005C   0xF240 0x30F5      MOVW     R0,#+1013
   \   00000060   0xE041             B.N      ??UART_Init_2
    244              }
    245          
    246              /* Enable uart clock */
    247              CLOCK_EnableClock(s_uartClock[UART_GetInstance(base)]);
   \                     ??UART_Init_1: (+1)
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0x.... 0x....      BL       UART_GetInstance
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   0000006C   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000070   0x.... 0x....      BL       CLOCK_EnableClock
    248          
    249              /* Disable UART TX RX before setting. */
    250              base->C2 &= ~(UART_C2_TE_MASK | UART_C2_RE_MASK);
   \   00000074   0x78E0             LDRB     R0,[R4, #+3]
   \   00000076   0xF010 0x00F3      ANDS     R0,R0,#0xF3
   \   0000007A   0x70E0             STRB     R0,[R4, #+3]
    251          
    252              /* Write the sbr value to the BDH and BDL registers*/
    253              base->BDH = (base->BDH & ~UART_BDH_SBR_MASK) | (uint8_t)(sbr >> 8);
   \   0000007C   0x7820             LDRB     R0,[R4, #+0]
   \   0000007E   0xF010 0x01E0      ANDS     R1,R0,#0xE0
   \   00000082   0x0038             MOVS     R0,R7
   \   00000084   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000086   0x0A00             LSRS     R0,R0,#+8
   \   00000088   0x4308             ORRS     R0,R0,R1
   \   0000008A   0x7020             STRB     R0,[R4, #+0]
    254              base->BDL = (uint8_t)sbr;
   \   0000008C   0x7067             STRB     R7,[R4, #+1]
    255          
    256          #if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
    257              /* Write the brfa value to the register*/
    258              base->C4 = (base->C4 & ~UART_C4_BRFA_MASK) | (brfa & UART_C4_BRFA_MASK);
   \   0000008E   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000090   0xF010 0x00E0      ANDS     R0,R0,#0xE0
   \   00000094   0xF01A 0x011F      ANDS     R1,R10,#0x1F
   \   00000098   0x4308             ORRS     R0,R1,R0
   \   0000009A   0x72A0             STRB     R0,[R4, #+10]
    259          #endif
    260          
    261              /* Set bit count */
    262              temp = base->C1 & ~UART_C1_M_MASK;
   \   0000009C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000009E   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   000000A2   0x4680             MOV      R8,R0
    263          
    264              /* Set parity mode */
    265              temp = temp & ~(UART_C1_PE_MASK | UART_C1_PT_MASK);
   \   000000A4   0xF018 0x08FC      ANDS     R8,R8,#0xFC
    266              base->C1 = temp | (uint8_t)config->parityMode;
   \   000000A8   0x7928             LDRB     R0,[R5, #+4]
   \   000000AA   0xEA50 0x0008      ORRS     R0,R0,R8
   \   000000AE   0x70A0             STRB     R0,[R4, #+2]
    267          
    268          #if defined(FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT
    269              /* Set stop bit per char */
    270              base->BDH = (base->BDH & ~UART_BDH_SBNS_MASK) | UART_BDH_SBNS((uint8_t)config->stopBitCount);
    271          #endif
    272          
    273          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    274              /* Set tx/rx FIFO watermark */
    275              base->TWFIFO = config->txFifoWatermark;
   \   000000B0   0x7968             LDRB     R0,[R5, #+5]
   \   000000B2   0x74E0             STRB     R0,[R4, #+19]
    276              base->RWFIFO = config->rxFifoWatermark;
   \   000000B4   0x79A8             LDRB     R0,[R5, #+6]
   \   000000B6   0x7560             STRB     R0,[R4, #+21]
    277          
    278              /* Enable tx/rx FIFO */
    279              base->PFIFO |= (UART_PFIFO_TXFE_MASK | UART_PFIFO_RXFE_MASK);
   \   000000B8   0x7C20             LDRB     R0,[R4, #+16]
   \   000000BA   0xF050 0x0088      ORRS     R0,R0,#0x88
   \   000000BE   0x7420             STRB     R0,[R4, #+16]
    280          
    281              /* Flush FIFO */
    282              base->CFIFO |= (UART_CFIFO_TXFLUSH_MASK | UART_CFIFO_RXFLUSH_MASK);
   \   000000C0   0x7C60             LDRB     R0,[R4, #+17]
   \   000000C2   0xF050 0x00C0      ORRS     R0,R0,#0xC0
   \   000000C6   0x7460             STRB     R0,[R4, #+17]
    283          #endif
    284          
    285              /* Enable TX/RX base on configure structure. */
    286              temp = base->C2;
   \   000000C8   0x78E0             LDRB     R0,[R4, #+3]
   \   000000CA   0x4680             MOV      R8,R0
    287          
    288              if (config->enableTx)
   \   000000CC   0x79E8             LDRB     R0,[R5, #+7]
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD001             BEQ.N    ??UART_Init_3
    289              {
    290                  temp |= UART_C2_TE_MASK;
   \   000000D2   0xF058 0x0808      ORRS     R8,R8,#0x8
    291              }
    292          
    293              if (config->enableRx)
   \                     ??UART_Init_3: (+1)
   \   000000D6   0x7A28             LDRB     R0,[R5, #+8]
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD001             BEQ.N    ??UART_Init_4
    294              {
    295                  temp |= UART_C2_RE_MASK;
   \   000000DC   0xF058 0x0804      ORRS     R8,R8,#0x4
    296              }
    297          
    298              base->C2 = temp;
   \                     ??UART_Init_4: (+1)
   \   000000E0   0xF884 0x8003      STRB     R8,[R4, #+3]
    299          
    300              return kStatus_Success;
   \   000000E4   0x2000             MOVS     R0,#+0
   \                     ??UART_Init_2: (+1)
   \   000000E6   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    301          }
    302          

   \                                 In section .text, align 2, keep-with-next
    303          void UART_Deinit(UART_Type *base)
    304          {
   \                     UART_Deinit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    305          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    306              /* Wait tx FIFO send out*/
    307              while (0 != base->TCFIFO)
   \                     ??UART_Deinit_0: (+1)
   \   00000004   0x7D20             LDRB     R0,[R4, #+20]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD1FC             BNE.N    ??UART_Deinit_0
    308              {
    309              }
    310          #endif
    311              /* Wait last char shoft out */
    312              while (0 == (base->S1 & UART_S1_TC_MASK))
   \                     ??UART_Deinit_1: (+1)
   \   0000000A   0x7920             LDRB     R0,[R4, #+4]
   \   0000000C   0x0640             LSLS     R0,R0,#+25
   \   0000000E   0xD5FC             BPL.N    ??UART_Deinit_1
    313              {
    314              }
    315          
    316              /* Disable the module. */
    317              base->C2 = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x70E0             STRB     R0,[R4, #+3]
    318          
    319              /* Disable uart clock */
    320              CLOCK_DisableClock(s_uartClock[UART_GetInstance(base)]);
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       UART_GetInstance
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   0000001E   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000022   0x.... 0x....      BL       CLOCK_DisableClock
    321          }
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    322          

   \                                 In section .text, align 2, keep-with-next
    323          void UART_GetDefaultConfig(uart_config_t *config)
    324          {
    325              assert(config);
    326          
    327              config->baudRate_Bps = 115200U;
   \                     UART_GetDefaultConfig: (+1)
   \   00000000   0xF45F 0x31E1      MOVS     R1,#+115200
   \   00000004   0x6001             STR      R1,[R0, #+0]
    328              config->parityMode = kUART_ParityDisabled;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x7101             STRB     R1,[R0, #+4]
    329          #if defined(FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT
    330              config->stopBitCount = kUART_OneStopBit;
    331          #endif
    332          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    333              config->txFifoWatermark = 0;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x7141             STRB     R1,[R0, #+5]
    334              config->rxFifoWatermark = 1;
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x7181             STRB     R1,[R0, #+6]
    335          #endif
    336              config->enableTx = false;
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x71C1             STRB     R1,[R0, #+7]
    337              config->enableRx = false;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x7201             STRB     R1,[R0, #+8]
    338          }
   \   0000001A   0x4770             BX       LR               ;; return
    339          

   \                                 In section .text, align 2, keep-with-next
    340          status_t UART_SetBaudRate(UART_Type *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz)
    341          {
   \                     UART_SetBaudRate: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0003             MOVS     R3,R0
    342              assert(baudRate_Bps);
    343          
    344              uint16_t sbr = 0;
   \   00000004   0x2400             MOVS     R4,#+0
    345              uint32_t baudDiff = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    346              uint8_t oldCtrl;
    347          
    348              /* Calculate the baud rate modulo divisor, sbr*/
    349              sbr = srcClock_Hz / (baudRate_Bps * 16);
   \   00000008   0x0108             LSLS     R0,R1,#+4
   \   0000000A   0xFBB2 0xF0F0      UDIV     R0,R2,R0
   \   0000000E   0x0004             MOVS     R4,R0
    350              /* set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate */
    351              if (sbr == 0)
   \   00000010   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD101             BNE.N    ??UART_SetBaudRate_0
    352              {
    353                  sbr = 1;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x0004             MOVS     R4,R0
    354              }
    355              
    356          #if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
    357              /* Determine if a fractional divider is needed to fine tune closer to the
    358               * desired baud, each value of brfa is in 1/32 increments,
    359               * hence the multiply-by-32. */
    360              uint16_t brfa = (32 * srcClock_Hz / (baudRate_Bps * 16)) - 32 * sbr;
   \                     ??UART_SetBaudRate_0: (+1)
   \   0000001A   0x0150             LSLS     R0,R2,#+5
   \   0000001C   0x010F             LSLS     R7,R1,#+4
   \   0000001E   0xFBB0 0xF0F7      UDIV     R0,R0,R7
   \   00000022   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000024   0xEBB0 0x1744      SUBS     R7,R0,R4, LSL #+5
    361          
    362              /* Calculate the baud rate based on the temporary SBR values and BRFA */
    363              baudDiff = (srcClock_Hz*2 / ((sbr*32 + brfa))) - baudRate_Bps;
   \   00000028   0x0050             LSLS     R0,R2,#+1
   \   0000002A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000002C   0xEA5F 0x1C44      LSLS     R12,R4,#+5
   \   00000030   0xFA1C 0xFC87      UXTAH    R12,R12,R7
   \   00000034   0xFBB0 0xF0FC      UDIV     R0,R0,R12
   \   00000038   0x1A40             SUBS     R0,R0,R1
   \   0000003A   0x0005             MOVS     R5,R0
    364          
    365          #else    
    366              /* Calculate the baud rate based on the temporary SBR values */
    367              baudDiff = (srcClock_Hz / (sbr * 16)) - baudRate_Bps;
    368          
    369              /* Select the better value between sbr and (sbr + 1) */
    370              if (baudDiff > (baudRate_Bps - (srcClock_Hz / (16 * (sbr + 1)))))
    371              {
    372                  baudDiff = baudRate_Bps - (srcClock_Hz / (16 * (sbr + 1)));
    373                  sbr++;
    374              }
    375          #endif
    376              
    377              /* next, check to see if actual baud rate is within 3% of desired baud rate
    378               * based on the calculate SBR value */
    379              if (baudDiff < ((baudRate_Bps / 100) * 3))
   \   0000003C   0x2064             MOVS     R0,#+100
   \   0000003E   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \   00000042   0xF05F 0x0C03      MOVS     R12,#+3
   \   00000046   0xFB0C 0xF000      MUL      R0,R12,R0
   \   0000004A   0x4285             CMP      R5,R0
   \   0000004C   0xD21A             BCS.N    ??UART_SetBaudRate_1
    380              {
    381                  /* Store C2 before disable Tx and Rx */
    382                  oldCtrl = base->C2;
   \   0000004E   0x78D8             LDRB     R0,[R3, #+3]
   \   00000050   0x0006             MOVS     R6,R0
    383          
    384                  /* Disable UART TX RX before setting. */
    385                  base->C2 &= ~(UART_C2_TE_MASK | UART_C2_RE_MASK);
   \   00000052   0x78D8             LDRB     R0,[R3, #+3]
   \   00000054   0xF010 0x00F3      ANDS     R0,R0,#0xF3
   \   00000058   0x70D8             STRB     R0,[R3, #+3]
    386          
    387                  /* Write the sbr value to the BDH and BDL registers*/
    388                  base->BDH = (base->BDH & ~UART_BDH_SBR_MASK) | (uint8_t)(sbr >> 8);
   \   0000005A   0x7818             LDRB     R0,[R3, #+0]
   \   0000005C   0xF010 0x0CE0      ANDS     R12,R0,#0xE0
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000064   0x0A00             LSRS     R0,R0,#+8
   \   00000066   0xEA50 0x000C      ORRS     R0,R0,R12
   \   0000006A   0x7018             STRB     R0,[R3, #+0]
    389                  base->BDL = (uint8_t)sbr;
   \   0000006C   0x705C             STRB     R4,[R3, #+1]
    390          
    391          #if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
    392                  /* Write the brfa value to the register*/
    393                  base->C4 = (base->C4 & ~UART_C4_BRFA_MASK) | (brfa & UART_C4_BRFA_MASK);
   \   0000006E   0x7A98             LDRB     R0,[R3, #+10]
   \   00000070   0xF010 0x00E0      ANDS     R0,R0,#0xE0
   \   00000074   0xF017 0x0C1F      ANDS     R12,R7,#0x1F
   \   00000078   0xEA5C 0x0000      ORRS     R0,R12,R0
   \   0000007C   0x7298             STRB     R0,[R3, #+10]
    394          #endif
    395                  /* Restore C2. */
    396                  base->C2 = oldCtrl;
   \   0000007E   0x70DE             STRB     R6,[R3, #+3]
    397          
    398                  return kStatus_Success;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xE001             B.N      ??UART_SetBaudRate_2
    399              }
    400              else
    401              {
    402                  /* Unacceptable baud rate difference of more than 3%*/
    403                  return kStatus_UART_BaudrateNotSupport;
   \                     ??UART_SetBaudRate_1: (+1)
   \   00000084   0xF240 0x30F5      MOVW     R0,#+1013
   \                     ??UART_SetBaudRate_2: (+1)
   \   00000088   0xBCF0             POP      {R4-R7}
   \   0000008A   0x4770             BX       LR               ;; return
    404              }
    405          }
    406          

   \                                 In section .text, align 2, keep-with-next
    407          void UART_EnableInterrupts(UART_Type *base, uint32_t mask)
    408          {
    409              /* The interrupt mask is combined by control bits from several register: ((CFIFO<<24) | (C3<<16) | (C2<<8) |(BDH))
    410               */
    411              base->BDH |= (mask & 0xFF);
   \                     UART_EnableInterrupts: (+1)
   \   00000000   0x7802             LDRB     R2,[R0, #+0]
   \   00000002   0x430A             ORRS     R2,R1,R2
   \   00000004   0x7002             STRB     R2,[R0, #+0]
    412              base->C2 |= ((mask >> 8) & 0xFF);
   \   00000006   0x78C2             LDRB     R2,[R0, #+3]
   \   00000008   0x0A0B             LSRS     R3,R1,#+8
   \   0000000A   0x431A             ORRS     R2,R3,R2
   \   0000000C   0x70C2             STRB     R2,[R0, #+3]
    413              base->C3 |= ((mask >> 16) & 0xFF);
   \   0000000E   0x7982             LDRB     R2,[R0, #+6]
   \   00000010   0x0C0B             LSRS     R3,R1,#+16
   \   00000012   0x431A             ORRS     R2,R3,R2
   \   00000014   0x7182             STRB     R2,[R0, #+6]
    414          
    415          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    416              base->CFIFO |= ((mask >> 24) & 0xFF);
   \   00000016   0x7C42             LDRB     R2,[R0, #+17]
   \   00000018   0x0E0B             LSRS     R3,R1,#+24
   \   0000001A   0x431A             ORRS     R2,R3,R2
   \   0000001C   0x7442             STRB     R2,[R0, #+17]
    417          #endif
    418          }
   \   0000001E   0x4770             BX       LR               ;; return
    419          

   \                                 In section .text, align 2, keep-with-next
    420          void UART_DisableInterrupts(UART_Type *base, uint32_t mask)
    421          {
    422              /* The interrupt mask is combined by control bits from several register: ((CFIFO<<24) | (C3<<16) | (C2<<8) |(BDH))
    423               */
    424              base->BDH &= ~(mask & 0xFF);
   \                     UART_DisableInterrupts: (+1)
   \   00000000   0x7802             LDRB     R2,[R0, #+0]
   \   00000002   0x438A             BICS     R2,R2,R1
   \   00000004   0x7002             STRB     R2,[R0, #+0]
    425              base->C2 &= ~((mask >> 8) & 0xFF);
   \   00000006   0x78C2             LDRB     R2,[R0, #+3]
   \   00000008   0x0A0B             LSRS     R3,R1,#+8
   \   0000000A   0x439A             BICS     R2,R2,R3
   \   0000000C   0x70C2             STRB     R2,[R0, #+3]
    426              base->C3 &= ~((mask >> 16) & 0xFF);
   \   0000000E   0x7982             LDRB     R2,[R0, #+6]
   \   00000010   0x0C0B             LSRS     R3,R1,#+16
   \   00000012   0x439A             BICS     R2,R2,R3
   \   00000014   0x7182             STRB     R2,[R0, #+6]
    427          
    428          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    429              base->CFIFO &= ~((mask >> 24) & 0xFF);
   \   00000016   0x7C42             LDRB     R2,[R0, #+17]
   \   00000018   0x0E0B             LSRS     R3,R1,#+24
   \   0000001A   0x439A             BICS     R2,R2,R3
   \   0000001C   0x7442             STRB     R2,[R0, #+17]
    430          #endif
    431          }
   \   0000001E   0x4770             BX       LR               ;; return
    432          

   \                                 In section .text, align 2, keep-with-next
    433          uint32_t UART_GetEnabledInterrupts(UART_Type *base)
    434          {
   \                     UART_GetEnabledInterrupts: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    435              uint32_t temp;
    436          
    437              temp = base->BDH | ((uint32_t)(base->C2) << 8) | ((uint32_t)(base->C3) << 16);
   \   00000002   0x780A             LDRB     R2,[R1, #+0]
   \   00000004   0x78CB             LDRB     R3,[R1, #+3]
   \   00000006   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000000A   0xEA52 0x2203      ORRS     R2,R2,R3, LSL #+8
   \   0000000E   0x798B             LDRB     R3,[R1, #+6]
   \   00000010   0xEA52 0x4203      ORRS     R2,R2,R3, LSL #+16
   \   00000014   0x0010             MOVS     R0,R2
    438          
    439          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    440              temp |= ((uint32_t)(base->CFIFO) << 24);
   \   00000016   0x7C4A             LDRB     R2,[R1, #+17]
   \   00000018   0xEA50 0x6002      ORRS     R0,R0,R2, LSL #+24
    441          #endif
    442          
    443              return temp;
   \   0000001C   0x4770             BX       LR               ;; return
    444          }
    445          

   \                                 In section .text, align 2, keep-with-next
    446          uint32_t UART_GetStatusFlags(UART_Type *base)
    447          {
   \                     UART_GetStatusFlags: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    448              uint32_t status_flag;
    449          
    450              status_flag = base->S1 | ((uint32_t)(base->S2) << 8);
   \   00000002   0x790A             LDRB     R2,[R1, #+4]
   \   00000004   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000006   0x794B             LDRB     R3,[R1, #+5]
   \   00000008   0xEA52 0x2203      ORRS     R2,R2,R3, LSL #+8
   \   0000000C   0x0010             MOVS     R0,R2
    451          
    452          #if defined(FSL_FEATURE_UART_HAS_EXTENDED_DATA_REGISTER_FLAGS) && FSL_FEATURE_UART_HAS_EXTENDED_DATA_REGISTER_FLAGS
    453              status_flag |= ((uint32_t)(base->ED) << 16);
   \   0000000E   0x7B0A             LDRB     R2,[R1, #+12]
   \   00000010   0xEA50 0x4002      ORRS     R0,R0,R2, LSL #+16
    454          #endif
    455          
    456          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    457              status_flag |= ((uint32_t)(base->SFIFO) << 24);
   \   00000014   0x7C8A             LDRB     R2,[R1, #+18]
   \   00000016   0xEA50 0x6002      ORRS     R0,R0,R2, LSL #+24
    458          #endif
    459          
    460              return status_flag;
   \   0000001A   0x4770             BX       LR               ;; return
    461          }
    462          

   \                                 In section .text, align 2, keep-with-next
    463          status_t UART_ClearStatusFlags(UART_Type *base, uint32_t mask)
    464          {
   \                     UART_ClearStatusFlags: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    465              uint8_t reg = base->S2;
   \   00000006   0x7967             LDRB     R7,[R4, #+5]
    466              status_t status;
    467          
    468          #if defined(FSL_FEATURE_UART_HAS_LIN_BREAK_DETECT) && FSL_FEATURE_UART_HAS_LIN_BREAK_DETECT
    469              reg &= ~(UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK);
   \   00000008   0xF017 0x073F      ANDS     R7,R7,#0x3F
    470          #else
    471              reg &= ~UART_S2_RXEDGIF_MASK;
    472          #endif
    473          
    474              base->S2 = reg | (uint8_t)(mask >> 8);
   \   0000000C   0x0A28             LSRS     R0,R5,#+8
   \   0000000E   0x4338             ORRS     R0,R0,R7
   \   00000010   0x7160             STRB     R0,[R4, #+5]
    475          
    476          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    477              base->SFIFO = (uint8_t)(mask >> 24);
   \   00000012   0x0E28             LSRS     R0,R5,#+24
   \   00000014   0x74A0             STRB     R0,[R4, #+18]
    478          #endif
    479          
    480              if (mask & (kUART_IdleLineFlag | kUART_RxOverrunFlag | kUART_NoiseErrorFlag | kUART_FramingErrorFlag |
    481                          kUART_ParityErrorFlag))
   \   00000016   0xF015 0x0F1F      TST      R5,#0x1F
   \   0000001A   0xD001             BEQ.N    ??UART_ClearStatusFlags_0
    482              {
    483                  /* Read base->D to clear the flags. */
    484                  (void)base->S1;
   \   0000001C   0x7920             LDRB     R0,[R4, #+4]
    485                  (void)base->D;
   \   0000001E   0x79E0             LDRB     R0,[R4, #+7]
    486              }
    487          
    488              /* If some flags still pending. */
    489              if (mask & UART_GetStatusFlags(base))
   \                     ??UART_ClearStatusFlags_0: (+1)
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       UART_GetStatusFlags
   \   00000026   0x4205             TST      R5,R0
   \   00000028   0xD003             BEQ.N    ??UART_ClearStatusFlags_1
    490              {
    491                  /* Some flags can only clear or set by the hardware itself, these flags are: kUART_TxDataRegEmptyFlag,
    492                  kUART_TransmissionCompleteFlag, kUART_RxDataRegFullFlag, kUART_RxActiveFlag, kUART_NoiseErrorInRxDataRegFlag,
    493                  kUART_ParityErrorInRxDataRegFlag, kUART_TxFifoEmptyFlag, kUART_RxFifoEmptyFlag. */
    494                  status = kStatus_UART_FlagCannotClearManually;
   \   0000002A   0xF240 0x30EE      MOVW     R0,#+1006
   \   0000002E   0x0006             MOVS     R6,R0
   \   00000030   0xE001             B.N      ??UART_ClearStatusFlags_2
    495              }
    496              else
    497              {
    498                  status = kStatus_Success;
   \                     ??UART_ClearStatusFlags_1: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x0006             MOVS     R6,R0
    499              }
    500          
    501              return status;
   \                     ??UART_ClearStatusFlags_2: (+1)
   \   00000036   0x0030             MOVS     R0,R6
   \   00000038   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    502          }
    503          

   \                                 In section .text, align 2, keep-with-next
    504          void UART_WriteBlocking(UART_Type *base, const uint8_t *data, size_t length)
    505          {
    506              /* This API can only ensure that the data is written into the data buffer but can't
    507              ensure all data in the data buffer are sent into the transmit shift buffer. */
    508              while (length--)
   \                     UART_WriteBlocking: (+1)
   \                     ??UART_WriteBlocking_0: (+1)
   \   00000000   0x0013             MOVS     R3,R2
   \   00000002   0x1E5A             SUBS     R2,R3,#+1
   \   00000004   0x2B00             CMP      R3,#+0
   \   00000006   0xD006             BEQ.N    ??UART_WriteBlocking_1
    509              {
    510                  while (!(base->S1 & UART_S1_TDRE_MASK))
   \                     ??UART_WriteBlocking_2: (+1)
   \   00000008   0x7903             LDRB     R3,[R0, #+4]
   \   0000000A   0x061B             LSLS     R3,R3,#+24
   \   0000000C   0xD5FC             BPL.N    ??UART_WriteBlocking_2
    511                  {
    512                  }
    513                  base->D = *(data++);
   \   0000000E   0x780B             LDRB     R3,[R1, #+0]
   \   00000010   0x71C3             STRB     R3,[R0, #+7]
   \   00000012   0x1C49             ADDS     R1,R1,#+1
   \   00000014   0xE7F4             B.N      ??UART_WriteBlocking_0
    514              }
    515          }
   \                     ??UART_WriteBlocking_1: (+1)
   \   00000016   0x4770             BX       LR               ;; return
    516          

   \                                 In section .text, align 2, keep-with-next
    517          static void UART_WriteNonBlocking(UART_Type *base, const uint8_t *data, size_t length)
    518          {
   \                     UART_WriteNonBlocking: (+1)
   \   00000000   0xB410             PUSH     {R4}
    519              /* The Non Blocking write data API assume user have ensured there is enough space in
    520              peripheral to write. */
    521              for (size_t i = 0; i < length; i++)
   \   00000002   0x2300             MOVS     R3,#+0
   \                     ??UART_WriteNonBlocking_0: (+1)
   \   00000004   0x4293             CMP      R3,R2
   \   00000006   0xD203             BCS.N    ??UART_WriteNonBlocking_1
    522              {
    523                  base->D = data[i];
   \   00000008   0x5CCC             LDRB     R4,[R1, R3]
   \   0000000A   0x71C4             STRB     R4,[R0, #+7]
    524              }
   \   0000000C   0x1C5B             ADDS     R3,R3,#+1
   \   0000000E   0xE7F9             B.N      ??UART_WriteNonBlocking_0
    525          }
   \                     ??UART_WriteNonBlocking_1: (+1)
   \   00000010   0xBC10             POP      {R4}
   \   00000012   0x4770             BX       LR               ;; return
    526          

   \                                 In section .text, align 2, keep-with-next
    527          void UART_ReadBlocking(UART_Type *base, uint8_t *data, size_t length)
    528          {
    529              while (length--)
   \                     UART_ReadBlocking: (+1)
   \                     ??UART_ReadBlocking_0: (+1)
   \   00000000   0x0013             MOVS     R3,R2
   \   00000002   0x1E5A             SUBS     R2,R3,#+1
   \   00000004   0x2B00             CMP      R3,#+0
   \   00000006   0xD006             BEQ.N    ??UART_ReadBlocking_1
    530              {
    531          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    532                  while (!base->RCFIFO)
   \                     ??UART_ReadBlocking_2: (+1)
   \   00000008   0x7D83             LDRB     R3,[R0, #+22]
   \   0000000A   0x2B00             CMP      R3,#+0
   \   0000000C   0xD0FC             BEQ.N    ??UART_ReadBlocking_2
    533          #else
    534                  while (!(base->S1 & UART_S1_RDRF_MASK))
    535          #endif
    536                  {
    537                  }
    538                  *(data++) = base->D;
   \   0000000E   0x79C3             LDRB     R3,[R0, #+7]
   \   00000010   0x700B             STRB     R3,[R1, #+0]
   \   00000012   0x1C49             ADDS     R1,R1,#+1
   \   00000014   0xE7F4             B.N      ??UART_ReadBlocking_0
    539              }
    540          }
   \                     ??UART_ReadBlocking_1: (+1)
   \   00000016   0x4770             BX       LR               ;; return
    541          

   \                                 In section .text, align 2, keep-with-next
    542          static void UART_ReadNonBlocking(UART_Type *base, uint8_t *data, size_t length)
    543          {
   \                     UART_ReadNonBlocking: (+1)
   \   00000000   0xB410             PUSH     {R4}
    544              /* The Non Blocking read data API assume user have ensured there is enough space in
    545              peripheral to write. */
    546              for (size_t i = 0; i < length; i++)
   \   00000002   0x2300             MOVS     R3,#+0
   \                     ??UART_ReadNonBlocking_0: (+1)
   \   00000004   0x4293             CMP      R3,R2
   \   00000006   0xD203             BCS.N    ??UART_ReadNonBlocking_1
    547              {
    548                  data[i] = base->D;
   \   00000008   0x79C4             LDRB     R4,[R0, #+7]
   \   0000000A   0x54CC             STRB     R4,[R1, R3]
    549              }
   \   0000000C   0x1C5B             ADDS     R3,R3,#+1
   \   0000000E   0xE7F9             B.N      ??UART_ReadNonBlocking_0
    550          }
   \                     ??UART_ReadNonBlocking_1: (+1)
   \   00000010   0xBC10             POP      {R4}
   \   00000012   0x4770             BX       LR               ;; return
    551          

   \                                 In section .text, align 2, keep-with-next
    552          void UART_CreateHandle(UART_Type *base, uart_handle_t *handle, uart_transfer_callback_t callback, void *userData)
    553          {
   \                     UART_CreateHandle: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    554              assert(handle);
    555          
    556              uint32_t instance;
    557          
    558              /* Zero the handle. */
    559              memset(handle, 0, sizeof(*handle));
   \   0000000C   0xF05F 0x0930      MOVS     R9,#+48
   \   00000010   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000014   0x4652             MOV      R2,R10
   \   00000016   0x4649             MOV      R1,R9
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       __aeabi_memset
    560          
    561              /* Set the TX/RX state. */
    562              handle->rxState = kUART_RxIdle;
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xF885 0x002D      STRB     R0,[R5, #+45]
    563              handle->txState = kUART_TxIdle;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF885 0x002C      STRB     R0,[R5, #+44]
    564          
    565              /* Set the callback and user data. */
    566              handle->callback = callback;
   \   0000002A   0x626E             STR      R6,[R5, #+36]
    567              handle->userData = userData;
   \   0000002C   0x62AF             STR      R7,[R5, #+40]
    568          
    569          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    570              /* Note:
    571                 Take care of the RX FIFO, RX interrupt request only assert when received bytes
    572                 equal or more than RX water mark, there is potential issue if RX water
    573                 mark larger than 1.
    574                 For example, if RX FIFO water mark is 2, upper layer needs 5 bytes and
    575                 5 bytes are received. the last byte will be saved in FIFO but not trigger
    576                 RX interrupt because the water mark is 2.
    577               */
    578              base->RWFIFO = 1U;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x7560             STRB     R0,[R4, #+21]
    579          #endif
    580          
    581              /* Get instance from peripheral base address. */
    582              instance = UART_GetInstance(base);
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       UART_GetInstance
   \   00000038   0x4680             MOV      R8,R0
    583          
    584              /* Save the handle in global variables to support the double weak mechanism. */
    585              s_uartHandle[instance] = handle;
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   0000003E   0xF840 0x5028      STR      R5,[R0, R8, LSL #+2]
    586          
    587              /* Enable interrupt in NVIC. */
    588              EnableIRQ(s_uartIRQ[instance]);
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   00000046   0xF910 0x0008      LDRSB    R0,[R0, R8]
   \   0000004A   0x.... 0x....      BL       EnableIRQ
    589          }
   \   0000004E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    590          

   \                                 In section .text, align 2, keep-with-next
    591          void UART_StartRingBuffer(UART_Type *base, uart_handle_t *handle, uint8_t *ringBuffer, size_t ringBufferSize)
    592          {
   \                     UART_StartRingBuffer: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    593              assert(handle);
    594          
    595              /* Setup the ringbuffer address */
    596              if (ringBuffer)
   \   0000000A   0x2E00             CMP      R6,#+0
   \   0000000C   0xD00A             BEQ.N    ??UART_StartRingBuffer_0
    597              {
    598                  handle->rxRingBuffer = ringBuffer;
   \   0000000E   0x61AE             STR      R6,[R5, #+24]
    599                  handle->rxRingBufferSize = ringBufferSize;
   \   00000010   0x61EF             STR      R7,[R5, #+28]
    600                  handle->rxRingBufferHead = 0U;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x8428             STRH     R0,[R5, #+32]
    601                  handle->rxRingBufferTail = 0U;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x8468             STRH     R0,[R5, #+34]
    602          
    603                  /* Enable the interrupt to accept the data when user need the ring buffer. */
    604                  UART_EnableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable);
   \   0000001A   0xF45F 0x2102      MOVS     R1,#+532480
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       UART_EnableInterrupts
    605              }
    606          }
   \                     ??UART_StartRingBuffer_0: (+1)
   \   00000024   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    607          

   \                                 In section .text, align 2, keep-with-next
    608          void UART_StopRingBuffer(UART_Type *base, uart_handle_t *handle)
    609          {
   \                     UART_StopRingBuffer: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    610              assert(handle);
    611          
    612              if (handle->rxState == kUART_RxIdle)
   \   00000006   0xF895 0x002D      LDRB     R0,[R5, #+45]
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD104             BNE.N    ??UART_StopRingBuffer_0
    613              {
    614                  UART_DisableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable);
   \   0000000E   0xF45F 0x2102      MOVS     R1,#+532480
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       UART_DisableInterrupts
    615              }
    616          
    617              handle->rxRingBuffer = NULL;
   \                     ??UART_StopRingBuffer_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x61A8             STR      R0,[R5, #+24]
    618              handle->rxRingBufferSize = 0U;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x61E8             STR      R0,[R5, #+28]
    619              handle->rxRingBufferHead = 0U;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x8428             STRH     R0,[R5, #+32]
    620              handle->rxRingBufferTail = 0U;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x8468             STRH     R0,[R5, #+34]
    621          }
   \   00000028   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    622          

   \                                 In section .text, align 2, keep-with-next
    623          status_t UART_SendNonBlocking(UART_Type *base, uart_handle_t *handle, uart_transfer_t *xfer)
    624          {
   \                     UART_SendNonBlocking: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    625              status_t status;
    626          
    627              /* Return error if current TX busy. */
    628              if (kUART_TxBusy == handle->txState)
   \   00000008   0xF895 0x002C      LDRB     R0,[R5, #+44]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD103             BNE.N    ??UART_SendNonBlocking_0
    629              {
    630                  status = kStatus_UART_TxBusy;
   \   00000010   0xF44F 0x707A      MOV      R0,#+1000
   \   00000014   0x0007             MOVS     R7,R0
   \   00000016   0xE00F             B.N      ??UART_SendNonBlocking_1
    631              }
    632              else
    633              {
    634                  handle->txData = xfer->data;
   \                     ??UART_SendNonBlocking_0: (+1)
   \   00000018   0x6830             LDR      R0,[R6, #+0]
   \   0000001A   0x6028             STR      R0,[R5, #+0]
    635                  handle->txDataSize = xfer->dataSize;
   \   0000001C   0x6870             LDR      R0,[R6, #+4]
   \   0000001E   0x6068             STR      R0,[R5, #+4]
    636                  handle->txDataSizeAll = xfer->dataSize;
   \   00000020   0x6870             LDR      R0,[R6, #+4]
   \   00000022   0x60A8             STR      R0,[R5, #+8]
    637                  handle->txState = kUART_TxBusy;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xF885 0x002C      STRB     R0,[R5, #+44]
    638          
    639                  /* Enable transmiter interrupt. */
    640                  UART_EnableInterrupts(base, kUART_TxDataRegEmptyInterruptEnable);
   \   0000002A   0xF44F 0x4100      MOV      R1,#+32768
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       UART_EnableInterrupts
    641          
    642                  status = kStatus_Success;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x0007             MOVS     R7,R0
    643              }
    644          
    645              return status;
   \                     ??UART_SendNonBlocking_1: (+1)
   \   00000038   0x0038             MOVS     R0,R7
   \   0000003A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    646          }
    647          

   \                                 In section .text, align 2, keep-with-next
    648          void UART_AbortSend(UART_Type *base, uart_handle_t *handle)
    649          {
   \                     UART_AbortSend: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    650              UART_DisableInterrupts(base, kUART_TxDataRegEmptyInterruptEnable | kUART_TransmissionCompleteInterruptEnable);
   \   00000006   0xF44F 0x4140      MOV      R1,#+49152
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       UART_DisableInterrupts
    651          
    652              handle->txDataSize = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x6068             STR      R0,[R5, #+4]
    653              handle->txState = kUART_TxIdle;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF885 0x002C      STRB     R0,[R5, #+44]
    654          }
   \   0000001A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    655          

   \                                 In section .text, align 2, keep-with-next
    656          status_t UART_GetSendCount(UART_Type *base, uart_handle_t *handle, uint32_t *count)
    657          {
   \                     UART_GetSendCount: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0003             MOVS     R3,R0
    658              if (kUART_TxIdle == handle->txState)
   \   00000004   0xF891 0x002C      LDRB     R0,[R1, #+44]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD101             BNE.N    ??UART_GetSendCount_0
    659              {
    660                  return kStatus_NoTransferInProgress;
   \   0000000C   0x2006             MOVS     R0,#+6
   \   0000000E   0xE008             B.N      ??UART_GetSendCount_1
    661              }
    662          
    663              if (!count)
   \                     ??UART_GetSendCount_0: (+1)
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD101             BNE.N    ??UART_GetSendCount_2
    664              {
    665                  return kStatus_InvalidArgument;
   \   00000014   0x2004             MOVS     R0,#+4
   \   00000016   0xE004             B.N      ??UART_GetSendCount_1
    666              }
    667          
    668              *count = handle->txDataSizeAll - handle->txDataSize;
   \                     ??UART_GetSendCount_2: (+1)
   \   00000018   0x6888             LDR      R0,[R1, #+8]
   \   0000001A   0x684C             LDR      R4,[R1, #+4]
   \   0000001C   0x1B00             SUBS     R0,R0,R4
   \   0000001E   0x6010             STR      R0,[R2, #+0]
    669          
    670              return kStatus_Success;
   \   00000020   0x2000             MOVS     R0,#+0
   \                     ??UART_GetSendCount_1: (+1)
   \   00000022   0xBC10             POP      {R4}
   \   00000024   0x4770             BX       LR               ;; return
    671          }
    672          

   \                                 In section .text, align 2, keep-with-next
    673          status_t UART_ReceiveNonBlocking(UART_Type *base, uart_handle_t *handle, uart_transfer_t *xfer, size_t *receivedBytes)
    674          {
   \                     UART_ReceiveNonBlocking: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
   \   0000000A   0x001E             MOVS     R6,R3
    675              uint32_t i;
    676              status_t status;
    677              /* How many bytes to copy from ring buffer to user memory. */
    678              size_t bytesToCopy = 0U;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    679              /* How many bytes to receive. */
    680              size_t bytesToReceive;
    681              /* How many bytes currently have received. */
    682              size_t bytesCurrentReceived;
    683              uint32_t regPrimask = 0U;
   \   00000010   0x2700             MOVS     R7,#+0
    684          
    685              /* How to get data:
    686                 1. If RX ring buffer is not enabled, then save xfer->data and xfer->dataSize
    687                    to uart handle, enable interrupt to store received data to xfer->data. When
    688                    all data received, trigger callback.
    689                 2. If RX ring buffer is enabled and not empty, get data from ring buffer first.
    690                    If there are enough data in ring buffer, copy them to xfer->data and return.
    691                    If there are not enough data in ring buffer, copy all of them to xfer->data,
    692                    save the xfer->data remained empty space to uart handle, receive data
    693                    to this empty space and trigger callback when finished. */
    694          
    695              if (kUART_RxBusy == handle->rxState)
   \   00000012   0xF894 0x002D      LDRB     R0,[R4, #+45]
   \   00000016   0x2803             CMP      R0,#+3
   \   00000018   0xD103             BNE.N    ??UART_ReceiveNonBlocking_0
    696              {
    697                  status = kStatus_UART_RxBusy;
   \   0000001A   0xF240 0x30E9      MOVW     R0,#+1001
   \   0000001E   0x9000             STR      R0,[SP, #+0]
   \   00000020   0xE056             B.N      ??UART_ReceiveNonBlocking_1
    698              }
    699              else
    700              {
    701                  bytesToReceive = xfer->dataSize;
   \                     ??UART_ReceiveNonBlocking_0: (+1)
   \   00000022   0x6868             LDR      R0,[R5, #+4]
   \   00000024   0x4681             MOV      R9,R0
    702                  bytesCurrentReceived = 0U;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x4682             MOV      R10,R0
    703          
    704                  /* If RX ring buffer is used. */
    705                  if (handle->rxRingBuffer)
   \   0000002A   0x69A0             LDR      R0,[R4, #+24]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD03A             BEQ.N    ??UART_ReceiveNonBlocking_2
    706                  {
    707                      /* Disable IRQ, protect ring buffer. */
    708                      regPrimask = __get_PRIMASK();
   \   00000030   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000034   0x0007             MOVS     R7,R0
    709                      __disable_irq();
   \   00000036   0xB672             CPSID    I
    710          
    711                      /* How many bytes in RX ring buffer currently. */
    712                      bytesToCopy = UART_GetRxRingBufferLength(handle);
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       UART_GetRxRingBufferLength
   \   0000003E   0x4680             MOV      R8,R0
    713          
    714                      if (bytesToCopy)
   \   00000040   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000044   0xD01F             BEQ.N    ??UART_ReceiveNonBlocking_3
    715                      {
    716                          bytesToCopy = MIN(bytesToReceive, bytesToCopy);
   \   00000046   0x45C1             CMP      R9,R8
   \   00000048   0xD201             BCS.N    ??UART_ReceiveNonBlocking_4
   \   0000004A   0x46C8             MOV      R8,R9
   \   0000004C   0xE7FF             B.N      ??UART_ReceiveNonBlocking_5
    717          
    718                          bytesToReceive -= bytesToCopy;
   \                     ??UART_ReceiveNonBlocking_4: (+1)
   \                     ??UART_ReceiveNonBlocking_5: (+1)
   \   0000004E   0xEBB9 0x0908      SUBS     R9,R9,R8
    719          
    720                          /* Copy data from ring buffer to user memory. */
    721                          for (i = 0U; i < bytesToCopy; i++)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x4683             MOV      R11,R0
   \                     ??UART_ReceiveNonBlocking_6: (+1)
   \   00000056   0x45C3             CMP      R11,R8
   \   00000058   0xD215             BCS.N    ??UART_ReceiveNonBlocking_3
    722                          {
    723                              xfer->data[bytesCurrentReceived++] = handle->rxRingBuffer[handle->rxRingBufferTail];
   \   0000005A   0x69A0             LDR      R0,[R4, #+24]
   \   0000005C   0x8C61             LDRH     R1,[R4, #+34]
   \   0000005E   0x5C40             LDRB     R0,[R0, R1]
   \   00000060   0x6829             LDR      R1,[R5, #+0]
   \   00000062   0xF801 0x000A      STRB     R0,[R1, R10]
   \   00000066   0xF11A 0x0A01      ADDS     R10,R10,#+1
    724          
    725                              /* Wrap to 0. Not use modulo (%) because it might be large and slow. */
    726                              if (handle->rxRingBufferTail + 1U == handle->rxRingBufferSize)
   \   0000006A   0x8C60             LDRH     R0,[R4, #+34]
   \   0000006C   0x1C40             ADDS     R0,R0,#+1
   \   0000006E   0x69E1             LDR      R1,[R4, #+28]
   \   00000070   0x4288             CMP      R0,R1
   \   00000072   0xD102             BNE.N    ??UART_ReceiveNonBlocking_7
    727                              {
    728                                  handle->rxRingBufferTail = 0U;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x8460             STRH     R0,[R4, #+34]
   \   00000078   0xE002             B.N      ??UART_ReceiveNonBlocking_8
    729                              }
    730                              else
    731                              {
    732                                  handle->rxRingBufferTail++;
   \                     ??UART_ReceiveNonBlocking_7: (+1)
   \   0000007A   0x8C60             LDRH     R0,[R4, #+34]
   \   0000007C   0x1C40             ADDS     R0,R0,#+1
   \   0000007E   0x8460             STRH     R0,[R4, #+34]
    733                              }
    734                          }
   \                     ??UART_ReceiveNonBlocking_8: (+1)
   \   00000080   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   00000084   0xE7E7             B.N      ??UART_ReceiveNonBlocking_6
    735                      }
    736          
    737                      /* If ring buffer does not have enough data, still need to read more data. */
    738                      if (bytesToReceive)
   \                     ??UART_ReceiveNonBlocking_3: (+1)
   \   00000086   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000008A   0xD009             BEQ.N    ??UART_ReceiveNonBlocking_9
    739                      {
    740                          /* No data in ring buffer, save the request to UART handle. */
    741                          handle->rxData = xfer->data + bytesCurrentReceived;
   \   0000008C   0x6828             LDR      R0,[R5, #+0]
   \   0000008E   0x4450             ADD      R0,R0,R10
   \   00000090   0x60E0             STR      R0,[R4, #+12]
    742                          handle->rxDataSize = bytesToReceive;
   \   00000092   0xF8C4 0x9010      STR      R9,[R4, #+16]
    743                          handle->rxDataSizeAll = bytesToReceive;
   \   00000096   0xF8C4 0x9014      STR      R9,[R4, #+20]
    744                          handle->rxState = kUART_RxBusy;
   \   0000009A   0x2003             MOVS     R0,#+3
   \   0000009C   0xF884 0x002D      STRB     R0,[R4, #+45]
    745                      }
    746          
    747                      /* Recover PRIMASK, enable IRQ if previously enabled. */
    748                      __set_PRIMASK(regPrimask);
   \                     ??UART_ReceiveNonBlocking_9: (+1)
   \   000000A0   0xF387 0x8810      MSR      PRIMASK,R7
   \   000000A4   0xE00E             B.N      ??UART_ReceiveNonBlocking_10
    749                  }
    750                  /* Ring buffer not used. */
    751                  else
    752                  {
    753                      handle->rxData = xfer->data + bytesCurrentReceived;
   \                     ??UART_ReceiveNonBlocking_2: (+1)
   \   000000A6   0x6828             LDR      R0,[R5, #+0]
   \   000000A8   0x4450             ADD      R0,R0,R10
   \   000000AA   0x60E0             STR      R0,[R4, #+12]
    754                      handle->rxDataSize = bytesToReceive;
   \   000000AC   0xF8C4 0x9010      STR      R9,[R4, #+16]
    755                      handle->rxDataSizeAll = bytesToReceive;
   \   000000B0   0xF8C4 0x9014      STR      R9,[R4, #+20]
    756                      handle->rxState = kUART_RxBusy;
   \   000000B4   0x2003             MOVS     R0,#+3
   \   000000B6   0xF884 0x002D      STRB     R0,[R4, #+45]
    757          
    758                      /* Enable RX interrupt. */
    759                      UART_EnableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable);
   \   000000BA   0xF45F 0x2102      MOVS     R1,#+532480
   \   000000BE   0x9802             LDR      R0,[SP, #+8]
   \   000000C0   0x.... 0x....      BL       UART_EnableInterrupts
    760                  }
    761          
    762                  /* Return the how many bytes have read. */
    763                  if (receivedBytes)
   \                     ??UART_ReceiveNonBlocking_10: (+1)
   \   000000C4   0x2E00             CMP      R6,#+0
   \   000000C6   0xD001             BEQ.N    ??UART_ReceiveNonBlocking_11
    764                  {
    765                      *receivedBytes = bytesCurrentReceived;
   \   000000C8   0xF8C6 0xA000      STR      R10,[R6, #+0]
    766                  }
    767          
    768                  status = kStatus_Success;
   \                     ??UART_ReceiveNonBlocking_11: (+1)
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x9000             STR      R0,[SP, #+0]
    769              }
    770          
    771              return status;
   \                     ??UART_ReceiveNonBlocking_1: (+1)
   \   000000D0   0x9800             LDR      R0,[SP, #+0]
   \   000000D2   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    772          }
    773          

   \                                 In section .text, align 2, keep-with-next
    774          void UART_AbortReceive(UART_Type *base, uart_handle_t *handle)
    775          {
   \                     UART_AbortReceive: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    776              /* Only abort the receive to handle->rxData, the RX ring buffer is still working. */
    777              if (!handle->rxRingBuffer)
   \   00000006   0x69A8             LDR      R0,[R5, #+24]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD104             BNE.N    ??UART_AbortReceive_0
    778              {
    779                  /* Disable RX interrupt. */
    780                  UART_DisableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable);
   \   0000000C   0xF45F 0x2102      MOVS     R1,#+532480
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       UART_DisableInterrupts
    781              }
    782          
    783              handle->rxDataSize = 0U;
   \                     ??UART_AbortReceive_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x6128             STR      R0,[R5, #+16]
    784              handle->rxState = kUART_RxIdle;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF885 0x002D      STRB     R0,[R5, #+45]
    785          }
   \   00000020   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    786          

   \                                 In section .text, align 2, keep-with-next
    787          status_t UART_GetReceiveCount(UART_Type *base, uart_handle_t *handle, uint32_t *count)
    788          {
   \                     UART_GetReceiveCount: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0003             MOVS     R3,R0
    789              if (kUART_RxIdle == handle->rxState)
   \   00000004   0xF891 0x002D      LDRB     R0,[R1, #+45]
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD101             BNE.N    ??UART_GetReceiveCount_0
    790              {
    791                  return kStatus_NoTransferInProgress;
   \   0000000C   0x2006             MOVS     R0,#+6
   \   0000000E   0xE008             B.N      ??UART_GetReceiveCount_1
    792              }
    793          
    794              if (!count)
   \                     ??UART_GetReceiveCount_0: (+1)
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD101             BNE.N    ??UART_GetReceiveCount_2
    795              {
    796                  return kStatus_InvalidArgument;
   \   00000014   0x2004             MOVS     R0,#+4
   \   00000016   0xE004             B.N      ??UART_GetReceiveCount_1
    797              }
    798          
    799              *count = handle->rxDataSizeAll - handle->rxDataSize;
   \                     ??UART_GetReceiveCount_2: (+1)
   \   00000018   0x6948             LDR      R0,[R1, #+20]
   \   0000001A   0x690C             LDR      R4,[R1, #+16]
   \   0000001C   0x1B00             SUBS     R0,R0,R4
   \   0000001E   0x6010             STR      R0,[R2, #+0]
    800          
    801              return kStatus_Success;
   \   00000020   0x2000             MOVS     R0,#+0
   \                     ??UART_GetReceiveCount_1: (+1)
   \   00000022   0xBC10             POP      {R4}
   \   00000024   0x4770             BX       LR               ;; return
    802          }
    803          

   \                                 In section .text, align 2, keep-with-next
    804          void UART_HandleIRQ(UART_Type *base, uart_handle_t *handle)
    805          {
   \                     UART_HandleIRQ: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    806              uint8_t count;
    807              uint8_t tempCount;
    808          
    809              /* If RX overrun. */
    810              if (UART_S1_OR_MASK & base->S1)
   \   00000006   0x7920             LDRB     R0,[R4, #+4]
   \   00000008   0x0700             LSLS     R0,R0,#+28
   \   0000000A   0xD50B             BPL.N    ??UART_HandleIRQ_0
    811              {
    812                  /* Read base->D, otherwise the RX does not work. */
    813                  (void)base->D;
   \   0000000C   0x79E0             LDRB     R0,[R4, #+7]
    814          
    815                  /* Trigger callback. */
    816                  if (handle->callback)
   \   0000000E   0x6A68             LDR      R0,[R5, #+36]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD007             BEQ.N    ??UART_HandleIRQ_0
    817                  {
    818                      handle->callback(base, handle, kStatus_UART_RxHardwareOverrun, handle->userData);
   \   00000014   0x6AAB             LDR      R3,[R5, #+40]
   \   00000016   0xF240 0x32F1      MOVW     R2,#+1009
   \   0000001A   0x0029             MOVS     R1,R5
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xF8D5 0xC024      LDR      R12,[R5, #+36]
   \   00000022   0x47E0             BLX      R12
    819                  }
    820              }
    821          
    822              /* Receive data register full */
    823              if ((UART_S1_RDRF_MASK & base->S1) && (UART_C2_RIE_MASK & base->C2))
   \                     ??UART_HandleIRQ_0: (+1)
   \   00000024   0x7920             LDRB     R0,[R4, #+4]
   \   00000026   0x0680             LSLS     R0,R0,#+26
   \   00000028   0xD573             BPL.N    ??UART_HandleIRQ_1
   \   0000002A   0x78E0             LDRB     R0,[R4, #+3]
   \   0000002C   0x0680             LSLS     R0,R0,#+26
   \   0000002E   0xD570             BPL.N    ??UART_HandleIRQ_1
    824              {
    825          /* Get the size that can be stored into buffer for this interrupt. */
    826          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    827                  count = base->RCFIFO;
   \   00000030   0x7DA0             LDRB     R0,[R4, #+22]
   \   00000032   0x0006             MOVS     R6,R0
    828          #else
    829                  count = 1;
    830          #endif
    831          
    832                  /* If handle->rxDataSize is not 0, first save data to handle->rxData. */
    833                  while ((count) && (handle->rxDataSize))
   \                     ??UART_HandleIRQ_2: (+1)
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0x2E00             CMP      R6,#+0
   \   00000038   0xD02A             BEQ.N    ??UART_HandleIRQ_3
   \   0000003A   0x6928             LDR      R0,[R5, #+16]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD027             BEQ.N    ??UART_HandleIRQ_3
    834                  {
    835          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    836                      tempCount = MIN(handle->rxDataSize, count);
   \   00000040   0x6928             LDR      R0,[R5, #+16]
   \   00000042   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000044   0x42B0             CMP      R0,R6
   \   00000046   0xD201             BCS.N    ??UART_HandleIRQ_4
   \   00000048   0x692F             LDR      R7,[R5, #+16]
   \   0000004A   0xE000             B.N      ??UART_HandleIRQ_5
   \                     ??UART_HandleIRQ_4: (+1)
   \   0000004C   0x0037             MOVS     R7,R6
    837          #else
    838                      tempCount = 1;
    839          #endif
    840          
    841                      /* Using non block API to read the data from the registers. */
    842                      UART_ReadNonBlocking(base, handle->rxData, tempCount);
   \                     ??UART_HandleIRQ_5: (+1)
   \   0000004E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000050   0x003A             MOVS     R2,R7
   \   00000052   0x68E9             LDR      R1,[R5, #+12]
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       UART_ReadNonBlocking
    843                      handle->rxData += tempCount;
   \   0000005A   0x68E8             LDR      R0,[R5, #+12]
   \   0000005C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005E   0x4438             ADD      R0,R0,R7
   \   00000060   0x60E8             STR      R0,[R5, #+12]
    844                      handle->rxDataSize -= tempCount;
   \   00000062   0x6928             LDR      R0,[R5, #+16]
   \   00000064   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000066   0x1BC0             SUBS     R0,R0,R7
   \   00000068   0x6128             STR      R0,[R5, #+16]
    845                      count -= tempCount;
   \   0000006A   0x1BF6             SUBS     R6,R6,R7
    846          
    847                      /* If all the data required for upper layer is ready, trigger callback. */
    848                      if (!handle->rxDataSize)
   \   0000006C   0x6928             LDR      R0,[R5, #+16]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD1E0             BNE.N    ??UART_HandleIRQ_2
    849                      {
    850                          handle->rxState = kUART_RxIdle;
   \   00000072   0x2002             MOVS     R0,#+2
   \   00000074   0xF885 0x002D      STRB     R0,[R5, #+45]
    851          
    852                          if (handle->callback)
   \   00000078   0x6A68             LDR      R0,[R5, #+36]
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD0DA             BEQ.N    ??UART_HandleIRQ_2
    853                          {
    854                              handle->callback(base, handle, kStatus_UART_RxIdle, handle->userData);
   \   0000007E   0x6AAB             LDR      R3,[R5, #+40]
   \   00000080   0xF240 0x32EB      MOVW     R2,#+1003
   \   00000084   0x0029             MOVS     R1,R5
   \   00000086   0x0020             MOVS     R0,R4
   \   00000088   0xF8D5 0xC024      LDR      R12,[R5, #+36]
   \   0000008C   0x47E0             BLX      R12
   \   0000008E   0xE7D1             B.N      ??UART_HandleIRQ_2
    855                          }
    856                      }
    857                  }
    858          
    859                  /* If use RX ring buffer, receive data to ring buffer. */
    860                  if (handle->rxRingBuffer)
   \                     ??UART_HandleIRQ_3: (+1)
   \   00000090   0x69A8             LDR      R0,[R5, #+24]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD035             BEQ.N    ??UART_HandleIRQ_6
    861                  {
    862                      while (count--)
   \                     ??UART_HandleIRQ_7: (+1)
   \   00000096   0x0030             MOVS     R0,R6
   \   00000098   0x1E46             SUBS     R6,R0,#+1
   \   0000009A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD038             BEQ.N    ??UART_HandleIRQ_1
    863                      {
    864                          /* If RX ring buffer is full, trigger callback to notify over run. */
    865                          if (UART_IsRxRingBufferFull(handle))
   \   000000A0   0x0028             MOVS     R0,R5
   \   000000A2   0x.... 0x....      BL       UART_IsRxRingBufferFull
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD00A             BEQ.N    ??UART_HandleIRQ_8
    866                          {
    867                              if (handle->callback)
   \   000000AA   0x6A68             LDR      R0,[R5, #+36]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD007             BEQ.N    ??UART_HandleIRQ_8
    868                              {
    869                                  handle->callback(base, handle, kStatus_UART_RxRingBufferOverrun, handle->userData);
   \   000000B0   0x6AAB             LDR      R3,[R5, #+40]
   \   000000B2   0xF44F 0x727C      MOV      R2,#+1008
   \   000000B6   0x0029             MOVS     R1,R5
   \   000000B8   0x0020             MOVS     R0,R4
   \   000000BA   0xF8D5 0xC024      LDR      R12,[R5, #+36]
   \   000000BE   0x47E0             BLX      R12
    870                              }
    871                          }
    872          
    873                          /* If ring buffer is still full after callback function, the oldest data is overrided. */
    874                          if (UART_IsRxRingBufferFull(handle))
   \                     ??UART_HandleIRQ_8: (+1)
   \   000000C0   0x0028             MOVS     R0,R5
   \   000000C2   0x.... 0x....      BL       UART_IsRxRingBufferFull
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD00A             BEQ.N    ??UART_HandleIRQ_9
    875                          {
    876                              /* Increase handle->rxRingBufferTail to make room for new data. */
    877                              if (handle->rxRingBufferTail + 1U == handle->rxRingBufferSize)
   \   000000CA   0x8C68             LDRH     R0,[R5, #+34]
   \   000000CC   0x1C40             ADDS     R0,R0,#+1
   \   000000CE   0x69E9             LDR      R1,[R5, #+28]
   \   000000D0   0x4288             CMP      R0,R1
   \   000000D2   0xD102             BNE.N    ??UART_HandleIRQ_10
    878                              {
    879                                  handle->rxRingBufferTail = 0U;
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0x8468             STRH     R0,[R5, #+34]
   \   000000D8   0xE002             B.N      ??UART_HandleIRQ_9
    880                              }
    881                              else
    882                              {
    883                                  handle->rxRingBufferTail++;
   \                     ??UART_HandleIRQ_10: (+1)
   \   000000DA   0x8C68             LDRH     R0,[R5, #+34]
   \   000000DC   0x1C40             ADDS     R0,R0,#+1
   \   000000DE   0x8468             STRH     R0,[R5, #+34]
    884                              }
    885                          }
    886          
    887                          /* Read data. */
    888                          handle->rxRingBuffer[handle->rxRingBufferHead] = base->D;
   \                     ??UART_HandleIRQ_9: (+1)
   \   000000E0   0x8C28             LDRH     R0,[R5, #+32]
   \   000000E2   0x79E1             LDRB     R1,[R4, #+7]
   \   000000E4   0x69AA             LDR      R2,[R5, #+24]
   \   000000E6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000E8   0x5411             STRB     R1,[R2, R0]
    889          
    890                          /* Increase handle->rxRingBufferHead. */
    891                          if (handle->rxRingBufferHead + 1U == handle->rxRingBufferSize)
   \   000000EA   0x8C28             LDRH     R0,[R5, #+32]
   \   000000EC   0x1C40             ADDS     R0,R0,#+1
   \   000000EE   0x69E9             LDR      R1,[R5, #+28]
   \   000000F0   0x4288             CMP      R0,R1
   \   000000F2   0xD102             BNE.N    ??UART_HandleIRQ_11
    892                          {
    893                              handle->rxRingBufferHead = 0U;
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0x8428             STRH     R0,[R5, #+32]
   \   000000F8   0xE7CD             B.N      ??UART_HandleIRQ_7
    894                          }
    895                          else
    896                          {
    897                              handle->rxRingBufferHead++;
   \                     ??UART_HandleIRQ_11: (+1)
   \   000000FA   0x8C28             LDRH     R0,[R5, #+32]
   \   000000FC   0x1C40             ADDS     R0,R0,#+1
   \   000000FE   0x8428             STRH     R0,[R5, #+32]
   \   00000100   0xE7C9             B.N      ??UART_HandleIRQ_7
    898                          }
    899                      }
    900                  }
    901                  /* If no receive requst pending, stop RX interrupt. */
    902                  else if (!handle->rxDataSize)
   \                     ??UART_HandleIRQ_6: (+1)
   \   00000102   0x6928             LDR      R0,[R5, #+16]
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD104             BNE.N    ??UART_HandleIRQ_1
    903                  {
    904                      UART_DisableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable);
   \   00000108   0xF45F 0x2102      MOVS     R1,#+532480
   \   0000010C   0x0020             MOVS     R0,R4
   \   0000010E   0x.... 0x....      BL       UART_DisableInterrupts
    905                  }
    906                  else
    907                  {
    908                  }
    909              }
    910          
    911              /* Send data register empty and the interrupt is enabled. */
    912              if ((base->S1 & UART_S1_TDRE_MASK) && (base->C2 & UART_C2_TIE_MASK))
   \                     ??UART_HandleIRQ_1: (+1)
   \   00000112   0x7920             LDRB     R0,[R4, #+4]
   \   00000114   0x0600             LSLS     R0,R0,#+24
   \   00000116   0xD53A             BPL.N    ??UART_HandleIRQ_12
   \   00000118   0x78E0             LDRB     R0,[R4, #+3]
   \   0000011A   0x0600             LSLS     R0,R0,#+24
   \   0000011C   0xD537             BPL.N    ??UART_HandleIRQ_12
    913              {
    914          /* Get the bytes that available at this moment. */
    915          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    916                  count = FSL_FEATURE_UART_FIFO_SIZEn(base) - base->TCFIFO;
                                 ^
Warning[Pe223]: function "FSL_FEATURE_UART_FIFO_SIZEn" declared implicitly
   \   0000011E   0x0020             MOVS     R0,R4
   \   00000120   0x.... 0x....      BL       FSL_FEATURE_UART_FIFO_SIZEn
   \   00000124   0x7D21             LDRB     R1,[R4, #+20]
   \   00000126   0x1A40             SUBS     R0,R0,R1
   \   00000128   0x0006             MOVS     R6,R0
    917          #else
    918                  count = 1;
    919          #endif
    920          
    921                  while ((count) && (handle->txDataSize))
   \                     ??UART_HandleIRQ_13: (+1)
   \   0000012A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000012C   0x2E00             CMP      R6,#+0
   \   0000012E   0xD02E             BEQ.N    ??UART_HandleIRQ_12
   \   00000130   0x6868             LDR      R0,[R5, #+4]
   \   00000132   0x2800             CMP      R0,#+0
   \   00000134   0xD02B             BEQ.N    ??UART_HandleIRQ_12
    922                  {
    923          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    924                      tempCount = MIN(handle->txDataSize, count);
   \   00000136   0x6868             LDR      R0,[R5, #+4]
   \   00000138   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000013A   0x42B0             CMP      R0,R6
   \   0000013C   0xD201             BCS.N    ??UART_HandleIRQ_14
   \   0000013E   0x686F             LDR      R7,[R5, #+4]
   \   00000140   0xE000             B.N      ??UART_HandleIRQ_15
   \                     ??UART_HandleIRQ_14: (+1)
   \   00000142   0x0037             MOVS     R7,R6
    925          #else
    926                      tempCount = 1;
    927          #endif
    928          
    929                      /* Using non block API to write the data to the registers. */
    930                      UART_WriteNonBlocking(base, handle->txData, tempCount);
   \                     ??UART_HandleIRQ_15: (+1)
   \   00000144   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000146   0x003A             MOVS     R2,R7
   \   00000148   0x6829             LDR      R1,[R5, #+0]
   \   0000014A   0x0020             MOVS     R0,R4
   \   0000014C   0x.... 0x....      BL       UART_WriteNonBlocking
    931                      handle->txData += tempCount;
   \   00000150   0x6828             LDR      R0,[R5, #+0]
   \   00000152   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000154   0x4438             ADD      R0,R0,R7
   \   00000156   0x6028             STR      R0,[R5, #+0]
    932                      handle->txDataSize -= tempCount;
   \   00000158   0x6868             LDR      R0,[R5, #+4]
   \   0000015A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000015C   0x1BC0             SUBS     R0,R0,R7
   \   0000015E   0x6068             STR      R0,[R5, #+4]
    933                      count -= tempCount;
   \   00000160   0x1BF6             SUBS     R6,R6,R7
    934          
    935                      /* If all the data are written to data register, TX finished. */
    936                      if (!handle->txDataSize)
   \   00000162   0x6868             LDR      R0,[R5, #+4]
   \   00000164   0x2800             CMP      R0,#+0
   \   00000166   0xD1E0             BNE.N    ??UART_HandleIRQ_13
    937                      {
    938                          handle->txState = kUART_TxIdle;
   \   00000168   0x2000             MOVS     R0,#+0
   \   0000016A   0xF885 0x002C      STRB     R0,[R5, #+44]
    939          
    940                          /* Disable TX register empty interrupt. */
    941                          base->C2 = (base->C2 & ~UART_C2_TIE_MASK);
   \   0000016E   0x78E0             LDRB     R0,[R4, #+3]
   \   00000170   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000174   0x70E0             STRB     R0,[R4, #+3]
    942          
    943                          /* Trigger callback. */
    944                          if (handle->callback)
   \   00000176   0x6A68             LDR      R0,[R5, #+36]
   \   00000178   0x2800             CMP      R0,#+0
   \   0000017A   0xD0D6             BEQ.N    ??UART_HandleIRQ_13
    945                          {
    946                              handle->callback(base, handle, kStatus_UART_TxIdle, handle->userData);
   \   0000017C   0x6AAB             LDR      R3,[R5, #+40]
   \   0000017E   0xF240 0x32EA      MOVW     R2,#+1002
   \   00000182   0x0029             MOVS     R1,R5
   \   00000184   0x0020             MOVS     R0,R4
   \   00000186   0xF8D5 0xC024      LDR      R12,[R5, #+36]
   \   0000018A   0x47E0             BLX      R12
   \   0000018C   0xE7CD             B.N      ??UART_HandleIRQ_13
    947                          }
    948                      }
    949                  }
    950              }
    951          }
   \                     ??UART_HandleIRQ_12: (+1)
   \   0000018E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    952          

   \                                 In section .text, align 2, keep-with-next
    953          void UART_HandleErrorIRQ(UART_Type *base, uart_handle_t *handle)
    954          {
    955              /* TODO: To be implemented. */
    956          }
   \                     UART_HandleErrorIRQ: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    957          
    958          #if defined(UART0)
    959          #if ((!(defined(FSL_FEATURE_SOC_LPSCI_COUNT))) || \
    960               ((defined(FSL_FEATURE_SOC_LPSCI_COUNT)) && (FSL_FEATURE_SOC_LPSCI_COUNT == 0)))

   \                                 In section .text, align 2, keep-with-next
    961          void UART0_DriverIRQHandler(void)
    962          {
   \                     UART0_DriverIRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    963              assert(s_uartHandle[0]);
    964          
    965              UART_HandleIRQ(UART0, s_uartHandle[0]);
   \   00000002   0x....             LDR.N    R0,??DataTable10_3
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x....             LDR.N    R0,??DataTable10_5  ;; 0x4006a000
   \   00000008   0x.... 0x....      BL       UART_HandleIRQ
    966          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return
    967          

   \                                 In section .text, align 2, keep-with-next
    968          void UART0_RX_TX_DriverIRQHandler(void)
    969          {
   \                     UART0_RX_TX_DriverIRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    970              UART0_DriverIRQHandler();
   \   00000002   0x.... 0x....      BL       UART0_DriverIRQHandler
    971          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    972          #endif
    973          #endif
    974          
    975          #if defined(UART1)

   \                                 In section .text, align 2, keep-with-next
    976          void UART1_DriverIRQHandler(void)
    977          {
   \                     UART1_DriverIRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    978              assert(s_uartHandle[1]);
    979          
    980              UART_HandleIRQ(UART1, s_uartHandle[1]);
   \   00000002   0x....             LDR.N    R0,??DataTable10_3
   \   00000004   0x6841             LDR      R1,[R0, #+4]
   \   00000006   0x....             LDR.N    R0,??DataTable10_6  ;; 0x4006b000
   \   00000008   0x.... 0x....      BL       UART_HandleIRQ
    981          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return
    982          

   \                                 In section .text, align 2, keep-with-next
    983          void UART1_RX_TX_DriverIRQHandler(void)
    984          {
   \                     UART1_RX_TX_DriverIRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    985              UART1_DriverIRQHandler();
   \   00000002   0x.... 0x....      BL       UART1_DriverIRQHandler
    986          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    987          #endif
    988          
    989          #if defined(UART2)

   \                                 In section .text, align 2, keep-with-next
    990          void UART2_DriverIRQHandler(void)
    991          {
   \                     UART2_DriverIRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    992              assert(s_uartHandle[2]);
    993          
    994              UART_HandleIRQ(UART2, s_uartHandle[2]);
   \   00000002   0x....             LDR.N    R0,??DataTable10_3
   \   00000004   0x6881             LDR      R1,[R0, #+8]
   \   00000006   0x....             LDR.N    R0,??DataTable10_7  ;; 0x4006c000
   \   00000008   0x.... 0x....      BL       UART_HandleIRQ
    995          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return
    996          

   \                                 In section .text, align 2, keep-with-next
    997          void UART2_RX_TX_DriverIRQHandler(void)
    998          {
   \                     UART2_RX_TX_DriverIRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    999              UART2_DriverIRQHandler();
   \   00000002   0x.... 0x....      BL       UART2_DriverIRQHandler
   1000          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
   1001          
   1002          #endif
   1003          
   1004          #if defined(UART3)

   \                                 In section .text, align 2, keep-with-next
   1005          void UART3_DriverIRQHandler(void)
   1006          {
   \                     UART3_DriverIRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1007              assert(s_uartHandle[3]);
   1008          
   1009              UART_HandleIRQ(UART3, s_uartHandle[3]);
   \   00000002   0x....             LDR.N    R0,??DataTable10_3
   \   00000004   0x68C1             LDR      R1,[R0, #+12]
   \   00000006   0x....             LDR.N    R0,??DataTable10_8  ;; 0x4006d000
   \   00000008   0x.... 0x....      BL       UART_HandleIRQ
   1010          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return
   1011          

   \                                 In section .text, align 2, keep-with-next
   1012          void UART3_RX_TX_DriverIRQHandler(void)
   1013          {
   \                     UART3_RX_TX_DriverIRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1014              UART3_DriverIRQHandler();
   \   00000002   0x.... 0x....      BL       UART3_DriverIRQHandler
   1015          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
   1016          #endif
   1017          
   1018          #if defined(UART4)

   \                                 In section .text, align 2, keep-with-next
   1019          void UART4_DriverIRQHandler(void)
   1020          {
   \                     UART4_DriverIRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1021              assert(s_uartHandle[4]);
   1022          
   1023              UART_HandleIRQ(UART4, s_uartHandle[4]);
   \   00000002   0x....             LDR.N    R0,??DataTable10_3
   \   00000004   0x6901             LDR      R1,[R0, #+16]
   \   00000006   0x....             LDR.N    R0,??DataTable10_9  ;; 0x400ea000
   \   00000008   0x.... 0x....      BL       UART_HandleIRQ
   1024          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return
   1025          

   \                                 In section .text, align 2, keep-with-next
   1026          void UART4_RX_TX_DriverIRQHandler(void)
   1027          {
   \                     UART4_RX_TX_DriverIRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1028              UART4_DriverIRQHandler();
   \   00000002   0x.... 0x....      BL       UART4_DriverIRQHandler
   1029          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
   1030          #endif
   1031          
   1032          #if defined(UART5)

   \                                 In section .text, align 2, keep-with-next
   1033          void UART5_DriverIRQHandler(void)
   1034          {
   \                     UART5_DriverIRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1035              assert(s_uartHandle[5]);
   1036          
   1037              UART_HandleIRQ(UART5, s_uartHandle[5]);
   \   00000002   0x....             LDR.N    R0,??DataTable10_3
   \   00000004   0x6941             LDR      R1,[R0, #+20]
   \   00000006   0x....             LDR.N    R0,??DataTable10_10  ;; 0x400eb000
   \   00000008   0x.... 0x....      BL       UART_HandleIRQ
   1038          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return
   1039          

   \                                 In section .text, align 2, keep-with-next
   1040          void UART5_RX_TX_DriverIRQHandler(void)
   1041          {
   \                     UART5_RX_TX_DriverIRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1042              UART5_DriverIRQHandler();
   \   00000002   0x.... 0x....      BL       UART5_DriverIRQHandler
   1043          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     s_uartBases

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     s_uartClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     s_uartHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     s_uartIRQ

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x4006A000         DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x4006B000         DC32     0x4006b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x4006C000         DC32     0x4006c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x4006D000         DC32     0x4006d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x400EA000         DC32     0x400ea000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x400EB000         DC32     0x400eb000
   1044          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CLOCK_DisableClock
       0   CLOCK_EnableClock
       8   EnableIRQ
         8   -> NVIC_EnableIRQ
       0   NVIC_EnableIRQ
       8   UART0_DriverIRQHandler
         8   -> UART_HandleIRQ
       8   UART0_RX_TX_DriverIRQHandler
         8   -> UART0_DriverIRQHandler
       8   UART1_DriverIRQHandler
         8   -> UART_HandleIRQ
       8   UART1_RX_TX_DriverIRQHandler
         8   -> UART1_DriverIRQHandler
       8   UART2_DriverIRQHandler
         8   -> UART_HandleIRQ
       8   UART2_RX_TX_DriverIRQHandler
         8   -> UART2_DriverIRQHandler
       8   UART3_DriverIRQHandler
         8   -> UART_HandleIRQ
       8   UART3_RX_TX_DriverIRQHandler
         8   -> UART3_DriverIRQHandler
       8   UART4_DriverIRQHandler
         8   -> UART_HandleIRQ
       8   UART4_RX_TX_DriverIRQHandler
         8   -> UART4_DriverIRQHandler
       8   UART5_DriverIRQHandler
         8   -> UART_HandleIRQ
       8   UART5_RX_TX_DriverIRQHandler
         8   -> UART5_DriverIRQHandler
      16   UART_AbortReceive
        16   -> UART_DisableInterrupts
      16   UART_AbortSend
        16   -> UART_DisableInterrupts
      24   UART_ClearStatusFlags
        24   -> UART_GetStatusFlags
      32   UART_CreateHandle
        32   -> EnableIRQ
        32   -> UART_GetInstance
        32   -> __aeabi_memset
       8   UART_Deinit
         8   -> CLOCK_DisableClock
         8   -> UART_GetInstance
       0   UART_DisableInterrupts
       0   UART_EnableInterrupts
       0   UART_GetDefaultConfig
       0   UART_GetEnabledInterrupts
       0   UART_GetInstance
       4   UART_GetReceiveCount
       0   UART_GetRxRingBufferLength
       4   UART_GetSendCount
       0   UART_GetStatusFlags
       0   UART_HandleErrorIRQ
      24   UART_HandleIRQ
        24   -- Indirect call
        24   -> FSL_FEATURE_UART_FIFO_SIZEn
        24   -> UART_DisableInterrupts
        24   -> UART_IsRxRingBufferFull
        24   -> UART_ReadNonBlocking
        24   -> UART_WriteNonBlocking
      32   UART_Init
        32   -> CLOCK_EnableClock
        32   -> UART_GetInstance
      16   UART_IsRxRingBufferFull
        16   -> UART_GetRxRingBufferLength
       0   UART_ReadBlocking
       4   UART_ReadNonBlocking
      48   UART_ReceiveNonBlocking
        48   -> UART_EnableInterrupts
        48   -> UART_GetRxRingBufferLength
      24   UART_SendNonBlocking
        24   -> UART_EnableInterrupts
      16   UART_SetBaudRate
      24   UART_StartRingBuffer
        24   -> UART_EnableInterrupts
      16   UART_StopRingBuffer
        16   -> UART_DisableInterrupts
       0   UART_WriteBlocking
       4   UART_WriteNonBlocking


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      22  CLOCK_DisableClock
      22  CLOCK_EnableClock
      14  EnableIRQ
      22  NVIC_EnableIRQ
      14  UART0_DriverIRQHandler
       8  UART0_RX_TX_DriverIRQHandler
      14  UART1_DriverIRQHandler
       8  UART1_RX_TX_DriverIRQHandler
      14  UART2_DriverIRQHandler
       8  UART2_RX_TX_DriverIRQHandler
      14  UART3_DriverIRQHandler
       8  UART3_RX_TX_DriverIRQHandler
      14  UART4_DriverIRQHandler
       8  UART4_RX_TX_DriverIRQHandler
      14  UART5_DriverIRQHandler
       8  UART5_RX_TX_DriverIRQHandler
      34  UART_AbortReceive
      28  UART_AbortSend
      58  UART_ClearStatusFlags
      82  UART_CreateHandle
      40  UART_Deinit
      32  UART_DisableInterrupts
      32  UART_EnableInterrupts
      28  UART_GetDefaultConfig
      30  UART_GetEnabledInterrupts
      30  UART_GetInstance
      38  UART_GetReceiveCount
      40  UART_GetRxRingBufferLength
      38  UART_GetSendCount
      28  UART_GetStatusFlags
       2  UART_HandleErrorIRQ
     400  UART_HandleIRQ
     234  UART_Init
      34  UART_IsRxRingBufferFull
      24  UART_ReadBlocking
      20  UART_ReadNonBlocking
     214  UART_ReceiveNonBlocking
      60  UART_SendNonBlocking
     140  UART_SetBaudRate
      38  UART_StartRingBuffer
      42  UART_StopRingBuffer
      24  UART_WriteBlocking
      20  UART_WriteNonBlocking
      24  s_uartBases
      24  s_uartClock
      24  s_uartHandle
       8  s_uartIRQ

 
    24 bytes in section .bss
    56 bytes in section .rodata
 2 046 bytes in section .text
 
 2 046 bytes of CODE  memory
    56 bytes of CONST memory
    24 bytes of DATA  memory

Errors: none
Warnings: 1
