###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:04
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\src\hardware_init_MK22FA12.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\src\hardware_init_MK22FA12.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\hardware_init_MK22FA12.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\hardware_init_MK22FA12.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\src\hardware_init_MK22FA12.c
      1          /*
      2           * Copyright (c) 2013-2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "bootloader_common.h"
     32          #include "bootloader/bl_context.h"
     33          #include "fsl_device_registers.h"
     34          #include "uart/fsl_uart.h"
     35          #include "smc/smc.h"
     36          
     37          ////////////////////////////////////////////////////////////////////////////////
     38          // Definitions
     39          ////////////////////////////////////////////////////////////////////////////////
     40          
     41          #define BOOT_PIN_NUMBER 6
     42          #define BOOT_PIN_PORT PORTC
     43          #define BOOT_PIN_GPIO GPIOC
     44          #define BOOT_PIN_ALT_MODE 1
     45          #define BOOT_PIN_DEBOUNCE_READ_COUNT 500
     46          
     47          #if TURINGSENSE
     48          #define LED_COUNT 3
     49          
     50          #define LED1_OFFSET 10 /* Red */
     51          #define LED2_OFFSET 11 /* Green */
     52          #define LED3_OFFSET 12 /* Blue */
     53          

   \                                 In section .data, align 4
     54          static uint8_t led_offset[LED_COUNT] = { LED1_OFFSET, LED2_OFFSET, LED3_OFFSET};
   \                     led_offset:
   \   00000000   0x0A 0x0B          DC8 10, 11, 12, 0
   \              0x0C 0x00    

   \                                 In section .data, align 4
     55          static PORT_Type *led_port[LED_COUNT] = { PORTA, PORTA, PORTA};
   \                     led_port:
   \   00000000   0x40049000         DC32 40049000H, 40049000H, 40049000H
   \              0x40049000   
   \              0x40049000   

   \                                 In section .data, align 4
     56          static GPIO_Type *led_gpio[LED_COUNT] = { GPIOA, GPIOA, GPIOA};
   \                     led_gpio:
   \   00000000   0x400FF000         DC32 400FF000H, 400FF000H, 400FF000H
   \              0x400FF000   
   \              0x400FF000   
     57          
     58          #endif /* TURINGSENSE */
     59          
     60          ////////////////////////////////////////////////////////////////////////////////
     61          // Variables
     62          ////////////////////////////////////////////////////////////////////////////////
     63          
     64          ////////////////////////////////////////////////////////////////////////////////
     65          // Code
     66          ////////////////////////////////////////////////////////////////////////////////
     67          

   \                                 In section .text, align 2, keep-with-next
     68          void init_hardware(void)
     69          {
   \                     init_hardware: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     70              exit_vlpr();
   \   00000002   0x.... 0x....      BL       exit_vlpr
     71          
     72              // Disable the MPU otherwise USB cannot access the bus
     73              MPU->CESR = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x....             LDR.N    R1,??DataTable6  ;; 0x4000d000
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     74          
     75              // Enable all the ports
     76              SIM->SCGC5 |= (SIM_SCGC5_PORTA_MASK | SIM_SCGC5_PORTB_MASK | SIM_SCGC5_PORTC_MASK | SIM_SCGC5_PORTD_MASK |
     77                             SIM_SCGC5_PORTE_MASK);
   \   0000000C   0x....             LDR.N    R0,??DataTable6_1  ;; 0x40048038
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF450 0x5078      ORRS     R0,R0,#0x3E00
   \   00000014   0x....             LDR.N    R1,??DataTable6_1  ;; 0x40048038
   \   00000016   0x6008             STR      R0,[R1, #+0]
     78          #if TURINGSENSE
     79              uint8_t i;
     80              for (i = 0; i < LED_COUNT; i++)
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x0008             MOVS     R0,R1
   \                     ??init_hardware_0: (+1)
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x2803             CMP      R0,#+3
   \   00000020   0xDA1C             BGE.N    ??init_hardware_1
     81              {
     82                  // Enable the LED pins GPIO
     83                  led_port[i]->PCR[led_offset[i]] = PORT_PCR_MUX(1);
   \   00000022   0x....             LDR.N    R1,??DataTable6_2
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   0000002A   0x....             LDR.N    R2,??DataTable6_3
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x5C12             LDRB     R2,[R2, R0]
   \   00000030   0xF44F 0x7380      MOV      R3,#+256
   \   00000034   0xF841 0x3022      STR      R3,[R1, R2, LSL #+2]
     84                  // Set ports to outputs
     85                  led_gpio[i]->PDDR |= (1 << led_offset[i]);
   \   00000038   0x....             LDR.N    R1,??DataTable6_4
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000040   0x6949             LDR      R1,[R1, #+20]
   \   00000042   0x2201             MOVS     R2,#+1
   \   00000044   0x....             LDR.N    R3,??DataTable6_3
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0x561B             LDRSB    R3,[R3, R0]
   \   0000004A   0x409A             LSLS     R2,R2,R3
   \   0000004C   0x4311             ORRS     R1,R2,R1
   \   0000004E   0x....             LDR.N    R2,??DataTable6_4
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   00000056   0x6151             STR      R1,[R2, #+20]
     86              }
   \   00000058   0x1C40             ADDS     R0,R0,#+1
   \   0000005A   0xE7DF             B.N      ??init_hardware_0
     87          #endif /* TURINGSENSE */
     88          }
   \                     ??init_hardware_1: (+1)
   \   0000005C   0xBD01             POP      {R0,PC}          ;; return
     89          

   \                                 In section .text, align 2, keep-with-next
     90          void deinit_hardware(void)
     91          {
     92              SIM->SCGC5 &= (uint32_t) ~(SIM_SCGC5_PORTA_MASK | SIM_SCGC5_PORTB_MASK | SIM_SCGC5_PORTC_MASK |
     93                                         SIM_SCGC5_PORTD_MASK | SIM_SCGC5_PORTE_MASK);
   \                     deinit_hardware: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable6_1  ;; 0x40048038
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF430 0x5078      BICS     R0,R0,#0x3E00
   \   00000008   0x....             LDR.N    R1,??DataTable6_1  ;; 0x40048038
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     94          
     95              // Restore SIM_SOPTx related bits being changed
     96              SIM->SOPT1 &= (uint32_t)~SIM_SOPT1_USBREGEN_MASK;
   \   0000000C   0x....             LDR.N    R0,??DataTable6_5  ;; 0x40047000
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   00000014   0x....             LDR.N    R1,??DataTable6_5  ;; 0x40047000
   \   00000016   0x6008             STR      R0,[R1, #+0]
     97              SIM->SOPT2 &= (uint32_t) ~(SIM_SOPT2_USBSRC_MASK | SIM_SOPT2_PLLFLLSEL_MASK);
   \   00000018   0x....             LDR.N    R0,??DataTable6_6  ;; 0x40048004
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF430 0x20A0      BICS     R0,R0,#0x50000
   \   00000020   0x....             LDR.N    R1,??DataTable6_6  ;; 0x40048004
   \   00000022   0x6008             STR      R0,[R1, #+0]
     98          }
   \   00000024   0x4770             BX       LR               ;; return
     99          
    100          #if TURINGSENSE
    101          //https://community.nxp.com/thread/433596

   \                                 In section .text, align 2, keep-with-next
    102          bool usb_clock_init(void) {
    103          SIM->SCGC4 &= ~SIM_SCGC4_USBOTG_MASK;
   \                     usb_clock_init: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable6_7  ;; 0x40048034
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   00000008   0x....             LDR.N    R1,??DataTable6_7  ;; 0x40048034
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    104          // SIM->CLKDIV2 = (uint32_t)0x00L;
    105          // SIM->SOPT2 |= SIM_SOPT2_USBSRC_MASK | SIM_SOPT2_PLLFLLSEL(0x03);
    106          //
    107          // SIM->SCGC4 |= SIM_SCGC4_USBOTG_MASK;
    108          //
    109          // USB0->CLK_RECOVER_IRC_EN = 0x03;
    110          // USB0->CLK_RECOVER_CTRL |= USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_MASK;
    111          //
    112          // USB0->CLK_RECOVER_CTRL |= 0x20;
    113          //
    114          // return true;
    115          SIM->CLKDIV2 = (uint32_t)0x00L;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x....             LDR.N    R1,??DataTable6_8  ;; 0x40048048
   \   00000010   0x6008             STR      R0,[R1, #+0]
    116          SIM->SOPT2 |= SIM_SOPT2_USBSRC_MASK | SIM_SOPT2_PLLFLLSEL(0x0);
   \   00000012   0x....             LDR.N    R0,??DataTable6_6  ;; 0x40048004
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF450 0x2080      ORRS     R0,R0,#0x40000
   \   0000001A   0x....             LDR.N    R1,??DataTable6_6  ;; 0x40048004
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    117          SIM->SCGC4 |= SIM_SCGC4_USBOTG_MASK;
   \   0000001E   0x....             LDR.N    R0,??DataTable6_7  ;; 0x40048034
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF450 0x2080      ORRS     R0,R0,#0x40000
   \   00000026   0x....             LDR.N    R1,??DataTable6_7  ;; 0x40048034
   \   00000028   0x6008             STR      R0,[R1, #+0]
    118          SIM->SOPT1 |= (SIM_SOPT1_USBSSTBY_MASK |SIM_SOPT1_USBREGEN_MASK);
   \   0000002A   0x....             LDR.N    R0,??DataTable6_5  ;; 0x40047000
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xF050 0x4040      ORRS     R0,R0,#0xC0000000
   \   00000032   0x....             LDR.N    R1,??DataTable6_5  ;; 0x40047000
   \   00000034   0x6008             STR      R0,[R1, #+0]
    119          // USB0->CLK_RECOVER_IRC_EN = 0x03;
    120          // USB0->CLK_RECOVER_CTRL |= USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_MASK;
    121          //
    122          // USB0->CLK_RECOVER_CTRL |= 0x20;
    123          return true; 
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x4770             BX       LR               ;; return
    124          }
    125          #else
    126          bool usb_clock_init(void)
    127          {
    128              SIM->SCGC4 &= ~SIM_SCGC4_USBOTG_MASK;
    129          
    130              SIM->CLKDIV2 = (uint32_t)0x00L;
    131              SIM->SOPT2 |= SIM_SOPT2_USBSRC_MASK | SIM_SOPT2_PLLFLLSEL(0x03);
    132          
    133              SIM->SCGC4 |= SIM_SCGC4_USBOTG_MASK;
    134          
    135              USB0->CLK_RECOVER_IRC_EN = 0x03;
    136              USB0->CLK_RECOVER_CTRL |= USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_MASK;
    137          
    138              USB0->CLK_RECOVER_CTRL |= 0x20;
    139              
    140              return true;
    141          }
    142          #endif /* TURINGSENSE */
    143          

   \                                 In section .text, align 2, keep-with-next
    144          uint32_t get_bus_clock(void)
    145          {
    146              uint32_t busClockDivider = ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> SIM_CLKDIV1_OUTDIV2_SHIFT) + 1;
   \                     get_bus_clock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable6_9  ;; 0x40048044
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF3C0 0x6003      UBFX     R0,R0,#+24,#+4
   \   00000008   0x1C40             ADDS     R0,R0,#+1
    147              return (SystemCoreClock / busClockDivider);
   \   0000000A   0x....             LDR.N    R1,??DataTable6_10
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \   00000012   0x4770             BX       LR               ;; return
    148          }
    149          

   \                                 In section .text, align 2, keep-with-next
    150          uint32_t get_uart_clock(uint32_t instance)
    151          {
   \                     get_uart_clock: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    152              switch (instance)
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD903             BLS.N    ??get_uart_clock_0
   \   0000000C   0x1E80             SUBS     R0,R0,#+2
   \   0000000E   0x2803             CMP      R0,#+3
   \   00000010   0xD903             BLS.N    ??get_uart_clock_1
   \   00000012   0xE005             B.N      ??get_uart_clock_2
    153              {
    154                  case 0:
    155                  case 1:
    156                      // UART0 and UART1 always use the system clock
    157                      return SystemCoreClock;
   \                     ??get_uart_clock_0: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable6_10
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xE003             B.N      ??get_uart_clock_3
    158                  case 2:
    159                  case 3:
    160                  case 4:
    161                  case 5:
    162                      // UART2, UART3, UART4, and UART5 always use the bus clock
    163                      return get_bus_clock();
   \                     ??get_uart_clock_1: (+1)
   \   0000001A   0x.... 0x....      BL       get_bus_clock
   \   0000001E   0xE000             B.N      ??get_uart_clock_3
    164                  default:
    165                      return 0;
   \                     ??get_uart_clock_2: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \                     ??get_uart_clock_3: (+1)
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    166              }
    167          }
    168          

   \                                 In section .text, align 2, keep-with-next
    169          bool is_boot_pin_asserted(void)
    170          {
    171          #ifdef BL_TARGET_FLASH
    172              // Initialize boot pin for GPIO
    173              BOOT_PIN_PORT->PCR[BOOT_PIN_NUMBER] |= PORT_PCR_MUX(BOOT_PIN_ALT_MODE);
   \                     is_boot_pin_asserted: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable6_11  ;; 0x4004b018
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000008   0x....             LDR.N    R1,??DataTable6_11  ;; 0x4004b018
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    174          
    175              // Set boot pin as an input
    176              BOOT_PIN_GPIO->PDDR &= (uint32_t) ~(1 << BOOT_PIN_NUMBER);
   \   0000000C   0x....             LDR.N    R0,??DataTable6_12  ;; 0x400ff094
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF07F 0x0140      MVNS     R1,#+64
   \   00000014   0x4008             ANDS     R0,R1,R0
   \   00000016   0x....             LDR.N    R1,??DataTable6_12  ;; 0x400ff094
   \   00000018   0x6008             STR      R0,[R1, #+0]
    177              // Set boot pin pullup enabled, pullup select, filter enable
    178              BOOT_PIN_PORT->PCR[BOOT_PIN_NUMBER] |= (PORT_PCR_PE_MASK | PORT_PCR_PS_MASK | PORT_PCR_PFE_MASK);
   \   0000001A   0x....             LDR.N    R0,??DataTable6_11  ;; 0x4004b018
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF050 0x0013      ORRS     R0,R0,#0x13
   \   00000022   0x....             LDR.N    R1,??DataTable6_11  ;; 0x4004b018
   \   00000024   0x6008             STR      R0,[R1, #+0]
    179          
    180              uint32_t readCount = 0;
   \   00000026   0x2000             MOVS     R0,#+0
    181          
    182              // Sample the pin a number of times
    183              for (uint32_t i = 0; i < BOOT_PIN_DEBOUNCE_READ_COUNT; i++)
   \   00000028   0x2100             MOVS     R1,#+0
   \                     ??is_boot_pin_asserted_0: (+1)
   \   0000002A   0xF5B1 0x7FFA      CMP      R1,#+500
   \   0000002E   0xD206             BCS.N    ??is_boot_pin_asserted_1
    184              {
    185                  readCount += ((BOOT_PIN_GPIO->PDIR) >> BOOT_PIN_NUMBER) & 1;
   \   00000030   0x....             LDR.N    R2,??DataTable6_13  ;; 0x400ff090
   \   00000032   0x6812             LDR      R2,[R2, #+0]
   \   00000034   0xF3C2 0x1280      UBFX     R2,R2,#+6,#+1
   \   00000038   0x1810             ADDS     R0,R2,R0
    186              }
   \   0000003A   0x1C49             ADDS     R1,R1,#+1
   \   0000003C   0xE7F5             B.N      ??is_boot_pin_asserted_0
    187          
    188              // boot pin is pulled high so we are measuring lows, make sure most of our measurements
    189              // registered as low
    190              return (readCount < (BOOT_PIN_DEBOUNCE_READ_COUNT / 2));
   \                     ??is_boot_pin_asserted_1: (+1)
   \   0000003E   0x28FA             CMP      R0,#+250
   \   00000040   0xD201             BCS.N    ??is_boot_pin_asserted_2
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xE000             B.N      ??is_boot_pin_asserted_3
   \                     ??is_boot_pin_asserted_2: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??is_boot_pin_asserted_3: (+1)
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x4770             BX       LR               ;; return
    191          #else
    192              // Boot pin for Flash only target
    193              return false;
    194          #endif
    195          }
    196          

   \                                 In section .text, align 2, keep-with-next
    197          void debug_init(void)
    198          {
    199          }
   \                     debug_init: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    200          
    201          #if __ICCARM__
    202          

   \                                 In section .text, align 2, keep-with-next
    203          size_t __write(int handle, const unsigned char *buf, size_t size)
    204          {
   \                     __write: (+1)
   \   00000000   0x0003             MOVS     R3,R0
   \   00000002   0x0010             MOVS     R0,R2
    205              return size;
   \   00000004   0x4770             BX       LR               ;; return
    206          }
    207          
    208          #endif // __ICCARM__
    209          

   \                                 In section .text, align 2, keep-with-next
    210          void update_available_peripherals()
    211          {
    212          }
   \                     update_available_peripherals: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    213          
    214          #if TURINGSENSE

   \                                 In section .text, align 2, keep-with-next
    215          void turnOnWhiteLed() {
    216              uint8_t i = 0;
   \                     turnOnWhiteLed: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
    217              // led ON
    218              for (i = 0; i < LED_COUNT; i++)
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x0008             MOVS     R0,R1
   \                     ??turnOnWhiteLed_0: (+1)
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x2803             CMP      R0,#+3
   \   0000000A   0xDA11             BGE.N    ??turnOnWhiteLed_1
    219              {
    220              	led_gpio[i]->PDOR &= (uint32_t) ~(1 << led_offset[i]);
   \   0000000C   0x....             LDR.N    R1,??DataTable6_4
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x....             LDR.N    R3,??DataTable6_3
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x561B             LDRSB    R3,[R3, R0]
   \   0000001E   0x409A             LSLS     R2,R2,R3
   \   00000020   0x4391             BICS     R1,R1,R2
   \   00000022   0x....             LDR.N    R2,??DataTable6_4
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   0000002A   0x6011             STR      R1,[R2, #+0]
    221              }
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0xE7EA             B.N      ??turnOnWhiteLed_0
    222          }
   \                     ??turnOnWhiteLed_1: (+1)
   \   00000030   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x4000D000         DC32     0x4000d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x40048038         DC32     0x40048038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     led_port

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     led_offset

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     led_gpio

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x40047000         DC32     0x40047000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x40048004         DC32     0x40048004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x40048048         DC32     0x40048048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x40048044         DC32     0x40048044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x........         DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x4004B018         DC32     0x4004b018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x400FF094         DC32     0x400ff094

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   0x400FF090         DC32     0x400ff090
    223          #endif /* TURINGSENSE */
    224          ////////////////////////////////////////////////////////////////////////////////
    225          // EOF
    226          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   __write
       0   debug_init
       0   deinit_hardware
       0   get_bus_clock
       8   get_uart_clock
         8   -> get_bus_clock
       8   init_hardware
         8   -> exit_vlpr
       0   is_boot_pin_asserted
       0   turnOnWhiteLed
       0   update_available_peripherals
       0   usb_clock_init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
       6  __write
       2  debug_init
      38  deinit_hardware
      20  get_bus_clock
      36  get_uart_clock
      94  init_hardware
      76  is_boot_pin_asserted
      12  led_gpio
       4  led_offset
      12  led_port
      50  turnOnWhiteLed
       2  update_available_peripherals
      58  usb_clock_init

 
  28 bytes in section .data
 438 bytes in section .text
 
 438 bytes of CODE memory
  28 bytes of DATA memory

Errors: none
Warnings: none
