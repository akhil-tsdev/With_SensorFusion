###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:23:58
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\security\src\cbc_mac.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\security\src\cbc_mac.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\cbc_mac.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\cbc_mac.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\security\src\cbc_mac.c
      1          /*
      2           * Copyright (c) 2014, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "bootloader_common.h"
     32          #include "security/cbc_mac.h"
     33          #include "security/aes_security.h"
     34          #include "assert.h"
     35          #include <string.h>
     36          
     37          #define CBC_MAC_BLOCK_SIZE 16
     38          #define CBC_MAC_BLOCK_SIZE_WORDS (CBC_MAC_BLOCK_SIZE / sizeof(uint32_t))
     39          

   \                                 In section .bss, align 4
     40          static uint32_t s_iv[CBC_MAC_BLOCK_SIZE_WORDS];
   \                     s_iv:
   \   00000000                      DS8 16

   \                                 In section .bss, align 4
     41          static uint32_t s_cbcKey[AES_128_KEY_SIZE_WORDS];
   \                     s_cbcKey:
   \   00000000                      DS8 16
     42          

   \                                 In section .text, align 2, keep-with-next
     43          void cbc_mac_init(uint8_t *key, uint8_t *iv)
     44          {
   \                     cbc_mac_init: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
     45              if (key)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD007             BEQ.N    ??cbc_mac_init_0
     46              {
     47                  // Save the key
     48                  memcpy(s_cbcKey, key, sizeof(s_cbcKey));
   \   0000000C   0x2610             MOVS     R6,#+16
   \   0000000E   0x....             LDR.N    R7,??DataTable2
   \   00000010   0x0032             MOVS     R2,R6
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0x0038             MOVS     R0,R7
   \   00000016   0x.... 0x....      BL       __aeabi_memcpy
     49              }
   \   0000001A   0xE008             B.N      ??cbc_mac_init_1
     50              else
     51              {
     52                  // Otherwise use a default key of all 0's
     53                  memset(s_cbcKey, 0, sizeof(s_cbcKey));
   \                     ??cbc_mac_init_0: (+1)
   \   0000001C   0x2610             MOVS     R6,#+16
   \   0000001E   0x2700             MOVS     R7,#+0
   \   00000020   0x.... 0x....      LDR.W    R8,??DataTable2
   \   00000024   0x003A             MOVS     R2,R7
   \   00000026   0x0031             MOVS     R1,R6
   \   00000028   0x4640             MOV      R0,R8
   \   0000002A   0x.... 0x....      BL       __aeabi_memset
     54              }
     55          
     56              if (iv)
   \                     ??cbc_mac_init_1: (+1)
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD007             BEQ.N    ??cbc_mac_init_2
     57              {
     58                  // Save the IV
     59                  memcpy(s_iv, iv, sizeof(s_iv));
   \   00000032   0x2610             MOVS     R6,#+16
   \   00000034   0x....             LDR.N    R7,??DataTable2_1
   \   00000036   0x0032             MOVS     R2,R6
   \   00000038   0x0029             MOVS     R1,R5
   \   0000003A   0x0038             MOVS     R0,R7
   \   0000003C   0x.... 0x....      BL       __aeabi_memcpy
     60              }
   \   00000040   0xE008             B.N      ??cbc_mac_init_3
     61              else
     62              {
     63                  // Otherwise use an IV of 0
     64                  memset(s_iv, 0, sizeof(s_iv));
   \                     ??cbc_mac_init_2: (+1)
   \   00000042   0x2610             MOVS     R6,#+16
   \   00000044   0x2700             MOVS     R7,#+0
   \   00000046   0x.... 0x....      LDR.W    R8,??DataTable2_1
   \   0000004A   0x003A             MOVS     R2,R7
   \   0000004C   0x0031             MOVS     R1,R6
   \   0000004E   0x4640             MOV      R0,R8
   \   00000050   0x.... 0x....      BL       __aeabi_memset
     65              }
     66          
     67              aes_init(s_cbcKey);
   \                     ??cbc_mac_init_3: (+1)
   \   00000054   0x....             LDR.N    R0,??DataTable2
   \   00000056   0x.... 0x....      BL       aes_init
     68          }
   \   0000005A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
     69          

   \                                 In section .text, align 2, keep-with-next
     70          void cbc_mac_encrypt(uint8_t *data, uint32_t length, uint8_t *dest)
     71          {
   \                     cbc_mac_encrypt: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x0015             MOVS     R5,R2
     72              assert((length % CBC_BLOCK_SIZE) == 0);
     73              uint32_t numBlocks = length / CBC_BLOCK_SIZE;
   \   0000000A   0x9806             LDR      R0,[SP, #+24]
   \   0000000C   0x0900             LSRS     R0,R0,#+4
   \   0000000E   0x9004             STR      R0,[SP, #+16]
     74              uint32_t i;
     75              uint32_t block[CBC_MAC_BLOCK_SIZE_WORDS];
     76          
     77              for (i = 0; i < numBlocks; i++)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x0006             MOVS     R6,R0
   \                     ??cbc_mac_encrypt_0: (+1)
   \   00000014   0x9804             LDR      R0,[SP, #+16]
   \   00000016   0x4286             CMP      R6,R0
   \   00000018   0xD236             BCS.N    ??cbc_mac_encrypt_1
     78              {
     79                  // copy into block to ensure 32 bit aligned
     80                  memcpy(block, data, sizeof(block));
   \   0000001A   0x2710             MOVS     R7,#+16
   \   0000001C   0x9405             STR      R4,[SP, #+20]
   \   0000001E   0x46E8             MOV      R8,SP
   \   00000020   0x003A             MOVS     R2,R7
   \   00000022   0x9905             LDR      R1,[SP, #+20]
   \   00000024   0x4640             MOV      R0,R8
   \   00000026   0x.... 0x....      BL       __aeabi_memcpy
     81          
     82                  // Before encrypting, XOR the block with the initialization vector
     83                  block[0] ^= s_iv[0];
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
   \   0000002C   0x....             LDR.N    R1,??DataTable2_1
   \   0000002E   0x6809             LDR      R1,[R1, #+0]
   \   00000030   0x4048             EORS     R0,R1,R0
   \   00000032   0x9000             STR      R0,[SP, #+0]
     84                  block[1] ^= s_iv[1];
   \   00000034   0x9801             LDR      R0,[SP, #+4]
   \   00000036   0x....             LDR.N    R1,??DataTable2_1
   \   00000038   0x6849             LDR      R1,[R1, #+4]
   \   0000003A   0x4048             EORS     R0,R1,R0
   \   0000003C   0x9001             STR      R0,[SP, #+4]
     85                  block[2] ^= s_iv[2];
   \   0000003E   0x9802             LDR      R0,[SP, #+8]
   \   00000040   0x....             LDR.N    R1,??DataTable2_1
   \   00000042   0x6889             LDR      R1,[R1, #+8]
   \   00000044   0x4048             EORS     R0,R1,R0
   \   00000046   0x9002             STR      R0,[SP, #+8]
     86                  block[3] ^= s_iv[3];
   \   00000048   0x9803             LDR      R0,[SP, #+12]
   \   0000004A   0x....             LDR.N    R1,??DataTable2_1
   \   0000004C   0x68C9             LDR      R1,[R1, #+12]
   \   0000004E   0x4048             EORS     R0,R1,R0
   \   00000050   0x9003             STR      R0,[SP, #+12]
     87          
     88                  // Encrypt in place
     89                  aes_encrypt(block, s_cbcKey, block);
   \   00000052   0x466A             MOV      R2,SP
   \   00000054   0x....             LDR.N    R1,??DataTable2
   \   00000056   0x4668             MOV      R0,SP
   \   00000058   0x.... 0x....      BL       aes_encrypt
     90          
     91                  // Save the generated cyphertext for the IV to the next block
     92                  memcpy(s_iv, block, sizeof(s_iv));
   \   0000005C   0xF05F 0x0810      MOVS     R8,#+16
   \   00000060   0x46E9             MOV      R9,SP
   \   00000062   0x.... 0x....      LDR.W    R10,??DataTable2_1
   \   00000066   0x4642             MOV      R2,R8
   \   00000068   0x4649             MOV      R1,R9
   \   0000006A   0x4650             MOV      R0,R10
   \   0000006C   0x.... 0x....      BL       __aeabi_memcpy
     93          
     94                  // Copy the data out to the destination
     95                  memcpy(dest, block, sizeof(block));
   \   00000070   0xF05F 0x0A10      MOVS     R10,#+16
   \   00000074   0x46EB             MOV      R11,SP
   \   00000076   0x4652             MOV      R2,R10
   \   00000078   0x4659             MOV      R1,R11
   \   0000007A   0x0028             MOVS     R0,R5
   \   0000007C   0x.... 0x....      BL       __aeabi_memcpy
     96          
     97                  data += CBC_MAC_BLOCK_SIZE;
   \   00000080   0x3410             ADDS     R4,R4,#+16
     98                  dest += CBC_MAC_BLOCK_SIZE;
   \   00000082   0x3510             ADDS     R5,R5,#+16
     99              }
   \   00000084   0x1C76             ADDS     R6,R6,#+1
   \   00000086   0xE7C5             B.N      ??cbc_mac_encrypt_0
    100          }
   \                     ??cbc_mac_encrypt_1: (+1)
   \   00000088   0xB007             ADD      SP,SP,#+28
   \   0000008A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    101          

   \                                 In section .text, align 2, keep-with-next
    102          void cbc_mac_decrypt(uint8_t *data, uint32_t length, uint8_t *dest)
    103          {
   \                     cbc_mac_decrypt: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0xB08C             SUB      SP,SP,#+48
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x0015             MOVS     R5,R2
    104              assert((length % CBC_BLOCK_SIZE) == 0);
    105              uint32_t numBlocks = length / CBC_BLOCK_SIZE;
   \   0000000A   0x980C             LDR      R0,[SP, #+48]
   \   0000000C   0x0900             LSRS     R0,R0,#+4
   \   0000000E   0x9004             STR      R0,[SP, #+16]
    106              uint32_t i;
    107              uint32_t block[CBC_MAC_BLOCK_SIZE_WORDS];
    108              uint32_t tempBlock[CBC_MAC_BLOCK_SIZE_WORDS];
    109          
    110              for (i = 0; i < numBlocks; i++)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x0006             MOVS     R6,R0
   \                     ??cbc_mac_decrypt_0: (+1)
   \   00000014   0x9804             LDR      R0,[SP, #+16]
   \   00000016   0x4286             CMP      R6,R0
   \   00000018   0xD240             BCS.N    ??cbc_mac_decrypt_1
    111              {
    112                  // Save the encrypted text before decrypting
    113                  memcpy(block, data, sizeof(block));
   \   0000001A   0x2010             MOVS     R0,#+16
   \   0000001C   0x9007             STR      R0,[SP, #+28]
   \   0000001E   0x9406             STR      R4,[SP, #+24]
   \   00000020   0xAF08             ADD      R7,SP,#+32
   \   00000022   0x9A07             LDR      R2,[SP, #+28]
   \   00000024   0x9906             LDR      R1,[SP, #+24]
   \   00000026   0x0038             MOVS     R0,R7
   \   00000028   0x.... 0x....      BL       __aeabi_memcpy
    114                  // Copy to tempBlock to ensure 32 bit alignment
    115                  memcpy(tempBlock, data, sizeof(tempBlock));
   \   0000002C   0x2710             MOVS     R7,#+16
   \   0000002E   0x9405             STR      R4,[SP, #+20]
   \   00000030   0x46E8             MOV      R8,SP
   \   00000032   0x003A             MOVS     R2,R7
   \   00000034   0x9905             LDR      R1,[SP, #+20]
   \   00000036   0x4640             MOV      R0,R8
   \   00000038   0x.... 0x....      BL       __aeabi_memcpy
    116          
    117                  // Decrypt in place
    118                  aes_decrypt(tempBlock, s_cbcKey, tempBlock);
   \   0000003C   0x466A             MOV      R2,SP
   \   0000003E   0x....             LDR.N    R1,??DataTable2
   \   00000040   0x4668             MOV      R0,SP
   \   00000042   0x.... 0x....      BL       aes_decrypt
    119          
    120                  // XOR the block with the initialization vector
    121                  tempBlock[0] ^= s_iv[0];
   \   00000046   0x9800             LDR      R0,[SP, #+0]
   \   00000048   0x....             LDR.N    R1,??DataTable2_1
   \   0000004A   0x6809             LDR      R1,[R1, #+0]
   \   0000004C   0x4048             EORS     R0,R1,R0
   \   0000004E   0x9000             STR      R0,[SP, #+0]
    122                  tempBlock[1] ^= s_iv[1];
   \   00000050   0x9801             LDR      R0,[SP, #+4]
   \   00000052   0x....             LDR.N    R1,??DataTable2_1
   \   00000054   0x6849             LDR      R1,[R1, #+4]
   \   00000056   0x4048             EORS     R0,R1,R0
   \   00000058   0x9001             STR      R0,[SP, #+4]
    123                  tempBlock[2] ^= s_iv[2];
   \   0000005A   0x9802             LDR      R0,[SP, #+8]
   \   0000005C   0x....             LDR.N    R1,??DataTable2_1
   \   0000005E   0x6889             LDR      R1,[R1, #+8]
   \   00000060   0x4048             EORS     R0,R1,R0
   \   00000062   0x9002             STR      R0,[SP, #+8]
    124                  tempBlock[3] ^= s_iv[3];
   \   00000064   0x9803             LDR      R0,[SP, #+12]
   \   00000066   0x....             LDR.N    R1,??DataTable2_1
   \   00000068   0x68C9             LDR      R1,[R1, #+12]
   \   0000006A   0x4048             EORS     R0,R1,R0
   \   0000006C   0x9003             STR      R0,[SP, #+12]
    125          
    126                  // Set the saved encrypted text as the IV for the next block
    127                  memcpy(s_iv, block, sizeof(block));
   \   0000006E   0xF05F 0x0810      MOVS     R8,#+16
   \   00000072   0xF10D 0x0920      ADD      R9,SP,#+32
   \   00000076   0x.... 0x....      LDR.W    R10,??DataTable2_1
   \   0000007A   0x4642             MOV      R2,R8
   \   0000007C   0x4649             MOV      R1,R9
   \   0000007E   0x4650             MOV      R0,R10
   \   00000080   0x.... 0x....      BL       __aeabi_memcpy
    128          
    129                  // Copy data back out to the destination
    130                  memcpy(dest, tempBlock, sizeof(tempBlock));
   \   00000084   0xF05F 0x0A10      MOVS     R10,#+16
   \   00000088   0x46EB             MOV      R11,SP
   \   0000008A   0x4652             MOV      R2,R10
   \   0000008C   0x4659             MOV      R1,R11
   \   0000008E   0x0028             MOVS     R0,R5
   \   00000090   0x.... 0x....      BL       __aeabi_memcpy
    131          
    132                  data += CBC_MAC_BLOCK_SIZE;
   \   00000094   0x3410             ADDS     R4,R4,#+16
    133                  dest += CBC_MAC_BLOCK_SIZE;
   \   00000096   0x3510             ADDS     R5,R5,#+16
    134              }
   \   00000098   0x1C76             ADDS     R6,R6,#+1
   \   0000009A   0xE7BB             B.N      ??cbc_mac_decrypt_0
    135          }
   \                     ??cbc_mac_decrypt_1: (+1)
   \   0000009C   0xB00D             ADD      SP,SP,#+52
   \   0000009E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    136          

   \                                 In section .text, align 2, keep-with-next
    137          void cbc_mac_finalize(void)
    138          {
    139          }
   \                     cbc_mac_finalize: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     s_cbcKey

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     s_iv

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      88   cbc_mac_decrypt
        88   -> __aeabi_memcpy
        88   -> aes_decrypt
      64   cbc_mac_encrypt
        64   -> __aeabi_memcpy
        64   -> aes_encrypt
       0   cbc_mac_finalize
      24   cbc_mac_init
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset
        24   -> aes_init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
     162  cbc_mac_decrypt
     142  cbc_mac_encrypt
       2  cbc_mac_finalize
      94  cbc_mac_init
      16  s_cbcKey
      16  s_iv

 
  32 bytes in section .bss
 408 bytes in section .text
 
 408 bytes of CODE memory
  32 bytes of DATA memory

Errors: none
Warnings: none
