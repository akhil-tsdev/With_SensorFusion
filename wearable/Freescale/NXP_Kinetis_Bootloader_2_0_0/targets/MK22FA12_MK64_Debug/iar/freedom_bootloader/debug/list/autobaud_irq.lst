###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:23:52
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\autobaud\src\autobaud_irq.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\autobaud\src\autobaud_irq.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\autobaud_irq.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\autobaud_irq.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\autobaud\src\autobaud_irq.c
      1          /*
      2           * Copyright (c) 2013, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "fsl_device_registers.h"
     32          #include "autobaud/autobaud.h"
     33          #include "microseconds/microseconds.h"
     34          #include "bootloader_common.h"
     35          
     36          ////////////////////////////////////////////////////////////////////////////////
     37          // Definitions
     38          ////////////////////////////////////////////////////////////////////////////////
     39          
     40          enum _autobaud_counts
     41          {
     42              //! the number of falling edge transitions being counted
     43              //! for 0x5A
     44              kFirstByteRequiredFallingEdges = 4,
     45              //! the number of falling edge transitions being counted
     46              //! for 0xA6
     47              kSecondByteRequiredFallingEdges = 3,
     48              //! the number of bits being measured for the baud rate
     49              //! for 0x5A we have the start bit + 7 bits to the last falling edge = 8 bits
     50              kNumberOfBitsForFirstByteMeasured = 8,
     51              //! for 0xA6 we have the start bit + 6 bits to the last falling edge = 7 bits
     52              kNumberOfBitsForSecondByteMeasured = 7,
     53              //! Time in microseconds that we will wait in between toggles before restarting detection
     54              //! Make this value 8 bits at 100 baud worth of time = 80000 microseconds
     55              kMaximumTimeBetweenFallingEdges = 80000,
     56              //! Autobaud baud step size that our calculation will be rounded to, this is to ensure
     57              //! that we can use a valid multiplier in the UART configuration which runs into problems
     58              //! at higher baud rates with slightly off baud rates (e.g. if we measure 115458 vs 115200)
     59              //! a calculation of UartClock at 48MHz gives an SBR calculation of 48000000/ (16 * 115458) = 25
     60              //! giving a baud rate calculation of 48000000/(16 * 25) = 120000 baud
     61              //! which is out of spec and fails
     62              kAutobaudStepSize = 1200
     63          };
     64          
     65          ////////////////////////////////////////////////////////////////////////////////
     66          // Prototypes
     67          ////////////////////////////////////////////////////////////////////////////////
     68          void instance_transition_callback(uint32_t instance);
     69          
     70          ////////////////////////////////////////////////////////////////////////////////
     71          // Variables
     72          ////////////////////////////////////////////////////////////////////////////////
     73          

   \                                 In section .bss, align 4
     74          static uint32_t s_transitionCount;
   \                     s_transitionCount:
   \   00000000                      DS8 4

   \                                 In section .bss, align 8
     75          static uint64_t s_firstByteTotalTicks;
   \                     s_firstByteTotalTicks:
   \   00000000                      DS8 8

   \                                 In section .bss, align 8
     76          static uint64_t s_secondByteTotalTicks;
   \                     s_secondByteTotalTicks:
   \   00000000                      DS8 8

   \                                 In section .bss, align 8
     77          static uint64_t s_lastToggleTicks;
   \                     s_lastToggleTicks:
   \   00000000                      DS8 8

   \                                 In section .bss, align 8
     78          static uint64_t s_ticksBetweenFailure;
   \                     s_ticksBetweenFailure:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
     79          static uint32_t s_instanceMeasured;
   \                     s_instanceMeasured:
   \   00000000                      DS8 4
     80          
     81          ////////////////////////////////////////////////////////////////////////////////
     82          // Code
     83          ////////////////////////////////////////////////////////////////////////////////
     84          

   \                                 In section .text, align 2, keep-with-next
     85          void autobaud_init(uint32_t instance)
     86          {
   \                     autobaud_init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     87              s_transitionCount = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x....             LDR.N    R1,??DataTable2
   \   00000008   0x6008             STR      R0,[R1, #+0]
     88              s_firstByteTotalTicks = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x....             LDR.N    R2,??DataTable2_1
   \   00000010   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
     89              s_secondByteTotalTicks = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x....             LDR.N    R2,??DataTable2_2
   \   0000001A   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
     90              s_lastToggleTicks = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x....             LDR.N    R2,??DataTable2_3
   \   00000024   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
     91              s_instanceMeasured = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x....             LDR.N    R1,??DataTable2_4
   \   0000002C   0x6008             STR      R0,[R1, #+0]
     92              s_ticksBetweenFailure = microseconds_convert_to_ticks(kMaximumTimeBetweenFallingEdges);
   \   0000002E   0x....             LDR.N    R0,??DataTable2_5  ;; 0x13880
   \   00000030   0x.... 0x....      BL       microseconds_convert_to_ticks
   \   00000034   0x....             LDR.N    R2,??DataTable2_6
   \   00000036   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
     93              enable_autobaud_pin_irq(instance, instance_transition_callback);
   \   0000003A   0x.... 0x....      ADR.W    R1,instance_transition_callback
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       enable_autobaud_pin_irq
     94          }
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
     95          

   \                                 In section .text, align 2, keep-with-next
     96          void autobaud_deinit(uint32_t instance)
     97          {
   \                     autobaud_deinit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     98              disable_autobaud_pin_irq(instance);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       disable_autobaud_pin_irq
     99          }
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
    100          

   \                                 In section .text, align 2, keep-with-next
    101          status_t autobaud_get_rate(uint32_t instance, uint32_t *rate)
    102          {
   \                     autobaud_get_rate: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    103              if ((s_transitionCount == (kFirstByteRequiredFallingEdges + kSecondByteRequiredFallingEdges)) &&
    104                  (instance == s_instanceMeasured))
   \   00000006   0x....             LDR.N    R0,??DataTable2
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x2807             CMP      R0,#+7
   \   0000000C   0xD122             BNE.N    ??autobaud_get_rate_0
   \   0000000E   0x....             LDR.N    R0,??DataTable2_4
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD11E             BNE.N    ??autobaud_get_rate_0
    105              {
    106                  uint32_t calculatedBaud =
    107                      (microseconds_get_clock() * (kNumberOfBitsForFirstByteMeasured + kNumberOfBitsForSecondByteMeasured)) /
    108                      (uint32_t)(s_firstByteTotalTicks + s_secondByteTotalTicks);
   \   00000016   0x.... 0x....      BL       microseconds_get_clock
   \   0000001A   0x210F             MOVS     R1,#+15
   \   0000001C   0xFB01 0xF600      MUL      R6,R1,R0
   \   00000020   0x....             LDR.N    R2,??DataTable2_1
   \   00000022   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \   00000026   0x....             LDR.N    R1,??DataTable2_2
   \   00000028   0xE9D1 0x2300      LDRD     R2,R3,[R1, #+0]
   \   0000002C   0x1810             ADDS     R0,R2,R0
   \   0000002E   0xFBB6 0xF1F0      UDIV     R1,R6,R0
    109          
    110                  // Round the rate to the nearest step size
    111                  // rounded = stepSize * (value/stepSize + .5)
    112                  // multiplying by 10 since we can't work with floats
    113                  *rate = ((((calculatedBaud * 10) / kAutobaudStepSize) + 5) / 10) * kAutobaudStepSize;
   \   00000032   0x200A             MOVS     R0,#+10
   \   00000034   0xFB00 0xF001      MUL      R0,R0,R1
   \   00000038   0xF44F 0x6296      MOV      R2,#+1200
   \   0000003C   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \   00000040   0x1D40             ADDS     R0,R0,#+5
   \   00000042   0x220A             MOVS     R2,#+10
   \   00000044   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \   00000048   0xF44F 0x6296      MOV      R2,#+1200
   \   0000004C   0x4350             MULS     R0,R2,R0
   \   0000004E   0x6028             STR      R0,[R5, #+0]
    114          
    115                  return kStatus_Success;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE000             B.N      ??autobaud_get_rate_1
    116              }
    117              else
    118              {
    119                  // no baud rate yet/inactive
    120                  return kStatus_Fail;
   \                     ??autobaud_get_rate_0: (+1)
   \   00000054   0x2001             MOVS     R0,#+1
   \                     ??autobaud_get_rate_1: (+1)
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
    121              }
    122          }
    123          

   \                                 In section .text, align 4, keep-with-next
    124          void instance_transition_callback(uint32_t instance)
    125          {
   \                     instance_transition_callback: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4680             MOV      R8,R0
    126              uint64_t ticks = microseconds_get_ticks();
   \   00000006   0x.... 0x....      BL       microseconds_get_ticks
   \   0000000A   0x0004             MOVS     R4,R0
   \   0000000C   0x000D             MOVS     R5,R1
    127              s_transitionCount++;
   \   0000000E   0x....             LDR.N    R0,??DataTable2
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \   00000014   0x....             LDR.N    R1,??DataTable2
   \   00000016   0x6008             STR      R0,[R1, #+0]
    128          
    129              uint64_t delta = ticks - s_lastToggleTicks;
   \   00000018   0x....             LDR.N    R0,??DataTable2_3
   \   0000001A   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   0000001E   0x1AA6             SUBS     R6,R4,R2
   \   00000020   0xEB75 0x0703      SBCS     R7,R5,R3
    130          
    131              // The last toggle was longer than we allow so treat this as the first one
    132              if (delta > s_ticksBetweenFailure)
   \   00000024   0x....             LDR.N    R0,??DataTable2_6
   \   00000026   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   0000002A   0x42BB             CMP      R3,R7
   \   0000002C   0xD805             BHI.N    ??instance_transition_callback_0
   \   0000002E   0xD301             BCC.N    ??instance_transition_callback_1
   \   00000030   0x42B2             CMP      R2,R6
   \   00000032   0xD202             BCS.N    ??instance_transition_callback_0
    133              {
    134                  s_transitionCount = 1;
   \                     ??instance_transition_callback_1: (+1)
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x....             LDR.N    R1,??DataTable2
   \   00000038   0x6008             STR      R0,[R1, #+0]
    135              }
    136          
    137              switch (s_transitionCount)
   \                     ??instance_transition_callback_0: (+1)
   \   0000003A   0x....             LDR.N    R0,??DataTable2
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xD006             BEQ.N    ??instance_transition_callback_2
   \   00000042   0x2804             CMP      R0,#+4
   \   00000044   0xD00B             BEQ.N    ??instance_transition_callback_3
   \   00000046   0x2805             CMP      R0,#+5
   \   00000048   0xD013             BEQ.N    ??instance_transition_callback_4
   \   0000004A   0x2807             CMP      R0,#+7
   \   0000004C   0xD015             BEQ.N    ??instance_transition_callback_5
   \   0000004E   0xE020             B.N      ??instance_transition_callback_6
    138              {
    139                  case 1:
    140                      // This is our first falling edge, store the initial ticks temporarily in firstByteTicks
    141                      // and save the instance that we are measuring
    142                      s_firstByteTotalTicks = ticks;
   \                     ??instance_transition_callback_2: (+1)
   \   00000050   0x....             LDR.N    R0,??DataTable2_1
   \   00000052   0xE9C0 0x4500      STRD     R4,R5,[R0, #+0]
    143                      s_instanceMeasured = instance;
   \   00000056   0x....             LDR.N    R0,??DataTable2_4
   \   00000058   0xF8C0 0x8000      STR      R8,[R0, #+0]
    144                      break;
   \   0000005C   0xE019             B.N      ??instance_transition_callback_6
    145          
    146                  case kFirstByteRequiredFallingEdges:
    147                      // We reached the end of our measurable first byte, subtract the current ticks from the initial
    148                      // first byte ticks
    149                      s_firstByteTotalTicks = ticks - s_firstByteTotalTicks;
   \                     ??instance_transition_callback_3: (+1)
   \   0000005E   0x....             LDR.N    R0,??DataTable2_1
   \   00000060   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   00000064   0x1AA0             SUBS     R0,R4,R2
   \   00000066   0xEB75 0x0103      SBCS     R1,R5,R3
   \   0000006A   0x....             LDR.N    R2,??DataTable2_1
   \   0000006C   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
    150                      break;
   \   00000070   0xE00F             B.N      ??instance_transition_callback_6
    151          
    152                  case (kFirstByteRequiredFallingEdges + 1):
    153                      // We hit our first falling edge of the second byte, store the initial ticks temporarily in secondByteTicks
    154                      s_secondByteTotalTicks = ticks;
   \                     ??instance_transition_callback_4: (+1)
   \   00000072   0x....             LDR.N    R0,??DataTable2_2
   \   00000074   0xE9C0 0x4500      STRD     R4,R5,[R0, #+0]
    155                      break;
   \   00000078   0xE00B             B.N      ??instance_transition_callback_6
    156          
    157                  case (kFirstByteRequiredFallingEdges + kSecondByteRequiredFallingEdges):
    158                      // We reached the end of our measurable second byte, subtract the current ticks from the initial
    159                      // second byte ticks
    160                      s_secondByteTotalTicks = ticks - s_secondByteTotalTicks;
   \                     ??instance_transition_callback_5: (+1)
   \   0000007A   0x....             LDR.N    R0,??DataTable2_2
   \   0000007C   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   00000080   0x1AA0             SUBS     R0,R4,R2
   \   00000082   0xEB75 0x0103      SBCS     R1,R5,R3
   \   00000086   0x....             LDR.N    R2,??DataTable2_2
   \   00000088   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
    161                      disable_autobaud_pin_irq(instance);
   \   0000008C   0x4640             MOV      R0,R8
   \   0000008E   0x.... 0x....      BL       disable_autobaud_pin_irq
    162                      break;
    163              }
    164          
    165              s_lastToggleTicks = ticks;
   \                     ??instance_transition_callback_6: (+1)
   \   00000092   0x....             LDR.N    R0,??DataTable2_3
   \   00000094   0xE9C0 0x4500      STRD     R4,R5,[R0, #+0]
    166          }
   \   00000098   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     s_transitionCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     s_firstByteTotalTicks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     s_secondByteTotalTicks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     s_lastToggleTicks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x........         DC32     s_instanceMeasured

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x00013880         DC32     0x13880

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x........         DC32     s_ticksBetweenFailure
    167          
    168          ////////////////////////////////////////////////////////////////////////////////
    169          // EOF
    170          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   autobaud_deinit
         8   -> disable_autobaud_pin_irq
      16   autobaud_get_rate
        16   -> microseconds_get_clock
       8   autobaud_init
         8   -> enable_autobaud_pin_irq
         8   -> microseconds_convert_to_ticks
      24   instance_transition_callback
        24   -> disable_autobaud_pin_irq
        24   -> microseconds_get_ticks


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
      12  autobaud_deinit
      88  autobaud_get_rate
      70  autobaud_init
     156  instance_transition_callback
       8  s_firstByteTotalTicks
       4  s_instanceMeasured
       8  s_lastToggleTicks
       8  s_secondByteTotalTicks
       8  s_ticksBetweenFailure
       4  s_transitionCount

 
  40 bytes in section .bss
 354 bytes in section .text
 
 354 bytes of CODE memory
  40 bytes of DATA memory

Errors: none
Warnings: none
