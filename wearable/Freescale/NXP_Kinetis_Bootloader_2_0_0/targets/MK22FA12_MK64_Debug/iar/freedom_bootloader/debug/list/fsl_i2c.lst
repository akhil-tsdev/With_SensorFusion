###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:03
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\i2c\fsl_i2c.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\i2c\fsl_i2c.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\fsl_i2c.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\fsl_i2c.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\i2c\fsl_i2c.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          #include "fsl_i2c.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable13  ;; 0xe000e100
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_EnableClock(clock_ip_name_t)
   \                     CLOCK_EnableClock: (+1)
   \   00000000   0x0C01             LSRS     R1,R0,#+16
   \   00000002   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000006   0xF511 0x218E      ADDS     R1,R1,#+290816
   \   0000000A   0x680A             LDR      R2,[R1, #+0]
   \   0000000C   0x2301             MOVS     R3,#+1
   \   0000000E   0x4083             LSLS     R3,R3,R0
   \   00000010   0x431A             ORRS     R2,R3,R2
   \   00000012   0x600A             STR      R2,[R1, #+0]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_DisableClock(clock_ip_name_t)
   \                     CLOCK_DisableClock: (+1)
   \   00000000   0x0C01             LSRS     R1,R0,#+16
   \   00000002   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000006   0xF511 0x218E      ADDS     R1,R1,#+290816
   \   0000000A   0x680A             LDR      R2,[R1, #+0]
   \   0000000C   0x2301             MOVS     R3,#+1
   \   0000000E   0x4083             LSLS     R3,R3,R0
   \   00000010   0x439A             BICS     R2,R2,R3
   \   00000012   0x600A             STR      R2,[R1, #+0]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void EnableIRQ(IRQn_Type)
   \                     EnableIRQ: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       NVIC_EnableIRQ
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void I2C_Enable(I2C_Type *, bool)
   \                     I2C_Enable: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??I2C_Enable_0
   \   00000006   0x7882             LDRB     R2,[R0, #+2]
   \   00000008   0xF052 0x0280      ORRS     R2,R2,#0x80
   \   0000000C   0x7082             STRB     R2,[R0, #+2]
   \   0000000E   0xE003             B.N      ??I2C_Enable_1
   \                     ??I2C_Enable_0: (+1)
   \   00000010   0x7882             LDRB     R2,[R0, #+2]
   \   00000012   0xF012 0x027F      ANDS     R2,R2,#0x7F
   \   00000016   0x7082             STRB     R2,[R0, #+2]
   \                     ??I2C_Enable_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t I2C_SlaveGetStatusFlags(I2C_Type *)
   \                     I2C_SlaveGetStatusFlags: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       I2C_MasterGetStatusFlags
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void I2C_MasterClearStatusFlags(I2C_Type *, uint32_t)
   \                     I2C_MasterClearStatusFlags: (+1)
   \   00000000   0x04CA             LSLS     R2,R1,#+19
   \   00000002   0xD503             BPL.N    ??I2C_MasterClearStatusFlags_0
   \   00000004   0x7982             LDRB     R2,[R0, #+6]
   \   00000006   0x0A0B             LSRS     R3,R1,#+8
   \   00000008   0x431A             ORRS     R2,R3,R2
   \   0000000A   0x7182             STRB     R2,[R0, #+6]
   \                     ??I2C_MasterClearStatusFlags_0: (+1)
   \   0000000C   0x044A             LSLS     R2,R1,#+17
   \   0000000E   0xD503             BPL.N    ??I2C_MasterClearStatusFlags_1
   \   00000010   0x7982             LDRB     R2,[R0, #+6]
   \   00000012   0x0A0B             LSRS     R3,R1,#+8
   \   00000014   0x431A             ORRS     R2,R3,R2
   \   00000016   0x7182             STRB     R2,[R0, #+6]
   \                     ??I2C_MasterClearStatusFlags_1: (+1)
   \   00000018   0x70C1             STRB     R1,[R0, #+3]
   \   0000001A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void I2C_SlaveClearStatusFlags(I2C_Type *, uint32_t)
   \                     I2C_SlaveClearStatusFlags: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       I2C_MasterClearStatusFlags
   \   0000000E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
     31          
     32          /*******************************************************************************
     33           * Definitions
     34           ******************************************************************************/
     35          
     36          /*! @brief i2c transfer state. */
     37          enum _i2c_transfer_states
     38          {
     39              kIdleState = 0x0U,             /*!< I2C bus idle. */
     40              kCheckAddressState = 0x1U,     /*!< 7-bit address check state. */
     41              kSendCommandState = 0x2U,      /*!< Send command byte phase. */
     42              kSendDataState = 0x3U,         /*!< Send data transfer phase. */
     43              kReceiveDataBeginState = 0x4U, /*!< Receive data transfer phase begin. */
     44              kReceiveDataState = 0x5U,      /*!< Receive data transfer phase. */
     45          };
     46          
     47          /*! @brief Common sets of flags used by the driver. */
     48          enum _i2c_flag_constants
     49          {
     50          /*! All flags which are cleared by the driver upon starting a transfer. */
     51          #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
     52              kClearFlags = kI2C_ArbitrationLostFlag | kI2C_IntPendingFlag | kI2C_StartDetectFlag | kI2C_StopDetectFlag,
     53              kIrqFlags = kI2C_GlobalInterruptEnable | kI2C_StartStopDetectInterruptEnable,
     54          #elif defined(FSL_FEATURE_I2C_HAS_STOP_DETECT) && FSL_FEATURE_I2C_HAS_STOP_DETECT
     55              kClearFlags = kI2C_ArbitrationLostFlag | kI2C_IntPendingFlag | kI2C_StopDetectFlag,
     56              kIrqFlags = kI2C_GlobalInterruptEnable | kI2C_StopDetectInterruptEnable,
     57          #else
     58              kClearFlags = kI2C_ArbitrationLostFlag | kI2C_IntPendingFlag,
     59              kIrqFlags = kI2C_GlobalInterruptEnable,
     60          #endif
     61          
     62          };
     63          
     64          /*! @brief Typedef for interrupt handler. */
     65          typedef void (*i2c_isr_t)(I2C_Type *base, void *i2cHandle);
     66          
     67          /*******************************************************************************
     68           * Prototypes
     69           ******************************************************************************/
     70          
     71          /*!
     72           * @brief Get instance number for I2C module.
     73           *
     74           * @param base I2C peripheral base address.
     75           */
     76          uint32_t I2C_GetInstance(I2C_Type *base);
     77          
     78          /*!
     79           * @brief Set up master transfer, send slave address and decide the initial
     80           * transfer state.
     81           *
     82           * @param base I2C peripheral base address.
     83           * @param handle pointer to i2c_master_handle_t structure which stores the transfer state.
     84           * @param xfer pointer to i2c_master_transfer_t structure.
     85           */
     86          static status_t I2C_InitTransferStateMachine(I2C_Type *base, i2c_master_handle_t *handle, i2c_master_transfer_t *xfer);
     87          
     88          /*!
     89           * @brief Check and clear status operation.
     90           *
     91           * @param base I2C peripheral base address.
     92           * @param status current i2c hardware status.
     93           * @retval kStatus_Success No error found.
     94           * @retval kStatus_I2C_ArbitrationLost Transfer error, arbitration lost.
     95           * @retval kStatus_I2C_Nak Received Nak error.
     96           */
     97          static status_t I2C_CheckAndClearError(I2C_Type *base, uint32_t status);
     98          
     99          /*!
    100           * @brief Master run transfer state machine to perform a byte of transfer.
    101           *
    102           * @param base I2C peripheral base address.
    103           * @param handle pointer to i2c_master_handle_t structure which stores the transfer state
    104           * @param isDone input param to get whether the thing is done, true is done
    105           * @retval kStatus_Success No error found.
    106           * @retval kStatus_I2C_ArbitrationLost Transfer error, arbitration lost.
    107           * @retval kStatus_I2C_Nak Received Nak error.
    108           * @retval kStatus_I2C_Timeout Transfer error, wait signal timeout.
    109           */
    110          static status_t I2C_MasterTransferRunStateMachine(I2C_Type *base, i2c_master_handle_t *handle, bool *isDone);
    111          
    112          /*!
    113           * @brief I2C common interrupt handler.
    114           *
    115           * @param base I2C peripheral base address.
    116           * @param handle pointer to i2c_master_handle_t structure which stores the transfer state
    117           */
    118          static void I2C_TransferCommonIRQHandler(I2C_Type *base, void *handle);
    119          
    120          /*******************************************************************************
    121           * Variables
    122           ******************************************************************************/
    123          
    124          /*! @brief Pointers to i2c handles for each instance. */

   \                                 In section .bss, align 4
    125          static void *s_i2cHandle[FSL_FEATURE_SOC_I2C_COUNT] = {NULL};
   \                     s_i2cHandle:
   \   00000000                      DS8 12
    126          
    127          /*! @brief SCL clock divider used to calculate baudrate. */

   \                                 In section .rodata, align 4
    128          const uint16_t s_i2cDividerTable[] = {20,   22,   24,   26,   28,   30,   34,   40,   28,   32,   36,   40,  44,
   \                     s_i2cDividerTable:
   \   00000000   0x0014 0x0016      DC16 20, 22, 24, 26, 28, 30, 34, 40, 28, 32, 36, 40, 44, 48, 56, 68, 48
   \              0x0018 0x001A
   \              0x001C 0x001E
   \              0x0022 0x0028
   \              0x001C 0x0020
   \              0x0024 0x0028
   \              0x002C 0x0030
   \              0x0038 0x0044
   \              0x0030       
   \   00000022   0x0038 0x0040      DC16 56, 64, 72, 80, 88, 104, 128, 80, 96, 112, 128, 144, 160, 192, 240
   \              0x0048 0x0050
   \              0x0058 0x0068
   \              0x0080 0x0050
   \              0x0060 0x0070
   \              0x0080 0x0090
   \              0x00A0 0x00C0
   \              0x00F0       
   \   00000040   0x00A0 0x00C0      DC16 160, 192, 224, 256, 288, 320, 384, 480, 320, 384, 448, 512, 576
   \              0x00E0 0x0100
   \              0x0120 0x0140
   \              0x0180 0x01E0
   \              0x0140 0x0180
   \              0x01C0 0x0200
   \              0x0240       
   \   0000005A   0x0280 0x0300      DC16 640, 768, 960, 640, 768, 896, 1024, 1152, 1280, 1536, 1920, 1280
   \              0x03C0 0x0280
   \              0x0300 0x0380
   \              0x0400 0x0480
   \              0x0500 0x0600
   \              0x0780 0x0500
   \   00000072   0x0600 0x0700      DC16 1536, 1792, 2048, 2304, 2560, 3072, 3840
   \              0x0800 0x0900
   \              0x0A00 0x0C00
   \              0x0F00       
    129                                                48,   56,   68,   48,   56,   64,   72,   80,   88,   104,  128,  80,  96,
    130                                                112,  128,  144,  160,  192,  240,  160,  192,  224,  256,  288,  320, 384,
    131                                                480,  320,  384,  448,  512,  576,  640,  768,  960,  640,  768,  896, 1024,
    132                                                1152, 1280, 1536, 1920, 1280, 1536, 1792, 2048, 2304, 2560, 3072, 3840};
    133          
    134          /*! @brief Pointers to i2c bases for each instance. */

   \                                 In section .rodata, align 4
    135          static I2C_Type *const s_i2cBases[] = I2C_BASE_PTRS;
   \                     s_i2cBases:
   \   00000000   0x40066000         DC32 40066000H, 40067000H, 400E6000H
   \              0x40067000   
   \              0x400E6000   
    136          
    137          /*! @brief Pointers to i2c IRQ number for each instance. */

   \                                 In section .rodata, align 4
    138          const IRQn_Type s_i2cIrqs[] = I2C_IRQS;
   \                     s_i2cIrqs:
   \   00000000   0x18 0x19          DC8 24, 25, 74, 0
   \              0x4A 0x00    
    139          
    140          /*! @brief Pointers to i2c clocks for each instance. */

   \                                 In section .rodata, align 4
    141          const clock_ip_name_t s_i2cClocks[] = I2C_CLOCKS;
   \                     s_i2cClocks:
   \   00000000   0x10340006         DC32 271843334, 271843335, 271056902
   \              0x10340007   
   \              0x10280006   
    142          
    143          /*! @brief Pointer to master IRQ handler for each instance. */

   \                                 In section .bss, align 4
    144          static i2c_isr_t s_i2cMasterIsr;
   \                     s_i2cMasterIsr:
   \   00000000                      DS8 4
    145          
    146          /*! @brief Pointer to slave IRQ handler for each instance. */

   \                                 In section .bss, align 4
    147          static i2c_isr_t s_i2cSlaveIsr;
   \                     s_i2cSlaveIsr:
   \   00000000                      DS8 4
    148          
    149          /*******************************************************************************
    150           * Codes
    151           ******************************************************************************/
    152          

   \                                 In section .text, align 2, keep-with-next
    153          uint32_t I2C_GetInstance(I2C_Type *base)
    154          {
   \                     I2C_GetInstance: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    155              uint32_t instance;
    156          
    157              /* Find the instance index from base address mappings. */
    158              for (instance = 0; instance < FSL_FEATURE_SOC_I2C_COUNT; instance++)
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x0010             MOVS     R0,R2
   \                     ??I2C_GetInstance_0: (+1)
   \   00000006   0x2803             CMP      R0,#+3
   \   00000008   0xD207             BCS.N    ??I2C_GetInstance_1
    159              {
    160                  if (s_i2cBases[instance] == base)
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable13_1
   \   0000000E   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   00000012   0x428A             CMP      R2,R1
   \   00000014   0xD001             BEQ.N    ??I2C_GetInstance_1
    161                  {
    162                      break;
    163                  }
    164              }
   \                     ??I2C_GetInstance_2: (+1)
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0xE7F5             B.N      ??I2C_GetInstance_0
    165          
    166              assert(instance < FSL_FEATURE_SOC_I2C_COUNT);
    167          
    168              return instance;
   \                     ??I2C_GetInstance_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    169          }
    170          

   \                                 In section .text, align 2, keep-with-next
    171          static status_t I2C_InitTransferStateMachine(I2C_Type *base, i2c_master_handle_t *handle, i2c_master_transfer_t *xfer)
    172          {
   \                     I2C_InitTransferStateMachine: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    173              status_t result = kStatus_Success;
   \   0000000A   0x2700             MOVS     R7,#+0
    174              i2c_direction_t direction = xfer->direction;
   \   0000000C   0xF896 0x8005      LDRB     R8,[R6, #+5]
    175              uint16_t timeout = UINT16_MAX;
   \   00000010   0xF64F 0x79FF      MOVW     R9,#+65535
    176          
    177              /* Initialize the handle transfer information. */
    178              handle->transfer = *xfer;
   \   00000014   0xEC96 0x0B06      VLDM     R6,{D0-D2}
   \   00000018   0xEC85 0x0B06      VSTM     R5,{D0-D2}
    179          
    180              /* Save total transfer size. */
    181              handle->transferSize = xfer->dataSize;
   \   0000001C   0x6970             LDR      R0,[R6, #+20]
   \   0000001E   0x61A8             STR      R0,[R5, #+24]
    182          
    183              /* Initial transfer state. */
    184              if (handle->transfer.subaddressSize > 0)
   \   00000020   0x7B28             LDRB     R0,[R5, #+12]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD007             BEQ.N    ??I2C_InitTransferStateMachine_0
    185              {
    186                  handle->state = kSendCommandState;
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0x7728             STRB     R0,[R5, #+28]
    187                  if (xfer->direction == kI2C_Read)
   \   0000002A   0x7970             LDRB     R0,[R6, #+5]
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD104             BNE.N    ??I2C_InitTransferStateMachine_1
    188                  {
    189                      direction = kI2C_Write;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x4680             MOV      R8,R0
   \   00000034   0xE001             B.N      ??I2C_InitTransferStateMachine_1
    190                  }
    191              }
    192              else
    193              {
    194                  handle->state = kCheckAddressState;
   \                     ??I2C_InitTransferStateMachine_0: (+1)
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x7728             STRB     R0,[R5, #+28]
    195              }
    196          
    197              /* Wait until the data register is ready for transmit. */
    198              while ((!(base->S & kI2C_TransferCompleteFlag)) && (--timeout))
   \                     ??I2C_InitTransferStateMachine_1: (+1)
   \   0000003A   0x78E0             LDRB     R0,[R4, #+3]
   \   0000003C   0x0600             LSLS     R0,R0,#+24
   \   0000003E   0xD406             BMI.N    ??I2C_InitTransferStateMachine_2
   \   00000040   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \   00000044   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000048   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000004C   0xD1F5             BNE.N    ??I2C_InitTransferStateMachine_1
    199              {
    200              }
    201          
    202              /* Failed to start the transfer. */
    203              if (timeout == 0)
   \                     ??I2C_InitTransferStateMachine_2: (+1)
   \   0000004E   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000052   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000056   0xD102             BNE.N    ??I2C_InitTransferStateMachine_3
    204              {
    205                  return kStatus_I2C_Timeout;
   \   00000058   0xF44F 0x608A      MOV      R0,#+1104
   \   0000005C   0xE017             B.N      ??I2C_InitTransferStateMachine_4
    206              }
    207          
    208              /* Clear all status before transfer. */
    209              I2C_MasterClearStatusFlags(base, kClearFlags);
   \                     ??I2C_InitTransferStateMachine_3: (+1)
   \   0000005E   0xF245 0x0112      MOVW     R1,#+20498
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0x.... 0x....      BL       I2C_MasterClearStatusFlags
    210          
    211              /* If repeated start is requested, send repeated start. */
    212              if (handle->transfer.flags & kI2C_TransferRepeatedStartFlag)
   \   00000068   0x7828             LDRB     R0,[R5, #+0]
   \   0000006A   0x0780             LSLS     R0,R0,#+30
   \   0000006C   0xD507             BPL.N    ??I2C_InitTransferStateMachine_5
    213              {
    214                  result = I2C_MasterRepeatedStart(base, handle->transfer.slaveAddress, direction);
   \   0000006E   0x4642             MOV      R2,R8
   \   00000070   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000072   0x7929             LDRB     R1,[R5, #+4]
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       I2C_MasterRepeatedStart
   \   0000007A   0x0007             MOVS     R7,R0
   \   0000007C   0xE006             B.N      ??I2C_InitTransferStateMachine_6
    215              }
    216              else /* For normal transfer, send start. */
    217              {
    218                  result = I2C_MasterStart(base, handle->transfer.slaveAddress, direction);
   \                     ??I2C_InitTransferStateMachine_5: (+1)
   \   0000007E   0x4642             MOV      R2,R8
   \   00000080   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000082   0x7929             LDRB     R1,[R5, #+4]
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       I2C_MasterStart
   \   0000008A   0x0007             MOVS     R7,R0
    219              }
    220          
    221              return result;
   \                     ??I2C_InitTransferStateMachine_6: (+1)
   \   0000008C   0x0038             MOVS     R0,R7
   \                     ??I2C_InitTransferStateMachine_4: (+1)
   \   0000008E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    222          }
    223          

   \                                 In section .text, align 2, keep-with-next
    224          static status_t I2C_CheckAndClearError(I2C_Type *base, uint32_t status)
    225          {
   \                     I2C_CheckAndClearError: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    226              status_t result = kStatus_Success;
   \   00000002   0x2000             MOVS     R0,#+0
    227          
    228              /* Check arbitration lost. */
    229              if (status & kI2C_ArbitrationLostFlag)
   \   00000004   0x06CB             LSLS     R3,R1,#+27
   \   00000006   0xD505             BPL.N    ??I2C_CheckAndClearError_0
    230              {
    231                  /* Clear arbitration lost flag. */
    232                  base->S = kI2C_ArbitrationLostFlag;
   \   00000008   0x2310             MOVS     R3,#+16
   \   0000000A   0x70D3             STRB     R3,[R2, #+3]
    233                  result = kStatus_I2C_ArbitrationLost;
   \   0000000C   0xF240 0x434F      MOVW     R3,#+1103
   \   00000010   0x0018             MOVS     R0,R3
   \   00000012   0xE004             B.N      ??I2C_CheckAndClearError_1
    234              }
    235              /* Check NAK */
    236              else if (status & kI2C_ReceiveNakFlag)
   \                     ??I2C_CheckAndClearError_0: (+1)
   \   00000014   0x07CB             LSLS     R3,R1,#+31
   \   00000016   0xD502             BPL.N    ??I2C_CheckAndClearError_1
    237              {
    238                  result = kStatus_I2C_Nak;
   \   00000018   0xF240 0x434E      MOVW     R3,#+1102
   \   0000001C   0x0018             MOVS     R0,R3
    239              }
    240              else
    241              {
    242              }
    243          
    244              return result;
   \                     ??I2C_CheckAndClearError_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
    245          }
    246          

   \                                 In section .text, align 2, keep-with-next
    247          static status_t I2C_MasterTransferRunStateMachine(I2C_Type *base, i2c_master_handle_t *handle, bool *isDone)
    248          {
   \                     I2C_MasterTransferRunStateMachine: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    249              status_t result = kStatus_Success;
   \   0000000A   0x2700             MOVS     R7,#+0
    250              uint32_t statusFlags = base->S;
   \   0000000C   0xF894 0x8003      LDRB     R8,[R4, #+3]
    251              *isDone = false;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x7030             STRB     R0,[R6, #+0]
    252              volatile uint8_t dummy = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF88D 0x0000      STRB     R0,[SP, #+0]
    253              bool ignoreNak = ((handle->state == kSendDataState) && (handle->transfer.dataSize == 0U)) ||
    254                               ((handle->state == kReceiveDataState) && (handle->transfer.dataSize == 1U));
   \   0000001A   0x7F28             LDRB     R0,[R5, #+28]
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xD102             BNE.N    ??I2C_MasterTransferRunStateMachine_0
   \   00000020   0x6968             LDR      R0,[R5, #+20]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD005             BEQ.N    ??I2C_MasterTransferRunStateMachine_1
   \                     ??I2C_MasterTransferRunStateMachine_0: (+1)
   \   00000026   0x7F28             LDRB     R0,[R5, #+28]
   \   00000028   0x2805             CMP      R0,#+5
   \   0000002A   0xD105             BNE.N    ??I2C_MasterTransferRunStateMachine_2
   \   0000002C   0x6968             LDR      R0,[R5, #+20]
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD102             BNE.N    ??I2C_MasterTransferRunStateMachine_2
   \                     ??I2C_MasterTransferRunStateMachine_1: (+1)
   \   00000032   0xF05F 0x0901      MOVS     R9,#+1
   \   00000036   0xE001             B.N      ??I2C_MasterTransferRunStateMachine_3
   \                     ??I2C_MasterTransferRunStateMachine_2: (+1)
   \   00000038   0xF05F 0x0900      MOVS     R9,#+0
    255          
    256              /* Add this to avoid build warning. */
    257              dummy++;
   \                     ??I2C_MasterTransferRunStateMachine_3: (+1)
   \   0000003C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \   00000042   0xF88D 0x0000      STRB     R0,[SP, #+0]
    258          
    259              /* Check & clear error flags. */
    260              result = I2C_CheckAndClearError(base, statusFlags);
   \   00000046   0x4641             MOV      R1,R8
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       I2C_CheckAndClearError
   \   0000004E   0x0007             MOVS     R7,R0
    261          
    262              /* Ignore Nak when it's appeared for last byte. */
    263              if ((result == kStatus_I2C_Nak) && ignoreNak)
   \   00000050   0xF240 0x404E      MOVW     R0,#+1102
   \   00000054   0x4287             CMP      R7,R0
   \   00000056   0xD106             BNE.N    ??I2C_MasterTransferRunStateMachine_4
   \   00000058   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000005C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000060   0xD001             BEQ.N    ??I2C_MasterTransferRunStateMachine_4
    264              {
    265                  result = kStatus_Success;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x0007             MOVS     R7,R0
    266              }
    267          
    268              if (result)
   \                     ??I2C_MasterTransferRunStateMachine_4: (+1)
   \   00000066   0x2F00             CMP      R7,#+0
   \   00000068   0xD001             BEQ.N    ??I2C_MasterTransferRunStateMachine_5
    269              {
    270                  return result;
   \   0000006A   0x0038             MOVS     R0,R7
   \   0000006C   0xE083             B.N      ??I2C_MasterTransferRunStateMachine_6
    271              }
    272          
    273              /* Handle Check address state to check the slave address is Acked in slave
    274                 probe application. */
    275              if (handle->state == kCheckAddressState)
   \                     ??I2C_MasterTransferRunStateMachine_5: (+1)
   \   0000006E   0x7F28             LDRB     R0,[R5, #+28]
   \   00000070   0x2801             CMP      R0,#+1
   \   00000072   0xD10D             BNE.N    ??I2C_MasterTransferRunStateMachine_7
    276              {
    277                  if (statusFlags & kI2C_ReceiveNakFlag)
   \   00000074   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   00000078   0xD502             BPL.N    ??I2C_MasterTransferRunStateMachine_8
    278                  {
    279                      return kStatus_I2C_Nak;
   \   0000007A   0xF240 0x404E      MOVW     R0,#+1102
   \   0000007E   0xE07A             B.N      ??I2C_MasterTransferRunStateMachine_6
    280                  }
    281                  else
    282                  {
    283                      if (handle->transfer.direction == kI2C_Write)
   \                     ??I2C_MasterTransferRunStateMachine_8: (+1)
   \   00000080   0x7968             LDRB     R0,[R5, #+5]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD102             BNE.N    ??I2C_MasterTransferRunStateMachine_9
    284                      {
    285                          /* Next state, send data. */
    286                          handle->state = kSendDataState;
   \   00000086   0x2003             MOVS     R0,#+3
   \   00000088   0x7728             STRB     R0,[R5, #+28]
   \   0000008A   0xE001             B.N      ??I2C_MasterTransferRunStateMachine_7
    287                      }
    288                      else
    289                      {
    290                          /* Next state, receive data begin. */
    291                          handle->state = kReceiveDataBeginState;
   \                     ??I2C_MasterTransferRunStateMachine_9: (+1)
   \   0000008C   0x2004             MOVS     R0,#+4
   \   0000008E   0x7728             STRB     R0,[R5, #+28]
    292                      }
    293                  }
    294              }
    295          
    296              /* Run state machine. */
    297              switch (handle->state)
   \                     ??I2C_MasterTransferRunStateMachine_7: (+1)
   \   00000090   0x7F28             LDRB     R0,[R5, #+28]
   \   00000092   0x2802             CMP      R0,#+2
   \   00000094   0xD006             BEQ.N    ??I2C_MasterTransferRunStateMachine_10
   \   00000096   0xD36D             BCC.N    ??I2C_MasterTransferRunStateMachine_11
   \   00000098   0x2804             CMP      R0,#+4
   \   0000009A   0xD03B             BEQ.N    ??I2C_MasterTransferRunStateMachine_12
   \   0000009C   0xD32A             BCC.N    ??I2C_MasterTransferRunStateMachine_13
   \   0000009E   0x2805             CMP      R0,#+5
   \   000000A0   0xD049             BEQ.N    ??I2C_MasterTransferRunStateMachine_14
   \   000000A2   0xE067             B.N      ??I2C_MasterTransferRunStateMachine_11
    298              {
    299                  /* Send I2C command. */
    300                  case kSendCommandState:
    301                      if (handle->transfer.subaddressSize)
   \                     ??I2C_MasterTransferRunStateMachine_10: (+1)
   \   000000A4   0x7B28             LDRB     R0,[R5, #+12]
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD009             BEQ.N    ??I2C_MasterTransferRunStateMachine_15
    302                      {
    303                          handle->transfer.subaddressSize--;
   \   000000AA   0x7B28             LDRB     R0,[R5, #+12]
   \   000000AC   0x1E40             SUBS     R0,R0,#+1
   \   000000AE   0x7328             STRB     R0,[R5, #+12]
    304                          base->D = ((handle->transfer.subaddress) >> (8 * handle->transfer.subaddressSize));
   \   000000B0   0x68A8             LDR      R0,[R5, #+8]
   \   000000B2   0x7B29             LDRB     R1,[R5, #+12]
   \   000000B4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B6   0x00C9             LSLS     R1,R1,#+3
   \   000000B8   0x40C8             LSRS     R0,R0,R1
   \   000000BA   0x7120             STRB     R0,[R4, #+4]
   \   000000BC   0xE019             B.N      ??I2C_MasterTransferRunStateMachine_16
    305                      }
    306                      else
    307                      {
    308                          if (handle->transfer.direction == kI2C_Write)
   \                     ??I2C_MasterTransferRunStateMachine_15: (+1)
   \   000000BE   0x7968             LDRB     R0,[R5, #+5]
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD10E             BNE.N    ??I2C_MasterTransferRunStateMachine_17
    309                          {
    310                              /* Next state, send data. */
    311                              handle->state = kSendDataState;
   \   000000C4   0x2003             MOVS     R0,#+3
   \   000000C6   0x7728             STRB     R0,[R5, #+28]
    312          
    313                              /* Send first byte of data. */
    314                              if (handle->transfer.dataSize > 0)
   \   000000C8   0x6968             LDR      R0,[R5, #+20]
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD011             BEQ.N    ??I2C_MasterTransferRunStateMachine_16
    315                              {
    316                                  base->D = *handle->transfer.data;
   \   000000CE   0x6928             LDR      R0,[R5, #+16]
   \   000000D0   0x7800             LDRB     R0,[R0, #+0]
   \   000000D2   0x7120             STRB     R0,[R4, #+4]
    317                                  handle->transfer.data++;
   \   000000D4   0x6928             LDR      R0,[R5, #+16]
   \   000000D6   0x1C40             ADDS     R0,R0,#+1
   \   000000D8   0x6128             STR      R0,[R5, #+16]
    318                                  handle->transfer.dataSize--;
   \   000000DA   0x6968             LDR      R0,[R5, #+20]
   \   000000DC   0x1E40             SUBS     R0,R0,#+1
   \   000000DE   0x6168             STR      R0,[R5, #+20]
   \   000000E0   0xE007             B.N      ??I2C_MasterTransferRunStateMachine_16
    319                              }
    320                          }
    321                          else
    322                          {
    323                              /* Send repeated start and slave address. */
    324                              result = I2C_MasterRepeatedStart(base, handle->transfer.slaveAddress, kI2C_Read);
   \                     ??I2C_MasterTransferRunStateMachine_17: (+1)
   \   000000E2   0x2201             MOVS     R2,#+1
   \   000000E4   0x7929             LDRB     R1,[R5, #+4]
   \   000000E6   0x0020             MOVS     R0,R4
   \   000000E8   0x.... 0x....      BL       I2C_MasterRepeatedStart
   \   000000EC   0x0007             MOVS     R7,R0
    325          
    326                              /* Next state, receive data begin. */
    327                              handle->state = kReceiveDataBeginState;
   \   000000EE   0x2004             MOVS     R0,#+4
   \   000000F0   0x7728             STRB     R0,[R5, #+28]
    328                          }
    329                      }
    330                      break;
   \                     ??I2C_MasterTransferRunStateMachine_16: (+1)
   \   000000F2   0xE03F             B.N      ??I2C_MasterTransferRunStateMachine_18
    331          
    332                  /* Send I2C data. */
    333                  case kSendDataState:
    334                      /* Send one byte of data. */
    335                      if (handle->transfer.dataSize > 0)
   \                     ??I2C_MasterTransferRunStateMachine_13: (+1)
   \   000000F4   0x6968             LDR      R0,[R5, #+20]
   \   000000F6   0x2800             CMP      R0,#+0
   \   000000F8   0xD009             BEQ.N    ??I2C_MasterTransferRunStateMachine_19
    336                      {
    337                          base->D = *handle->transfer.data;
   \   000000FA   0x6928             LDR      R0,[R5, #+16]
   \   000000FC   0x7800             LDRB     R0,[R0, #+0]
   \   000000FE   0x7120             STRB     R0,[R4, #+4]
    338                          handle->transfer.data++;
   \   00000100   0x6928             LDR      R0,[R5, #+16]
   \   00000102   0x1C40             ADDS     R0,R0,#+1
   \   00000104   0x6128             STR      R0,[R5, #+16]
    339                          handle->transfer.dataSize--;
   \   00000106   0x6968             LDR      R0,[R5, #+20]
   \   00000108   0x1E40             SUBS     R0,R0,#+1
   \   0000010A   0x6168             STR      R0,[R5, #+20]
   \   0000010C   0xE001             B.N      ??I2C_MasterTransferRunStateMachine_20
    340                      }
    341                      else
    342                      {
    343                          *isDone = true;
   \                     ??I2C_MasterTransferRunStateMachine_19: (+1)
   \   0000010E   0x2001             MOVS     R0,#+1
   \   00000110   0x7030             STRB     R0,[R6, #+0]
    344                      }
    345                      break;
   \                     ??I2C_MasterTransferRunStateMachine_20: (+1)
   \   00000112   0xE02F             B.N      ??I2C_MasterTransferRunStateMachine_18
    346          
    347                  /* Start I2C data receive. */
    348                  case kReceiveDataBeginState:
    349                      base->C1 &= ~(I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
   \                     ??I2C_MasterTransferRunStateMachine_12: (+1)
   \   00000114   0x78A0             LDRB     R0,[R4, #+2]
   \   00000116   0xF010 0x00E7      ANDS     R0,R0,#0xE7
   \   0000011A   0x70A0             STRB     R0,[R4, #+2]
    350          
    351                      /* Send nak at the last receive byte. */
    352                      if (handle->transfer.dataSize == 1)
   \   0000011C   0x6968             LDR      R0,[R5, #+20]
   \   0000011E   0x2801             CMP      R0,#+1
   \   00000120   0xD103             BNE.N    ??I2C_MasterTransferRunStateMachine_21
    353                      {
    354                          base->C1 |= I2C_C1_TXAK_MASK;
   \   00000122   0x78A0             LDRB     R0,[R4, #+2]
   \   00000124   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000128   0x70A0             STRB     R0,[R4, #+2]
    355                      }
    356          
    357                      /* Read dummy to release the bus. */
    358                      dummy = base->D;
   \                     ??I2C_MasterTransferRunStateMachine_21: (+1)
   \   0000012A   0x7920             LDRB     R0,[R4, #+4]
   \   0000012C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    359          
    360                      /* Next state, receive data. */
    361                      handle->state = kReceiveDataState;
   \   00000130   0x2005             MOVS     R0,#+5
   \   00000132   0x7728             STRB     R0,[R5, #+28]
    362                      break;
   \   00000134   0xE01E             B.N      ??I2C_MasterTransferRunStateMachine_18
    363          
    364                  /* Receive I2C data. */
    365                  case kReceiveDataState:
    366                      /* Receive one byte of data. */
    367                      if (handle->transfer.dataSize--)
   \                     ??I2C_MasterTransferRunStateMachine_14: (+1)
   \   00000136   0x6968             LDR      R0,[R5, #+20]
   \   00000138   0x1E41             SUBS     R1,R0,#+1
   \   0000013A   0x6169             STR      R1,[R5, #+20]
   \   0000013C   0x2800             CMP      R0,#+0
   \   0000013E   0xD018             BEQ.N    ??I2C_MasterTransferRunStateMachine_22
    368                      {
    369                          if (handle->transfer.dataSize == 0)
   \   00000140   0x6968             LDR      R0,[R5, #+20]
   \   00000142   0x2800             CMP      R0,#+0
   \   00000144   0xD108             BNE.N    ??I2C_MasterTransferRunStateMachine_23
    370                          {
    371                              *isDone = true;
   \   00000146   0x2001             MOVS     R0,#+1
   \   00000148   0x7030             STRB     R0,[R6, #+0]
    372          
    373                              /* Send stop if kI2C_TransferNoStop is not asserted. */
    374                              if (!(handle->transfer.flags & kI2C_TransferNoStopFlag))
   \   0000014A   0x7828             LDRB     R0,[R5, #+0]
   \   0000014C   0x0740             LSLS     R0,R0,#+29
   \   0000014E   0xD403             BMI.N    ??I2C_MasterTransferRunStateMachine_23
    375                              {
    376                                  result = I2C_MasterStop(base);
   \   00000150   0x0020             MOVS     R0,R4
   \   00000152   0x.... 0x....      BL       I2C_MasterStop
   \   00000156   0x0007             MOVS     R7,R0
    377                              }
    378                          }
    379          
    380                          /* Send NAK at the last receive byte. */
    381                          if (handle->transfer.dataSize == 1)
   \                     ??I2C_MasterTransferRunStateMachine_23: (+1)
   \   00000158   0x6968             LDR      R0,[R5, #+20]
   \   0000015A   0x2801             CMP      R0,#+1
   \   0000015C   0xD103             BNE.N    ??I2C_MasterTransferRunStateMachine_24
    382                          {
    383                              base->C1 |= I2C_C1_TXAK_MASK;
   \   0000015E   0x78A0             LDRB     R0,[R4, #+2]
   \   00000160   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000164   0x70A0             STRB     R0,[R4, #+2]
    384                          }
    385          
    386                          /* Read the data byte into the transfer buffer. */
    387                          *handle->transfer.data = base->D;
   \                     ??I2C_MasterTransferRunStateMachine_24: (+1)
   \   00000166   0x6928             LDR      R0,[R5, #+16]
   \   00000168   0x7921             LDRB     R1,[R4, #+4]
   \   0000016A   0x7001             STRB     R1,[R0, #+0]
    388                          handle->transfer.data++;
   \   0000016C   0x6928             LDR      R0,[R5, #+16]
   \   0000016E   0x1C40             ADDS     R0,R0,#+1
   \   00000170   0x6128             STR      R0,[R5, #+16]
    389                      }
    390                      break;
   \                     ??I2C_MasterTransferRunStateMachine_22: (+1)
   \   00000172   0xE7FF             B.N      ??I2C_MasterTransferRunStateMachine_18
    391          
    392                  default:
    393                      break;
    394              }
    395          
    396              return result;
   \                     ??I2C_MasterTransferRunStateMachine_11: (+1)
   \                     ??I2C_MasterTransferRunStateMachine_18: (+1)
   \   00000174   0x0038             MOVS     R0,R7
   \                     ??I2C_MasterTransferRunStateMachine_6: (+1)
   \   00000176   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    397          }
    398          

   \                                 In section .text, align 2, keep-with-next
    399          static void I2C_TransferCommonIRQHandler(I2C_Type *base, void *handle)
    400          {
   \                     I2C_TransferCommonIRQHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    401              /* Check if master interrupt. */
    402              if ((base->S & kI2C_ArbitrationLostFlag) || (base->C1 & I2C_C1_MST_MASK))
   \   00000006   0x78E0             LDRB     R0,[R4, #+3]
   \   00000008   0x06C0             LSLS     R0,R0,#+27
   \   0000000A   0xD402             BMI.N    ??I2C_TransferCommonIRQHandler_0
   \   0000000C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000000E   0x0680             LSLS     R0,R0,#+26
   \   00000010   0xD506             BPL.N    ??I2C_TransferCommonIRQHandler_1
    403              {
    404                  s_i2cMasterIsr(base, handle);
   \                     ??I2C_TransferCommonIRQHandler_0: (+1)
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   0000001A   0x6812             LDR      R2,[R2, #+0]
   \   0000001C   0x4790             BLX      R2
   \   0000001E   0xE005             B.N      ??I2C_TransferCommonIRQHandler_2
    405              }
    406              else
    407              {
    408                  s_i2cSlaveIsr(base, handle);
   \                     ??I2C_TransferCommonIRQHandler_1: (+1)
   \   00000020   0x0029             MOVS     R1,R5
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      LDR.W    R2,??DataTable13_3
   \   00000028   0x6812             LDR      R2,[R2, #+0]
   \   0000002A   0x4790             BLX      R2
    409              }
    410          }
   \                     ??I2C_TransferCommonIRQHandler_2: (+1)
   \   0000002C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    411          

   \                                 In section .text, align 2, keep-with-next
    412          void I2C_MasterInit(I2C_Type *base, const i2c_master_config_t *masterConfig, uint32_t srcClock_Hz)
    413          {
   \                     I2C_MasterInit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    414              assert(masterConfig && srcClock_Hz);
    415          
    416              /* Temporary register for filter read. */
    417              uint8_t fltReg;
    418          #if defined(FSL_FEATURE_I2C_HAS_HIGH_DRIVE_SELECTION) && FSL_FEATURE_I2C_HAS_HIGH_DRIVE_SELECTION
    419              uint8_t c2Reg;
    420          #endif
    421          
    422              /* Enable I2C clock. */
    423              CLOCK_EnableClock(s_i2cClocks[I2C_GetInstance(base)]);
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       I2C_GetInstance
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   00000014   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000018   0x.... 0x....      BL       CLOCK_EnableClock
    424          
    425              /* Disable I2C prior to configuring it. */
    426              base->C1 &= ~(I2C_C1_IICEN_MASK);
   \   0000001C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000001E   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000022   0x70A0             STRB     R0,[R4, #+2]
    427          
    428              /* Clear all flags. */
    429              I2C_MasterClearStatusFlags(base, kClearFlags);
   \   00000024   0xF245 0x0112      MOVW     R1,#+20498
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       I2C_MasterClearStatusFlags
    430          
    431              /* Configure baud rate. */
    432              I2C_MasterSetBaudRate(base, masterConfig->baudRate_Bps, srcClock_Hz);
   \   0000002E   0x0032             MOVS     R2,R6
   \   00000030   0x6869             LDR      R1,[R5, #+4]
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       I2C_MasterSetBaudRate
    433          
    434          #if defined(FSL_FEATURE_I2C_HAS_HIGH_DRIVE_SELECTION) && FSL_FEATURE_I2C_HAS_HIGH_DRIVE_SELECTION
    435              /* Configure high drive feature. */
    436              c2Reg = base->C2;
   \   00000038   0x7960             LDRB     R0,[R4, #+5]
   \   0000003A   0x4680             MOV      R8,R0
    437              c2Reg &= ~(I2C_C2_HDRS_MASK);
   \   0000003C   0xF018 0x08DF      ANDS     R8,R8,#0xDF
    438              c2Reg |= I2C_C2_HDRS(masterConfig->enableHighDrive);
   \   00000040   0x7868             LDRB     R0,[R5, #+1]
   \   00000042   0xEA58 0x1840      ORRS     R8,R8,R0, LSL #+5
    439              base->C2 = c2Reg;
   \   00000046   0xF884 0x8005      STRB     R8,[R4, #+5]
    440          #endif
    441          
    442              /* Read out the FLT register. */
    443              fltReg = base->FLT;
   \   0000004A   0x79A0             LDRB     R0,[R4, #+6]
   \   0000004C   0x0007             MOVS     R7,R0
    444          
    445          #if defined(FSL_FEATURE_I2C_HAS_STOP_HOLD_OFF) && FSL_FEATURE_I2C_HAS_STOP_HOLD_OFF
    446              /* Configure the stop / hold enable. */
    447              fltReg &= ~(I2C_FLT_SHEN_MASK);
   \   0000004E   0xF017 0x077F      ANDS     R7,R7,#0x7F
    448              fltReg |= I2C_FLT_SHEN(masterConfig->enableStopHold);
   \   00000052   0x78A8             LDRB     R0,[R5, #+2]
   \   00000054   0xEA57 0x17C0      ORRS     R7,R7,R0, LSL #+7
    449          #endif
    450          
    451              /* Configure the glitch filter value. */
    452              fltReg &= ~(I2C_FLT_FLT_MASK);
   \   00000058   0xF017 0x07F0      ANDS     R7,R7,#0xF0
    453              fltReg |= I2C_FLT_FLT(masterConfig->glitchFilterWidth);
   \   0000005C   0x7A28             LDRB     R0,[R5, #+8]
   \   0000005E   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000062   0x4307             ORRS     R7,R0,R7
    454          
    455              /* Write the register value back to the filter register. */
    456              base->FLT = fltReg;
   \   00000064   0x71A7             STRB     R7,[R4, #+6]
    457          
    458              /* Enable the I2C peripheral based on the configuration. */
    459              base->C1 = I2C_C1_IICEN(masterConfig->enableMaster);
   \   00000066   0x7828             LDRB     R0,[R5, #+0]
   \   00000068   0x01C0             LSLS     R0,R0,#+7
   \   0000006A   0x70A0             STRB     R0,[R4, #+2]
    460          }
   \   0000006C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    461          

   \                                 In section .text, align 2, keep-with-next
    462          void I2C_MasterDeinit(I2C_Type *base)
    463          {
   \                     I2C_MasterDeinit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    464              /* Disable I2C module. */
    465              I2C_Enable(base, false);
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       I2C_Enable
    466          
    467              /* Disable I2C clock. */
    468              CLOCK_DisableClock(s_i2cClocks[I2C_GetInstance(base)]);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       I2C_GetInstance
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   00000016   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   0000001A   0x.... 0x....      BL       CLOCK_DisableClock
    469          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    470          

   \                                 In section .text, align 2, keep-with-next
    471          void I2C_MasterGetDefaultConfig(i2c_master_config_t *masterConfig)
    472          {
    473              assert(masterConfig);
    474          
    475              /* Default baud rate at 100kbps. */
    476              masterConfig->baudRate_Bps = 100000U;
   \                     I2C_MasterGetDefaultConfig: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable13_5  ;; 0x186a0
   \   00000004   0x6041             STR      R1,[R0, #+4]
    477          
    478          /* Default pin high drive is disabled. */
    479          #if defined(FSL_FEATURE_I2C_HAS_HIGH_DRIVE_SELECTION) && FSL_FEATURE_I2C_HAS_HIGH_DRIVE_SELECTION
    480              masterConfig->enableHighDrive = false;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x7041             STRB     R1,[R0, #+1]
    481          #endif
    482          
    483          /* Default stop hold enable is disabled. */
    484          #if defined(FSL_FEATURE_I2C_HAS_STOP_HOLD_OFF) && FSL_FEATURE_I2C_HAS_STOP_HOLD_OFF
    485              masterConfig->enableStopHold = false;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x7081             STRB     R1,[R0, #+2]
    486          #endif
    487          
    488              /* Default glitch filter value is no filter. */
    489              masterConfig->glitchFilterWidth = 0U;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x7201             STRB     R1,[R0, #+8]
    490          
    491              /* Enable the I2C peripheral. */
    492              masterConfig->enableMaster = true;
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x7001             STRB     R1,[R0, #+0]
    493          }
   \   00000016   0x4770             BX       LR               ;; return
    494          

   \                                 In section .text, align 2, keep-with-next
    495          void I2C_EnableInterrupts(I2C_Type *base, uint32_t mask)
    496          {
    497              if (mask & kI2C_GlobalInterruptEnable)
   \                     I2C_EnableInterrupts: (+1)
   \   00000000   0x064A             LSLS     R2,R1,#+25
   \   00000002   0xD503             BPL.N    ??I2C_EnableInterrupts_0
    498              {
    499                  base->C1 |= I2C_C1_IICIE_MASK;
   \   00000004   0x7882             LDRB     R2,[R0, #+2]
   \   00000006   0xF052 0x0240      ORRS     R2,R2,#0x40
   \   0000000A   0x7082             STRB     R2,[R0, #+2]
    500              }
    501          
    502          #if defined(FSL_FEATURE_I2C_HAS_STOP_DETECT) && FSL_FEATURE_I2C_HAS_STOP_DETECT
    503              if (mask & kI2C_StopDetectInterruptEnable)
    504              {
    505                  base->FLT |= I2C_FLT_STOPIE_MASK;
    506              }
    507          #endif /* FSL_FEATURE_I2C_HAS_STOP_DETECT */
    508          
    509          #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
    510              if (mask & kI2C_StartStopDetectInterruptEnable)
   \                     ??I2C_EnableInterrupts_0: (+1)
   \   0000000C   0x068A             LSLS     R2,R1,#+26
   \   0000000E   0xD503             BPL.N    ??I2C_EnableInterrupts_1
    511              {
    512                  base->FLT |= I2C_FLT_SSIE_MASK;
   \   00000010   0x7982             LDRB     R2,[R0, #+6]
   \   00000012   0xF052 0x0220      ORRS     R2,R2,#0x20
   \   00000016   0x7182             STRB     R2,[R0, #+6]
    513              }
    514          #endif /* FSL_FEATURE_I2C_HAS_START_STOP_DETECT */
    515          }
   \                     ??I2C_EnableInterrupts_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    516          

   \                                 In section .text, align 2, keep-with-next
    517          void I2C_DisableInterrupts(I2C_Type *base, uint32_t mask)
    518          {
    519              if (mask & kI2C_GlobalInterruptEnable)
   \                     I2C_DisableInterrupts: (+1)
   \   00000000   0x064A             LSLS     R2,R1,#+25
   \   00000002   0xD503             BPL.N    ??I2C_DisableInterrupts_0
    520              {
    521                  base->C1 &= ~I2C_C1_IICIE_MASK;
   \   00000004   0x7882             LDRB     R2,[R0, #+2]
   \   00000006   0xF012 0x02BF      ANDS     R2,R2,#0xBF
   \   0000000A   0x7082             STRB     R2,[R0, #+2]
    522              }
    523          
    524          #if defined(FSL_FEATURE_I2C_HAS_STOP_DETECT) && FSL_FEATURE_I2C_HAS_STOP_DETECT
    525              if (mask & kI2C_StopDetectInterruptEnable)
    526              {
    527                  base->FLT &= ~I2C_FLT_STOPIE_MASK;
    528              }
    529          #endif /* FSL_FEATURE_I2C_HAS_STOP_DETECT */
    530          
    531          #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
    532              if (mask & kI2C_StartStopDetectInterruptEnable)
   \                     ??I2C_DisableInterrupts_0: (+1)
   \   0000000C   0x068A             LSLS     R2,R1,#+26
   \   0000000E   0xD503             BPL.N    ??I2C_DisableInterrupts_1
    533              {
    534                  base->FLT &= ~I2C_FLT_SSIE_MASK;
   \   00000010   0x7982             LDRB     R2,[R0, #+6]
   \   00000012   0xF012 0x02DF      ANDS     R2,R2,#0xDF
   \   00000016   0x7182             STRB     R2,[R0, #+6]
    535              }
    536          #endif /* FSL_FEATURE_I2C_HAS_START_STOP_DETECT */
    537          }
   \                     ??I2C_DisableInterrupts_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    538          

   \                                 In section .text, align 2, keep-with-next
    539          void I2C_MasterSetBaudRate(I2C_Type *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz)
    540          {
   \                     I2C_MasterSetBaudRate: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
    541              uint32_t multiplier;
    542              uint32_t computedRate;
    543              uint32_t absError;
    544              uint32_t bestError = UINT32_MAX;
   \   00000004   0xF05F 0x36FF      MOVS     R6,#-1
    545              uint32_t bestMult = 0u;
   \   00000008   0x2700             MOVS     R7,#+0
    546              uint32_t bestIcr = 0u;
   \   0000000A   0xF05F 0x0C00      MOVS     R12,#+0
    547              uint8_t mult;
    548              uint8_t i;
    549          
    550              /* Search for the settings with the lowest error. Mult is the MULT field of the I2C_F register,
    551               * and ranges from 0-2. It selects the multiplier factor for the divider. */
    552              for (mult = 0u; (mult <= 2u) && (bestError != 0); ++mult)
   \   0000000E   0xF05F 0x0900      MOVS     R9,#+0
   \   00000012   0x46CE             MOV      LR,R9
   \                     ??I2C_MasterSetBaudRate_0: (+1)
   \   00000014   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \   00000018   0xF1BE 0x0F03      CMP      LR,#+3
   \   0000001C   0xD22F             BCS.N    ??I2C_MasterSetBaudRate_1
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD02D             BEQ.N    ??I2C_MasterSetBaudRate_1
    553              {
    554                  multiplier = 1u << mult;
   \   00000022   0xF05F 0x0901      MOVS     R9,#+1
   \   00000026   0xFA19 0xF90E      LSLS     R9,R9,LR
   \   0000002A   0x464B             MOV      R3,R9
    555          
    556                  /* Scan table to find best match. */
    557                  for (i = 0u; i < sizeof(s_i2cDividerTable) / sizeof(uint16_t); ++i)
   \   0000002C   0xF05F 0x0900      MOVS     R9,#+0
   \   00000030   0x46C8             MOV      R8,R9
   \                     ??I2C_MasterSetBaudRate_2: (+1)
   \   00000032   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000036   0xF1B8 0x0F40      CMP      R8,#+64
   \   0000003A   0xD21D             BCS.N    ??I2C_MasterSetBaudRate_3
    558                  {
    559                      computedRate = srcClock_Hz / (multiplier * s_i2cDividerTable[i]);
   \   0000003C   0x.... 0x....      LDR.W    R9,??DataTable13_6
   \   00000040   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000044   0xF839 0x9018      LDRH     R9,[R9, R8, LSL #+1]
   \   00000048   0xFB09 0xF903      MUL      R9,R9,R3
   \   0000004C   0xFBB2 0xF9F9      UDIV     R9,R2,R9
   \   00000050   0x464C             MOV      R4,R9
    560                      absError = baudRate_Bps > computedRate ? (baudRate_Bps - computedRate) : (computedRate - baudRate_Bps);
   \   00000052   0x428C             CMP      R4,R1
   \   00000054   0xD201             BCS.N    ??I2C_MasterSetBaudRate_4
   \   00000056   0x1B0D             SUBS     R5,R1,R4
   \   00000058   0xE000             B.N      ??I2C_MasterSetBaudRate_5
   \                     ??I2C_MasterSetBaudRate_4: (+1)
   \   0000005A   0x1A65             SUBS     R5,R4,R1
    561          
    562                      if (absError < bestError)
   \                     ??I2C_MasterSetBaudRate_5: (+1)
   \   0000005C   0x42B5             CMP      R5,R6
   \   0000005E   0xD208             BCS.N    ??I2C_MasterSetBaudRate_6
    563                      {
    564                          bestMult = mult;
   \   00000060   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \   00000064   0x4677             MOV      R7,LR
    565                          bestIcr = i;
   \   00000066   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000006A   0x46C4             MOV      R12,R8
    566                          bestError = absError;
   \   0000006C   0x002E             MOVS     R6,R5
    567          
    568                          /* If the error is 0, then we can stop searching because we won't find a better match. */
    569                          if (absError == 0)
   \   0000006E   0x2D00             CMP      R5,#+0
   \   00000070   0xD002             BEQ.N    ??I2C_MasterSetBaudRate_3
    570                          {
    571                              break;
    572                          }
    573                      }
    574                  }
   \                     ??I2C_MasterSetBaudRate_6: (+1)
   \   00000072   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000076   0xE7DC             B.N      ??I2C_MasterSetBaudRate_2
    575              }
   \                     ??I2C_MasterSetBaudRate_3: (+1)
   \   00000078   0xF11E 0x0E01      ADDS     LR,LR,#+1
   \   0000007C   0xE7CA             B.N      ??I2C_MasterSetBaudRate_0
    576          
    577              /* Set frequency register based on best settings. */
    578              base->F = I2C_F_MULT(bestMult) | I2C_F_ICR(bestIcr);
   \                     ??I2C_MasterSetBaudRate_1: (+1)
   \   0000007E   0xF01C 0x093F      ANDS     R9,R12,#0x3F
   \   00000082   0xEA59 0x1987      ORRS     R9,R9,R7, LSL #+6
   \   00000086   0xF880 0x9001      STRB     R9,[R0, #+1]
    579          }
   \   0000008A   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    580          

   \                                 In section .text, align 2, keep-with-next
    581          status_t I2C_MasterStart(I2C_Type *base, uint8_t address, i2c_direction_t direction)
    582          {
   \                     I2C_MasterStart: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    583              status_t result = kStatus_Success;
   \   00000008   0x2700             MOVS     R7,#+0
    584              uint32_t statusFlags = I2C_MasterGetStatusFlags(base);
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       I2C_MasterGetStatusFlags
   \   00000010   0x0001             MOVS     R1,R0
    585          
    586              /* Return an error if the bus is already in use. */
    587              if (statusFlags & kI2C_BusBusyFlag)
   \   00000012   0x0688             LSLS     R0,R1,#+26
   \   00000014   0xD503             BPL.N    ??I2C_MasterStart_0
    588              {
    589                  result = kStatus_I2C_Busy;
   \   00000016   0xF240 0x404C      MOVW     R0,#+1100
   \   0000001A   0x0007             MOVS     R7,R0
   \   0000001C   0xE00C             B.N      ??I2C_MasterStart_1
    590              }
    591              else
    592              {
    593                  /* Send the START signal. */
    594                  base->C1 |= I2C_C1_MST_MASK | I2C_C1_TX_MASK;
   \                     ??I2C_MasterStart_0: (+1)
   \   0000001E   0x78A0             LDRB     R0,[R4, #+2]
   \   00000020   0xF050 0x0030      ORRS     R0,R0,#0x30
   \   00000024   0x70A0             STRB     R0,[R4, #+2]
    595          
    596          #if defined(FSL_FEATURE_I2C_HAS_DOUBLE_BUFFERING) && FSL_FEATURE_I2C_HAS_DOUBLE_BUFFERING
    597                  while (!(base->S2 & I2C_S2_EMPTY_MASK))
    598                  {
    599                  }
    600          #endif /* FSL_FEATURE_I2C_HAS_DOUBLE_BUFFERING */
    601          
    602                  base->D = (((uint32_t)address) << 1U | ((direction == kI2C_Read) ? 1U : 0U));
   \   00000026   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000028   0x2E01             CMP      R6,#+1
   \   0000002A   0xD101             BNE.N    ??I2C_MasterStart_2
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE000             B.N      ??I2C_MasterStart_3
   \                     ??I2C_MasterStart_2: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??I2C_MasterStart_3: (+1)
   \   00000032   0xEA50 0x0045      ORRS     R0,R0,R5, LSL #+1
   \   00000036   0x7120             STRB     R0,[R4, #+4]
    603              }
    604          
    605              return result;
   \                     ??I2C_MasterStart_1: (+1)
   \   00000038   0x0038             MOVS     R0,R7
   \   0000003A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    606          }
    607          

   \                                 In section .text, align 2, keep-with-next
    608          status_t I2C_MasterRepeatedStart(I2C_Type *base, uint8_t address, i2c_direction_t direction)
    609          {
   \                     I2C_MasterRepeatedStart: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    610              status_t result = kStatus_Success;
   \   0000000A   0x2700             MOVS     R7,#+0
    611              uint8_t savedMult;
    612              uint32_t statusFlags = I2C_MasterGetStatusFlags(base);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       I2C_MasterGetStatusFlags
   \   00000012   0x0001             MOVS     R1,R0
    613              uint8_t timeDelay = 6;
   \   00000014   0x2206             MOVS     R2,#+6
    614          
    615              /* Return an error if the bus is already in use, but not by us. */
    616              if ((statusFlags & kI2C_BusBusyFlag) && ((base->C1 & I2C_C1_MST_MASK) == 0))
   \   00000016   0x0688             LSLS     R0,R1,#+26
   \   00000018   0xD506             BPL.N    ??I2C_MasterRepeatedStart_0
   \   0000001A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000001C   0x0680             LSLS     R0,R0,#+26
   \   0000001E   0xD403             BMI.N    ??I2C_MasterRepeatedStart_0
    617              {
    618                  result = kStatus_I2C_Busy;
   \   00000020   0xF240 0x404C      MOVW     R0,#+1100
   \   00000024   0x0007             MOVS     R7,R0
   \   00000026   0xE01A             B.N      ??I2C_MasterRepeatedStart_1
    619              }
    620              else
    621              {
    622                  savedMult = base->F;
   \                     ??I2C_MasterRepeatedStart_0: (+1)
   \   00000028   0x7860             LDRB     R0,[R4, #+1]
   \   0000002A   0x4680             MOV      R8,R0
    623                  base->F = savedMult & (~I2C_F_MULT_MASK);
   \   0000002C   0xF018 0x003F      ANDS     R0,R8,#0x3F
   \   00000030   0x7060             STRB     R0,[R4, #+1]
    624          
    625                  /* We are already in a transfer, so send a repeated start. */
    626                  base->C1 |= I2C_C1_RSTA_MASK;
   \   00000032   0x78A0             LDRB     R0,[R4, #+2]
   \   00000034   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000038   0x70A0             STRB     R0,[R4, #+2]
    627          
    628                  /* Restore the multiplier factor. */
    629                  base->F = savedMult;
   \   0000003A   0xF884 0x8001      STRB     R8,[R4, #+1]
    630          
    631                  /* Add some delay to wait the Re-Start signal. */
    632                  while (timeDelay--)
   \                     ??I2C_MasterRepeatedStart_2: (+1)
   \   0000003E   0x0010             MOVS     R0,R2
   \   00000040   0x1E42             SUBS     R2,R0,#+1
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD001             BEQ.N    ??I2C_MasterRepeatedStart_3
    633                  {
    634                      __NOP();
   \   00000048   0xBF00             Nop      
   \   0000004A   0xE7F8             B.N      ??I2C_MasterRepeatedStart_2
    635                  }
    636          
    637          #if defined(FSL_FEATURE_I2C_HAS_DOUBLE_BUFFERING) && FSL_FEATURE_I2C_HAS_DOUBLE_BUFFERING
    638                  while (!(base->S2 & I2C_S2_EMPTY_MASK))
    639                  {
    640                  }
    641          #endif /* FSL_FEATURE_I2C_HAS_DOUBLE_BUFFERING */
    642          
    643                  base->D = (((uint32_t)address) << 1U | ((direction == kI2C_Read) ? 1U : 0U));
   \                     ??I2C_MasterRepeatedStart_3: (+1)
   \   0000004C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004E   0x2E01             CMP      R6,#+1
   \   00000050   0xD101             BNE.N    ??I2C_MasterRepeatedStart_4
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xE000             B.N      ??I2C_MasterRepeatedStart_5
   \                     ??I2C_MasterRepeatedStart_4: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \                     ??I2C_MasterRepeatedStart_5: (+1)
   \   00000058   0xEA50 0x0045      ORRS     R0,R0,R5, LSL #+1
   \   0000005C   0x7120             STRB     R0,[R4, #+4]
    644              }
    645          
    646              return result;
   \                     ??I2C_MasterRepeatedStart_1: (+1)
   \   0000005E   0x0038             MOVS     R0,R7
   \   00000060   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    647          }
    648          

   \                                 In section .text, align 2, keep-with-next
    649          status_t I2C_MasterStop(I2C_Type *base)
    650          {
   \                     I2C_MasterStop: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    651              status_t result = kStatus_Success;
   \   00000002   0x2000             MOVS     R0,#+0
    652              uint16_t timeout = UINT16_MAX;
   \   00000004   0xF64F 0x72FF      MOVW     R2,#+65535
    653          
    654              /* Issue the STOP command on the bus. */
    655              base->C1 &= ~(I2C_C1_MST_MASK | I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
   \   00000008   0x788B             LDRB     R3,[R1, #+2]
   \   0000000A   0xF013 0x03C7      ANDS     R3,R3,#0xC7
   \   0000000E   0x708B             STRB     R3,[R1, #+2]
    656          
    657              /* Wait until data transfer complete. */
    658              while ((base->S & kI2C_BusBusyFlag) && (--timeout))
   \                     ??I2C_MasterStop_0: (+1)
   \   00000010   0x78CB             LDRB     R3,[R1, #+3]
   \   00000012   0x069B             LSLS     R3,R3,#+26
   \   00000014   0xD503             BPL.N    ??I2C_MasterStop_1
   \   00000016   0x1E52             SUBS     R2,R2,#+1
   \   00000018   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD1F8             BNE.N    ??I2C_MasterStop_0
    659              {
    660              }
    661          
    662              if (timeout == 0)
   \                     ??I2C_MasterStop_1: (+1)
   \   0000001E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000020   0x2A00             CMP      R2,#+0
   \   00000022   0xD102             BNE.N    ??I2C_MasterStop_2
    663              {
    664                  result = kStatus_I2C_Timeout;
   \   00000024   0xF44F 0x638A      MOV      R3,#+1104
   \   00000028   0x0018             MOVS     R0,R3
    665              }
    666          
    667              return result;
   \                     ??I2C_MasterStop_2: (+1)
   \   0000002A   0x4770             BX       LR               ;; return
    668          }
    669          

   \                                 In section .text, align 2, keep-with-next
    670          uint32_t I2C_MasterGetStatusFlags(I2C_Type *base)
    671          {
   \                     I2C_MasterGetStatusFlags: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    672              uint32_t statusFlags = base->S;
   \   00000002   0x78C8             LDRB     R0,[R1, #+3]
    673          
    674          #ifdef I2C_HAS_STOP_DETECT
    675              /* Look up the STOPF bit from the filter register. */
    676              if (base->FLT & I2C_FLT_STOPF_MASK)
   \   00000004   0x798A             LDRB     R2,[R1, #+6]
   \   00000006   0x0652             LSLS     R2,R2,#+25
   \   00000008   0xD501             BPL.N    ??I2C_MasterGetStatusFlags_0
    677              {
    678                  statusFlags |= kI2C_StopDetectFlag;
   \   0000000A   0xF450 0x4080      ORRS     R0,R0,#0x4000
    679              }
    680          #endif
    681          
    682          #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
    683              /* Look up the STARTF bit from the filter register. */
    684              if (base->FLT & I2C_FLT_STARTF_MASK)
   \                     ??I2C_MasterGetStatusFlags_0: (+1)
   \   0000000E   0x798A             LDRB     R2,[R1, #+6]
   \   00000010   0x06D2             LSLS     R2,R2,#+27
   \   00000012   0xD501             BPL.N    ??I2C_MasterGetStatusFlags_1
    685              {
    686                  statusFlags |= kI2C_StartDetectFlag;
   \   00000014   0xF450 0x5080      ORRS     R0,R0,#0x1000
    687              }
    688          #endif /* FSL_FEATURE_I2C_HAS_START_STOP_DETECT */
    689          
    690              return statusFlags;
   \                     ??I2C_MasterGetStatusFlags_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    691          }
    692          

   \                                 In section .text, align 2, keep-with-next
    693          status_t I2C_MasterWriteBlocking(I2C_Type *base, const uint8_t *txBuff, size_t txSize)
    694          {
   \                     I2C_MasterWriteBlocking: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0003             MOVS     R3,R0
    695              status_t result = kStatus_Success;
   \   00000004   0x2000             MOVS     R0,#+0
    696              uint8_t statusFlags = 0;
   \   00000006   0x2400             MOVS     R4,#+0
    697          
    698              /* Wait until the data register is ready for transmit. */
    699              while (!(base->S & kI2C_TransferCompleteFlag))
   \                     ??I2C_MasterWriteBlocking_0: (+1)
   \   00000008   0x78DD             LDRB     R5,[R3, #+3]
   \   0000000A   0x062D             LSLS     R5,R5,#+24
   \   0000000C   0xD5FC             BPL.N    ??I2C_MasterWriteBlocking_0
    700              {
    701              }
    702          
    703              /* Clear the IICIF flag. */
    704              base->S = kI2C_IntPendingFlag;
   \   0000000E   0x2502             MOVS     R5,#+2
   \   00000010   0x70DD             STRB     R5,[R3, #+3]
    705          
    706              /* Setup the I2C peripheral to transmit data. */
    707              base->C1 |= I2C_C1_TX_MASK;
   \   00000012   0x789D             LDRB     R5,[R3, #+2]
   \   00000014   0xF055 0x0510      ORRS     R5,R5,#0x10
   \   00000018   0x709D             STRB     R5,[R3, #+2]
    708          
    709              while (txSize--)
   \                     ??I2C_MasterWriteBlocking_1: (+1)
   \   0000001A   0x0015             MOVS     R5,R2
   \   0000001C   0x1E6A             SUBS     R2,R5,#+1
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD019             BEQ.N    ??I2C_MasterWriteBlocking_2
    710              {
    711                  /* Send a byte of data. */
    712                  base->D = *txBuff++;
   \   00000022   0x780D             LDRB     R5,[R1, #+0]
   \   00000024   0x711D             STRB     R5,[R3, #+4]
   \   00000026   0x1C49             ADDS     R1,R1,#+1
    713          
    714                  /* Wait until data transfer complete. */
    715                  while (!(base->S & kI2C_IntPendingFlag))
   \                     ??I2C_MasterWriteBlocking_3: (+1)
   \   00000028   0x78DD             LDRB     R5,[R3, #+3]
   \   0000002A   0x07AD             LSLS     R5,R5,#+30
   \   0000002C   0xD5FC             BPL.N    ??I2C_MasterWriteBlocking_3
    716                  {
    717                  }
    718          
    719                  statusFlags = base->S;
   \   0000002E   0x78DD             LDRB     R5,[R3, #+3]
   \   00000030   0x002C             MOVS     R4,R5
    720          
    721                  /* Clear the IICIF flag. */
    722                  base->S = kI2C_IntPendingFlag;
   \   00000032   0x2502             MOVS     R5,#+2
   \   00000034   0x70DD             STRB     R5,[R3, #+3]
    723          
    724                  /* Check if arbitration lost or no acknowledgement (NAK), return failure status. */
    725                  if (statusFlags & kI2C_ArbitrationLostFlag)
   \   00000036   0x06E5             LSLS     R5,R4,#+27
   \   00000038   0xD504             BPL.N    ??I2C_MasterWriteBlocking_4
    726                  {
    727                      base->S = kI2C_ArbitrationLostFlag;
   \   0000003A   0x2510             MOVS     R5,#+16
   \   0000003C   0x70DD             STRB     R5,[R3, #+3]
    728                      result = kStatus_I2C_ArbitrationLost;
   \   0000003E   0xF240 0x454F      MOVW     R5,#+1103
   \   00000042   0x0028             MOVS     R0,R5
    729                  }
    730          
    731                  if (statusFlags & kI2C_ReceiveNakFlag)
   \                     ??I2C_MasterWriteBlocking_4: (+1)
   \   00000044   0x07E5             LSLS     R5,R4,#+31
   \   00000046   0xD504             BPL.N    ??I2C_MasterWriteBlocking_5
    732                  {
    733                      base->S = kI2C_ReceiveNakFlag;
   \   00000048   0x2501             MOVS     R5,#+1
   \   0000004A   0x70DD             STRB     R5,[R3, #+3]
    734                      result = kStatus_I2C_Nak;
   \   0000004C   0xF240 0x454E      MOVW     R5,#+1102
   \   00000050   0x0028             MOVS     R0,R5
    735                  }
    736          
    737                  if (result != kStatus_Success)
   \                     ??I2C_MasterWriteBlocking_5: (+1)
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD0E1             BEQ.N    ??I2C_MasterWriteBlocking_1
    738                  {
    739                      /* Breaking out of the send loop. */
    740                      break;
    741                  }
    742              }
    743          
    744              return result;
   \                     ??I2C_MasterWriteBlocking_2: (+1)
   \   00000056   0xBC30             POP      {R4,R5}
   \   00000058   0x4770             BX       LR               ;; return
    745          }
    746          

   \                                 In section .text, align 2, keep-with-next
    747          status_t I2C_MasterReadBlocking(I2C_Type *base, uint8_t *rxBuff, size_t rxSize)
    748          {
   \                     I2C_MasterReadBlocking: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    749              status_t result = kStatus_Success;
   \   00000008   0x2700             MOVS     R7,#+0
    750              volatile uint8_t dummy = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    751          
    752              /* Add this to avoid build warning. */
    753              dummy++;
   \   00000010   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0xF88D 0x0000      STRB     R0,[SP, #+0]
    754          
    755              /* Wait until the data register is ready for transmit. */
    756              while (!(base->S & kI2C_TransferCompleteFlag))
   \                     ??I2C_MasterReadBlocking_0: (+1)
   \   0000001A   0x78E0             LDRB     R0,[R4, #+3]
   \   0000001C   0x0600             LSLS     R0,R0,#+24
   \   0000001E   0xD5FC             BPL.N    ??I2C_MasterReadBlocking_0
    757              {
    758              }
    759          
    760              /* Clear the IICIF flag. */
    761              base->S = kI2C_IntPendingFlag;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x70E0             STRB     R0,[R4, #+3]
    762          
    763              /* Setup the I2C peripheral to receive data. */
    764              base->C1 &= ~(I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
   \   00000024   0x78A0             LDRB     R0,[R4, #+2]
   \   00000026   0xF010 0x00E7      ANDS     R0,R0,#0xE7
   \   0000002A   0x70A0             STRB     R0,[R4, #+2]
    765          
    766              /* If rxSize equals 1, configure to send NAK. */
    767              if (rxSize == 1)
   \   0000002C   0x2E01             CMP      R6,#+1
   \   0000002E   0xD103             BNE.N    ??I2C_MasterReadBlocking_1
    768              {
    769                  /* Issue NACK on read. */
    770                  base->C1 |= I2C_C1_TXAK_MASK;
   \   00000030   0x78A0             LDRB     R0,[R4, #+2]
   \   00000032   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000036   0x70A0             STRB     R0,[R4, #+2]
    771              }
    772          
    773              /* Do dummy read. */
    774              dummy = base->D;
   \                     ??I2C_MasterReadBlocking_1: (+1)
   \   00000038   0x7920             LDRB     R0,[R4, #+4]
   \   0000003A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    775          
    776              while ((rxSize--))
   \                     ??I2C_MasterReadBlocking_2: (+1)
   \   0000003E   0x0030             MOVS     R0,R6
   \   00000040   0x1E46             SUBS     R6,R0,#+1
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD014             BEQ.N    ??I2C_MasterReadBlocking_3
    777              {
    778                  /* Wait until data transfer complete. */
    779                  while (!(base->S & kI2C_IntPendingFlag))
   \                     ??I2C_MasterReadBlocking_4: (+1)
   \   00000046   0x78E0             LDRB     R0,[R4, #+3]
   \   00000048   0x0780             LSLS     R0,R0,#+30
   \   0000004A   0xD5FC             BPL.N    ??I2C_MasterReadBlocking_4
    780                  {
    781                  }
    782          
    783                  /* Clear the IICIF flag. */
    784                  base->S = kI2C_IntPendingFlag;
   \   0000004C   0x2002             MOVS     R0,#+2
   \   0000004E   0x70E0             STRB     R0,[R4, #+3]
    785          
    786                  /* Single byte use case. */
    787                  if (rxSize == 0)
   \   00000050   0x2E00             CMP      R6,#+0
   \   00000052   0xD103             BNE.N    ??I2C_MasterReadBlocking_5
    788                  {
    789                      /* Read the final byte. */
    790                      result = I2C_MasterStop(base);
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       I2C_MasterStop
   \   0000005A   0x0007             MOVS     R7,R0
    791                  }
    792          
    793                  if (rxSize == 1)
   \                     ??I2C_MasterReadBlocking_5: (+1)
   \   0000005C   0x2E01             CMP      R6,#+1
   \   0000005E   0xD103             BNE.N    ??I2C_MasterReadBlocking_6
    794                  {
    795                      /* Issue NACK on read. */
    796                      base->C1 |= I2C_C1_TXAK_MASK;
   \   00000060   0x78A0             LDRB     R0,[R4, #+2]
   \   00000062   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000066   0x70A0             STRB     R0,[R4, #+2]
    797                  }
    798          
    799                  /* Read from the data register. */
    800                  *rxBuff++ = base->D;
   \                     ??I2C_MasterReadBlocking_6: (+1)
   \   00000068   0x7920             LDRB     R0,[R4, #+4]
   \   0000006A   0x7028             STRB     R0,[R5, #+0]
   \   0000006C   0x1C6D             ADDS     R5,R5,#+1
   \   0000006E   0xE7E6             B.N      ??I2C_MasterReadBlocking_2
    801              }
    802          
    803              return result;
   \                     ??I2C_MasterReadBlocking_3: (+1)
   \   00000070   0x0038             MOVS     R0,R7
   \   00000072   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    804          }
    805          

   \                                 In section .text, align 2, keep-with-next
    806          status_t I2C_MasterTransferBlocking(I2C_Type *base, i2c_master_transfer_t *xfer)
    807          {
   \                     I2C_MasterTransferBlocking: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    808              assert(xfer);
    809          
    810              i2c_direction_t direction = xfer->direction;
   \   00000006   0x796E             LDRB     R6,[R5, #+5]
    811              status_t result = kStatus_Success;
   \   00000008   0x2700             MOVS     R7,#+0
    812          
    813              /* Clear all status before transfer. */
    814              I2C_MasterClearStatusFlags(base, kClearFlags);
   \   0000000A   0xF245 0x0112      MOVW     R1,#+20498
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       I2C_MasterClearStatusFlags
    815          
    816              /* Wait until ready to complete. */
    817              while (!(base->S & kI2C_TransferCompleteFlag))
   \                     ??I2C_MasterTransferBlocking_0: (+1)
   \   00000014   0x78E0             LDRB     R0,[R4, #+3]
   \   00000016   0x0600             LSLS     R0,R0,#+24
   \   00000018   0xD5FC             BPL.N    ??I2C_MasterTransferBlocking_0
    818              {
    819              }
    820          
    821              /* Change to send write address when it's a read operation with command. */
    822              if ((xfer->subaddressSize > 0) && (xfer->direction == kI2C_Read))
   \   0000001A   0x7B28             LDRB     R0,[R5, #+12]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD004             BEQ.N    ??I2C_MasterTransferBlocking_1
   \   00000020   0x7968             LDRB     R0,[R5, #+5]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD101             BNE.N    ??I2C_MasterTransferBlocking_1
    823              {
    824                  direction = kI2C_Write;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x0006             MOVS     R6,R0
    825              }
    826          
    827              /* If repeated start is requested, send repeated start. */
    828              if (xfer->flags & kI2C_TransferRepeatedStartFlag)
   \                     ??I2C_MasterTransferBlocking_1: (+1)
   \   0000002A   0x7828             LDRB     R0,[R5, #+0]
   \   0000002C   0x0780             LSLS     R0,R0,#+30
   \   0000002E   0xD507             BPL.N    ??I2C_MasterTransferBlocking_2
    829              {
    830                  result = I2C_MasterRepeatedStart(base, xfer->slaveAddress, direction);
   \   00000030   0x0032             MOVS     R2,R6
   \   00000032   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000034   0x7929             LDRB     R1,[R5, #+4]
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       I2C_MasterRepeatedStart
   \   0000003C   0x0007             MOVS     R7,R0
   \   0000003E   0xE006             B.N      ??I2C_MasterTransferBlocking_3
    831              }
    832              else /* For normal transfer, send start. */
    833              {
    834                  result = I2C_MasterStart(base, xfer->slaveAddress, direction);
   \                     ??I2C_MasterTransferBlocking_2: (+1)
   \   00000040   0x0032             MOVS     R2,R6
   \   00000042   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000044   0x7929             LDRB     R1,[R5, #+4]
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       I2C_MasterStart
   \   0000004C   0x0007             MOVS     R7,R0
    835              }
    836          
    837              /* Return if error. */
    838              if (result)
   \                     ??I2C_MasterTransferBlocking_3: (+1)
   \   0000004E   0x2F00             CMP      R7,#+0
   \   00000050   0xD001             BEQ.N    ??I2C_MasterTransferBlocking_4
    839              {
    840                  return result;
   \   00000052   0x0038             MOVS     R0,R7
   \   00000054   0xE082             B.N      ??I2C_MasterTransferBlocking_5
    841              }
    842          
    843              /* Send subaddress. */
    844              if (xfer->subaddressSize)
   \                     ??I2C_MasterTransferBlocking_4: (+1)
   \   00000056   0x7B28             LDRB     R0,[R5, #+12]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD044             BEQ.N    ??I2C_MasterTransferBlocking_6
    845              {
    846                  do
    847                  {
    848                      /* Wait until data transfer complete. */
    849                      while (!(base->S & kI2C_IntPendingFlag))
   \                     ??I2C_MasterTransferBlocking_7: (+1)
   \   0000005C   0x78E0             LDRB     R0,[R4, #+3]
   \   0000005E   0x0780             LSLS     R0,R0,#+30
   \   00000060   0xD5FC             BPL.N    ??I2C_MasterTransferBlocking_7
    850                      {
    851                      }
    852          
    853                      /* Clear interrupt pending flag. */
    854                      base->S = kI2C_IntPendingFlag;
   \   00000062   0x2002             MOVS     R0,#+2
   \   00000064   0x70E0             STRB     R0,[R4, #+3]
    855          
    856                      /* Check if there's transfer error. */
    857                      result = I2C_CheckAndClearError(base, base->S);
   \   00000066   0x78E1             LDRB     R1,[R4, #+3]
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x.... 0x....      BL       I2C_CheckAndClearError
   \   0000006E   0x0007             MOVS     R7,R0
    858          
    859                      if (result)
   \   00000070   0x2F00             CMP      R7,#+0
   \   00000072   0xD008             BEQ.N    ??I2C_MasterTransferBlocking_8
    860                      {
    861                          if (result == kStatus_I2C_Nak)
   \   00000074   0xF240 0x404E      MOVW     R0,#+1102
   \   00000078   0x4287             CMP      R7,R0
   \   0000007A   0xD102             BNE.N    ??I2C_MasterTransferBlocking_9
    862                          {
    863                              I2C_MasterStop(base);
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0x.... 0x....      BL       I2C_MasterStop
    864                          }
    865          
    866                          return result;
   \                     ??I2C_MasterTransferBlocking_9: (+1)
   \   00000082   0x0038             MOVS     R0,R7
   \   00000084   0xE06A             B.N      ??I2C_MasterTransferBlocking_5
    867                      }
    868          
    869                      xfer->subaddressSize--;
   \                     ??I2C_MasterTransferBlocking_8: (+1)
   \   00000086   0x7B28             LDRB     R0,[R5, #+12]
   \   00000088   0x1E40             SUBS     R0,R0,#+1
   \   0000008A   0x7328             STRB     R0,[R5, #+12]
    870                      base->D = ((xfer->subaddress) >> (8 * xfer->subaddressSize));
   \   0000008C   0x68A8             LDR      R0,[R5, #+8]
   \   0000008E   0x7B29             LDRB     R1,[R5, #+12]
   \   00000090   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000092   0x00C9             LSLS     R1,R1,#+3
   \   00000094   0x40C8             LSRS     R0,R0,R1
   \   00000096   0x7120             STRB     R0,[R4, #+4]
    871          
    872                  } while ((xfer->subaddressSize > 0) && (result == kStatus_Success));
   \   00000098   0x7B28             LDRB     R0,[R5, #+12]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD001             BEQ.N    ??I2C_MasterTransferBlocking_10
   \   0000009E   0x2F00             CMP      R7,#+0
   \   000000A0   0xD0DC             BEQ.N    ??I2C_MasterTransferBlocking_7
    873          
    874                  if (xfer->direction == kI2C_Read)
   \                     ??I2C_MasterTransferBlocking_10: (+1)
   \   000000A2   0x7968             LDRB     R0,[R5, #+5]
   \   000000A4   0x2801             CMP      R0,#+1
   \   000000A6   0xD11E             BNE.N    ??I2C_MasterTransferBlocking_6
    875                  {
    876                      /* Wait until data transfer complete. */
    877                      while (!(base->S & kI2C_IntPendingFlag))
   \                     ??I2C_MasterTransferBlocking_11: (+1)
   \   000000A8   0x78E0             LDRB     R0,[R4, #+3]
   \   000000AA   0x0780             LSLS     R0,R0,#+30
   \   000000AC   0xD5FC             BPL.N    ??I2C_MasterTransferBlocking_11
    878                      {
    879                      }
    880          
    881                      /* Clear pending flag. */
    882                      base->S = kI2C_IntPendingFlag;
   \   000000AE   0x2002             MOVS     R0,#+2
   \   000000B0   0x70E0             STRB     R0,[R4, #+3]
    883          
    884                      /* Check if there's transfer error. */
    885                      result = I2C_CheckAndClearError(base, base->S);
   \   000000B2   0x78E1             LDRB     R1,[R4, #+3]
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0x.... 0x....      BL       I2C_CheckAndClearError
   \   000000BA   0x0007             MOVS     R7,R0
    886          
    887                      if (result)
   \   000000BC   0x2F00             CMP      R7,#+0
   \   000000BE   0xD008             BEQ.N    ??I2C_MasterTransferBlocking_12
    888                      {
    889                          if (result == kStatus_I2C_Nak)
   \   000000C0   0xF240 0x404E      MOVW     R0,#+1102
   \   000000C4   0x4287             CMP      R7,R0
   \   000000C6   0xD102             BNE.N    ??I2C_MasterTransferBlocking_13
    890                          {
    891                              I2C_MasterStop(base);
   \   000000C8   0x0020             MOVS     R0,R4
   \   000000CA   0x.... 0x....      BL       I2C_MasterStop
    892                          }
    893          
    894                          return result;
   \                     ??I2C_MasterTransferBlocking_13: (+1)
   \   000000CE   0x0038             MOVS     R0,R7
   \   000000D0   0xE044             B.N      ??I2C_MasterTransferBlocking_5
    895                      }
    896          
    897                      /* Send repeated start and slave address. */
    898                      result = I2C_MasterRepeatedStart(base, xfer->slaveAddress, kI2C_Read);
   \                     ??I2C_MasterTransferBlocking_12: (+1)
   \   000000D2   0x2201             MOVS     R2,#+1
   \   000000D4   0x7929             LDRB     R1,[R5, #+4]
   \   000000D6   0x0020             MOVS     R0,R4
   \   000000D8   0x.... 0x....      BL       I2C_MasterRepeatedStart
   \   000000DC   0x0007             MOVS     R7,R0
    899          
    900                      /* Return if error. */
    901                      if (result)
   \   000000DE   0x2F00             CMP      R7,#+0
   \   000000E0   0xD001             BEQ.N    ??I2C_MasterTransferBlocking_6
    902                      {
    903                          return result;
   \   000000E2   0x0038             MOVS     R0,R7
   \   000000E4   0xE03A             B.N      ??I2C_MasterTransferBlocking_5
    904                      }
    905                  }
    906              }
    907          
    908              /* Wait until address + command transfer complete. */
    909              while (!(base->S & kI2C_IntPendingFlag))
   \                     ??I2C_MasterTransferBlocking_6: (+1)
   \   000000E6   0x78E0             LDRB     R0,[R4, #+3]
   \   000000E8   0x0780             LSLS     R0,R0,#+30
   \   000000EA   0xD5FC             BPL.N    ??I2C_MasterTransferBlocking_6
    910              {
    911              }
    912          
    913              /* Check if there's transfer error. */
    914              result = I2C_CheckAndClearError(base, base->S);
   \   000000EC   0x78E1             LDRB     R1,[R4, #+3]
   \   000000EE   0x0020             MOVS     R0,R4
   \   000000F0   0x.... 0x....      BL       I2C_CheckAndClearError
   \   000000F4   0x0007             MOVS     R7,R0
    915          
    916              /* Return if error. */
    917              if (result)
   \   000000F6   0x2F00             CMP      R7,#+0
   \   000000F8   0xD008             BEQ.N    ??I2C_MasterTransferBlocking_14
    918              {
    919                  if (result == kStatus_I2C_Nak)
   \   000000FA   0xF240 0x404E      MOVW     R0,#+1102
   \   000000FE   0x4287             CMP      R7,R0
   \   00000100   0xD102             BNE.N    ??I2C_MasterTransferBlocking_15
    920                  {
    921                      I2C_MasterStop(base);
   \   00000102   0x0020             MOVS     R0,R4
   \   00000104   0x.... 0x....      BL       I2C_MasterStop
    922                  }
    923          
    924                  return result;
   \                     ??I2C_MasterTransferBlocking_15: (+1)
   \   00000108   0x0038             MOVS     R0,R7
   \   0000010A   0xE027             B.N      ??I2C_MasterTransferBlocking_5
    925              }
    926          
    927              /* Transmit data. */
    928              if ((xfer->direction == kI2C_Write) && (xfer->dataSize > 0))
   \                     ??I2C_MasterTransferBlocking_14: (+1)
   \   0000010C   0x7968             LDRB     R0,[R5, #+5]
   \   0000010E   0x2800             CMP      R0,#+0
   \   00000110   0xD117             BNE.N    ??I2C_MasterTransferBlocking_16
   \   00000112   0x6968             LDR      R0,[R5, #+20]
   \   00000114   0x2800             CMP      R0,#+0
   \   00000116   0xD014             BEQ.N    ??I2C_MasterTransferBlocking_16
    929              {
    930                  /* Send Data. */
    931                  result = I2C_MasterWriteBlocking(base, xfer->data, xfer->dataSize);
   \   00000118   0x696A             LDR      R2,[R5, #+20]
   \   0000011A   0x6929             LDR      R1,[R5, #+16]
   \   0000011C   0x0020             MOVS     R0,R4
   \   0000011E   0x.... 0x....      BL       I2C_MasterWriteBlocking
   \   00000122   0x0007             MOVS     R7,R0
    932          
    933                  if (((result == kStatus_Success) && (!(xfer->flags & kI2C_TransferNoStopFlag))) || (result == kStatus_I2C_Nak))
   \   00000124   0x2F00             CMP      R7,#+0
   \   00000126   0xD102             BNE.N    ??I2C_MasterTransferBlocking_17
   \   00000128   0x7828             LDRB     R0,[R5, #+0]
   \   0000012A   0x0740             LSLS     R0,R0,#+29
   \   0000012C   0xD503             BPL.N    ??I2C_MasterTransferBlocking_18
   \                     ??I2C_MasterTransferBlocking_17: (+1)
   \   0000012E   0xF240 0x404E      MOVW     R0,#+1102
   \   00000132   0x4287             CMP      R7,R0
   \   00000134   0xD105             BNE.N    ??I2C_MasterTransferBlocking_16
    934                  {
    935                      /* Clear the IICIF flag. */
    936                      base->S = kI2C_IntPendingFlag;
   \                     ??I2C_MasterTransferBlocking_18: (+1)
   \   00000136   0x2002             MOVS     R0,#+2
   \   00000138   0x70E0             STRB     R0,[R4, #+3]
    937          
    938                      /* Send stop. */
    939                      result = I2C_MasterStop(base);
   \   0000013A   0x0020             MOVS     R0,R4
   \   0000013C   0x.... 0x....      BL       I2C_MasterStop
   \   00000140   0x0007             MOVS     R7,R0
    940                  }
    941              }
    942          
    943              /* Receive Data. */
    944              if ((xfer->direction == kI2C_Read) && (xfer->dataSize > 0))
   \                     ??I2C_MasterTransferBlocking_16: (+1)
   \   00000142   0x7968             LDRB     R0,[R5, #+5]
   \   00000144   0x2801             CMP      R0,#+1
   \   00000146   0xD108             BNE.N    ??I2C_MasterTransferBlocking_19
   \   00000148   0x6968             LDR      R0,[R5, #+20]
   \   0000014A   0x2800             CMP      R0,#+0
   \   0000014C   0xD005             BEQ.N    ??I2C_MasterTransferBlocking_19
    945              {
    946                  result = I2C_MasterReadBlocking(base, xfer->data, xfer->dataSize);
   \   0000014E   0x696A             LDR      R2,[R5, #+20]
   \   00000150   0x6929             LDR      R1,[R5, #+16]
   \   00000152   0x0020             MOVS     R0,R4
   \   00000154   0x.... 0x....      BL       I2C_MasterReadBlocking
   \   00000158   0x0007             MOVS     R7,R0
    947              }
    948          
    949              return result;
   \                     ??I2C_MasterTransferBlocking_19: (+1)
   \   0000015A   0x0038             MOVS     R0,R7
   \                     ??I2C_MasterTransferBlocking_5: (+1)
   \   0000015C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    950          }
    951          

   \                                 In section .text, align 2, keep-with-next
    952          void I2C_MasterTransferCreateHandle(I2C_Type *base,
    953                                              i2c_master_handle_t *handle,
    954                                              i2c_master_transfer_callback_t callback,
    955                                              void *userData)
    956          {
   \                     I2C_MasterTransferCreateHandle: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    957              assert(handle);
    958          
    959              uint32_t instance = I2C_GetInstance(base);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       I2C_GetInstance
   \   00000012   0x4680             MOV      R8,R0
    960          
    961              /* Zero handle. */
    962              memset(handle, 0, sizeof(*handle));
   \   00000014   0xF05F 0x0928      MOVS     R9,#+40
   \   00000018   0xF05F 0x0A00      MOVS     R10,#+0
   \   0000001C   0x4652             MOV      R2,R10
   \   0000001E   0x4649             MOV      R1,R9
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0x.... 0x....      BL       __aeabi_memset
    963          
    964              /* Set callback and userData. */
    965              handle->completionCallback = callback;
   \   00000026   0x622E             STR      R6,[R5, #+32]
    966              handle->userData = userData;
   \   00000028   0x626F             STR      R7,[R5, #+36]
    967          
    968              /* Save the context in global variables to support the double weak mechanism. */
    969              s_i2cHandle[instance] = handle;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable13_7
   \   0000002E   0xF840 0x5028      STR      R5,[R0, R8, LSL #+2]
    970          
    971              /* Save master interrupt handler. */
    972              s_i2cMasterIsr = I2C_MasterTransferHandleIRQ;
   \   00000032   0x.... 0x....      ADR.W    R0,I2C_MasterTransferHandleIRQ
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    973          
    974              /* Enable NVIC interrupt. */
    975              EnableIRQ(s_i2cIrqs[instance]);
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable13_8
   \   00000040   0xF910 0x0008      LDRSB    R0,[R0, R8]
   \   00000044   0x.... 0x....      BL       EnableIRQ
    976          }
   \   00000048   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    977          

   \                                 In section .text, align 2, keep-with-next
    978          status_t I2C_MasterTransferNonBlocking(I2C_Type *base, i2c_master_handle_t *handle, i2c_master_transfer_t *xfer)
    979          {
   \                     I2C_MasterTransferNonBlocking: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    980              assert(handle);
    981              assert(xfer);
    982          
    983              status_t result = kStatus_Success;
   \   00000008   0x2700             MOVS     R7,#+0
    984          
    985              /* Check if the I2C bus is idle - if not return busy status. */
    986              if (handle->state != kIdleState)
   \   0000000A   0x7F28             LDRB     R0,[R5, #+28]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??I2C_MasterTransferNonBlocking_0
    987              {
    988                  result = kStatus_I2C_Busy;
   \   00000010   0xF240 0x404C      MOVW     R0,#+1100
   \   00000014   0x0007             MOVS     R7,R0
   \   00000016   0xE00B             B.N      ??I2C_MasterTransferNonBlocking_1
    989              }
    990              else
    991              {
    992                  /* Start up the master transfer state machine. */
    993                  result = I2C_InitTransferStateMachine(base, handle, xfer);
   \                     ??I2C_MasterTransferNonBlocking_0: (+1)
   \   00000018   0x0032             MOVS     R2,R6
   \   0000001A   0x0029             MOVS     R1,R5
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       I2C_InitTransferStateMachine
   \   00000022   0x0007             MOVS     R7,R0
    994          
    995                  if (result == kStatus_Success)
   \   00000024   0x2F00             CMP      R7,#+0
   \   00000026   0xD103             BNE.N    ??I2C_MasterTransferNonBlocking_1
    996                  {
    997                      /* Enable the I2C interrupts. */
    998                      I2C_EnableInterrupts(base, kI2C_GlobalInterruptEnable);
   \   00000028   0x2140             MOVS     R1,#+64
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       I2C_EnableInterrupts
    999                  }
   1000              }
   1001          
   1002              return result;
   \                     ??I2C_MasterTransferNonBlocking_1: (+1)
   \   00000030   0x0038             MOVS     R0,R7
   \   00000032   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1003          }
   1004          

   \                                 In section .text, align 2, keep-with-next
   1005          void I2C_MasterTransferAbort(I2C_Type *base, i2c_master_handle_t *handle)
   1006          {
   \                     I2C_MasterTransferAbort: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1007              assert(handle);
   1008          
   1009              /* Disable interrupt. */
   1010              I2C_DisableInterrupts(base, kI2C_GlobalInterruptEnable);
   \   00000006   0x2140             MOVS     R1,#+64
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       I2C_DisableInterrupts
   1011          
   1012              /* Reset the state to idle. */
   1013              handle->state = kIdleState;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x7728             STRB     R0,[R5, #+28]
   1014          }
   \   00000012   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1015          

   \                                 In section .text, align 2, keep-with-next
   1016          status_t I2C_MasterTransferGetCount(I2C_Type *base, i2c_master_handle_t *handle, size_t *count)
   1017          {
   \                     I2C_MasterTransferGetCount: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0003             MOVS     R3,R0
   1018              assert(handle);
   1019          
   1020              if (!count)
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD101             BNE.N    ??I2C_MasterTransferGetCount_0
   1021              {
   1022                  return kStatus_InvalidArgument;
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0xE004             B.N      ??I2C_MasterTransferGetCount_1
   1023              }
   1024          
   1025              *count = handle->transferSize - handle->transfer.dataSize;
   \                     ??I2C_MasterTransferGetCount_0: (+1)
   \   0000000C   0x6988             LDR      R0,[R1, #+24]
   \   0000000E   0x694C             LDR      R4,[R1, #+20]
   \   00000010   0x1B00             SUBS     R0,R0,R4
   \   00000012   0x6010             STR      R0,[R2, #+0]
   1026          
   1027              return kStatus_Success;
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??I2C_MasterTransferGetCount_1: (+1)
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return
   1028          }
   1029          

   \                                 In section .text, align 4, keep-with-next
   1030          void I2C_MasterTransferHandleIRQ(I2C_Type *base, void *i2cHandle)
   1031          {
   \                     I2C_MasterTransferHandleIRQ: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1032              assert(i2cHandle);
   1033          
   1034              i2c_master_handle_t *handle = (i2c_master_handle_t *)i2cHandle;
   \   00000006   0x002E             MOVS     R6,R5
   1035              status_t result = kStatus_Success;
   \   00000008   0x2700             MOVS     R7,#+0
   1036              bool isDone;
   1037          
   1038              /* Clear the interrupt flag. */
   1039              base->S = kI2C_IntPendingFlag;
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x70E0             STRB     R0,[R4, #+3]
   1040          
   1041              /* Check transfer complete flag. */
   1042              result = I2C_MasterTransferRunStateMachine(base, handle, &isDone);
   \   0000000E   0x466A             MOV      R2,SP
   \   00000010   0x0031             MOVS     R1,R6
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       I2C_MasterTransferRunStateMachine
   \   00000018   0x0007             MOVS     R7,R0
   1043          
   1044              if (isDone || result)
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD101             BNE.N    ??I2C_MasterTransferHandleIRQ_0
   \   00000022   0x2F00             CMP      R7,#+0
   \   00000024   0xD021             BEQ.N    ??I2C_MasterTransferHandleIRQ_1
   1045              {
   1046                  /* Send stop command if transfer done or received Nak. */
   1047                  if ((!(handle->transfer.flags & kI2C_TransferNoStopFlag)) || (result == kStatus_I2C_Nak))
   \                     ??I2C_MasterTransferHandleIRQ_0: (+1)
   \   00000026   0x7830             LDRB     R0,[R6, #+0]
   \   00000028   0x0740             LSLS     R0,R0,#+29
   \   0000002A   0xD503             BPL.N    ??I2C_MasterTransferHandleIRQ_2
   \   0000002C   0xF240 0x404E      MOVW     R0,#+1102
   \   00000030   0x4287             CMP      R7,R0
   \   00000032   0xD10A             BNE.N    ??I2C_MasterTransferHandleIRQ_3
   1048                  {
   1049                      /* Ensure stop command is a need. */
   1050                      if ((base->C1 & I2C_C1_MST_MASK))
   \                     ??I2C_MasterTransferHandleIRQ_2: (+1)
   \   00000034   0x78A0             LDRB     R0,[R4, #+2]
   \   00000036   0x0680             LSLS     R0,R0,#+26
   \   00000038   0xD507             BPL.N    ??I2C_MasterTransferHandleIRQ_3
   1051                      {
   1052                          if (I2C_MasterStop(base) != kStatus_Success)
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       I2C_MasterStop
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD002             BEQ.N    ??I2C_MasterTransferHandleIRQ_3
   1053                          {
   1054                              result = kStatus_I2C_Timeout;
   \   00000044   0xF44F 0x608A      MOV      R0,#+1104
   \   00000048   0x0007             MOVS     R7,R0
   1055                          }
   1056                      }
   1057                  }
   1058          
   1059                  /* Restore handle to idle state. */
   1060                  handle->state = kIdleState;
   \                     ??I2C_MasterTransferHandleIRQ_3: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x7730             STRB     R0,[R6, #+28]
   1061          
   1062                  /* Disable interrupt. */
   1063                  I2C_DisableInterrupts(base, kI2C_GlobalInterruptEnable);
   \   0000004E   0x2140             MOVS     R1,#+64
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       I2C_DisableInterrupts
   1064          
   1065                  /* Call the callback function after the function has completed. */
   1066                  if (handle->completionCallback)
   \   00000056   0x6A30             LDR      R0,[R6, #+32]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD006             BEQ.N    ??I2C_MasterTransferHandleIRQ_1
   1067                  {
   1068                      handle->completionCallback(base, handle, result, handle->userData);
   \   0000005C   0x6A73             LDR      R3,[R6, #+36]
   \   0000005E   0x003A             MOVS     R2,R7
   \   00000060   0x0031             MOVS     R1,R6
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0xF8D6 0xC020      LDR      R12,[R6, #+32]
   \   00000068   0x47E0             BLX      R12
   1069                  }
   1070              }
   1071          }
   \                     ??I2C_MasterTransferHandleIRQ_1: (+1)
   \   0000006A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1072          

   \                                 In section .text, align 2, keep-with-next
   1073          void I2C_SlaveInit(I2C_Type *base, const i2c_slave_config_t *slaveConfig)
   1074          {
   \                     I2C_SlaveInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1075              assert(slaveConfig);
   1076          
   1077              uint8_t tmpReg;
   1078          
   1079              CLOCK_EnableClock(s_i2cClocks[I2C_GetInstance(base)]);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       I2C_GetInstance
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   00000010   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000014   0x.... 0x....      BL       CLOCK_EnableClock
   1080          
   1081              /* Configure addressing mode. */
   1082              switch (slaveConfig->addressingMode)
   \   00000018   0x7AA8             LDRB     R0,[R5, #+10]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD002             BEQ.N    ??I2C_SlaveInit_0
   \   0000001E   0x2802             CMP      R0,#+2
   \   00000020   0xD004             BEQ.N    ??I2C_SlaveInit_1
   \   00000022   0xE00E             B.N      ??I2C_SlaveInit_2
   1083              {
   1084                  case kI2C_Address7bit:
   1085                      base->A1 = ((uint32_t)(slaveConfig->slaveAddress)) << 1U;
   \                     ??I2C_SlaveInit_0: (+1)
   \   00000024   0x88E8             LDRH     R0,[R5, #+6]
   \   00000026   0x0040             LSLS     R0,R0,#+1
   \   00000028   0x7020             STRB     R0,[R4, #+0]
   1086                      break;
   \   0000002A   0xE00A             B.N      ??I2C_SlaveInit_3
   1087          
   1088                  case kI2C_RangeMatch:
   1089                      assert(slaveConfig->slaveAddress < slaveConfig->upperAddress);
   1090                      base->A1 = ((uint32_t)(slaveConfig->slaveAddress)) << 1U;
   \                     ??I2C_SlaveInit_1: (+1)
   \   0000002C   0x88E8             LDRH     R0,[R5, #+6]
   \   0000002E   0x0040             LSLS     R0,R0,#+1
   \   00000030   0x7020             STRB     R0,[R4, #+0]
   1091                      base->RA = ((uint32_t)(slaveConfig->upperAddress)) << 1U;
   \   00000032   0x8928             LDRH     R0,[R5, #+8]
   \   00000034   0x0040             LSLS     R0,R0,#+1
   \   00000036   0x71E0             STRB     R0,[R4, #+7]
   1092                      base->C2 |= I2C_C2_RMEN_MASK;
   \   00000038   0x7960             LDRB     R0,[R4, #+5]
   \   0000003A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000003E   0x7160             STRB     R0,[R4, #+5]
   1093                      break;
   \   00000040   0xE7FF             B.N      ??I2C_SlaveInit_3
   1094          
   1095                  default:
   1096                      break;
   1097              }
   1098          
   1099              /* Configure low power wake up feature. */
   1100              tmpReg = base->C1;
   \                     ??I2C_SlaveInit_2: (+1)
   \                     ??I2C_SlaveInit_3: (+1)
   \   00000042   0x78A0             LDRB     R0,[R4, #+2]
   \   00000044   0x0006             MOVS     R6,R0
   1101              tmpReg &= ~I2C_C1_WUEN_MASK;
   \   00000046   0xF016 0x06FD      ANDS     R6,R6,#0xFD
   1102              base->C1 = tmpReg | I2C_C1_WUEN(slaveConfig->enableWakeUp) | I2C_C1_IICEN(slaveConfig->enableSlave);
   \   0000004A   0x78A8             LDRB     R0,[R5, #+2]
   \   0000004C   0xEA56 0x0040      ORRS     R0,R6,R0, LSL #+1
   \   00000050   0x7829             LDRB     R1,[R5, #+0]
   \   00000052   0xEA50 0x10C1      ORRS     R0,R0,R1, LSL #+7
   \   00000056   0x70A0             STRB     R0,[R4, #+2]
   1103          
   1104              /* Configure general call & baud rate control & high drive feature. */
   1105              tmpReg = base->C2;
   \   00000058   0x7960             LDRB     R0,[R4, #+5]
   \   0000005A   0x0006             MOVS     R6,R0
   1106              tmpReg &= ~(I2C_C2_SBRC_MASK | I2C_C2_GCAEN_MASK);
   \   0000005C   0xF016 0x066F      ANDS     R6,R6,#0x6F
   1107              tmpReg |= I2C_C2_SBRC(slaveConfig->enableBaudRateCtl) | I2C_C2_GCAEN(slaveConfig->enableGeneralCall);
   \   00000060   0x7928             LDRB     R0,[R5, #+4]
   \   00000062   0x7869             LDRB     R1,[R5, #+1]
   \   00000064   0x01C9             LSLS     R1,R1,#+7
   \   00000066   0xEA51 0x1000      ORRS     R0,R1,R0, LSL #+4
   \   0000006A   0x4306             ORRS     R6,R0,R6
   1108          #if defined(FSL_FEATURE_I2C_HAS_HIGH_DRIVE_SELECTION) && FSL_FEATURE_I2C_HAS_HIGH_DRIVE_SELECTION
   1109              tmpReg &= ~I2C_C2_HDRS_MASK;
   \   0000006C   0xF016 0x06DF      ANDS     R6,R6,#0xDF
   1110              tmpReg |= I2C_C2_HDRS(slaveConfig->enableHighDrive);
   \   00000070   0x78E8             LDRB     R0,[R5, #+3]
   \   00000072   0xEA56 0x1640      ORRS     R6,R6,R0, LSL #+5
   1111          #endif
   1112              base->C2 = tmpReg;
   \   00000076   0x7166             STRB     R6,[R4, #+5]
   1113          }
   \   00000078   0xBD70             POP      {R4-R6,PC}       ;; return
   1114          

   \                                 In section .text, align 2, keep-with-next
   1115          void I2C_SlaveDeinit(I2C_Type *base)
   1116          {
   \                     I2C_SlaveDeinit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1117              /* Disable I2C module. */
   1118              I2C_Enable(base, false);
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       I2C_Enable
   1119          
   1120              /* Disable I2C clock. */
   1121              CLOCK_DisableClock(s_i2cClocks[I2C_GetInstance(base)]);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       I2C_GetInstance
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   00000016   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   0000001A   0x.... 0x....      BL       CLOCK_DisableClock
   1122          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   1123          

   \                                 In section .text, align 2, keep-with-next
   1124          void I2C_SlaveGetDefaultConfig(i2c_slave_config_t *slaveConfig)
   1125          {
   1126              assert(slaveConfig);
   1127          
   1128              /* By default slave is addressed with 7-bit address. */
   1129              slaveConfig->addressingMode = kI2C_Address7bit;
   \                     I2C_SlaveGetDefaultConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7281             STRB     R1,[R0, #+10]
   1130          
   1131              /* General call mode is disabled by default. */
   1132              slaveConfig->enableGeneralCall = false;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7041             STRB     R1,[R0, #+1]
   1133          
   1134              /* Slave address match waking up MCU from low power mode is disabled. */
   1135              slaveConfig->enableWakeUp = false;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7081             STRB     R1,[R0, #+2]
   1136          
   1137          #if defined(FSL_FEATURE_I2C_HAS_HIGH_DRIVE_SELECTION) && FSL_FEATURE_I2C_HAS_HIGH_DRIVE_SELECTION
   1138              /* Default pin high drive is disabled. */
   1139              slaveConfig->enableHighDrive = false;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x70C1             STRB     R1,[R0, #+3]
   1140          #endif
   1141          
   1142              /* Independent slave mode baud rate at maximum frequency is disabled. */
   1143              slaveConfig->enableBaudRateCtl = false;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x7101             STRB     R1,[R0, #+4]
   1144          
   1145              /* Enable the I2C peripheral. */
   1146              slaveConfig->enableSlave = true;
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x7001             STRB     R1,[R0, #+0]
   1147          }
   \   00000018   0x4770             BX       LR               ;; return
   1148          

   \                                 In section .text, align 2, keep-with-next
   1149          status_t I2C_SlaveWriteBlocking(I2C_Type *base, const uint8_t *txBuff, size_t txSize)
   1150          {
   \                     I2C_SlaveWriteBlocking: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1151              return I2C_MasterWriteBlocking(base, txBuff, txSize);
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       I2C_MasterWriteBlocking
   \   00000012   0xBD70             POP      {R4-R6,PC}       ;; return
   1152          }
   1153          

   \                                 In section .text, align 2, keep-with-next
   1154          void I2C_SlaveReadBlocking(I2C_Type *base, uint8_t *rxBuff, size_t rxSize)
   1155          {
   1156              /* Clear the IICIF flag. */
   1157              base->S = kI2C_IntPendingFlag;
   \                     I2C_SlaveReadBlocking: (+1)
   \   00000000   0x2302             MOVS     R3,#+2
   \   00000002   0x70C3             STRB     R3,[R0, #+3]
   1158          
   1159              /* Wait until the data register is ready for receive. */
   1160              while (!(base->S & kI2C_TransferCompleteFlag))
   \                     ??I2C_SlaveReadBlocking_0: (+1)
   \   00000004   0x78C3             LDRB     R3,[R0, #+3]
   \   00000006   0x061B             LSLS     R3,R3,#+24
   \   00000008   0xD5FC             BPL.N    ??I2C_SlaveReadBlocking_0
   1161              {
   1162              }
   1163          
   1164              /* Setup the I2C peripheral to receive data. */
   1165              base->C1 &= ~(I2C_C1_TX_MASK);
   \   0000000A   0x7883             LDRB     R3,[R0, #+2]
   \   0000000C   0xF013 0x03EF      ANDS     R3,R3,#0xEF
   \   00000010   0x7083             STRB     R3,[R0, #+2]
   1166          
   1167              while (rxSize--)
   \                     ??I2C_SlaveReadBlocking_1: (+1)
   \   00000012   0x0013             MOVS     R3,R2
   \   00000014   0x1E5A             SUBS     R2,R3,#+1
   \   00000016   0x2B00             CMP      R3,#+0
   \   00000018   0xD008             BEQ.N    ??I2C_SlaveReadBlocking_2
   1168              {
   1169                  /* Clear the IICIF flag. */
   1170                  base->S = kI2C_IntPendingFlag;
   \   0000001A   0x2302             MOVS     R3,#+2
   \   0000001C   0x70C3             STRB     R3,[R0, #+3]
   1171          
   1172                  /* Read from the data register. */
   1173                  *rxBuff++ = base->D;
   \   0000001E   0x7903             LDRB     R3,[R0, #+4]
   \   00000020   0x700B             STRB     R3,[R1, #+0]
   \   00000022   0x1C49             ADDS     R1,R1,#+1
   1174          
   1175                  /* Wait until data transfer complete. */
   1176                  while (!(base->S & kI2C_IntPendingFlag))
   \                     ??I2C_SlaveReadBlocking_3: (+1)
   \   00000024   0x78C3             LDRB     R3,[R0, #+3]
   \   00000026   0x079B             LSLS     R3,R3,#+30
   \   00000028   0xD4F3             BMI.N    ??I2C_SlaveReadBlocking_1
   \   0000002A   0xE7FB             B.N      ??I2C_SlaveReadBlocking_3
   1177                  {
   1178                  }
   1179              }
   1180          }
   \                     ??I2C_SlaveReadBlocking_2: (+1)
   \   0000002C   0x4770             BX       LR               ;; return
   1181          

   \                                 In section .text, align 2, keep-with-next
   1182          void I2C_SlaveTransferCreateHandle(I2C_Type *base,
   1183                                             i2c_slave_handle_t *handle,
   1184                                             i2c_slave_transfer_callback_t callback,
   1185                                             void *userData)
   1186          {
   \                     I2C_SlaveTransferCreateHandle: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1187              assert(handle);
   1188          
   1189              uint32_t instance = I2C_GetInstance(base);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       I2C_GetInstance
   \   00000012   0x4680             MOV      R8,R0
   1190          
   1191              /* Zero handle. */
   1192              memset(handle, 0, sizeof(*handle));
   \   00000014   0xF05F 0x0924      MOVS     R9,#+36
   \   00000018   0xF05F 0x0A00      MOVS     R10,#+0
   \   0000001C   0x4652             MOV      R2,R10
   \   0000001E   0x4649             MOV      R1,R9
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0x.... 0x....      BL       __aeabi_memset
   1193          
   1194              /* Set callback and userData. */
   1195              handle->callback = callback;
   \   00000026   0x61EE             STR      R6,[R5, #+28]
   1196              handle->userData = userData;
   \   00000028   0x622F             STR      R7,[R5, #+32]
   1197          
   1198              /* Save the context in global variables to support the double weak mechanism. */
   1199              s_i2cHandle[instance] = handle;
   \   0000002A   0x....             LDR.N    R0,??DataTable13_7
   \   0000002C   0xF840 0x5028      STR      R5,[R0, R8, LSL #+2]
   1200          
   1201              /* Save slave interrupt handler. */
   1202              s_i2cSlaveIsr = I2C_SlaveTransferHandleIRQ;
   \   00000030   0x.... 0x....      ADR.W    R0,I2C_SlaveTransferHandleIRQ
   \   00000034   0x....             LDR.N    R1,??DataTable13_3
   \   00000036   0x6008             STR      R0,[R1, #+0]
   1203          
   1204              /* Enable NVIC interrupt. */
   1205              EnableIRQ(s_i2cIrqs[instance]);
   \   00000038   0x....             LDR.N    R0,??DataTable13_8
   \   0000003A   0xF910 0x0008      LDRSB    R0,[R0, R8]
   \   0000003E   0x.... 0x....      BL       EnableIRQ
   1206          }
   \   00000042   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1207          

   \                                 In section .text, align 2, keep-with-next
   1208          status_t I2C_SlaveTransferNonBlocking(I2C_Type *base, i2c_slave_handle_t *handle, uint32_t eventMask)
   1209          {
   \                     I2C_SlaveTransferNonBlocking: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1210              assert(handle);
   1211          
   1212              /* Check if the I2C bus is idle - if not return busy status. */
   1213              if (handle->isBusy)
   \   0000000A   0x7828             LDRB     R0,[R5, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD002             BEQ.N    ??I2C_SlaveTransferNonBlocking_0
   1214              {
   1215                  return kStatus_I2C_Busy;
   \   00000010   0xF240 0x404C      MOVW     R0,#+1100
   \   00000014   0xE01C             B.N      ??I2C_SlaveTransferNonBlocking_1
   1216              }
   1217              else
   1218              {
   1219                  /* Disable LPI2C IRQ sources while we configure stuff. */
   1220                  I2C_DisableInterrupts(base, kIrqFlags);
   \                     ??I2C_SlaveTransferNonBlocking_0: (+1)
   \   00000016   0x2160             MOVS     R1,#+96
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       I2C_DisableInterrupts
   1221          
   1222                  /* Clear transfer in handle. */
   1223                  memset(&handle->transfer, 0, sizeof(handle->transfer));
   \   0000001E   0x2714             MOVS     R7,#+20
   \   00000020   0xF05F 0x0800      MOVS     R8,#+0
   \   00000024   0xF115 0x0904      ADDS     R9,R5,#+4
   \   00000028   0x4642             MOV      R2,R8
   \   0000002A   0x0039             MOVS     R1,R7
   \   0000002C   0x4648             MOV      R0,R9
   \   0000002E   0x.... 0x....      BL       __aeabi_memset
   1224          
   1225                  /* Record that we're busy. */
   1226                  handle->isBusy = true;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x7028             STRB     R0,[R5, #+0]
   1227          
   1228                  /* Set up event mask. tx and rx are always enabled. */
   1229                  handle->eventMask = eventMask | kI2C_SlaveTransmitEvent | kI2C_SlaveReceiveEvent;
   \   00000036   0xF056 0x0006      ORRS     R0,R6,#0x6
   \   0000003A   0x61A8             STR      R0,[R5, #+24]
   1230          
   1231                  /* Clear all flags. */
   1232                  I2C_SlaveClearStatusFlags(base, kClearFlags);
   \   0000003C   0xF245 0x0112      MOVW     R1,#+20498
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       I2C_SlaveClearStatusFlags
   1233          
   1234                  /* Enable I2C internal IRQ sources. NVIC IRQ was enabled in CreateHandle() */
   1235                  I2C_EnableInterrupts(base, kIrqFlags);
   \   00000046   0x2160             MOVS     R1,#+96
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       I2C_EnableInterrupts
   1236              }
   1237          
   1238              return kStatus_Success;
   \   0000004E   0x2000             MOVS     R0,#+0
   \                     ??I2C_SlaveTransferNonBlocking_1: (+1)
   \   00000050   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1239          }
   1240          

   \                                 In section .text, align 2, keep-with-next
   1241          void I2C_SlaveTransferAbort(I2C_Type *base, i2c_slave_handle_t *handle)
   1242          {
   \                     I2C_SlaveTransferAbort: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1243              assert(handle);
   1244          
   1245              if (handle->isBusy)
   \   00000008   0x7828             LDRB     R0,[R5, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD00E             BEQ.N    ??I2C_SlaveTransferAbort_0
   1246              {
   1247                  /* Disable interrupts. */
   1248                  I2C_DisableInterrupts(base, kIrqFlags);
   \   0000000E   0x2160             MOVS     R1,#+96
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       I2C_DisableInterrupts
   1249          
   1250                  /* Reset transfer info. */
   1251                  memset(&handle->transfer, 0, sizeof(handle->transfer));
   \   00000016   0x2614             MOVS     R6,#+20
   \   00000018   0x2700             MOVS     R7,#+0
   \   0000001A   0xF115 0x0804      ADDS     R8,R5,#+4
   \   0000001E   0x003A             MOVS     R2,R7
   \   00000020   0x0031             MOVS     R1,R6
   \   00000022   0x4640             MOV      R0,R8
   \   00000024   0x.... 0x....      BL       __aeabi_memset
   1252          
   1253                  /* Reset the state to idle. */
   1254                  handle->isBusy = false;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x7028             STRB     R0,[R5, #+0]
   1255              }
   1256          }
   \                     ??I2C_SlaveTransferAbort_0: (+1)
   \   0000002C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1257          

   \                                 In section .text, align 2, keep-with-next
   1258          status_t I2C_SlaveTransferGetCount(I2C_Type *base, i2c_slave_handle_t *handle, size_t *count)
   1259          {
   \                     I2C_SlaveTransferGetCount: (+1)
   \   00000000   0x0003             MOVS     R3,R0
   1260              assert(handle);
   1261          
   1262              if (!count)
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD101             BNE.N    ??I2C_SlaveTransferGetCount_0
   1263              {
   1264                  return kStatus_InvalidArgument;
   \   00000006   0x2004             MOVS     R0,#+4
   \   00000008   0xE009             B.N      ??I2C_SlaveTransferGetCount_1
   1265              }
   1266          
   1267              /* Catch when there is not an active transfer. */
   1268              if (!handle->isBusy)
   \                     ??I2C_SlaveTransferGetCount_0: (+1)
   \   0000000A   0x7808             LDRB     R0,[R1, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD103             BNE.N    ??I2C_SlaveTransferGetCount_2
   1269              {
   1270                  *count = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x6010             STR      R0,[R2, #+0]
   1271                  return kStatus_NoTransferInProgress;
   \   00000014   0x2006             MOVS     R0,#+6
   \   00000016   0xE002             B.N      ??I2C_SlaveTransferGetCount_1
   1272              }
   1273          
   1274              /* For an active transfer, just return the count from the handle. */
   1275              *count = handle->transfer.transferredCount;
   \                     ??I2C_SlaveTransferGetCount_2: (+1)
   \   00000018   0x6948             LDR      R0,[R1, #+20]
   \   0000001A   0x6010             STR      R0,[R2, #+0]
   1276          
   1277              return kStatus_Success;
   \   0000001C   0x2000             MOVS     R0,#+0
   \                     ??I2C_SlaveTransferGetCount_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
   1278          }
   1279          

   \                                 In section .text, align 4, keep-with-next
   1280          void I2C_SlaveTransferHandleIRQ(I2C_Type *base, void *i2cHandle)
   1281          {
   \                     I2C_SlaveTransferHandleIRQ: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1282              assert(i2cHandle);
   1283          
   1284              uint16_t status;
   1285              bool doTransmit = false;
   \   00000008   0x2700             MOVS     R7,#+0
   1286              i2c_slave_handle_t *handle = (i2c_slave_handle_t *)i2cHandle;
   \   0000000A   0x46A8             MOV      R8,R5
   1287              i2c_slave_transfer_t *xfer;
   1288              volatile uint8_t dummy = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1289          
   1290              /* Add this to avoid build warning. */
   1291              dummy++;
   \   00000012   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1292          
   1293              status = I2C_SlaveGetStatusFlags(base);
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       I2C_SlaveGetStatusFlags
   \   00000022   0x0006             MOVS     R6,R0
   1294              xfer = &(handle->transfer);
   \   00000024   0xF118 0x0004      ADDS     R0,R8,#+4
   \   00000028   0x4681             MOV      R9,R0
   1295          
   1296          #ifdef I2C_HAS_STOP_DETECT
   1297              /* Check stop flag. */
   1298              if (status & kI2C_StopDetectFlag)
   \   0000002A   0x0470             LSLS     R0,R6,#+17
   \   0000002C   0xD525             BPL.N    ??I2C_SlaveTransferHandleIRQ_0
   1299              {
   1300                  I2C_MasterClearStatusFlags(base, kI2C_StopDetectFlag);
   \   0000002E   0xF44F 0x4180      MOV      R1,#+16384
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       I2C_MasterClearStatusFlags
   1301          
   1302                  /* Clear the interrupt flag. */
   1303                  base->S = kI2C_IntPendingFlag;
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0x70E0             STRB     R0,[R4, #+3]
   1304          
   1305                  /* Call slave callback if this is the STOP of the transfer. */
   1306                  if (handle->isBusy)
   \   0000003C   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD019             BEQ.N    ??I2C_SlaveTransferHandleIRQ_1
   1307                  {
   1308                      xfer->event = kI2C_SlaveCompletionEvent;
   \   00000044   0x2020             MOVS     R0,#+32
   \   00000046   0xF889 0x0000      STRB     R0,[R9, #+0]
   1309                      xfer->completionStatus = kStatus_Success;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF8C9 0x000C      STR      R0,[R9, #+12]
   1310                      handle->isBusy = false;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xF888 0x0000      STRB     R0,[R8, #+0]
   1311          
   1312                      if ((handle->eventMask & xfer->event) && (handle->callback))
   \   00000056   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \   0000005A   0xF899 0x1000      LDRB     R1,[R9, #+0]
   \   0000005E   0x4208             TST      R0,R1
   \   00000060   0xD00A             BEQ.N    ??I2C_SlaveTransferHandleIRQ_1
   \   00000062   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD006             BEQ.N    ??I2C_SlaveTransferHandleIRQ_1
   1313                      {
   1314                          handle->callback(base, xfer, handle->userData);
   \   0000006A   0xF8D8 0x2020      LDR      R2,[R8, #+32]
   \   0000006E   0x4649             MOV      R1,R9
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0xF8D8 0x301C      LDR      R3,[R8, #+28]
   \   00000076   0x4798             BLX      R3
   1315                      }
   1316                  }
   1317          
   1318                  return;
   \                     ??I2C_SlaveTransferHandleIRQ_1: (+1)
   \   00000078   0xE0EB             B.N      ??I2C_SlaveTransferHandleIRQ_2
   1319              }
   1320          #endif /* I2C_HAS_STOP_DETECT */
   1321          
   1322          #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
   1323              /* Check start flag. */
   1324              if (status & kI2C_StartDetectFlag)
   \                     ??I2C_SlaveTransferHandleIRQ_0: (+1)
   \   0000007A   0x04F0             LSLS     R0,R6,#+19
   \   0000007C   0xD51D             BPL.N    ??I2C_SlaveTransferHandleIRQ_3
   1325              {
   1326                  I2C_MasterClearStatusFlags(base, kI2C_StartDetectFlag);
   \   0000007E   0xF44F 0x5180      MOV      R1,#+4096
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0x.... 0x....      BL       I2C_MasterClearStatusFlags
   1327          
   1328                  /* Clear the interrupt flag. */
   1329                  base->S = kI2C_IntPendingFlag;
   \   00000088   0x2002             MOVS     R0,#+2
   \   0000008A   0x70E0             STRB     R0,[R4, #+3]
   1330          
   1331                  xfer->event = kI2C_SlaveRepeatedStartEvent;
   \   0000008C   0x2010             MOVS     R0,#+16
   \   0000008E   0xF889 0x0000      STRB     R0,[R9, #+0]
   1332          
   1333                  if ((handle->eventMask & xfer->event) && (handle->callback))
   \   00000092   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \   00000096   0xF899 0x1000      LDRB     R1,[R9, #+0]
   \   0000009A   0x4208             TST      R0,R1
   \   0000009C   0xD00A             BEQ.N    ??I2C_SlaveTransferHandleIRQ_4
   \   0000009E   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD006             BEQ.N    ??I2C_SlaveTransferHandleIRQ_4
   1334                  {
   1335                      handle->callback(base, xfer, handle->userData);
   \   000000A6   0xF8D8 0x2020      LDR      R2,[R8, #+32]
   \   000000AA   0x4649             MOV      R1,R9
   \   000000AC   0x0020             MOVS     R0,R4
   \   000000AE   0xF8D8 0x301C      LDR      R3,[R8, #+28]
   \   000000B2   0x4798             BLX      R3
   1336                  }
   1337          
   1338                  if (!(status & kI2C_AddressMatchFlag))
   \                     ??I2C_SlaveTransferHandleIRQ_4: (+1)
   \   000000B4   0x0670             LSLS     R0,R6,#+25
   \   000000B6   0xF140 0x80CC      BPL.W    ??I2C_SlaveTransferHandleIRQ_2
   1339                  {
   1340                      return;
   1341                  }
   1342              }
   1343          #endif /* FSL_FEATURE_I2C_HAS_START_STOP_DETECT */
   1344          
   1345              /* Clear the interrupt flag. */
   1346              base->S = kI2C_IntPendingFlag;
   \                     ??I2C_SlaveTransferHandleIRQ_3: (+1)
   \   000000BA   0x2002             MOVS     R0,#+2
   \   000000BC   0x70E0             STRB     R0,[R4, #+3]
   1347          
   1348              /* Check NAK */
   1349              if (status & kI2C_ReceiveNakFlag)
   \   000000BE   0x07F0             LSLS     R0,R6,#+31
   \   000000C0   0xD529             BPL.N    ??I2C_SlaveTransferHandleIRQ_5
   1350              {
   1351                  /* Set receive mode. */
   1352                  base->C1 &= ~(I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
   \   000000C2   0x78A0             LDRB     R0,[R4, #+2]
   \   000000C4   0xF010 0x00E7      ANDS     R0,R0,#0xE7
   \   000000C8   0x70A0             STRB     R0,[R4, #+2]
   1353          
   1354                  /* Read dummy. */
   1355                  dummy = base->D;
   \   000000CA   0x7920             LDRB     R0,[R4, #+4]
   \   000000CC   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1356          
   1357                  if (handle->transfer.dataSize != 0)
   \   000000D0   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xF000 0x809C      BEQ.W    ??I2C_SlaveTransferHandleIRQ_6
   1358                  {
   1359                      xfer->event = kI2C_SlaveCompletionEvent;
   \   000000DA   0x2020             MOVS     R0,#+32
   \   000000DC   0xF889 0x0000      STRB     R0,[R9, #+0]
   1360                      xfer->completionStatus = kStatus_I2C_Nak;
   \   000000E0   0xF240 0x404E      MOVW     R0,#+1102
   \   000000E4   0xF8C9 0x000C      STR      R0,[R9, #+12]
   1361                      handle->isBusy = false;
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0xF888 0x0000      STRB     R0,[R8, #+0]
   1362          
   1363                      if ((handle->eventMask & xfer->event) && (handle->callback))
   \   000000EE   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \   000000F2   0xF899 0x1000      LDRB     R1,[R9, #+0]
   \   000000F6   0x4208             TST      R0,R1
   \   000000F8   0xF000 0x808B      BEQ.W    ??I2C_SlaveTransferHandleIRQ_6
   \   000000FC   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xF000 0x8086      BEQ.W    ??I2C_SlaveTransferHandleIRQ_6
   1364                      {
   1365                          handle->callback(base, xfer, handle->userData);
   \   00000106   0xF8D8 0x2020      LDR      R2,[R8, #+32]
   \   0000010A   0x4649             MOV      R1,R9
   \   0000010C   0x0020             MOVS     R0,R4
   \   0000010E   0xF8D8 0x301C      LDR      R3,[R8, #+28]
   \   00000112   0x4798             BLX      R3
   \   00000114   0xE07D             B.N      ??I2C_SlaveTransferHandleIRQ_6
   1366                      }
   1367                  }
   1368                  else
   1369                  {
   1370          #ifndef I2C_HAS_STOP_DETECT
   1371                      xfer->event = kI2C_SlaveCompletionEvent;
   1372                      xfer->completionStatus = kStatus_Success;
   1373                      handle->isBusy = false;
   1374          
   1375                      if ((handle->eventMask & xfer->event) && (handle->callback))
   1376                      {
   1377                          handle->callback(base, xfer, handle->userData);
   1378                      }
   1379          #endif /* !FSL_FEATURE_I2C_HAS_START_STOP_DETECT or !FSL_FEATURE_I2C_HAS_STOP_DETECT */
   1380                  }
   1381              }
   1382              /* Check address match. */
   1383              else if (status & kI2C_AddressMatchFlag)
   \                     ??I2C_SlaveTransferHandleIRQ_5: (+1)
   \   00000116   0x0670             LSLS     R0,R6,#+25
   \   00000118   0xD559             BPL.N    ??I2C_SlaveTransferHandleIRQ_7
   1384              {
   1385                  handle->isBusy = true;
   \   0000011A   0x2001             MOVS     R0,#+1
   \   0000011C   0xF888 0x0000      STRB     R0,[R8, #+0]
   1386                  xfer->event = kI2C_SlaveAddressMatchEvent;
   \   00000120   0x2001             MOVS     R0,#+1
   \   00000122   0xF889 0x0000      STRB     R0,[R9, #+0]
   1387          
   1388                  if ((handle->eventMask & xfer->event) && (handle->callback))
   \   00000126   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \   0000012A   0xF899 0x1000      LDRB     R1,[R9, #+0]
   \   0000012E   0x4208             TST      R0,R1
   \   00000130   0xD00A             BEQ.N    ??I2C_SlaveTransferHandleIRQ_8
   \   00000132   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \   00000136   0x2800             CMP      R0,#+0
   \   00000138   0xD006             BEQ.N    ??I2C_SlaveTransferHandleIRQ_8
   1389                  {
   1390                      handle->callback(base, xfer, handle->userData);
   \   0000013A   0xF8D8 0x2020      LDR      R2,[R8, #+32]
   \   0000013E   0x4649             MOV      R1,R9
   \   00000140   0x0020             MOVS     R0,R4
   \   00000142   0xF8D8 0x301C      LDR      R3,[R8, #+28]
   \   00000146   0x4798             BLX      R3
   1391                  }
   1392          
   1393                  /* Slave transmit, master reading from slave. */
   1394                  if (status & kI2C_TransferDirectionFlag)
   \                     ??I2C_SlaveTransferHandleIRQ_8: (+1)
   \   00000148   0x0770             LSLS     R0,R6,#+29
   \   0000014A   0xD51F             BPL.N    ??I2C_SlaveTransferHandleIRQ_9
   1395                  {
   1396                      /* Change direction to send data. */
   1397                      base->C1 |= I2C_C1_TX_MASK;
   \   0000014C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000014E   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000152   0x70A0             STRB     R0,[R4, #+2]
   1398          
   1399                      /* If we're out of data, invoke callback to get more. */
   1400                      if ((!xfer->data) || (!xfer->dataSize))
   \   00000154   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \   00000158   0x2800             CMP      R0,#+0
   \   0000015A   0xD003             BEQ.N    ??I2C_SlaveTransferHandleIRQ_10
   \   0000015C   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \   00000160   0x2800             CMP      R0,#+0
   \   00000162   0xD110             BNE.N    ??I2C_SlaveTransferHandleIRQ_11
   1401                      {
   1402                          xfer->event = kI2C_SlaveTransmitEvent;
   \                     ??I2C_SlaveTransferHandleIRQ_10: (+1)
   \   00000164   0x2002             MOVS     R0,#+2
   \   00000166   0xF889 0x0000      STRB     R0,[R9, #+0]
   1403          
   1404                          if (handle->callback)
   \   0000016A   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \   0000016E   0x2800             CMP      R0,#+0
   \   00000170   0xD006             BEQ.N    ??I2C_SlaveTransferHandleIRQ_12
   1405                          {
   1406                              handle->callback(base, xfer, handle->userData);
   \   00000172   0xF8D8 0x2020      LDR      R2,[R8, #+32]
   \   00000176   0x4649             MOV      R1,R9
   \   00000178   0x0020             MOVS     R0,R4
   \   0000017A   0xF8D8 0x301C      LDR      R3,[R8, #+28]
   \   0000017E   0x4798             BLX      R3
   1407                          }
   1408          
   1409                          /* Clear the transferred count now that we have a new buffer. */
   1410                          xfer->transferredCount = 0;
   \                     ??I2C_SlaveTransferHandleIRQ_12: (+1)
   \   00000180   0x2000             MOVS     R0,#+0
   \   00000182   0xF8C9 0x0010      STR      R0,[R9, #+16]
   1411                      }
   1412          
   1413                      doTransmit = true;
   \                     ??I2C_SlaveTransferHandleIRQ_11: (+1)
   \   00000186   0x2001             MOVS     R0,#+1
   \   00000188   0x0007             MOVS     R7,R0
   \   0000018A   0xE042             B.N      ??I2C_SlaveTransferHandleIRQ_6
   1414                  }
   1415                  else
   1416                  {
   1417                      /* Slave receive, master writing to slave. */
   1418                      base->C1 &= ~(I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
   \                     ??I2C_SlaveTransferHandleIRQ_9: (+1)
   \   0000018C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000018E   0xF010 0x00E7      ANDS     R0,R0,#0xE7
   \   00000192   0x70A0             STRB     R0,[R4, #+2]
   1419          
   1420                      /* If we're out of data, invoke callback to get more. */
   1421                      if ((!xfer->data) || (!xfer->dataSize))
   \   00000194   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \   00000198   0x2800             CMP      R0,#+0
   \   0000019A   0xD003             BEQ.N    ??I2C_SlaveTransferHandleIRQ_13
   \   0000019C   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \   000001A0   0x2800             CMP      R0,#+0
   \   000001A2   0xD110             BNE.N    ??I2C_SlaveTransferHandleIRQ_14
   1422                      {
   1423                          xfer->event = kI2C_SlaveReceiveEvent;
   \                     ??I2C_SlaveTransferHandleIRQ_13: (+1)
   \   000001A4   0x2004             MOVS     R0,#+4
   \   000001A6   0xF889 0x0000      STRB     R0,[R9, #+0]
   1424          
   1425                          if (handle->callback)
   \   000001AA   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \   000001AE   0x2800             CMP      R0,#+0
   \   000001B0   0xD006             BEQ.N    ??I2C_SlaveTransferHandleIRQ_15
   1426                          {
   1427                              handle->callback(base, xfer, handle->userData);
   \   000001B2   0xF8D8 0x2020      LDR      R2,[R8, #+32]
   \   000001B6   0x4649             MOV      R1,R9
   \   000001B8   0x0020             MOVS     R0,R4
   \   000001BA   0xF8D8 0x301C      LDR      R3,[R8, #+28]
   \   000001BE   0x4798             BLX      R3
   1428                          }
   1429          
   1430                          /* Clear the transferred count now that we have a new buffer. */
   1431                          xfer->transferredCount = 0;
   \                     ??I2C_SlaveTransferHandleIRQ_15: (+1)
   \   000001C0   0x2000             MOVS     R0,#+0
   \   000001C2   0xF8C9 0x0010      STR      R0,[R9, #+16]
   1432                      }
   1433          
   1434                      /* Read dummy to release the bus. */
   1435                      dummy = base->D;
   \                     ??I2C_SlaveTransferHandleIRQ_14: (+1)
   \   000001C6   0x7920             LDRB     R0,[R4, #+4]
   \   000001C8   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   000001CC   0xE021             B.N      ??I2C_SlaveTransferHandleIRQ_6
   1436                  }
   1437              }
   1438              /* Check transfer complete flag. */
   1439              else if (status & kI2C_TransferCompleteFlag)
   \                     ??I2C_SlaveTransferHandleIRQ_7: (+1)
   \   000001CE   0x0630             LSLS     R0,R6,#+24
   \   000001D0   0xD51C             BPL.N    ??I2C_SlaveTransferHandleIRQ_16
   1440              {
   1441                  /* Slave transmit, master reading from slave. */
   1442                  if (status & kI2C_TransferDirectionFlag)
   \   000001D2   0x0770             LSLS     R0,R6,#+29
   \   000001D4   0xD502             BPL.N    ??I2C_SlaveTransferHandleIRQ_17
   1443                  {
   1444                      doTransmit = true;
   \   000001D6   0x2001             MOVS     R0,#+1
   \   000001D8   0x0007             MOVS     R7,R0
   \   000001DA   0xE01A             B.N      ??I2C_SlaveTransferHandleIRQ_6
   1445                  }
   1446                  else
   1447                  {
   1448                      /* Slave receive, master writing to slave. */
   1449                      uint8_t data = base->D;
   \                     ??I2C_SlaveTransferHandleIRQ_17: (+1)
   \   000001DC   0x7920             LDRB     R0,[R4, #+4]
   1450          
   1451                      if (handle->transfer.dataSize)
   \   000001DE   0xF8D8 0x100C      LDR      R1,[R8, #+12]
   \   000001E2   0x2900             CMP      R1,#+0
   \   000001E4   0xD015             BEQ.N    ??I2C_SlaveTransferHandleIRQ_6
   1452                      {
   1453                          /* Receive data. */
   1454                          *handle->transfer.data++ = data;
   \   000001E6   0xF8D8 0x1008      LDR      R1,[R8, #+8]
   \   000001EA   0x1C4A             ADDS     R2,R1,#+1
   \   000001EC   0xF8C8 0x2008      STR      R2,[R8, #+8]
   \   000001F0   0x7008             STRB     R0,[R1, #+0]
   1455                          handle->transfer.dataSize--;
   \   000001F2   0xF8D8 0x100C      LDR      R1,[R8, #+12]
   \   000001F6   0x1E49             SUBS     R1,R1,#+1
   \   000001F8   0xF8C8 0x100C      STR      R1,[R8, #+12]
   1456                          xfer->transferredCount++;
   \   000001FC   0xF8D9 0x1010      LDR      R1,[R9, #+16]
   \   00000200   0x1C49             ADDS     R1,R1,#+1
   \   00000202   0xF8C9 0x1010      STR      R1,[R9, #+16]
   1457                          if (!handle->transfer.dataSize)
   \   00000206   0xF8D8 0x100C      LDR      R1,[R8, #+12]
   \   0000020A   0xE002             B.N      ??I2C_SlaveTransferHandleIRQ_6
   1458                          {
   1459          #ifndef I2C_HAS_STOP_DETECT
   1460                              xfer->event = kI2C_SlaveCompletionEvent;
   1461                              xfer->completionStatus = kStatus_Success;
   1462                              handle->isBusy = false;
   1463          
   1464                              /* Proceed receive complete event. */
   1465                              if ((handle->eventMask & xfer->event) && (handle->callback))
   1466                              {
   1467                                  handle->callback(base, xfer, handle->userData);
   1468                              }
   1469          #endif /* !FSL_FEATURE_I2C_HAS_START_STOP_DETECT or !FSL_FEATURE_I2C_HAS_STOP_DETECT */
   1470                          }
   1471                      }
   1472                  }
   1473              }
   1474              else
   1475              {
   1476                  /* Read dummy to release bus. */
   1477                  dummy = base->D;
   \                     ??I2C_SlaveTransferHandleIRQ_16: (+1)
   \   0000020C   0x7920             LDRB     R0,[R4, #+4]
   \   0000020E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1478              }
   1479          
   1480              /* Send data if there is the need. */
   1481              if (doTransmit)
   \                     ??I2C_SlaveTransferHandleIRQ_6: (+1)
   \   00000212   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000214   0x2F00             CMP      R7,#+0
   \   00000216   0xD01C             BEQ.N    ??I2C_SlaveTransferHandleIRQ_18
   1482              {
   1483                  if (handle->transfer.dataSize)
   \   00000218   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \   0000021C   0x2800             CMP      R0,#+0
   \   0000021E   0xD011             BEQ.N    ??I2C_SlaveTransferHandleIRQ_19
   1484                  {
   1485                      /* Send data. */
   1486                      base->D = *handle->transfer.data++;
   \   00000220   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   00000224   0x1C41             ADDS     R1,R0,#+1
   \   00000226   0xF8C8 0x1008      STR      R1,[R8, #+8]
   \   0000022A   0x7800             LDRB     R0,[R0, #+0]
   \   0000022C   0x7120             STRB     R0,[R4, #+4]
   1487                      handle->transfer.dataSize--;
   \   0000022E   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \   00000232   0x1E40             SUBS     R0,R0,#+1
   \   00000234   0xF8C8 0x000C      STR      R0,[R8, #+12]
   1488                      xfer->transferredCount++;
   \   00000238   0xF8D9 0x0010      LDR      R0,[R9, #+16]
   \   0000023C   0x1C40             ADDS     R0,R0,#+1
   \   0000023E   0xF8C9 0x0010      STR      R0,[R9, #+16]
   \   00000242   0xE006             B.N      ??I2C_SlaveTransferHandleIRQ_18
   1489                  }
   1490                  else
   1491                  {
   1492                      /* Switch to receive mode. */
   1493                      base->C1 &= ~(I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
   \                     ??I2C_SlaveTransferHandleIRQ_19: (+1)
   \   00000244   0x78A0             LDRB     R0,[R4, #+2]
   \   00000246   0xF010 0x00E7      ANDS     R0,R0,#0xE7
   \   0000024A   0x70A0             STRB     R0,[R4, #+2]
   1494          
   1495                      /* Read dummy to release bus. */
   1496                      dummy = base->D;
   \   0000024C   0x7920             LDRB     R0,[R4, #+4]
   \   0000024E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1497          
   1498          #ifndef I2C_HAS_STOP_DETECT
   1499                      xfer->event = kI2C_SlaveCompletionEvent;
   1500                      xfer->completionStatus = kStatus_Success;
   1501                      handle->isBusy = false;
   1502          
   1503                      /* Proceed txdone event. */
   1504                      if ((handle->eventMask & xfer->event) && (handle->callback))
   1505                      {
   1506                          handle->callback(base, xfer, handle->userData);
   1507                      }
   1508          #endif /* !FSL_FEATURE_I2C_HAS_START_STOP_DETECT or !FSL_FEATURE_I2C_HAS_STOP_DETECT */
   1509                  }
   1510              }
   1511          }
   \                     ??I2C_SlaveTransferHandleIRQ_18: (+1)
   \                     ??I2C_SlaveTransferHandleIRQ_2: (+1)
   \   00000252   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   1512          

   \                                 In section .text, align 2, keep-with-next
   1513          void I2C0_DriverIRQHandler(void)
   1514          {
   \                     I2C0_DriverIRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1515              I2C_TransferCommonIRQHandler(I2C0, s_i2cHandle[0]);
   \   00000002   0x....             LDR.N    R0,??DataTable13_7
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x....             LDR.N    R0,??DataTable13_9  ;; 0x40066000
   \   00000008   0x.... 0x....      BL       I2C_TransferCommonIRQHandler
   1516          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return
   1517          
   1518          #if (FSL_FEATURE_SOC_I2C_COUNT > 1)

   \                                 In section .text, align 2, keep-with-next
   1519          void I2C1_DriverIRQHandler(void)
   1520          {
   \                     I2C1_DriverIRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1521              I2C_TransferCommonIRQHandler(I2C1, s_i2cHandle[1]);
   \   00000002   0x....             LDR.N    R0,??DataTable13_7
   \   00000004   0x6841             LDR      R1,[R0, #+4]
   \   00000006   0x....             LDR.N    R0,??DataTable13_10  ;; 0x40067000
   \   00000008   0x.... 0x....      BL       I2C_TransferCommonIRQHandler
   1522          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return
   1523          #endif /* I2C COUNT > 1 */
   1524          
   1525          #if (FSL_FEATURE_SOC_I2C_COUNT > 2)

   \                                 In section .text, align 2, keep-with-next
   1526          void I2C2_DriverIRQHandler(void)
   1527          {
   \                     I2C2_DriverIRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1528              I2C_TransferCommonIRQHandler(I2C2, s_i2cHandle[2]);
   \   00000002   0x....             LDR.N    R0,??DataTable13_7
   \   00000004   0x6881             LDR      R1,[R0, #+8]
   \   00000006   0x....             LDR.N    R0,??DataTable13_11  ;; 0x400e6000
   \   00000008   0x.... 0x....      BL       I2C_TransferCommonIRQHandler
   1529          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     s_i2cBases

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     s_i2cMasterIsr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     s_i2cSlaveIsr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x........         DC32     s_i2cClocks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x000186A0         DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x........         DC32     s_i2cDividerTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x........         DC32     s_i2cHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x........         DC32     s_i2cIrqs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x40066000         DC32     0x40066000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0x40067000         DC32     0x40067000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   0x400E6000         DC32     0x400e6000
   1530          #endif /* I2C COUNT > 2 */
   1531          #if (FSL_FEATURE_SOC_I2C_COUNT > 3)
   1532          void I2C3_DriverIRQHandler(void)
   1533          {
   1534              I2C_TransferCommonIRQHandler(I2C3, s_i2cHandle[3]);
   1535          }
   1536          #endif /* I2C COUNT > 3 */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CLOCK_DisableClock
       0   CLOCK_EnableClock
       8   EnableIRQ
         8   -> NVIC_EnableIRQ
       8   I2C0_DriverIRQHandler
         8   -> I2C_TransferCommonIRQHandler
       8   I2C1_DriverIRQHandler
         8   -> I2C_TransferCommonIRQHandler
       8   I2C2_DriverIRQHandler
         8   -> I2C_TransferCommonIRQHandler
       0   I2C_CheckAndClearError
       0   I2C_DisableInterrupts
       0   I2C_Enable
       0   I2C_EnableInterrupts
       0   I2C_GetInstance
      32   I2C_InitTransferStateMachine
        32   -> I2C_MasterClearStatusFlags
        32   -> I2C_MasterRepeatedStart
        32   -> I2C_MasterStart
       0   I2C_MasterClearStatusFlags
       8   I2C_MasterDeinit
         8   -> CLOCK_DisableClock
         8   -> I2C_Enable
         8   -> I2C_GetInstance
       0   I2C_MasterGetDefaultConfig
       0   I2C_MasterGetStatusFlags
      24   I2C_MasterInit
        24   -> CLOCK_EnableClock
        24   -> I2C_GetInstance
        24   -> I2C_MasterClearStatusFlags
        24   -> I2C_MasterSetBaudRate
      24   I2C_MasterReadBlocking
        24   -> I2C_MasterStop
      24   I2C_MasterRepeatedStart
        24   -> I2C_MasterGetStatusFlags
      28   I2C_MasterSetBaudRate
      24   I2C_MasterStart
        24   -> I2C_MasterGetStatusFlags
       0   I2C_MasterStop
      16   I2C_MasterTransferAbort
        16   -> I2C_DisableInterrupts
      24   I2C_MasterTransferBlocking
        24   -> I2C_CheckAndClearError
        24   -> I2C_MasterClearStatusFlags
        24   -> I2C_MasterReadBlocking
        24   -> I2C_MasterRepeatedStart
        24   -> I2C_MasterStart
        24   -> I2C_MasterStop
        24   -> I2C_MasterWriteBlocking
      32   I2C_MasterTransferCreateHandle
        32   -> EnableIRQ
        32   -> I2C_GetInstance
        32   -> __aeabi_memset
       4   I2C_MasterTransferGetCount
      24   I2C_MasterTransferHandleIRQ
        24   -- Indirect call
        24   -> I2C_DisableInterrupts
        24   -> I2C_MasterStop
        24   -> I2C_MasterTransferRunStateMachine
      24   I2C_MasterTransferNonBlocking
        24   -> I2C_EnableInterrupts
        24   -> I2C_InitTransferStateMachine
      32   I2C_MasterTransferRunStateMachine
        32   -> I2C_CheckAndClearError
        32   -> I2C_MasterRepeatedStart
        32   -> I2C_MasterStop
       8   I2C_MasterWriteBlocking
      16   I2C_SlaveClearStatusFlags
        16   -> I2C_MasterClearStatusFlags
       8   I2C_SlaveDeinit
         8   -> CLOCK_DisableClock
         8   -> I2C_Enable
         8   -> I2C_GetInstance
       0   I2C_SlaveGetDefaultConfig
       8   I2C_SlaveGetStatusFlags
         8   -> I2C_MasterGetStatusFlags
      16   I2C_SlaveInit
        16   -> CLOCK_EnableClock
        16   -> I2C_GetInstance
       0   I2C_SlaveReadBlocking
      24   I2C_SlaveTransferAbort
        24   -> I2C_DisableInterrupts
        24   -> __aeabi_memset
      32   I2C_SlaveTransferCreateHandle
        32   -> EnableIRQ
        32   -> I2C_GetInstance
        32   -> __aeabi_memset
       0   I2C_SlaveTransferGetCount
      32   I2C_SlaveTransferHandleIRQ
        32   -- Indirect call
        32   -> I2C_MasterClearStatusFlags
        32   -> I2C_SlaveGetStatusFlags
      32   I2C_SlaveTransferNonBlocking
        32   -> I2C_DisableInterrupts
        32   -> I2C_EnableInterrupts
        32   -> I2C_SlaveClearStatusFlags
        32   -> __aeabi_memset
      16   I2C_SlaveWriteBlocking
        16   -> I2C_MasterWriteBlocking
      16   I2C_TransferCommonIRQHandler
        16   -- Indirect call
       0   NVIC_EnableIRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
      22  CLOCK_DisableClock
      22  CLOCK_EnableClock
      14  EnableIRQ
      14  I2C0_DriverIRQHandler
      14  I2C1_DriverIRQHandler
      14  I2C2_DriverIRQHandler
      32  I2C_CheckAndClearError
      26  I2C_DisableInterrupts
      26  I2C_Enable
      26  I2C_EnableInterrupts
      28  I2C_GetInstance
     146  I2C_InitTransferStateMachine
      28  I2C_MasterClearStatusFlags
      32  I2C_MasterDeinit
      24  I2C_MasterGetDefaultConfig
      26  I2C_MasterGetStatusFlags
     112  I2C_MasterInit
     116  I2C_MasterReadBlocking
     100  I2C_MasterRepeatedStart
     142  I2C_MasterSetBaudRate
      60  I2C_MasterStart
      44  I2C_MasterStop
      20  I2C_MasterTransferAbort
     350  I2C_MasterTransferBlocking
      76  I2C_MasterTransferCreateHandle
      26  I2C_MasterTransferGetCount
     108  I2C_MasterTransferHandleIRQ
      52  I2C_MasterTransferNonBlocking
     378  I2C_MasterTransferRunStateMachine
      90  I2C_MasterWriteBlocking
      16  I2C_SlaveClearStatusFlags
      32  I2C_SlaveDeinit
      26  I2C_SlaveGetDefaultConfig
      12  I2C_SlaveGetStatusFlags
     122  I2C_SlaveInit
      46  I2C_SlaveReadBlocking
      48  I2C_SlaveTransferAbort
      70  I2C_SlaveTransferCreateHandle
      32  I2C_SlaveTransferGetCount
     598  I2C_SlaveTransferHandleIRQ
      84  I2C_SlaveTransferNonBlocking
      20  I2C_SlaveWriteBlocking
      46  I2C_TransferCommonIRQHandler
      22  NVIC_EnableIRQ
      12  s_i2cBases
      12  s_i2cClocks
     128  s_i2cDividerTable
      12  s_i2cHandle
       4  s_i2cIrqs
       4  s_i2cMasterIsr
       4  s_i2cSlaveIsr

 
    20 bytes in section .bss
   156 bytes in section .rodata
 3 390 bytes in section .text
 
 3 390 bytes of CODE  memory
   156 bytes of CONST memory
    20 bytes of DATA  memory

Errors: none
Warnings: none
