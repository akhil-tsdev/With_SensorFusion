###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:02
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\flash\fsl_flash.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\flash\fsl_flash.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\fsl_flash.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\fsl_flash.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\flash\fsl_flash.c
      1          /*
      2           * Copyright (c) 2015-2016, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "fsl_flash.h"
     32          
     33          /*******************************************************************************
     34           * Definitions
     35           ******************************************************************************/
     36          
     37          /*!
     38           * @name Misc utility defines
     39           * @{
     40           */
     41          #ifndef ALIGN_DOWN
     42          #define ALIGN_DOWN(x, a) ((x) & (uint32_t)(-((int32_t)(a))))
     43          #endif
     44          #ifndef ALIGN_UP
     45          #define ALIGN_UP(x, a) (-((int32_t)((uint32_t)(-((int32_t)(x))) & (uint32_t)(-((int32_t)(a))))))
     46          #endif
     47          
     48          #define BYTES_JOIN_TO_WORD_1_3(x, y) ((((uint32_t)(x)&0xFFU) << 24) | ((uint32_t)(y)&0xFFFFFFU))
     49          #define BYTES_JOIN_TO_WORD_2_2(x, y) ((((uint32_t)(x)&0xFFFFU) << 16) | ((uint32_t)(y)&0xFFFFU))
     50          #define BYTES_JOIN_TO_WORD_3_1(x, y) ((((uint32_t)(x)&0xFFFFFFU) << 8) | ((uint32_t)(y)&0xFFU))
     51          #define BYTES_JOIN_TO_WORD_1_1_2(x, y, z) \
     52              ((((uint32_t)(x)&0xFFU) << 24) | (((uint32_t)(y)&0xFFU) << 16) | ((uint32_t)(z)&0xFFFFU))
     53          #define BYTES_JOIN_TO_WORD_1_2_1(x, y, z) \
     54              ((((uint32_t)(x)&0xFFU) << 24) | (((uint32_t)(y)&0xFFFFU) << 8) | ((uint32_t)(z)&0xFFU))
     55          #define BYTES_JOIN_TO_WORD_2_1_1(x, y, z) \
     56              ((((uint32_t)(x)&0xFFFFU) << 16) | (((uint32_t)(y)&0xFFU) << 8) | ((uint32_t)(z)&0xFFU))
     57          #define BYTES_JOIN_TO_WORD_1_1_1_1(x, y, z, w)                                                      \
     58              ((((uint32_t)(x)&0xFFU) << 24) | (((uint32_t)(y)&0xFFU) << 16) | (((uint32_t)(z)&0xFFU) << 8) | \
     59               ((uint32_t)(w)&0xFFU))
     60          /*@}*/
     61          
     62          /*! @brief Data flash IFR map Field*/
     63          #if defined(FSL_FEATURE_FLASH_IS_FTFE) && FSL_FEATURE_FLASH_IS_FTFE
     64          #define DFLASH_IFR_READRESOURCE_START_ADDRESS 0x8003F8U
     65          #else /* FSL_FEATURE_FLASH_IS_FTFL == 1 or FSL_FEATURE_FLASH_IS_FTFA = =1 */
     66          #define DFLASH_IFR_READRESOURCE_START_ADDRESS 0x8000F8U
     67          #endif
     68          
     69          /*!
     70           * @name Reserved FlexNVM size (For a variety of purposes) defines
     71           * @{
     72           */
     73          #define FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED 0xFFFFFFFFU
     74          #define FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_RESERVED 0xFFFFU
     75          /*@}*/
     76          
     77          /*!
     78           * @name Flash Program Once Field defines
     79           * @{
     80           */
     81          #if defined(FSL_FEATURE_FLASH_IS_FTFA) && FSL_FEATURE_FLASH_IS_FTFA
     82          /* FTFA parts(eg. K80, KL80, L5K) support both 4-bytes and 8-bytes unit size */
     83          #define FLASH_PROGRAM_ONCE_MIN_ID_8BYTES \
     84              0x10U /* Minimum Index indcating one of Progam Once Fields which is accessed in 8-byte records */
     85          #define FLASH_PROGRAM_ONCE_MAX_ID_8BYTES \
     86              0x13U /* Maximum Index indcating one of Progam Once Fields which is accessed in 8-byte records */
     87          #define FLASH_PROGRAM_ONCE_IS_4BYTES_UNIT_SUPPORT 1
     88          #define FLASH_PROGRAM_ONCE_IS_8BYTES_UNIT_SUPPORT 1
     89          #elif defined(FSL_FEATURE_FLASH_IS_FTFE) && FSL_FEATURE_FLASH_IS_FTFE
     90          /* FTFE parts(eg. K65, KE18) only support 8-bytes unit size */
     91          #define FLASH_PROGRAM_ONCE_IS_4BYTES_UNIT_SUPPORT 0
     92          #define FLASH_PROGRAM_ONCE_IS_8BYTES_UNIT_SUPPORT 1
     93          #elif defined(FSL_FEATURE_FLASH_IS_FTFL) && FSL_FEATURE_FLASH_IS_FTFL
     94          /* FTFL parts(eg. K20) only support 4-bytes unit size */
     95          #define FLASH_PROGRAM_ONCE_IS_4BYTES_UNIT_SUPPORT 1
     96          #define FLASH_PROGRAM_ONCE_IS_8BYTES_UNIT_SUPPORT 0
     97          #endif
     98          /*@}*/
     99          
    100          /*!
    101           * @name Flash security status defines
    102           * @{
    103           */
    104          #define FLASH_SECURITY_STATE_KEYEN 0x80U
    105          #define FLASH_SECURITY_STATE_UNSECURED 0x02U
    106          #define FLASH_NOT_SECURE 0x01U
    107          #define FLASH_SECURE_BACKDOOR_ENABLED 0x02U
    108          #define FLASH_SECURE_BACKDOOR_DISABLED 0x04U
    109          /*@}*/
    110          
    111          /*!
    112           * @name Flash controller command numbers
    113           * @{
    114           */
    115          #define FTFx_VERIFY_BLOCK 0x00U                    /*!< RD1BLK*/
    116          #define FTFx_VERIFY_SECTION 0x01U                  /*!< RD1SEC*/
    117          #define FTFx_PROGRAM_CHECK 0x02U                   /*!< PGMCHK*/
    118          #define FTFx_READ_RESOURCE 0x03U                   /*!< RDRSRC*/
    119          #define FTFx_PROGRAM_LONGWORD 0x06U                /*!< PGM4*/
    120          #define FTFx_PROGRAM_PHRASE 0x07U                  /*!< PGM8*/
    121          #define FTFx_ERASE_BLOCK 0x08U                     /*!< ERSBLK*/
    122          #define FTFx_ERASE_SECTOR 0x09U                    /*!< ERSSCR*/
    123          #define FTFx_PROGRAM_SECTION 0x0BU                 /*!< PGMSEC*/
    124          #define FTFx_VERIFY_ALL_BLOCK 0x40U                /*!< RD1ALL*/
    125          #define FTFx_READ_ONCE 0x41U                       /*!< RDONCE or RDINDEX*/
    126          #define FTFx_PROGRAM_ONCE 0x43U                    /*!< PGMONCE or PGMINDEX*/
    127          #define FTFx_ERASE_ALL_BLOCK 0x44U                 /*!< ERSALL*/
    128          #define FTFx_SECURITY_BY_PASS 0x45U                /*!< VFYKEY*/
    129          #define FTFx_SWAP_CONTROL 0x46U                    /*!< SWAP*/
    130          #define FTFx_ERASE_ALL_BLOCK_UNSECURE 0x49U        /*!< ERSALLU*/
    131          #define FTFx_VERIFY_ALL_EXECUTE_ONLY_SEGMENT 0x4AU /*!< RD1XA*/
    132          #define FTFx_ERASE_ALL_EXECUTE_ONLY_SEGMENT 0x4BU  /*!< ERSXA*/
    133          #define FTFx_PROGRAM_PARTITION 0x80U               /*!< PGMPART)*/
    134          #define FTFx_SET_FLEXRAM_FUNCTION 0x81U            /*!< SETRAM*/
    135                                                             /*@}*/
    136          
    137          /*!
    138           * @name Common flash register info defines
    139           * @{
    140           */
    141          #if defined(FTFA)
    142          #define FTFx FTFA
    143          #define FTFx_BASE FTFA_BASE
    144          #define FTFx_FSTAT_CCIF_MASK FTFA_FSTAT_CCIF_MASK
    145          #define FTFx_FSTAT_RDCOLERR_MASK FTFA_FSTAT_RDCOLERR_MASK
    146          #define FTFx_FSTAT_ACCERR_MASK FTFA_FSTAT_ACCERR_MASK
    147          #define FTFx_FSTAT_FPVIOL_MASK FTFA_FSTAT_FPVIOL_MASK
    148          #define FTFx_FSTAT_MGSTAT0_MASK FTFA_FSTAT_MGSTAT0_MASK
    149          #define FTFx_FSEC_SEC_MASK FTFA_FSEC_SEC_MASK
    150          #define FTFx_FSEC_KEYEN_MASK FTFA_FSEC_KEYEN_MASK
    151          #if defined(FSL_FEATURE_FLASH_HAS_FLEX_RAM) && FSL_FEATURE_FLASH_HAS_FLEX_RAM
    152          #define FTFx_FCNFG_RAMRDY_MASK FTFA_FCNFG_RAMRDY_MASK
    153          #endif /* FSL_FEATURE_FLASH_HAS_FLEX_RAM */
    154          #if defined(FSL_FEATURE_FLASH_HAS_FLEX_NVM) && FSL_FEATURE_FLASH_HAS_FLEX_NVM
    155          #define FTFx_FCNFG_EEERDY_MASK FTFA_FCNFG_EEERDY_MASK
    156          #endif /* FSL_FEATURE_FLASH_HAS_FLEX_NVM */
    157          #elif defined(FTFE)
    158          #define FTFx FTFE
    159          #define FTFx_BASE FTFE_BASE
    160          #define FTFx_FSTAT_CCIF_MASK FTFE_FSTAT_CCIF_MASK
    161          #define FTFx_FSTAT_RDCOLERR_MASK FTFE_FSTAT_RDCOLERR_MASK
    162          #define FTFx_FSTAT_ACCERR_MASK FTFE_FSTAT_ACCERR_MASK
    163          #define FTFx_FSTAT_FPVIOL_MASK FTFE_FSTAT_FPVIOL_MASK
    164          #define FTFx_FSTAT_MGSTAT0_MASK FTFE_FSTAT_MGSTAT0_MASK
    165          #define FTFx_FSEC_SEC_MASK FTFE_FSEC_SEC_MASK
    166          #define FTFx_FSEC_KEYEN_MASK FTFE_FSEC_KEYEN_MASK
    167          #if defined(FSL_FEATURE_FLASH_HAS_FLEX_RAM) && FSL_FEATURE_FLASH_HAS_FLEX_RAM
    168          #define FTFx_FCNFG_RAMRDY_MASK FTFE_FCNFG_RAMRDY_MASK
    169          #endif /* FSL_FEATURE_FLASH_HAS_FLEX_RAM */
    170          #if defined(FSL_FEATURE_FLASH_HAS_FLEX_NVM) && FSL_FEATURE_FLASH_HAS_FLEX_NVM
    171          #define FTFx_FCNFG_EEERDY_MASK FTFE_FCNFG_EEERDY_MASK
    172          #endif /* FSL_FEATURE_FLASH_HAS_FLEX_NVM */
    173          #elif defined(FTFL)
    174          #define FTFx FTFL
    175          #define FTFx_BASE FTFL_BASE
    176          #define FTFx_FSTAT_CCIF_MASK FTFL_FSTAT_CCIF_MASK
    177          #define FTFx_FSTAT_RDCOLERR_MASK FTFL_FSTAT_RDCOLERR_MASK
    178          #define FTFx_FSTAT_ACCERR_MASK FTFL_FSTAT_ACCERR_MASK
    179          #define FTFx_FSTAT_FPVIOL_MASK FTFL_FSTAT_FPVIOL_MASK
    180          #define FTFx_FSTAT_MGSTAT0_MASK FTFL_FSTAT_MGSTAT0_MASK
    181          #define FTFx_FSEC_SEC_MASK FTFL_FSEC_SEC_MASK
    182          #define FTFx_FSEC_KEYEN_MASK FTFL_FSEC_KEYEN_MASK
    183          #if defined(FSL_FEATURE_FLASH_HAS_FLEX_RAM) && FSL_FEATURE_FLASH_HAS_FLEX_RAM
    184          #define FTFx_FCNFG_RAMRDY_MASK FTFL_FCNFG_RAMRDY_MASK
    185          #endif /* FSL_FEATURE_FLASH_HAS_FLEX_RAM */
    186          #if defined(FSL_FEATURE_FLASH_HAS_FLEX_NVM) && FSL_FEATURE_FLASH_HAS_FLEX_NVM
    187          #define FTFx_FCNFG_EEERDY_MASK FTFL_FCNFG_EEERDY_MASK
    188          #endif /* FSL_FEATURE_FLASH_HAS_FLEX_NVM */
    189          #else
    190          #error "Unknown flash controller"
    191          #endif
    192          /*@}*/
    193          
    194          /*!
    195           * @brief Enumeration for access segment property.
    196           */
    197          enum _flash_access_segment_property
    198          {
    199              kFLASH_AccessSegmentBase = 256UL,
    200          };
    201          
    202          /*!
    203           * @brief Enumeration for flash config area.
    204           */
    205          enum _flash_config_area_range
    206          {
    207              kFLASH_ConfigAreaStart = 0x400U,
    208              kFLASH_ConfigAreaEnd = 0x40FU
    209          };
    210          
    211          /*! @brief Total flash region count*/
    212          #define FSL_FEATURE_FTFx_REGION_COUNT (32U)
    213          
    214          /*!
    215           * @name Flash register access type defines
    216           * @{
    217           */
    218          #if FLASH_DRIVER_IS_FLASH_RESIDENT
    219          #define FTFx_REG_ACCESS_TYPE volatile uint8_t *
    220          #define FTFx_REG32_ACCESS_TYPE volatile uint32_t *
    221          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
    222                 /*@}*/
    223          
    224          /*******************************************************************************
    225           * Prototypes
    226           ******************************************************************************/
    227          
    228          #if FLASH_DRIVER_IS_FLASH_RESIDENT
    229          /*! @brief Copy flash_run_command() to RAM*/
    230          static void copy_flash_run_command(uint32_t *flashRunCommand);
    231          /*! @brief Copy flash_cache_clear_command() to RAM*/
    232          static void copy_flash_cache_clear_command(uint32_t *flashCacheClearCommand);
    233          /*! @brief Check whether flash execute-in-ram functions are ready*/
    234          static status_t flash_check_execute_in_ram_function_info(flash_config_t *config);
    235          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
    236          
    237          /*! @brief Internal function Flash command sequence. Called by driver APIs only*/
    238          static status_t flash_command_sequence(flash_config_t *config);
    239          
    240          /*! @brief Perform the cache clear to the flash*/
    241          void flash_cache_clear(flash_config_t *config);
    242          
    243          /*! @brief Validates the range and alignment of the given address range.*/
    244          static status_t flash_check_range(flash_config_t *config,
    245                                            uint32_t startAddress,
    246                                            uint32_t lengthInBytes,
    247                                            uint32_t alignmentBaseline);
    248          /*! @brief Gets the right address, sector and block size of current flash type which is indicated by address.*/
    249          static status_t flash_get_matched_operation_info(flash_config_t *config,
    250                                                           uint32_t address,
    251                                                           flash_operation_config_t *info);
    252          /*! @brief Validates the given user key for flash erase APIs.*/
    253          static status_t flash_check_user_key(uint32_t key);
    254          
    255          #if FLASH_SSD_IS_FLEXNVM_ENABLED
    256          /*! @brief Updates FlexNVM memory partition status according to data flash 0 IFR.*/
    257          static status_t flash_update_flexnvm_memory_partition_status(flash_config_t *config);
    258          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
    259          
    260          #if defined(FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD) && FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD
    261          /*! @brief Validates the range of the given resource address.*/
    262          static status_t flash_check_resource_range(uint32_t start,
    263                                                     uint32_t lengthInBytes,
    264                                                     uint32_t alignmentBaseline,
    265                                                     flash_read_resource_option_t option);
    266          #endif /* FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD */
    267          
    268          #if defined(FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD) && FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD
    269          /*! @brief Validates the gived swap control option.*/
    270          static status_t flash_check_swap_control_option(flash_swap_control_option_t option);
    271          #endif /* FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD */
    272          
    273          #if defined(FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP) && FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP
    274          /*! @brief Validates the gived address to see if it is equal to swap indicator address in pflash swap IFR.*/
    275          static status_t flash_validate_swap_indicator_address(flash_config_t *config, uint32_t address);
    276          #endif /* FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP */
    277          
    278          #if defined(FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD) && FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD
    279          /*! @brief Validates the gived flexram function option.*/
    280          static inline status_t flasn_check_flexram_function_option_range(flash_flexram_function_option_t option);
    281          #endif /* FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD */
    282          
    283          /*******************************************************************************
    284           * Variables
    285           ******************************************************************************/
    286          
    287          /*! @brief Access to FTFx->FCCOB */
    288          #if defined(FSL_FEATURE_FLASH_IS_FTFA) && FSL_FEATURE_FLASH_IS_FTFA
    289          volatile uint32_t *const kFCCOBx = (volatile uint32_t *)&FTFA->FCCOB3;
    290          #elif defined(FSL_FEATURE_FLASH_IS_FTFE) && FSL_FEATURE_FLASH_IS_FTFE

   \                                 In section .rodata, align 4
    291          volatile uint32_t *const kFCCOBx = (volatile uint32_t *)&FTFE->FCCOB3;
   \                     kFCCOBx:
   \   00000000   0x40020004         DC32 40020004H
    292          #elif defined(FSL_FEATURE_FLASH_IS_FTFL) && FSL_FEATURE_FLASH_IS_FTFL
    293          volatile uint32_t *const kFCCOBx = (volatile uint32_t *)&FTFL->FCCOB3;
    294          #else
    295          #error "Unknown flash controller"
    296          #endif
    297          
    298          /*! @brief Access to FTFx->FPROT */
    299          #if defined(FSL_FEATURE_FLASH_IS_FTFA) && FSL_FEATURE_FLASH_IS_FTFA
    300          volatile uint32_t *const kFPROT = (volatile uint32_t *)&FTFA->FPROT3;
    301          #elif defined(FSL_FEATURE_FLASH_IS_FTFE) && FSL_FEATURE_FLASH_IS_FTFE

   \                                 In section .rodata, align 4
    302          volatile uint32_t *const kFPROT = (volatile uint32_t *)&FTFE->FPROT3;
   \                     kFPROT:
   \   00000000   0x40020010         DC32 40020010H
    303          #elif defined(FSL_FEATURE_FLASH_IS_FTFL) && FSL_FEATURE_FLASH_IS_FTFL
    304          volatile uint32_t *const kFPROT = (volatile uint32_t *)&FTFL->FPROT3;
    305          #else
    306          #error "Unknown flash controller"
    307          #endif
    308          
    309          #if FLASH_DRIVER_IS_FLASH_RESIDENT
    310          /*! @brief A function pointer used to point to relocated flash_run_command() */

   \                                 In section .bss, align 4
    311          static void (*callFlashRunCommand)(FTFx_REG_ACCESS_TYPE ftfx_fstat);
   \                     callFlashRunCommand:
   \   00000000                      DS8 4
    312          /*! @brief A function pointer used to point to relocated flash_cache_clear_command() */

   \                                 In section .bss, align 4
    313          static void (*callFlashCacheClearCommand)(FTFx_REG32_ACCESS_TYPE ftfx_reg);
   \                     callFlashCacheClearCommand:
   \   00000000                      DS8 4
    314          
    315          /*!
    316           * @brief Position independent code of flash_run_command()
    317           *
    318           * Note1: The prototype of C function is shown as below:
    319           * @code
    320           *   void flash_run_command(FTFx_REG_ACCESS_TYPE ftfx_fstat)
    321           *   {
    322           *       // clear CCIF bit
    323           *       *ftfx_fstat = FTFx_FSTAT_CCIF_MASK;
    324           *
    325           *       // Check CCIF bit of the flash status register, wait till it is set.
    326           *       // IP team indicates that this loop will always complete.
    327           *       while (!((*ftfx_fstat) & FTFx_FSTAT_CCIF_MASK))
    328           *       {
    329           *       }
    330           *   }
    331           * @endcode
    332           * Note2: The binary code is generated by IAR 7.50.1
    333           */

   \                                 In section .rodata, align 4
    334          const static uint16_t s_flashRunCommandFunctionCode[] = {
   \                     s_flashRunCommandFunctionCode:
   \   00000000   0x2180 0x7001      DC16 8576, 28673, 30722, 16906, 53500, 18288
   \              0x7802 0x420A
   \              0xD0FC 0x4770
    335              0x2180, /* MOVS  R1, #128 ; 0x80 */
    336              0x7001, /* STRB  R1, [R0] */
    337              /* @4: */
    338              0x7802, /* LDRB  R2, [R0] */
    339              0x420a, /* TST   R2, R1 */
    340              0xd0fc, /* BEQ.N @4 */
    341              0x4770  /* BX    LR */
    342          };
    343          
    344          /*!
    345           * @brief Position independent code of flash_cache_clear_command()
    346           *
    347           * Note1: The prototype of C function is shown as below:
    348           * @code
    349           *   void flash_cache_clear_command(FTFx_REG32_ACCESS_TYPE ftfx_reg)
    350           *   {
    351           *   #if defined(FSL_FEATURE_FLASH_HAS_MCM_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_MCM_FLASH_CACHE_CONTROLS
    352           *       *ftfx_reg |= MCM_PLACR_CFCC_MASK;
    353           *   #elif defined(FSL_FEATURE_FLASH_HAS_FMC_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_FMC_FLASH_CACHE_CONTROLS
    354           *   #if defined(FMC_PFB01CR_CINV_WAY_MASK)
    355           *       *ftfx_reg = (*ftfx_reg & ~FMC_PFB01CR_CINV_WAY_MASK) | FMC_PFB01CR_CINV_WAY(~0);
    356           *   #else
    357           *       *ftfx_reg = (*ftfx_reg & ~FMC_PFB0CR_CINV_WAY_MASK) | FMC_PFB0CR_CINV_WAY(~0);
    358           *   #endif
    359           *   #elif defined(FSL_FEATURE_FLASH_HAS_MSCM_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_MSCM_FLASH_CACHE_CONTROLS
    360           *       *ftfx_reg |= MSCM_OCMDR_OCMC1(2);
    361           *       *ftfx_reg |= MSCM_OCMDR_OCMC1(1);
    362           *   #else
    363           *   #if defined(FMC_PFB0CR_S_INV_MASK)
    364           *       *ftfx_reg |= FMC_PFB0CR_S_INV_MASK;
    365           *   #elif defined(FMC_PFB01CR_S_INV_MASK)
    366           *       *ftfx_reg |= FMC_PFB01CR_S_INV_MASK;
    367           *   #endif
    368           *   //    #error "Unknown flash cache controller"
    369           *   #endif // FSL_FEATURE_FTFx_MCM_FLASH_CACHE_CONTROLS
    370           *       // Memory barriers for good measure.
    371           *       // All Cache, Branch predictor and TLB maintenance operations before this instruction complete
    372           *       __ISB();
    373           *       __DSB();
    374           *   }
    375           * @endcode
    376           * Note2: The binary code is generated by IAR 7.50.1
    377           */
    378          #if defined(FSL_FEATURE_FLASH_HAS_MCM_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_MCM_FLASH_CACHE_CONTROLS
    379          const static uint16_t s_flashCacheClearCommandFunctionCode[] = {
    380              0x6801,         /* LDR  R1, [R0] */
    381              0x2280,         /* MOVS R2, #128   ; 0x80 */
    382              0x00d2,         /* LSLS R2, R2, #3 */
    383              0x430a,         /* ORRS R2, R2, R1 */
    384              0x6002,         /* STR  R2, [R0] */
    385              0xf3bf, 0x8f6f, /* ISB */
    386              0xf3bf, 0x8f4f, /* DSB */
    387              0x4770          /* BX   LR */
    388          };
    389          #elif defined(FSL_FEATURE_FLASH_HAS_FMC_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_FMC_FLASH_CACHE_CONTROLS

   \                                 In section .rodata, align 4
    390          const static uint16_t s_flashCacheClearCommandFunctionCode[] = {
   \                     s_flashCacheClearCommandFunctionCode:
   \   00000000   0x6801 0x22F0      DC16 26625, 8944, 1042, 17162, 24578, 62399, 36719, 62399, 36687, 18288
   \              0x0412 0x430A
   \              0x6002 0xF3BF
   \              0x8F6F 0xF3BF
   \              0x8F4F 0x4770
    391              0x6801,         /* LDR  R1, [R0] */
    392              0x22f0,         /* MOVS R2, #240    ; 0xf0 */
    393              0x0412,         /* LSLS R2, R2, #16 */
    394              0x430a,         /* ORRS R2, R2, R1 */
    395              0x6002,         /* STR  R2, [R0] */
    396              0xf3bf, 0x8f6f, /* ISB */
    397              0xf3bf, 0x8f4f, /* DSB */
    398              0x4770          /* BX   LR */
    399          };
    400          #elif defined(FSL_FEATURE_FLASH_HAS_MSCM_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_MSCM_FLASH_CACHE_CONTROLS
    401          const static uint16_t s_flashCacheClearCommandFunctionCode[] = {
    402              0x6801,         /* LDR  R1, [R0] */
    403              0x2220,         /* MOVS R2, #32    ; 0x20 */
    404              0x430a,         /* ORRS R2, R2, R1 */
    405              0x6002,         /* STR  R2, [R0] */
    406              0x6801,         /* LDR  R1, [R0] */
    407              0x2210,         /* MOVS R2, #16    ; 0x10 */
    408              0x430a,         /* ORRS R2, R2, R1 */
    409              0x6002,         /* STR  R2, [R0] */
    410              0xf3bf, 0x8f6f, /* ISB */
    411              0xf3bf, 0x8f4f, /* DSB */
    412              0x4770          /* BX   LR */
    413          };
    414          #else
    415          #if defined(FMC_PFB0CR_S_INV_MASK) || defined(FMC_PFB01CR_S_INV_MASK)
    416          const static uint16_t s_flashCacheClearCommandFunctionCode[] = {
    417              0x6801,         /* LDR  R1, [R0]  */
    418              0x2280,         /* MOVS R2, #128    ; 0x80 */
    419              0x0312,         /* LSLS R2, R2, #12 */
    420              0x430a,         /* ORRS R2, R2, R1 */
    421              0x6002,         /* STR  R2, [R0] */
    422              0xf3bf, 0x8f6f, /* ISB */
    423              0xf3bf, 0x8f4f, /* DSB */
    424              0x4770          /* BX   LR */
    425          };
    426          #else
    427          const static uint16_t s_flashCacheClearCommandFunctionCode[] = {
    428              0xf3bf, 0x8f6f, /* ISB */
    429              0xf3bf, 0x8f4f, /* DSB */
    430              0x4770          /* BX   LR */
    431          };
    432          #endif
    433          #endif
    434          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
    435          
    436          #if (FLASH_DRIVER_IS_FLASH_RESIDENT && !FLASH_DRIVER_IS_EXPORTED)
    437          /*! @brief A static buffer used to hold flash_run_command() */
    438          static uint32_t s_flashRunCommand[kFLASH_ExecuteInRamFunctionMaxSizeInWords];
    439          /*! @brief A static buffer used to hold flash_cache_clear_command() */
    440          static uint32_t s_flashCacheClearCommand[kFLASH_ExecuteInRamFunctionMaxSizeInWords];
    441          /*! @brief Flash execute-in-ram function information */
    442          static flash_execute_in_ram_function_config_t s_flashExecuteInRamFunctionInfo;
    443          #endif
    444          
    445          /*!
    446           * @brief Table of pflash sizes.
    447           *
    448           *  The index into this table is the value of the SIM_FCFG1.PFSIZE bitfield.
    449           *
    450           *  The values in this table have been right shifted 10 bits so that they will all fit within
    451           *  an 16-bit integer. To get the actual flash density, you must left shift the looked up value
    452           *  by 10 bits.
    453           *
    454           *  Elements of this table have a value of 0 in cases where the PFSIZE bitfield value is
    455           *  reserved.
    456           *
    457           *  Code to use the table:
    458           *  @code
    459           *      uint8_t pfsize = (SIM->FCFG1 & SIM_FCFG1_PFSIZE_MASK) >> SIM_FCFG1_PFSIZE_SHIFT;
    460           *      flashDensity = ((uint32_t)kPFlashDensities[pfsize]) << 10;
    461           *  @endcode
    462           */

   \                                 In section .rodata, align 4
    463          const uint16_t kPFlashDensities[] = {
   \                     kPFlashDensities:
   \   00000000   0x0008 0x0010      DC16 8, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024
   \              0x0018 0x0020
   \              0x0030 0x0040
   \              0x0060 0x0080
   \              0x00C0 0x0100
   \              0x0180 0x0200
   \              0x0300 0x0400
   \   0000001C   0x0600             DC16 1536
   \   0000001E   0x00 0x00          DC8 0, 0
    464              8,    /* 0x0 - 8192, 8KB */
    465              16,   /* 0x1 - 16384, 16KB */
    466              24,   /* 0x2 - 24576, 24KB */
    467              32,   /* 0x3 - 32768, 32KB */
    468              48,   /* 0x4 - 49152, 48KB */
    469              64,   /* 0x5 - 65536, 64KB */
    470              96,   /* 0x6 - 98304, 96KB */
    471              128,  /* 0x7 - 131072, 128KB */
    472              192,  /* 0x8 - 196608, 192KB */
    473              256,  /* 0x9 - 262144, 256KB */
    474              384,  /* 0xa - 393216, 384KB */
    475              512,  /* 0xb - 524288, 512KB */
    476              768,  /* 0xc - 786432, 768KB */
    477              1024, /* 0xd - 1048576, 1MB */
    478              1536, /* 0xe - 1572864, 1.5MB */
    479              /* 2048,  0xf - 2097152, 2MB */
    480          };
    481          
    482          /*******************************************************************************
    483           * Code
    484           ******************************************************************************/
    485          

   \                                 In section .text, align 2, keep-with-next
    486          status_t FLASH_Init(flash_config_t *config)
    487          {
   \                     FLASH_Init: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    488              uint32_t flashDensity;
    489          
    490              if (config == NULL)
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD101             BNE.N    ??FLASH_Init_0
    491              {
    492                  return kStatus_FLASH_InvalidArgument;
   \   00000006   0x2004             MOVS     R0,#+4
   \   00000008   0xE028             B.N      ??FLASH_Init_1
    493              }
    494          
    495              /* calculate the flash density from SIM_FCFG1.PFSIZE */
    496              uint8_t pfsize = (SIM->FCFG1 & SIM_FCFG1_PFSIZE_MASK) >> SIM_FCFG1_PFSIZE_SHIFT;
   \                     ??FLASH_Init_0: (+1)
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x4004804c
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x0E00             LSRS     R0,R0,#+24
   \   00000012   0xF010 0x030F      ANDS     R3,R0,#0xF
    497              /* PFSIZE=0xf means that on customer parts the IFR was not correctly programmed.
    498               * We just use the pre-defined flash size in feature file here to support pre-production parts */
    499              if (pfsize == 0xf)
   \   00000016   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000018   0x2B0F             CMP      R3,#+15
   \   0000001A   0xD103             BNE.N    ??FLASH_Init_2
    500              {
    501                  flashDensity = FSL_FEATURE_FLASH_PFLASH_BLOCK_COUNT * FSL_FEATURE_FLASH_PFLASH_BLOCK_SIZE;
   \   0000001C   0xF45F 0x1080      MOVS     R0,#+1048576
   \   00000020   0x0002             MOVS     R2,R0
   \   00000022   0xE006             B.N      ??FLASH_Init_3
    502              }
    503              else
    504              {
    505                  flashDensity = ((uint32_t)kPFlashDensities[pfsize]) << 10;
   \                     ??FLASH_Init_2: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable24
   \   00000028   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000002A   0xF830 0x0013      LDRH     R0,[R0, R3, LSL #+1]
   \   0000002E   0x0280             LSLS     R0,R0,#+10
   \   00000030   0x0002             MOVS     R2,R0
    506              }
    507          
    508              /* fill out a few of the structure members */
    509              config->PFlashBlockBase = FSL_FEATURE_FLASH_PFLASH_START_ADDRESS;
   \                     ??FLASH_Init_3: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x6008             STR      R0,[R1, #+0]
    510              config->PFlashTotalSize = flashDensity;
   \   00000036   0x604A             STR      R2,[R1, #+4]
    511              config->PFlashBlockCount = FSL_FEATURE_FLASH_PFLASH_BLOCK_COUNT;
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0x6088             STR      R0,[R1, #+8]
    512              config->PFlashSectorSize = FSL_FEATURE_FLASH_PFLASH_BLOCK_SECTOR_SIZE;
   \   0000003C   0xF44F 0x5080      MOV      R0,#+4096
   \   00000040   0x60C8             STR      R0,[R1, #+12]
    513          
    514          #if defined(FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL) && FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    515              config->PFlashAccessSegmentSize = kFLASH_AccessSegmentBase << FTFx->FACSS;
    516              config->PFlashAccessSegmentCount = FTFx->FACSN;
    517          #else
    518              config->PFlashAccessSegmentSize = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x6148             STR      R0,[R1, #+20]
    519              config->PFlashAccessSegmentCount = 0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x6188             STR      R0,[R1, #+24]
    520          #endif /* FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL */
    521          
    522              config->PFlashCallback = NULL;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x6108             STR      R0,[R1, #+16]
    523          
    524          /* copy required flash commands to RAM */
    525          #if (FLASH_DRIVER_IS_FLASH_RESIDENT && !FLASH_DRIVER_IS_EXPORTED)
    526              if (kStatus_FLASH_Success != flash_check_execute_in_ram_function_info(config))
    527              {
    528                  s_flashExecuteInRamFunctionInfo.activeFunctionCount = 0;
    529                  s_flashExecuteInRamFunctionInfo.flashRunCommand = s_flashRunCommand;
    530                  s_flashExecuteInRamFunctionInfo.flashCacheClearCommand = s_flashCacheClearCommand;
    531                  config->flashExecuteInRamFunctionInfo = &s_flashExecuteInRamFunctionInfo.activeFunctionCount;
    532                  FLASH_PrepareExecuteInRamFunctions(config);
    533              }
    534          #endif
    535          
    536              config->FlexRAMBlockBase = FSL_FEATURE_FLASH_FLEX_RAM_START_ADDRESS;
   \   0000004E   0xF05F 0x50A0      MOVS     R0,#+335544320
   \   00000052   0x6208             STR      R0,[R1, #+32]
    537              config->FlexRAMTotalSize = FSL_FEATURE_FLASH_FLEX_RAM_SIZE;
   \   00000054   0xF44F 0x5080      MOV      R0,#+4096
   \   00000058   0x6248             STR      R0,[R1, #+36]
    538          
    539          #if FLASH_SSD_IS_FLEXNVM_ENABLED
    540              {
    541                  status_t returnCode;
    542                  config->DFlashBlockBase = FSL_FEATURE_FLASH_FLEX_NVM_START_ADDRESS;
    543                  returnCode = flash_update_flexnvm_memory_partition_status(config);
    544                  if (returnCode != kStatus_FLASH_Success)
    545                  {
    546                      return returnCode;
    547                  }
    548              }
    549          #endif
    550          
    551              return kStatus_FLASH_Success;
   \   0000005A   0x2000             MOVS     R0,#+0
   \                     ??FLASH_Init_1: (+1)
   \   0000005C   0x4770             BX       LR               ;; return
    552          }
    553          

   \                                 In section .text, align 2, keep-with-next
    554          status_t FLASH_SetCallback(flash_config_t *config, flash_callback_t callback)
    555          {
   \                     FLASH_SetCallback: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    556              if (config == NULL)
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD101             BNE.N    ??FLASH_SetCallback_0
    557              {
    558                  return kStatus_FLASH_InvalidArgument;
   \   00000006   0x2004             MOVS     R0,#+4
   \   00000008   0xE001             B.N      ??FLASH_SetCallback_1
    559              }
    560          
    561              config->PFlashCallback = callback;
   \                     ??FLASH_SetCallback_0: (+1)
   \   0000000A   0x6111             STR      R1,[R2, #+16]
    562          
    563              return kStatus_FLASH_Success;
   \   0000000C   0x2000             MOVS     R0,#+0
   \                     ??FLASH_SetCallback_1: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    564          }
    565          
    566          #if FLASH_DRIVER_IS_FLASH_RESIDENT

   \                                 In section .text, align 2, keep-with-next
    567          status_t FLASH_PrepareExecuteInRamFunctions(flash_config_t *config)
    568          {
   \                     FLASH_PrepareExecuteInRamFunctions: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    569              flash_execute_in_ram_function_config_t *flashExecuteInRamFunctionInfo;
    570          
    571              if (config == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??FLASH_PrepareExecuteInRamFunctions_0
    572              {
    573                  return kStatus_FLASH_InvalidArgument;
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0xE00A             B.N      ??FLASH_PrepareExecuteInRamFunctions_1
    574              }
    575          
    576              flashExecuteInRamFunctionInfo = (flash_execute_in_ram_function_config_t *)config->flashExecuteInRamFunctionInfo;
   \                     ??FLASH_PrepareExecuteInRamFunctions_0: (+1)
   \   0000000C   0x69E0             LDR      R0,[R4, #+28]
   \   0000000E   0x0005             MOVS     R5,R0
    577          
    578              copy_flash_run_command(flashExecuteInRamFunctionInfo->flashRunCommand);
   \   00000010   0x6868             LDR      R0,[R5, #+4]
   \   00000012   0x.... 0x....      BL       copy_flash_run_command
    579              copy_flash_cache_clear_command(flashExecuteInRamFunctionInfo->flashCacheClearCommand);
   \   00000016   0x68A8             LDR      R0,[R5, #+8]
   \   00000018   0x.... 0x....      BL       copy_flash_cache_clear_command
    580              flashExecuteInRamFunctionInfo->activeFunctionCount = kFLASH_ExecuteInRamFunctionTotalNum;
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x6028             STR      R0,[R5, #+0]
    581          
    582              return kStatus_FLASH_Success;
   \   00000020   0x2000             MOVS     R0,#+0
   \                     ??FLASH_PrepareExecuteInRamFunctions_1: (+1)
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    583          }
    584          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
    585          

   \                                 In section .text, align 2, keep-with-next
    586          status_t FLASH_EraseAll(flash_config_t *config, uint32_t key)
    587          {
   \                     FLASH_EraseAll: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    588              status_t returnCode;
    589          
    590              if (config == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??FLASH_EraseAll_0
    591              {
    592                  return kStatus_FLASH_InvalidArgument;
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0xE015             B.N      ??FLASH_EraseAll_1
    593              }
    594          
    595              /* preparing passing parameter to erase all flash blocks */
    596              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_ERASE_ALL_BLOCK, 0xFFFFFFU);
   \                     ??FLASH_EraseAll_0: (+1)
   \   0000000E   0xF07F 0x403B      MVNS     R0,#-1157627904
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable25
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0x6008             STR      R0,[R1, #+0]
    597          
    598              /* Validate the user key */
    599              returnCode = flash_check_user_key(key);
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0x.... 0x....      BL       flash_check_user_key
   \   00000020   0x0006             MOVS     R6,R0
    600              if (returnCode)
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD001             BEQ.N    ??FLASH_EraseAll_2
    601              {
    602                  return returnCode;
   \   00000026   0x0030             MOVS     R0,R6
   \   00000028   0xE007             B.N      ??FLASH_EraseAll_1
    603              }
    604          
    605              /* calling flash command sequence function to execute the command */
    606              returnCode = flash_command_sequence(config);
   \                     ??FLASH_EraseAll_2: (+1)
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       flash_command_sequence
   \   00000030   0x0006             MOVS     R6,R0
    607          
    608              flash_cache_clear(config);
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       flash_cache_clear
    609          
    610          #if FLASH_SSD_IS_FLEXNVM_ENABLED
    611              /* Data flash IFR will be erased by erase all command, so we need to
    612               *  update FlexNVM memory partition status synchronously */
    613              if (returnCode == kStatus_FLASH_Success)
    614              {
    615                  returnCode = flash_update_flexnvm_memory_partition_status(config);
    616              }
    617          #endif
    618          
    619              return returnCode;
   \   00000038   0x0030             MOVS     R0,R6
   \                     ??FLASH_EraseAll_1: (+1)
   \   0000003A   0xBD70             POP      {R4-R6,PC}       ;; return
    620          }
    621          

   \                                 In section .text, align 2, keep-with-next
    622          status_t FLASH_Erase(flash_config_t *config, uint32_t start, uint32_t lengthInBytes, uint32_t key)
    623          {
   \                     FLASH_Erase: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    624              uint32_t sectorSize;
    625              flash_operation_config_t flashInfo;
    626              uint32_t endAddress;      /* storing end address */
    627              uint32_t numberOfSectors; /* number of sectors calculated by endAddress */
    628              status_t returnCode;
    629          
    630              flash_get_matched_operation_info(config, start, &flashInfo);
   \   0000000E   0x466A             MOV      R2,SP
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       flash_get_matched_operation_info
    631          
    632              /* Check the supplied address range. */
    633              returnCode = flash_check_range(config, start, lengthInBytes, flashInfo.sectorCmdAddressAligment);
   \   00000018   0x9B04             LDR      R3,[SP, #+16]
   \   0000001A   0x0032             MOVS     R2,R6
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       flash_check_range
   \   00000024   0x4683             MOV      R11,R0
    634              if (returnCode)
   \   00000026   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000002A   0xD001             BEQ.N    ??FLASH_Erase_0
    635              {
    636                  return returnCode;
   \   0000002C   0x4658             MOV      R0,R11
   \   0000002E   0xE03A             B.N      ??FLASH_Erase_1
    637              }
    638          
    639              start = flashInfo.convertedAddress;
   \                     ??FLASH_Erase_0: (+1)
   \   00000030   0x9800             LDR      R0,[SP, #+0]
   \   00000032   0x0005             MOVS     R5,R0
    640              sectorSize = flashInfo.activeSectorSize;
   \   00000034   0x9801             LDR      R0,[SP, #+4]
   \   00000036   0x4680             MOV      R8,R0
    641          
    642              /* calculating Flash end address */
    643              endAddress = start + lengthInBytes - 1;
   \   00000038   0x1970             ADDS     R0,R6,R5
   \   0000003A   0x1E40             SUBS     R0,R0,#+1
   \   0000003C   0x4681             MOV      R9,R0
    644          
    645              /* re-calculate the endAddress and align it to the start of the next sector
    646               * which will be used in the comparison below */
    647              if (endAddress % sectorSize)
   \   0000003E   0xFBB9 0xF0F8      UDIV     R0,R9,R8
   \   00000042   0xFB08 0x9010      MLS      R0,R8,R0,R9
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD007             BEQ.N    ??FLASH_Erase_2
    648              {
    649                  numberOfSectors = endAddress / sectorSize + 1;
   \   0000004A   0xFBB9 0xF0F8      UDIV     R0,R9,R8
   \   0000004E   0x1C40             ADDS     R0,R0,#+1
   \   00000050   0x4682             MOV      R10,R0
    650                  endAddress = numberOfSectors * sectorSize - 1;
   \   00000052   0xFB08 0xF00A      MUL      R0,R8,R10
   \   00000056   0x1E40             SUBS     R0,R0,#+1
   \   00000058   0x4681             MOV      R9,R0
    651              }
    652          
    653              /* the start address will increment to the next sector address
    654               * until it reaches the endAdddress */
    655              while (start <= endAddress)
   \                     ??FLASH_Erase_2: (+1)
   \   0000005A   0x45A9             CMP      R9,R5
   \   0000005C   0xD31F             BCC.N    ??FLASH_Erase_3
    656              {
    657                  /* preparing passing parameter to erase a flash block */
    658                  kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_ERASE_SECTOR, start);
   \   0000005E   0xF025 0x407F      BIC      R0,R5,#0xFF000000
   \   00000062   0xF050 0x6010      ORRS     R0,R0,#0x9000000
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable25
   \   0000006A   0x6809             LDR      R1,[R1, #+0]
   \   0000006C   0x6008             STR      R0,[R1, #+0]
    659          
    660                  /* Validate the user key */
    661                  returnCode = flash_check_user_key(key);
   \   0000006E   0x0038             MOVS     R0,R7
   \   00000070   0x.... 0x....      BL       flash_check_user_key
   \   00000074   0x4683             MOV      R11,R0
    662                  if (returnCode)
   \   00000076   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000007A   0xD001             BEQ.N    ??FLASH_Erase_4
    663                  {
    664                      return returnCode;
   \   0000007C   0x4658             MOV      R0,R11
   \   0000007E   0xE012             B.N      ??FLASH_Erase_1
    665                  }
    666          
    667                  /* calling flash command sequence function to execute the command */
    668                  returnCode = flash_command_sequence(config);
   \                     ??FLASH_Erase_4: (+1)
   \   00000080   0x0020             MOVS     R0,R4
   \   00000082   0x.... 0x....      BL       flash_command_sequence
   \   00000086   0x4683             MOV      R11,R0
    669          
    670                  /* calling flash callback function if it is available */
    671                  if (config->PFlashCallback)
   \   00000088   0x6920             LDR      R0,[R4, #+16]
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD001             BEQ.N    ??FLASH_Erase_5
    672                  {
    673                      config->PFlashCallback();
   \   0000008E   0x6920             LDR      R0,[R4, #+16]
   \   00000090   0x4780             BLX      R0
    674                  }
    675          
    676                  /* checking the success of command execution */
    677                  if (kStatus_FLASH_Success != returnCode)
   \                     ??FLASH_Erase_5: (+1)
   \   00000092   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000096   0xD102             BNE.N    ??FLASH_Erase_3
    678                  {
    679                      break;
    680                  }
    681                  else
    682                  {
    683                      /* Increment to the next sector */
    684                      start += sectorSize;
   \                     ??FLASH_Erase_6: (+1)
   \   00000098   0xEB18 0x0505      ADDS     R5,R8,R5
   \   0000009C   0xE7DD             B.N      ??FLASH_Erase_2
    685                  }
    686              }
    687          
    688              flash_cache_clear(config);
   \                     ??FLASH_Erase_3: (+1)
   \   0000009E   0x0020             MOVS     R0,R4
   \   000000A0   0x.... 0x....      BL       flash_cache_clear
    689          
    690              return (returnCode);
   \   000000A4   0x4658             MOV      R0,R11
   \                     ??FLASH_Erase_1: (+1)
   \   000000A6   0xB009             ADD      SP,SP,#+36
   \   000000A8   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    691          }
    692          
    693          #if defined(FSL_FEATURE_FLASH_HAS_ERASE_ALL_BLOCKS_UNSECURE_CMD) && FSL_FEATURE_FLASH_HAS_ERASE_ALL_BLOCKS_UNSECURE_CMD
    694          status_t FLASH_EraseAllUnsecure(flash_config_t *config, uint32_t key)
    695          {
    696              status_t returnCode;
    697          
    698              if (config == NULL)
    699              {
    700                  return kStatus_FLASH_InvalidArgument;
    701              }
    702          
    703              /* Prepare passing parameter to erase all flash blocks (unsecure). */
    704              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_ERASE_ALL_BLOCK_UNSECURE, 0xFFFFFFU);
    705          
    706              /* Validate the user key */
    707              returnCode = flash_check_user_key(key);
    708              if (returnCode)
    709              {
    710                  return returnCode;
    711              }
    712          
    713              /* calling flash command sequence function to execute the command */
    714              returnCode = flash_command_sequence(config);
    715          
    716              flash_cache_clear(config);
    717          
    718          #if FLASH_SSD_IS_FLEXNVM_ENABLED
    719              /* Data flash IFR will be erased by erase all unsecure command, so we need to
    720               *  update FlexNVM memory partition status synchronously */
    721              if (returnCode == kStatus_FLASH_Success)
    722              {
    723                  returnCode = flash_update_flexnvm_memory_partition_status(config);
    724              }
    725          #endif
    726          
    727              return returnCode;
    728          }
    729          #endif /* FSL_FEATURE_FLASH_HAS_ERASE_ALL_BLOCKS_UNSECURE_CMD */
    730          

   \                                 In section .text, align 2, keep-with-next
    731          status_t FLASH_EraseAllExecuteOnlySegments(flash_config_t *config, uint32_t key)
    732          {
   \                     FLASH_EraseAllExecuteOnlySegments: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    733              status_t returnCode;
    734          
    735              if (config == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??FLASH_EraseAllExecuteOnlySegments_0
    736              {
    737                  return kStatus_FLASH_InvalidArgument;
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0xE015             B.N      ??FLASH_EraseAllExecuteOnlySegments_1
    738              }
    739          
    740              /* preparing passing parameter to erase all execute-only segments
    741               * 1st element for the FCCOB register */
    742              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_ERASE_ALL_EXECUTE_ONLY_SEGMENT, 0xFFFFFFU);
   \                     ??FLASH_EraseAllExecuteOnlySegments_0: (+1)
   \   0000000E   0xF07F 0x4034      MVNS     R0,#-1275068416
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable25
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0x6008             STR      R0,[R1, #+0]
    743          
    744              /* Validate the user key */
    745              returnCode = flash_check_user_key(key);
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0x.... 0x....      BL       flash_check_user_key
   \   00000020   0x0006             MOVS     R6,R0
    746              if (returnCode)
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD001             BEQ.N    ??FLASH_EraseAllExecuteOnlySegments_2
    747              {
    748                  return returnCode;
   \   00000026   0x0030             MOVS     R0,R6
   \   00000028   0xE007             B.N      ??FLASH_EraseAllExecuteOnlySegments_1
    749              }
    750          
    751              /* calling flash command sequence function to execute the command */
    752              returnCode = flash_command_sequence(config);
   \                     ??FLASH_EraseAllExecuteOnlySegments_2: (+1)
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       flash_command_sequence
   \   00000030   0x0006             MOVS     R6,R0
    753          
    754              flash_cache_clear(config);
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       flash_cache_clear
    755          
    756              return returnCode;
   \   00000038   0x0030             MOVS     R0,R6
   \                     ??FLASH_EraseAllExecuteOnlySegments_1: (+1)
   \   0000003A   0xBD70             POP      {R4-R6,PC}       ;; return
    757          }
    758          

   \                                 In section .text, align 2, keep-with-next
    759          status_t FLASH_Program(flash_config_t *config, uint32_t start, uint32_t *src, uint32_t lengthInBytes)
    760          {
   \                     FLASH_Program: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    761              status_t returnCode;
    762              flash_operation_config_t flashInfo;
    763          
    764              if (src == NULL)
   \   0000000E   0x2E00             CMP      R6,#+0
   \   00000010   0xD101             BNE.N    ??FLASH_Program_0
    765              {
    766                  return kStatus_FLASH_InvalidArgument;
   \   00000012   0x2004             MOVS     R0,#+4
   \   00000014   0xE04C             B.N      ??FLASH_Program_1
    767              }
    768          
    769              flash_get_matched_operation_info(config, start, &flashInfo);
   \                     ??FLASH_Program_0: (+1)
   \   00000016   0x466A             MOV      R2,SP
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       flash_get_matched_operation_info
    770          
    771              /* Check the supplied address range. */
    772              returnCode = flash_check_range(config, start, lengthInBytes, flashInfo.blockWriteUnitSize);
   \   00000020   0x9B03             LDR      R3,[SP, #+12]
   \   00000022   0x003A             MOVS     R2,R7
   \   00000024   0x0029             MOVS     R1,R5
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       flash_check_range
   \   0000002C   0x4680             MOV      R8,R0
    773              if (returnCode)
   \   0000002E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000032   0xD001             BEQ.N    ??FLASH_Program_2
    774              {
    775                  return returnCode;
   \   00000034   0x4640             MOV      R0,R8
   \   00000036   0xE03B             B.N      ??FLASH_Program_1
    776              }
    777          
    778              start = flashInfo.convertedAddress;
   \                     ??FLASH_Program_2: (+1)
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0x0005             MOVS     R5,R0
    779          
    780              while (lengthInBytes > 0)
   \                     ??FLASH_Program_3: (+1)
   \   0000003C   0x2F00             CMP      R7,#+0
   \   0000003E   0xD033             BEQ.N    ??FLASH_Program_4
    781              {
    782                  /* preparing passing parameter to program the flash block */
    783                  kFCCOBx[1] = *src++;
   \   00000040   0x6830             LDR      R0,[R6, #+0]
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable25
   \   00000046   0x6809             LDR      R1,[R1, #+0]
   \   00000048   0x6048             STR      R0,[R1, #+4]
   \   0000004A   0x1D36             ADDS     R6,R6,#+4
    784                  if (4 == flashInfo.blockWriteUnitSize)
   \   0000004C   0x9803             LDR      R0,[SP, #+12]
   \   0000004E   0x2804             CMP      R0,#+4
   \   00000050   0xD108             BNE.N    ??FLASH_Program_5
    785                  {
    786                      kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_PROGRAM_LONGWORD, start);
   \   00000052   0xF025 0x407F      BIC      R0,R5,#0xFF000000
   \   00000056   0xF050 0x60C0      ORRS     R0,R0,#0x6000000
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable25
   \   0000005E   0x6809             LDR      R1,[R1, #+0]
   \   00000060   0x6008             STR      R0,[R1, #+0]
   \   00000062   0xE010             B.N      ??FLASH_Program_6
    787                  }
    788                  else if (8 == flashInfo.blockWriteUnitSize)
   \                     ??FLASH_Program_5: (+1)
   \   00000064   0x9803             LDR      R0,[SP, #+12]
   \   00000066   0x2808             CMP      R0,#+8
   \   00000068   0xD10D             BNE.N    ??FLASH_Program_6
    789                  {
    790                      kFCCOBx[2] = *src++;
   \   0000006A   0x6830             LDR      R0,[R6, #+0]
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable25
   \   00000070   0x6809             LDR      R1,[R1, #+0]
   \   00000072   0x6088             STR      R0,[R1, #+8]
   \   00000074   0x1D36             ADDS     R6,R6,#+4
    791                      kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_PROGRAM_PHRASE, start);
   \   00000076   0xF025 0x407F      BIC      R0,R5,#0xFF000000
   \   0000007A   0xF050 0x60E0      ORRS     R0,R0,#0x7000000
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable25
   \   00000082   0x6809             LDR      R1,[R1, #+0]
   \   00000084   0x6008             STR      R0,[R1, #+0]
    792                  }
    793                  else
    794                  {
    795                  }
    796          
    797                  /* calling flash command sequence function to execute the command */
    798                  returnCode = flash_command_sequence(config);
   \                     ??FLASH_Program_6: (+1)
   \   00000086   0x0020             MOVS     R0,R4
   \   00000088   0x.... 0x....      BL       flash_command_sequence
   \   0000008C   0x4680             MOV      R8,R0
    799          
    800                  /* calling flash callback function if it is available */
    801                  if (config->PFlashCallback)
   \   0000008E   0x6920             LDR      R0,[R4, #+16]
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD001             BEQ.N    ??FLASH_Program_7
    802                  {
    803                      config->PFlashCallback();
   \   00000094   0x6920             LDR      R0,[R4, #+16]
   \   00000096   0x4780             BLX      R0
    804                  }
    805          
    806                  /* checking for the success of command execution */
    807                  if (kStatus_FLASH_Success != returnCode)
   \                     ??FLASH_Program_7: (+1)
   \   00000098   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000009C   0xD104             BNE.N    ??FLASH_Program_4
    808                  {
    809                      break;
    810                  }
    811                  else
    812                  {
    813                      /* update start address for next iteration */
    814                      start += flashInfo.blockWriteUnitSize;
   \                     ??FLASH_Program_8: (+1)
   \   0000009E   0x9803             LDR      R0,[SP, #+12]
   \   000000A0   0x1945             ADDS     R5,R0,R5
    815          
    816                      /* update lengthInBytes for next iteration */
    817                      lengthInBytes -= flashInfo.blockWriteUnitSize;
   \   000000A2   0x9803             LDR      R0,[SP, #+12]
   \   000000A4   0x1A3F             SUBS     R7,R7,R0
   \   000000A6   0xE7C9             B.N      ??FLASH_Program_3
    818                  }
    819              }
    820          
    821              flash_cache_clear(config);
   \                     ??FLASH_Program_4: (+1)
   \   000000A8   0x0020             MOVS     R0,R4
   \   000000AA   0x.... 0x....      BL       flash_cache_clear
    822          
    823              return (returnCode);
   \   000000AE   0x4640             MOV      R0,R8
   \                     ??FLASH_Program_1: (+1)
   \   000000B0   0xB008             ADD      SP,SP,#+32
   \   000000B2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    824          }
    825          

   \                                 In section .text, align 2, keep-with-next
    826          status_t FLASH_ProgramOnce(flash_config_t *config, uint32_t index, uint32_t *src, uint32_t lengthInBytes)
    827          {
   \                     FLASH_ProgramOnce: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    828              status_t returnCode;
    829          
    830              if ((config == NULL) || (src == NULL))
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD001             BEQ.N    ??FLASH_ProgramOnce_0
   \   00000010   0x2E00             CMP      R6,#+0
   \   00000012   0xD101             BNE.N    ??FLASH_ProgramOnce_1
    831              {
    832                  return kStatus_FLASH_InvalidArgument;
   \                     ??FLASH_ProgramOnce_0: (+1)
   \   00000014   0x2004             MOVS     R0,#+4
   \   00000016   0xE01B             B.N      ??FLASH_ProgramOnce_2
    833              }
    834          
    835              /* pass paramters to FTFx */
    836              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_1_2(FTFx_PROGRAM_ONCE, index, 0xFFFFU);
   \                     ??FLASH_ProgramOnce_1: (+1)
   \   00000018   0x0428             LSLS     R0,R5,#+16
   \   0000001A   0xF410 0x007F      ANDS     R0,R0,#0xFF0000
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable25_1  ;; 0x4300ffff
   \   00000022   0x4308             ORRS     R0,R1,R0
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable25
   \   00000028   0x6809             LDR      R1,[R1, #+0]
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    837          
    838              kFCCOBx[1] = *src;
   \   0000002C   0x6830             LDR      R0,[R6, #+0]
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable25
   \   00000032   0x6809             LDR      R1,[R1, #+0]
   \   00000034   0x6048             STR      R0,[R1, #+4]
    839          
    840          /* Note: Have to seperate the first index from the rest if it equals 0
    841           * to avoid a pointless comparison of unsigned int to 0 compiler warning */
    842          #if FLASH_PROGRAM_ONCE_IS_8BYTES_UNIT_SUPPORT
    843          #if FLASH_PROGRAM_ONCE_IS_4BYTES_UNIT_SUPPORT
    844              if (((index == FLASH_PROGRAM_ONCE_MIN_ID_8BYTES) ||
    845                   /* Range check */
    846                   ((index >= FLASH_PROGRAM_ONCE_MIN_ID_8BYTES + 1) && (index <= FLASH_PROGRAM_ONCE_MAX_ID_8BYTES))) &&
    847                  (lengthInBytes == 8))
    848          #endif /* FLASH_PROGRAM_ONCE_IS_4BYTES_UNIT_SUPPORT */
    849              {
    850                  kFCCOBx[2] = *(src + 1);
   \   00000036   0x6870             LDR      R0,[R6, #+4]
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable25
   \   0000003C   0x6809             LDR      R1,[R1, #+0]
   \   0000003E   0x6088             STR      R0,[R1, #+8]
    851              }
    852          #endif /* FLASH_PROGRAM_ONCE_IS_8BYTES_UNIT_SUPPORT */
    853          
    854              /* calling flash command sequence function to execute the command */
    855              returnCode = flash_command_sequence(config);
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       flash_command_sequence
   \   00000046   0x4680             MOV      R8,R0
    856          
    857              flash_cache_clear(config);
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       flash_cache_clear
    858          
    859              return returnCode;
   \   0000004E   0x4640             MOV      R0,R8
   \                     ??FLASH_ProgramOnce_2: (+1)
   \   00000050   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    860          }
    861          
    862          #if defined(FSL_FEATURE_FLASH_HAS_PROGRAM_SECTION_CMD) && FSL_FEATURE_FLASH_HAS_PROGRAM_SECTION_CMD

   \                                 In section .text, align 2, keep-with-next
    863          status_t FLASH_ProgramSection(flash_config_t *config, uint32_t start, uint32_t *src, uint32_t lengthInBytes)
    864          {
   \                     FLASH_ProgramSection: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB08C             SUB      SP,SP,#+48
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
   \   0000000A   0x001E             MOVS     R6,R3
    865              status_t returnCode;
    866              uint32_t sectorSize;
    867              flash_operation_config_t flashInfo;
    868          #if defined(FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD) && FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD
    869              bool needSwitchFlexRamMode = false;
    870          #endif /* FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD */
    871          
    872              if (src == NULL)
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xD101             BNE.N    ??FLASH_ProgramSection_0
    873              {
    874                  return kStatus_FLASH_InvalidArgument;
   \   00000010   0x2004             MOVS     R0,#+4
   \   00000012   0xE07E             B.N      ??FLASH_ProgramSection_1
    875              }
    876          
    877              flash_get_matched_operation_info(config, start, &flashInfo);
   \                     ??FLASH_ProgramSection_0: (+1)
   \   00000014   0xAA04             ADD      R2,SP,#+16
   \   00000016   0x0021             MOVS     R1,R4
   \   00000018   0x980C             LDR      R0,[SP, #+48]
   \   0000001A   0x.... 0x....      BL       flash_get_matched_operation_info
    878          
    879              /* Check the supplied address range. */
    880              returnCode = flash_check_range(config, start, lengthInBytes, flashInfo.sectionCmdAddressAligment);
   \   0000001E   0x9B09             LDR      R3,[SP, #+36]
   \   00000020   0x0032             MOVS     R2,R6
   \   00000022   0x0021             MOVS     R1,R4
   \   00000024   0x980C             LDR      R0,[SP, #+48]
   \   00000026   0x.... 0x....      BL       flash_check_range
   \   0000002A   0x9000             STR      R0,[SP, #+0]
    881              if (returnCode)
   \   0000002C   0x9800             LDR      R0,[SP, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD001             BEQ.N    ??FLASH_ProgramSection_2
    882              {
    883                  return returnCode;
   \   00000032   0x9800             LDR      R0,[SP, #+0]
   \   00000034   0xE06D             B.N      ??FLASH_ProgramSection_1
    884              }
    885          
    886              start = flashInfo.convertedAddress;
   \                     ??FLASH_ProgramSection_2: (+1)
   \   00000036   0x9804             LDR      R0,[SP, #+16]
   \   00000038   0x0004             MOVS     R4,R0
    887              sectorSize = flashInfo.activeSectorSize;
   \   0000003A   0x9805             LDR      R0,[SP, #+20]
   \   0000003C   0x9001             STR      R0,[SP, #+4]
    888          
    889          #if defined(FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD) && FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD
    890              /* Switch function of FlexRAM if needed */
    891              if (!(FTFx->FCNFG & FTFx_FCNFG_RAMRDY_MASK))
    892              {
    893                  needSwitchFlexRamMode = true;
    894          
    895                  returnCode = FLASH_SetFlexramFunction(config, kFLASH_FlexramFunctionOptionAvailableAsRam);
    896                  if (returnCode != kStatus_FLASH_Success)
    897                  {
    898                      return kStatus_FLASH_SetFlexramAsRamError;
    899                  }
    900              }
    901          #endif /* FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD */
    902          
    903              while (lengthInBytes > 0)
   \                     ??FLASH_ProgramSection_3: (+1)
   \   0000003E   0x2E00             CMP      R6,#+0
   \   00000040   0xD063             BEQ.N    ??FLASH_ProgramSection_4
    904              {
    905                  /* Make sure the write operation doesn't span two sectors */
    906                  uint32_t endAddressOfCurrentSector = ALIGN_UP(start, sectorSize);
   \   00000042   0x4260             RSBS     R0,R4,#+0
   \   00000044   0x9901             LDR      R1,[SP, #+4]
   \   00000046   0x4249             RSBS     R1,R1,#+0
   \   00000048   0x4008             ANDS     R0,R1,R0
   \   0000004A   0xF1D0 0x0900      RSBS     R9,R0,#+0
    907                  uint32_t lengthTobeProgrammedOfCurrentSector;
    908                  uint32_t currentOffset = 0;
   \   0000004E   0xF05F 0x0800      MOVS     R8,#+0
    909          
    910                  if (endAddressOfCurrentSector == start)
   \   00000052   0x45A1             CMP      R9,R4
   \   00000054   0xD102             BNE.N    ??FLASH_ProgramSection_5
    911                  {
    912                      endAddressOfCurrentSector += sectorSize;
   \   00000056   0x9801             LDR      R0,[SP, #+4]
   \   00000058   0xEB10 0x0909      ADDS     R9,R0,R9
    913                  }
    914          
    915                  if (lengthInBytes + start > endAddressOfCurrentSector)
   \                     ??FLASH_ProgramSection_5: (+1)
   \   0000005C   0x19A0             ADDS     R0,R4,R6
   \   0000005E   0x4581             CMP      R9,R0
   \   00000060   0xD203             BCS.N    ??FLASH_ProgramSection_6
    916                  {
    917                      lengthTobeProgrammedOfCurrentSector = endAddressOfCurrentSector - start;
   \   00000062   0xEBB9 0x0004      SUBS     R0,R9,R4
   \   00000066   0x0007             MOVS     R7,R0
   \   00000068   0xE000             B.N      ??FLASH_ProgramSection_7
    918                  }
    919                  else
    920                  {
    921                      lengthTobeProgrammedOfCurrentSector = lengthInBytes;
   \                     ??FLASH_ProgramSection_6: (+1)
   \   0000006A   0x0037             MOVS     R7,R6
    922                  }
    923          
    924                  /* Program Current Sector */
    925                  while (lengthTobeProgrammedOfCurrentSector > 0)
   \                     ??FLASH_ProgramSection_7: (+1)
   \   0000006C   0x2F00             CMP      R7,#+0
   \   0000006E   0xD043             BEQ.N    ??FLASH_ProgramSection_8
    926                  {
    927                      /* Make sure the program size doesn't exceeds Acceleration RAM size */
    928                      uint32_t programSizeOfCurrentPass;
    929                      uint32_t numberOfPhases;
    930          
    931                      if (lengthTobeProgrammedOfCurrentSector > kFLASH_AccelerationRamSize)
   \   00000070   0xF5B7 0x6F80      CMP      R7,#+1024
   \   00000074   0xD903             BLS.N    ??FLASH_ProgramSection_9
    932                      {
    933                          programSizeOfCurrentPass = kFLASH_AccelerationRamSize;
   \   00000076   0xF44F 0x6080      MOV      R0,#+1024
   \   0000007A   0x4682             MOV      R10,R0
   \   0000007C   0xE000             B.N      ??FLASH_ProgramSection_10
    934                      }
    935                      else
    936                      {
    937                          programSizeOfCurrentPass = lengthTobeProgrammedOfCurrentSector;
   \                     ??FLASH_ProgramSection_9: (+1)
   \   0000007E   0x46BA             MOV      R10,R7
    938                      }
    939          
    940                      /* Copy data to FlexRAM */
    941                      memcpy((void *)FSL_FEATURE_FLASH_FLEX_RAM_START_ADDRESS, src + currentOffset / 4, programSizeOfCurrentPass);
   \                     ??FLASH_ProgramSection_10: (+1)
   \   00000080   0xEA5F 0x0098      LSRS     R0,R8,#+2
   \   00000084   0xEB05 0x0080      ADD      R0,R5,R0, LSL #+2
   \   00000088   0x9003             STR      R0,[SP, #+12]
   \   0000008A   0xF05F 0x5BA0      MOVS     R11,#+335544320
   \   0000008E   0x4652             MOV      R2,R10
   \   00000090   0x9903             LDR      R1,[SP, #+12]
   \   00000092   0x4658             MOV      R0,R11
   \   00000094   0x.... 0x....      BL       __aeabi_memcpy
    942                      /* Set start address of the data to be programmed */
    943                      kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_PROGRAM_SECTION, start + currentOffset);
   \   00000098   0xEB18 0x0004      ADDS     R0,R8,R4
   \   0000009C   0xF020 0x407F      BIC      R0,R0,#0xFF000000
   \   000000A0   0xF050 0x6030      ORRS     R0,R0,#0xB000000
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable25
   \   000000A8   0x6809             LDR      R1,[R1, #+0]
   \   000000AA   0x6008             STR      R0,[R1, #+0]
    944                      /* Set program size in terms of FEATURE_FLASH_SECTION_CMD_ADDRESS_ALIGMENT */
    945                      numberOfPhases = programSizeOfCurrentPass / flashInfo.sectionCmdAddressAligment;
   \   000000AC   0x9809             LDR      R0,[SP, #+36]
   \   000000AE   0xFBBA 0xF0F0      UDIV     R0,R10,R0
   \   000000B2   0x9002             STR      R0,[SP, #+8]
    946          
    947                      kFCCOBx[1] = BYTES_JOIN_TO_WORD_2_2(numberOfPhases, 0xFFFFU);
   \   000000B4   0x9802             LDR      R0,[SP, #+8]
   \   000000B6   0x0400             LSLS     R0,R0,#+16
   \   000000B8   0xF440 0x407F      ORR      R0,R0,#0xFF00
   \   000000BC   0xF050 0x00FF      ORRS     R0,R0,#0xFF
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable25
   \   000000C4   0x6809             LDR      R1,[R1, #+0]
   \   000000C6   0x6048             STR      R0,[R1, #+4]
    948          
    949                      /* Peform command sequence */
    950                      returnCode = flash_command_sequence(config);
   \   000000C8   0x980C             LDR      R0,[SP, #+48]
   \   000000CA   0x.... 0x....      BL       flash_command_sequence
   \   000000CE   0x9000             STR      R0,[SP, #+0]
    951          
    952                      /* calling flash callback function if it is available */
    953                      if (config->PFlashCallback)
   \   000000D0   0x980C             LDR      R0,[SP, #+48]
   \   000000D2   0x6900             LDR      R0,[R0, #+16]
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD002             BEQ.N    ??FLASH_ProgramSection_11
    954                      {
    955                          config->PFlashCallback();
   \   000000D8   0x980C             LDR      R0,[SP, #+48]
   \   000000DA   0x6900             LDR      R0,[R0, #+16]
   \   000000DC   0x4780             BLX      R0
    956                      }
    957          
    958                      if (returnCode != kStatus_FLASH_Success)
   \                     ??FLASH_ProgramSection_11: (+1)
   \   000000DE   0x9800             LDR      R0,[SP, #+0]
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xD004             BEQ.N    ??FLASH_ProgramSection_12
    959                      {
    960                          flash_cache_clear(config);
   \   000000E4   0x980C             LDR      R0,[SP, #+48]
   \   000000E6   0x.... 0x....      BL       flash_cache_clear
    961                          return returnCode;
   \   000000EA   0x9800             LDR      R0,[SP, #+0]
   \   000000EC   0xE011             B.N      ??FLASH_ProgramSection_1
    962                      }
    963          
    964                      lengthTobeProgrammedOfCurrentSector -= programSizeOfCurrentPass;
   \                     ??FLASH_ProgramSection_12: (+1)
   \   000000EE   0xEBB7 0x070A      SUBS     R7,R7,R10
    965                      currentOffset += programSizeOfCurrentPass;
   \   000000F2   0xEB1A 0x0808      ADDS     R8,R10,R8
   \   000000F6   0xE7B9             B.N      ??FLASH_ProgramSection_7
    966                  }
    967          
    968                  src += currentOffset / 4;
   \                     ??FLASH_ProgramSection_8: (+1)
   \   000000F8   0xEA5F 0x0098      LSRS     R0,R8,#+2
   \   000000FC   0xEB05 0x0580      ADD      R5,R5,R0, LSL #+2
    969                  start += currentOffset;
   \   00000100   0xEB18 0x0404      ADDS     R4,R8,R4
    970                  lengthInBytes -= currentOffset;
   \   00000104   0xEBB6 0x0608      SUBS     R6,R6,R8
   \   00000108   0xE799             B.N      ??FLASH_ProgramSection_3
    971              }
    972          
    973              flash_cache_clear(config);
   \                     ??FLASH_ProgramSection_4: (+1)
   \   0000010A   0x980C             LDR      R0,[SP, #+48]
   \   0000010C   0x.... 0x....      BL       flash_cache_clear
    974          
    975          #if defined(FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD) && FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD
    976              /* Restore function of FlexRAM if needed. */
    977              if (needSwitchFlexRamMode)
    978              {
    979                  returnCode = FLASH_SetFlexramFunction(config, kFLASH_FlexramFunctionOptionAvailableForEeprom);
    980                  if (returnCode != kStatus_FLASH_Success)
    981                  {
    982                      return kStatus_FLASH_RecoverFlexramAsEepromError;
    983                  }
    984              }
    985          #endif /* FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD */
    986          
    987              return returnCode;
   \   00000110   0x9800             LDR      R0,[SP, #+0]
   \                     ??FLASH_ProgramSection_1: (+1)
   \   00000112   0xB00D             ADD      SP,SP,#+52
   \   00000114   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    988          }
    989          #endif /* FSL_FEATURE_FLASH_HAS_PROGRAM_SECTION_CMD */
    990          
    991          #if FLASH_SSD_IS_FLEXNVM_ENABLED
    992          status_t FLASH_EepromWrite(flash_config_t *config, uint32_t start, uint8_t *src, uint32_t lengthInBytes)
    993          {
    994              status_t returnCode;
    995              bool needSwitchFlexRamMode = false;
    996          
    997              if (config == NULL)
    998              {
    999                  return kStatus_FLASH_InvalidArgument;
   1000              }
   1001          
   1002              /* Validates the range of the given address */
   1003              if ((start < config->FlexRAMBlockBase) ||
   1004                  ((start + lengthInBytes) > (config->FlexRAMBlockBase + config->EEpromTotalSize)))
   1005              {
   1006                  return kStatus_FLASH_AddressError;
   1007              }
   1008          
   1009              returnCode = kStatus_FLASH_Success;
   1010          
   1011              /* Switch function of FlexRAM if needed */
   1012              if (!(FTFx->FCNFG & FTFx_FCNFG_EEERDY_MASK))
   1013              {
   1014                  needSwitchFlexRamMode = true;
   1015          
   1016                  returnCode = FLASH_SetFlexramFunction(config, kFLASH_FlexramFunctionOptionAvailableForEeprom);
   1017                  if (returnCode != kStatus_FLASH_Success)
   1018                  {
   1019                      return kStatus_FLASH_SetFlexramAsEepromError;
   1020                  }
   1021              }
   1022          
   1023              /* Write data to FlexRAM when it is used as EEPROM emulator */
   1024              while (lengthInBytes > 0)
   1025              {
   1026                  if ((!(start & 0x3U)) && (lengthInBytes >= 4))
   1027                  {
   1028                      *(uint32_t *)start = *(uint32_t *)src;
   1029                      start += 4;
   1030                      src += 4;
   1031                      lengthInBytes -= 4;
   1032                  }
   1033                  else if ((!(start & 0x1U)) && (lengthInBytes >= 2))
   1034                  {
   1035                      *(uint16_t *)start = *(uint16_t *)src;
   1036                      start += 2;
   1037                      src += 2;
   1038                      lengthInBytes -= 2;
   1039                  }
   1040                  else
   1041                  {
   1042                      *(uint8_t *)start = *src;
   1043                      start += 1;
   1044                      src += 1;
   1045                      lengthInBytes -= 1;
   1046                  }
   1047                  /* Wait till EEERDY bit is set */
   1048                  while (!(FTFx->FCNFG & FTFx_FCNFG_EEERDY_MASK))
   1049                  {
   1050                  }
   1051          
   1052                  /* Check for protection violation error */
   1053                  if (FTFx->FSTAT & FTFx_FSTAT_FPVIOL_MASK)
   1054                  {
   1055                      return kStatus_FLASH_ProtectionViolation;
   1056                  }
   1057              }
   1058          
   1059              /* Switch function of FlexRAM if needed */
   1060              if (needSwitchFlexRamMode)
   1061              {
   1062                  returnCode = FLASH_SetFlexramFunction(config, kFLASH_FlexramFunctionOptionAvailableAsRam);
   1063                  if (returnCode != kStatus_FLASH_Success)
   1064                  {
   1065                      return kStatus_FLASH_RecoverFlexramAsRamError;
   1066                  }
   1067              }
   1068          
   1069              return returnCode;
   1070          }
   1071          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   1072          
   1073          #if defined(FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD) && FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD

   \                                 In section .text, align 2, keep-with-next
   1074          status_t FLASH_ReadResource(
   1075              flash_config_t *config, uint32_t start, uint32_t *dst, uint32_t lengthInBytes, flash_read_resource_option_t option)
   1076          {
   \                     FLASH_ReadResource: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x0005             MOVS     R5,R0
   \   00000008   0x000E             MOVS     R6,R1
   \   0000000A   0x0017             MOVS     R7,R2
   \   0000000C   0x4698             MOV      R8,R3
   \   0000000E   0x9C10             LDR      R4,[SP, #+64]
   1077              status_t returnCode;
   1078              flash_operation_config_t flashInfo;
   1079          
   1080              if ((config == NULL) || (dst == NULL))
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD001             BEQ.N    ??FLASH_ReadResource_0
   \   00000014   0x2F00             CMP      R7,#+0
   \   00000016   0xD101             BNE.N    ??FLASH_ReadResource_1
   1081              {
   1082                  return kStatus_FLASH_InvalidArgument;
   \                     ??FLASH_ReadResource_0: (+1)
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0xE050             B.N      ??FLASH_ReadResource_2
   1083              }
   1084          
   1085              flash_get_matched_operation_info(config, start, &flashInfo);
   \                     ??FLASH_ReadResource_1: (+1)
   \   0000001C   0x466A             MOV      R2,SP
   \   0000001E   0x0031             MOVS     R1,R6
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0x.... 0x....      BL       flash_get_matched_operation_info
   1086          
   1087              /* Check the supplied address range. */
   1088              returnCode = flash_check_resource_range(start, lengthInBytes, flashInfo.resourceCmdAddressAligment, option);
   \   00000026   0x0023             MOVS     R3,R4
   \   00000028   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000002A   0x9A06             LDR      R2,[SP, #+24]
   \   0000002C   0x4641             MOV      R1,R8
   \   0000002E   0x0030             MOVS     R0,R6
   \   00000030   0x.... 0x....      BL       flash_check_resource_range
   \   00000034   0x4681             MOV      R9,R0
   1089              if (returnCode != kStatus_FLASH_Success)
   \   00000036   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000003A   0xD001             BEQ.N    ??FLASH_ReadResource_3
   1090              {
   1091                  return returnCode;
   \   0000003C   0x4648             MOV      R0,R9
   \   0000003E   0xE03E             B.N      ??FLASH_ReadResource_2
   1092              }
   1093          
   1094              while (lengthInBytes > 0)
   \                     ??FLASH_ReadResource_3: (+1)
   \   00000040   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000044   0xD03A             BEQ.N    ??FLASH_ReadResource_4
   1095              {
   1096                  /* preparing passing parameter */
   1097                  kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_READ_RESOURCE, start);
   \   00000046   0xF026 0x407F      BIC      R0,R6,#0xFF000000
   \   0000004A   0xF050 0x7040      ORRS     R0,R0,#0x3000000
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable25
   \   00000052   0x6809             LDR      R1,[R1, #+0]
   \   00000054   0x6008             STR      R0,[R1, #+0]
   1098                  if (flashInfo.resourceCmdAddressAligment == 4)
   \   00000056   0x9806             LDR      R0,[SP, #+24]
   \   00000058   0x2804             CMP      R0,#+4
   \   0000005A   0xD108             BNE.N    ??FLASH_ReadResource_5
   1099                  {
   1100                      kFCCOBx[2] = BYTES_JOIN_TO_WORD_1_3(option, 0xFFFFFFU);
   \   0000005C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005E   0x0620             LSLS     R0,R4,#+24
   \   00000060   0xF070 0x407F      ORNS     R0,R0,#-16777216
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable25
   \   00000068   0x6809             LDR      R1,[R1, #+0]
   \   0000006A   0x6088             STR      R0,[R1, #+8]
   \   0000006C   0xE00A             B.N      ??FLASH_ReadResource_6
   1101                  }
   1102                  else if (flashInfo.resourceCmdAddressAligment == 8)
   \                     ??FLASH_ReadResource_5: (+1)
   \   0000006E   0x9806             LDR      R0,[SP, #+24]
   \   00000070   0x2808             CMP      R0,#+8
   \   00000072   0xD107             BNE.N    ??FLASH_ReadResource_6
   1103                  {
   1104                      kFCCOBx[1] = BYTES_JOIN_TO_WORD_1_3(option, 0xFFFFFFU);
   \   00000074   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000076   0x0620             LSLS     R0,R4,#+24
   \   00000078   0xF070 0x407F      ORNS     R0,R0,#-16777216
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable25
   \   00000080   0x6809             LDR      R1,[R1, #+0]
   \   00000082   0x6048             STR      R0,[R1, #+4]
   1105                  }
   1106                  else
   1107                  {
   1108                  }
   1109          
   1110                  /* calling flash command sequence function to execute the command */
   1111                  returnCode = flash_command_sequence(config);
   \                     ??FLASH_ReadResource_6: (+1)
   \   00000084   0x0028             MOVS     R0,R5
   \   00000086   0x.... 0x....      BL       flash_command_sequence
   \   0000008A   0x4681             MOV      R9,R0
   1112          
   1113                  if (kStatus_FLASH_Success != returnCode)
   \   0000008C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000090   0xD114             BNE.N    ??FLASH_ReadResource_4
   1114                  {
   1115                      break;
   1116                  }
   1117          
   1118                  /* fetch data */
   1119                  *dst++ = kFCCOBx[1];
   \                     ??FLASH_ReadResource_7: (+1)
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0x6840             LDR      R0,[R0, #+4]
   \   0000009A   0x6038             STR      R0,[R7, #+0]
   \   0000009C   0x1D3F             ADDS     R7,R7,#+4
   1120                  if (flashInfo.resourceCmdAddressAligment == 8)
   \   0000009E   0x9806             LDR      R0,[SP, #+24]
   \   000000A0   0x2808             CMP      R0,#+8
   \   000000A2   0xD105             BNE.N    ??FLASH_ReadResource_8
   1121                  {
   1122                      *dst++ = kFCCOBx[2];
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable25
   \   000000A8   0x6800             LDR      R0,[R0, #+0]
   \   000000AA   0x6880             LDR      R0,[R0, #+8]
   \   000000AC   0x6038             STR      R0,[R7, #+0]
   \   000000AE   0x1D3F             ADDS     R7,R7,#+4
   1123                  }
   1124                  /* update start address for next iteration */
   1125                  start += flashInfo.resourceCmdAddressAligment;
   \                     ??FLASH_ReadResource_8: (+1)
   \   000000B0   0x9806             LDR      R0,[SP, #+24]
   \   000000B2   0x1986             ADDS     R6,R0,R6
   1126                  /* update lengthInBytes for next iteration */
   1127                  lengthInBytes -= flashInfo.resourceCmdAddressAligment;
   \   000000B4   0x9806             LDR      R0,[SP, #+24]
   \   000000B6   0xEBB8 0x0800      SUBS     R8,R8,R0
   \   000000BA   0xE7C1             B.N      ??FLASH_ReadResource_3
   1128              }
   1129          
   1130              return (returnCode);
   \                     ??FLASH_ReadResource_4: (+1)
   \   000000BC   0x4648             MOV      R0,R9
   \                     ??FLASH_ReadResource_2: (+1)
   \   000000BE   0xB009             ADD      SP,SP,#+36
   \   000000C0   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   1131          }
   1132          #endif /* FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD */
   1133          

   \                                 In section .text, align 2, keep-with-next
   1134          status_t FLASH_ReadOnce(flash_config_t *config, uint32_t index, uint32_t *dst, uint32_t lengthInBytes)
   1135          {
   \                     FLASH_ReadOnce: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1136              status_t returnCode;
   1137          
   1138              if ((config == NULL) || (dst == NULL))
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD001             BEQ.N    ??FLASH_ReadOnce_0
   \   00000010   0x2E00             CMP      R6,#+0
   \   00000012   0xD101             BNE.N    ??FLASH_ReadOnce_1
   1139              {
   1140                  return kStatus_FLASH_InvalidArgument;
   \                     ??FLASH_ReadOnce_0: (+1)
   \   00000014   0x2004             MOVS     R0,#+4
   \   00000016   0xE01B             B.N      ??FLASH_ReadOnce_2
   1141              }
   1142          
   1143              /* pass paramters to FTFx */
   1144              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_1_2(FTFx_READ_ONCE, index, 0xFFFFU);
   \                     ??FLASH_ReadOnce_1: (+1)
   \   00000018   0x0428             LSLS     R0,R5,#+16
   \   0000001A   0xF410 0x007F      ANDS     R0,R0,#0xFF0000
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable25_2  ;; 0x4100ffff
   \   00000022   0x4308             ORRS     R0,R1,R0
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable25
   \   00000028   0x6809             LDR      R1,[R1, #+0]
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   1145          
   1146              /* calling flash command sequence function to execute the command */
   1147              returnCode = flash_command_sequence(config);
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       flash_command_sequence
   \   00000032   0x4680             MOV      R8,R0
   1148          
   1149              if (kStatus_FLASH_Success == returnCode)
   \   00000034   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000038   0xD109             BNE.N    ??FLASH_ReadOnce_3
   1150              {
   1151                  *dst = kFCCOBx[1];
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable25
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x6840             LDR      R0,[R0, #+4]
   \   00000042   0x6030             STR      R0,[R6, #+0]
   1152          /* Note: Have to seperate the first index from the rest if it equals 0
   1153           *       to avoid a pointless comparison of unsigned int to 0 compiler warning */
   1154          #if FLASH_PROGRAM_ONCE_IS_8BYTES_UNIT_SUPPORT
   1155          #if FLASH_PROGRAM_ONCE_IS_4BYTES_UNIT_SUPPORT
   1156                  if (((index == FLASH_PROGRAM_ONCE_MIN_ID_8BYTES) ||
   1157                       /* Range check */
   1158                       ((index >= FLASH_PROGRAM_ONCE_MIN_ID_8BYTES + 1) && (index <= FLASH_PROGRAM_ONCE_MAX_ID_8BYTES))) &&
   1159                      (lengthInBytes == 8))
   1160          #endif /* FLASH_PROGRAM_ONCE_IS_4BYTES_UNIT_SUPPORT */
   1161                  {
   1162                      *(dst + 1) = kFCCOBx[2];
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x6880             LDR      R0,[R0, #+8]
   \   0000004C   0x6070             STR      R0,[R6, #+4]
   1163                  }
   1164          #endif /* FLASH_PROGRAM_ONCE_IS_8BYTES_UNIT_SUPPORT */
   1165              }
   1166          
   1167              return returnCode;
   \                     ??FLASH_ReadOnce_3: (+1)
   \   0000004E   0x4640             MOV      R0,R8
   \                     ??FLASH_ReadOnce_2: (+1)
   \   00000050   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1168          }
   1169          

   \                                 In section .text, align 2, keep-with-next
   1170          status_t FLASH_GetSecurityState(flash_config_t *config, flash_security_state_t *state)
   1171          {
   \                     FLASH_GetSecurityState: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   1172              /* store data read from flash register */
   1173              uint8_t registerValue;
   1174          
   1175              if ((config == NULL) || (state == NULL))
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD001             BEQ.N    ??FLASH_GetSecurityState_0
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD101             BNE.N    ??FLASH_GetSecurityState_1
   1176              {
   1177                  return kStatus_FLASH_InvalidArgument;
   \                     ??FLASH_GetSecurityState_0: (+1)
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0xE016             B.N      ??FLASH_GetSecurityState_2
   1178              }
   1179          
   1180              /* Get flash security register value */
   1181              registerValue = FTFx->FSEC;
   \                     ??FLASH_GetSecurityState_1: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable25_3  ;; 0x40020002
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x0003             MOVS     R3,R0
   1182          
   1183              /* check the status of the flash security bits in the security register */
   1184              if (FLASH_SECURITY_STATE_UNSECURED == (registerValue & FTFx_FSEC_SEC_MASK))
   \   00000016   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000018   0xF013 0x0003      ANDS     R0,R3,#0x3
   \   0000001C   0x2802             CMP      R0,#+2
   \   0000001E   0xD102             BNE.N    ??FLASH_GetSecurityState_3
   1185              {
   1186                  /* Flash in unsecured state */
   1187                  *state = kFLASH_SecurityStateNotSecure;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x7008             STRB     R0,[R1, #+0]
   \   00000024   0xE009             B.N      ??FLASH_GetSecurityState_4
   1188              }
   1189              else
   1190              {
   1191                  /* Flash in secured state
   1192                   * check for backdoor key security enable bit */
   1193                  if (FLASH_SECURITY_STATE_KEYEN == (registerValue & FTFx_FSEC_KEYEN_MASK))
   \                     ??FLASH_GetSecurityState_3: (+1)
   \   00000026   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000028   0xF013 0x00C0      ANDS     R0,R3,#0xC0
   \   0000002C   0x2880             CMP      R0,#+128
   \   0000002E   0xD102             BNE.N    ??FLASH_GetSecurityState_5
   1194                  {
   1195                      /* Backdoor key security enabled */
   1196                      *state = kFLASH_SecurityStateBackdoorEnabled;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x7008             STRB     R0,[R1, #+0]
   \   00000034   0xE001             B.N      ??FLASH_GetSecurityState_4
   1197                  }
   1198                  else
   1199                  {
   1200                      /* Backdoor key security disabled */
   1201                      *state = kFLASH_SecurityStateBackdoorDisabled;
   \                     ??FLASH_GetSecurityState_5: (+1)
   \   00000036   0x2002             MOVS     R0,#+2
   \   00000038   0x7008             STRB     R0,[R1, #+0]
   1202                  }
   1203              }
   1204          
   1205              return (kStatus_FLASH_Success);
   \                     ??FLASH_GetSecurityState_4: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \                     ??FLASH_GetSecurityState_2: (+1)
   \   0000003C   0x4770             BX       LR               ;; return
   1206          }
   1207          

   \                                 In section .text, align 2, keep-with-next
   1208          status_t FLASH_SecurityBypass(flash_config_t *config, const uint8_t *backdoorKey)
   1209          {
   \                     FLASH_SecurityBypass: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1210              uint8_t registerValue; /* registerValue */
   1211              status_t returnCode;   /* return code variable */
   1212          
   1213              if ((config == NULL) || (backdoorKey == NULL))
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD001             BEQ.N    ??FLASH_SecurityBypass_0
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD101             BNE.N    ??FLASH_SecurityBypass_1
   1214              {
   1215                  return kStatus_FLASH_InvalidArgument;
   \                     ??FLASH_SecurityBypass_0: (+1)
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0xE031             B.N      ??FLASH_SecurityBypass_2
   1216              }
   1217          
   1218              /* set the default return code as kStatus_Success */
   1219              returnCode = kStatus_FLASH_Success;
   \                     ??FLASH_SecurityBypass_1: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x0007             MOVS     R7,R0
   1220          
   1221              /* Get flash security register value */
   1222              registerValue = FTFx->FSEC;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable25_3  ;; 0x40020002
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x0006             MOVS     R6,R0
   1223          
   1224              /* Check to see if flash is in secure state (any state other than 0x2)
   1225               * If not, then skip this since flash is not secure */
   1226              if (0x02 != (registerValue & 0x03))
   \   0000001E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000020   0xF016 0x0003      ANDS     R0,R6,#0x3
   \   00000024   0x2802             CMP      R0,#+2
   \   00000026   0xD025             BEQ.N    ??FLASH_SecurityBypass_3
   1227              {
   1228                  /* preparing passing parameter to erase a flash block */
   1229                  kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_SECURITY_BY_PASS, 0xFFFFFFU);
   \   00000028   0xF07F 0x403A      MVNS     R0,#-1174405120
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable25
   \   00000030   0x6809             LDR      R1,[R1, #+0]
   \   00000032   0x6008             STR      R0,[R1, #+0]
   1230                  kFCCOBx[1] = BYTES_JOIN_TO_WORD_1_1_1_1(backdoorKey[0], backdoorKey[1], backdoorKey[2], backdoorKey[3]);
   \   00000034   0x7828             LDRB     R0,[R5, #+0]
   \   00000036   0x7869             LDRB     R1,[R5, #+1]
   \   00000038   0x0409             LSLS     R1,R1,#+16
   \   0000003A   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   0000003E   0x78A9             LDRB     R1,[R5, #+2]
   \   00000040   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000044   0x78E9             LDRB     R1,[R5, #+3]
   \   00000046   0x4308             ORRS     R0,R1,R0
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable25
   \   0000004C   0x6809             LDR      R1,[R1, #+0]
   \   0000004E   0x6048             STR      R0,[R1, #+4]
   1231                  kFCCOBx[2] = BYTES_JOIN_TO_WORD_1_1_1_1(backdoorKey[4], backdoorKey[5], backdoorKey[6], backdoorKey[7]);
   \   00000050   0x7928             LDRB     R0,[R5, #+4]
   \   00000052   0x7969             LDRB     R1,[R5, #+5]
   \   00000054   0x0409             LSLS     R1,R1,#+16
   \   00000056   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   0000005A   0x79A9             LDRB     R1,[R5, #+6]
   \   0000005C   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000060   0x79E9             LDRB     R1,[R5, #+7]
   \   00000062   0x4308             ORRS     R0,R1,R0
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable25
   \   00000068   0x6809             LDR      R1,[R1, #+0]
   \   0000006A   0x6088             STR      R0,[R1, #+8]
   1232          
   1233                  /* calling flash command sequence function to execute the command */
   1234                  returnCode = flash_command_sequence(config);
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       flash_command_sequence
   \   00000072   0x0007             MOVS     R7,R0
   1235              }
   1236          
   1237              return (returnCode);
   \                     ??FLASH_SecurityBypass_3: (+1)
   \   00000074   0x0038             MOVS     R0,R7
   \                     ??FLASH_SecurityBypass_2: (+1)
   \   00000076   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1238          }
   1239          

   \                                 In section .text, align 2, keep-with-next
   1240          status_t FLASH_VerifyEraseAll(flash_config_t *config, flash_margin_value_t margin)
   1241          {
   \                     FLASH_VerifyEraseAll: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1242              if (config == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??FLASH_VerifyEraseAll_0
   1243              {
   1244                  return kStatus_FLASH_InvalidArgument;
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0xE00B             B.N      ??FLASH_VerifyEraseAll_1
   1245              }
   1246          
   1247              /* preparing passing parameter to verify all block command */
   1248              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_1_2(FTFx_VERIFY_ALL_BLOCK, margin, 0xFFFFU);
   \                     ??FLASH_VerifyEraseAll_0: (+1)
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable25_4  ;; 0x4000ffff
   \   00000014   0xEA50 0x4005      ORRS     R0,R0,R5, LSL #+16
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable25
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   1249          
   1250              /* calling flash command sequence function to execute the command */
   1251              return flash_command_sequence(config);
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       flash_command_sequence
   \                     ??FLASH_VerifyEraseAll_1: (+1)
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1252          }
   1253          

   \                                 In section .text, align 2, keep-with-next
   1254          status_t FLASH_VerifyErase(flash_config_t *config, uint32_t start, uint32_t lengthInBytes, flash_margin_value_t margin)
   1255          {
   \                     FLASH_VerifyErase: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB08B             SUB      SP,SP,#+44
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   1256              /* Check arguments. */
   1257              uint32_t blockSize;
   1258              flash_operation_config_t flashInfo;
   1259              uint32_t nextBlockStartAddress;
   1260              uint32_t remainingBytes;
   1261              status_t returnCode;
   1262          
   1263              flash_get_matched_operation_info(config, start, &flashInfo);
   \   0000000E   0xAA02             ADD      R2,SP,#+8
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       flash_get_matched_operation_info
   1264          
   1265              returnCode = flash_check_range(config, start, lengthInBytes, flashInfo.sectionCmdAddressAligment);
   \   00000018   0x9B07             LDR      R3,[SP, #+28]
   \   0000001A   0x0032             MOVS     R2,R6
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       flash_check_range
   \   00000024   0x4681             MOV      R9,R0
   1266              if (returnCode)
   \   00000026   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000002A   0xD001             BEQ.N    ??FLASH_VerifyErase_0
   1267              {
   1268                  return returnCode;
   \   0000002C   0x4648             MOV      R0,R9
   \   0000002E   0xE045             B.N      ??FLASH_VerifyErase_1
   1269              }
   1270          
   1271              flash_get_matched_operation_info(config, start, &flashInfo);
   \                     ??FLASH_VerifyErase_0: (+1)
   \   00000030   0xAA02             ADD      R2,SP,#+8
   \   00000032   0x0029             MOVS     R1,R5
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       flash_get_matched_operation_info
   1272              start = flashInfo.convertedAddress;
   \   0000003A   0x9802             LDR      R0,[SP, #+8]
   \   0000003C   0x0005             MOVS     R5,R0
   1273              blockSize = flashInfo.activeBlockSize;
   \   0000003E   0x9804             LDR      R0,[SP, #+16]
   \   00000040   0x9000             STR      R0,[SP, #+0]
   1274          
   1275              nextBlockStartAddress = ALIGN_UP(start, blockSize);
   \   00000042   0x4268             RSBS     R0,R5,#+0
   \   00000044   0x9900             LDR      R1,[SP, #+0]
   \   00000046   0x4249             RSBS     R1,R1,#+0
   \   00000048   0x4008             ANDS     R0,R1,R0
   \   0000004A   0x4240             RSBS     R0,R0,#+0
   \   0000004C   0x4682             MOV      R10,R0
   1276              if (nextBlockStartAddress == start)
   \   0000004E   0x45AA             CMP      R10,R5
   \   00000050   0xD102             BNE.N    ??FLASH_VerifyErase_2
   1277              {
   1278                  nextBlockStartAddress += blockSize;
   \   00000052   0x9800             LDR      R0,[SP, #+0]
   \   00000054   0xEB10 0x0A0A      ADDS     R10,R0,R10
   1279              }
   1280          
   1281              remainingBytes = lengthInBytes;
   \                     ??FLASH_VerifyErase_2: (+1)
   \   00000058   0x46B0             MOV      R8,R6
   1282          
   1283              while (remainingBytes)
   \                     ??FLASH_VerifyErase_3: (+1)
   \   0000005A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000005E   0xD02C             BEQ.N    ??FLASH_VerifyErase_4
   1284              {
   1285                  uint32_t numberOfPhrases;
   1286                  uint32_t verifyLength = nextBlockStartAddress - start;
   \   00000060   0xEBBA 0x0B05      SUBS     R11,R10,R5
   1287                  if (verifyLength > remainingBytes)
   \   00000064   0x45D8             CMP      R8,R11
   \   00000066   0xD200             BCS.N    ??FLASH_VerifyErase_5
   1288                  {
   1289                      verifyLength = remainingBytes;
   \   00000068   0x46C3             MOV      R11,R8
   1290                  }
   1291          
   1292                  numberOfPhrases = verifyLength / flashInfo.sectionCmdAddressAligment;
   \                     ??FLASH_VerifyErase_5: (+1)
   \   0000006A   0x9807             LDR      R0,[SP, #+28]
   \   0000006C   0xFBBB 0xF0F0      UDIV     R0,R11,R0
   \   00000070   0x9001             STR      R0,[SP, #+4]
   1293          
   1294                  /* Fill in verify section command parameters. */
   1295                  kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_VERIFY_SECTION, start);
   \   00000072   0xF025 0x407F      BIC      R0,R5,#0xFF000000
   \   00000076   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable25
   \   0000007E   0x6809             LDR      R1,[R1, #+0]
   \   00000080   0x6008             STR      R0,[R1, #+0]
   1296                  kFCCOBx[1] = BYTES_JOIN_TO_WORD_2_1_1(numberOfPhrases, margin, 0xFFU);
   \   00000082   0x9801             LDR      R0,[SP, #+4]
   \   00000084   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000086   0x0239             LSLS     R1,R7,#+8
   \   00000088   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   0000008C   0xF050 0x00FF      ORRS     R0,R0,#0xFF
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable25
   \   00000094   0x6809             LDR      R1,[R1, #+0]
   \   00000096   0x6048             STR      R0,[R1, #+4]
   1297          
   1298                  /* calling flash command sequence function to execute the command */
   1299                  returnCode = flash_command_sequence(config);
   \   00000098   0x0020             MOVS     R0,R4
   \   0000009A   0x.... 0x....      BL       flash_command_sequence
   \   0000009E   0x4681             MOV      R9,R0
   1300                  if (returnCode)
   \   000000A0   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000A4   0xD001             BEQ.N    ??FLASH_VerifyErase_6
   1301                  {
   1302                      return returnCode;
   \   000000A6   0x4648             MOV      R0,R9
   \   000000A8   0xE008             B.N      ??FLASH_VerifyErase_1
   1303                  }
   1304          
   1305                  remainingBytes -= verifyLength;
   \                     ??FLASH_VerifyErase_6: (+1)
   \   000000AA   0xEBB8 0x080B      SUBS     R8,R8,R11
   1306                  start += verifyLength;
   \   000000AE   0xEB1B 0x0505      ADDS     R5,R11,R5
   1307                  nextBlockStartAddress += blockSize;
   \   000000B2   0x9800             LDR      R0,[SP, #+0]
   \   000000B4   0xEB10 0x0A0A      ADDS     R10,R0,R10
   \   000000B8   0xE7CF             B.N      ??FLASH_VerifyErase_3
   1308              }
   1309          
   1310              return kStatus_FLASH_Success;
   \                     ??FLASH_VerifyErase_4: (+1)
   \   000000BA   0x2000             MOVS     R0,#+0
   \                     ??FLASH_VerifyErase_1: (+1)
   \   000000BC   0xB00B             ADD      SP,SP,#+44
   \   000000BE   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1311          }
   1312          

   \                                 In section .text, align 2, keep-with-next
   1313          status_t FLASH_VerifyProgram(flash_config_t *config,
   1314                                       uint32_t start,
   1315                                       uint32_t lengthInBytes,
   1316                                       const uint32_t *expectedData,
   1317                                       flash_margin_value_t margin,
   1318                                       uint32_t *failedAddress,
   1319                                       uint32_t *failedData)
   1320          {
   \                     FLASH_VerifyProgram: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x0005             MOVS     R5,R0
   \   00000008   0x000E             MOVS     R6,R1
   \   0000000A   0x0017             MOVS     R7,R2
   \   0000000C   0x4698             MOV      R8,R3
   \   0000000E   0x9C12             LDR      R4,[SP, #+72]
   \   00000010   0xF8DD 0x904C      LDR      R9,[SP, #+76]
   \   00000014   0xF8DD 0xA050      LDR      R10,[SP, #+80]
   1321              status_t returnCode;
   1322              flash_operation_config_t flashInfo;
   1323          
   1324              if (expectedData == NULL)
   \   00000018   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001C   0xD101             BNE.N    ??FLASH_VerifyProgram_0
   1325              {
   1326                  return kStatus_FLASH_InvalidArgument;
   \   0000001E   0x2004             MOVS     R0,#+4
   \   00000020   0xE047             B.N      ??FLASH_VerifyProgram_1
   1327              }
   1328          
   1329              flash_get_matched_operation_info(config, start, &flashInfo);
   \                     ??FLASH_VerifyProgram_0: (+1)
   \   00000022   0x466A             MOV      R2,SP
   \   00000024   0x0031             MOVS     R1,R6
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0x.... 0x....      BL       flash_get_matched_operation_info
   1330          
   1331              returnCode = flash_check_range(config, start, lengthInBytes, flashInfo.checkCmdAddressAligment);
   \   0000002C   0x9B07             LDR      R3,[SP, #+28]
   \   0000002E   0x003A             MOVS     R2,R7
   \   00000030   0x0031             MOVS     R1,R6
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x.... 0x....      BL       flash_check_range
   \   00000038   0x4683             MOV      R11,R0
   1332              if (returnCode)
   \   0000003A   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000003E   0xD001             BEQ.N    ??FLASH_VerifyProgram_2
   1333              {
   1334                  return returnCode;
   \   00000040   0x4658             MOV      R0,R11
   \   00000042   0xE036             B.N      ??FLASH_VerifyProgram_1
   1335              }
   1336          
   1337              start = flashInfo.convertedAddress;
   \                     ??FLASH_VerifyProgram_2: (+1)
   \   00000044   0x9800             LDR      R0,[SP, #+0]
   \   00000046   0x0006             MOVS     R6,R0
   1338          
   1339              while (lengthInBytes)
   \                     ??FLASH_VerifyProgram_3: (+1)
   \   00000048   0x2F00             CMP      R7,#+0
   \   0000004A   0xD031             BEQ.N    ??FLASH_VerifyProgram_4
   1340              {
   1341                  /* preparing passing parameter to program check the flash block */
   1342                  kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_PROGRAM_CHECK, start);
   \   0000004C   0xF026 0x407F      BIC      R0,R6,#0xFF000000
   \   00000050   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable25
   \   00000058   0x6809             LDR      R1,[R1, #+0]
   \   0000005A   0x6008             STR      R0,[R1, #+0]
   1343                  kFCCOBx[1] = BYTES_JOIN_TO_WORD_1_3(margin, 0xFFFFFFU);
   \   0000005C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005E   0x0620             LSLS     R0,R4,#+24
   \   00000060   0xF070 0x407F      ORNS     R0,R0,#-16777216
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable25
   \   00000068   0x6809             LDR      R1,[R1, #+0]
   \   0000006A   0x6048             STR      R0,[R1, #+4]
   1344                  kFCCOBx[2] = *expectedData;
   \   0000006C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable25
   \   00000074   0x6809             LDR      R1,[R1, #+0]
   \   00000076   0x6088             STR      R0,[R1, #+8]
   1345          
   1346                  /* calling flash command sequence function to execute the command */
   1347                  returnCode = flash_command_sequence(config);
   \   00000078   0x0028             MOVS     R0,R5
   \   0000007A   0x.... 0x....      BL       flash_command_sequence
   \   0000007E   0x4683             MOV      R11,R0
   1348          
   1349                  /* checking for the success of command execution */
   1350                  if (kStatus_FLASH_Success != returnCode)
   \   00000080   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000084   0xD00B             BEQ.N    ??FLASH_VerifyProgram_5
   1351                  {
   1352                      if (failedAddress)
   \   00000086   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000008A   0xD001             BEQ.N    ??FLASH_VerifyProgram_6
   1353                      {
   1354                          *failedAddress = start;
   \   0000008C   0xF8C9 0x6000      STR      R6,[R9, #+0]
   1355                      }
   1356                      if (failedData)
   \                     ??FLASH_VerifyProgram_6: (+1)
   \   00000090   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000094   0xD002             BEQ.N    ??FLASH_VerifyProgram_7
   1357                      {
   1358                          *failedData = 0;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xF8CA 0x0000      STR      R0,[R10, #+0]
   1359                      }
   1360                      break;
   \                     ??FLASH_VerifyProgram_7: (+1)
   \   0000009C   0xE008             B.N      ??FLASH_VerifyProgram_4
   1361                  }
   1362          
   1363                  lengthInBytes -= flashInfo.checkCmdAddressAligment;
   \                     ??FLASH_VerifyProgram_5: (+1)
   \   0000009E   0x9807             LDR      R0,[SP, #+28]
   \   000000A0   0x1A3F             SUBS     R7,R7,R0
   1364                  expectedData += flashInfo.checkCmdAddressAligment / sizeof(*expectedData);
   \   000000A2   0x9807             LDR      R0,[SP, #+28]
   \   000000A4   0x0880             LSRS     R0,R0,#+2
   \   000000A6   0xEB08 0x0880      ADD      R8,R8,R0, LSL #+2
   1365                  start += flashInfo.checkCmdAddressAligment;
   \   000000AA   0x9807             LDR      R0,[SP, #+28]
   \   000000AC   0x1986             ADDS     R6,R0,R6
   \   000000AE   0xE7CB             B.N      ??FLASH_VerifyProgram_3
   1366              }
   1367          
   1368              return (returnCode);
   \                     ??FLASH_VerifyProgram_4: (+1)
   \   000000B0   0x4658             MOV      R0,R11
   \                     ??FLASH_VerifyProgram_1: (+1)
   \   000000B2   0xB009             ADD      SP,SP,#+36
   \   000000B4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1369          }
   1370          

   \                                 In section .text, align 2, keep-with-next
   1371          status_t FLASH_VerifyEraseAllExecuteOnlySegments(flash_config_t *config, flash_margin_value_t margin)
   1372          {
   \                     FLASH_VerifyEraseAllExecuteOnlySegments: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1373              if (config == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??FLASH_VerifyEraseAllExecuteOnlySegments_0
   1374              {
   1375                  return kStatus_FLASH_InvalidArgument;
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0xE00B             B.N      ??FLASH_VerifyEraseAllExecuteOnlySegments_1
   1376              }
   1377          
   1378              /* preparing passing parameter to verify erase all execute-only segments command */
   1379              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_1_2(FTFx_VERIFY_ALL_EXECUTE_ONLY_SEGMENT, margin, 0xFFFFU);
   \                     ??FLASH_VerifyEraseAllExecuteOnlySegments_0: (+1)
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable25_5  ;; 0x4a00ffff
   \   00000014   0xEA50 0x4005      ORRS     R0,R0,R5, LSL #+16
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable25
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   1380          
   1381              /* calling flash command sequence function to execute the command */
   1382              return flash_command_sequence(config);
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       flash_command_sequence
   \                     ??FLASH_VerifyEraseAllExecuteOnlySegments_1: (+1)
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1383          }
   1384          

   \                                 In section .text, align 2, keep-with-next
   1385          status_t FLASH_IsProtected(flash_config_t *config,
   1386                                     uint32_t start,
   1387                                     uint32_t lengthInBytes,
   1388                                     flash_protection_state_t *protection_state)
   1389          {
   \                     FLASH_IsProtected: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB0AB             SUB      SP,SP,#+172
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   1390              uint32_t endAddress;           /* end address for protection check */
   1391              uint32_t protectionRegionSize; /* size of flash protection region */
   1392              uint32_t regionCheckedCounter; /* increments each time the flash address was checked for
   1393                                              * protection status */
   1394              uint32_t regionCounter;        /* incrementing variable used to increment through the flash
   1395                                              * protection regions */
   1396              uint32_t protectStatusCounter; /* increments each time a flash region was detected as protected */
   1397          
   1398              uint8_t flashRegionProtectStatus[FSL_FEATURE_FTFx_REGION_COUNT]; /* array of the protection status for each
   1399                                                                                * protection region */
   1400              uint32_t flashRegionAddress[FSL_FEATURE_FTFx_REGION_COUNT + 1];  /* array of the start addresses for each flash
   1401                                                                                * protection region. Note this is REGION_COUNT+1
   1402                                                                                * due to requiring the next start address after
   1403                                                                                * the end of flash for loop-check purposes below */
   1404              status_t returnCode;
   1405          
   1406              if (protection_state == NULL)
   \   0000000E   0x2F00             CMP      R7,#+0
   \   00000010   0xD101             BNE.N    ??FLASH_IsProtected_0
   1407              {
   1408                  return kStatus_FLASH_InvalidArgument;
   \   00000012   0x2004             MOVS     R0,#+4
   \   00000014   0xE0A0             B.N      ??FLASH_IsProtected_1
   1409              }
   1410          
   1411              /* Check the supplied address range. */
   1412              returnCode = flash_check_range(config, start, lengthInBytes, FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
   \                     ??FLASH_IsProtected_0: (+1)
   \   00000016   0x2308             MOVS     R3,#+8
   \   00000018   0x0032             MOVS     R2,R6
   \   0000001A   0x0029             MOVS     R1,R5
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       flash_check_range
   \   00000022   0x4683             MOV      R11,R0
   1413              if (returnCode)
   \   00000024   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000028   0xD001             BEQ.N    ??FLASH_IsProtected_2
   1414              {
   1415                  return returnCode;
   \   0000002A   0x4658             MOV      R0,R11
   \   0000002C   0xE094             B.N      ??FLASH_IsProtected_1
   1416              }
   1417          
   1418              /* calculating Flash end address */
   1419              endAddress = start + lengthInBytes;
   \                     ??FLASH_IsProtected_2: (+1)
   \   0000002E   0x1970             ADDS     R0,R6,R5
   \   00000030   0x9001             STR      R0,[SP, #+4]
   1420          
   1421              /* Calculate the size of the flash protection region
   1422               * If the flash density is > 32KB, then protection region is 1/32 of total flash density
   1423               * Else if flash density is < 32KB, then flash protection region is set to 1KB */
   1424              if (config->PFlashTotalSize > 32 * 1024)
   \   00000032   0x6860             LDR      R0,[R4, #+4]
   \   00000034   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000038   0xD903             BLS.N    ??FLASH_IsProtected_3
   1425              {
   1426                  protectionRegionSize = (config->PFlashTotalSize) / FSL_FEATURE_FTFx_REGION_COUNT;
   \   0000003A   0x6860             LDR      R0,[R4, #+4]
   \   0000003C   0x0940             LSRS     R0,R0,#+5
   \   0000003E   0x9000             STR      R0,[SP, #+0]
   \   00000040   0xE002             B.N      ??FLASH_IsProtected_4
   1427              }
   1428              else
   1429              {
   1430                  protectionRegionSize = 1024;
   \                     ??FLASH_IsProtected_3: (+1)
   \   00000042   0xF44F 0x6080      MOV      R0,#+1024
   \   00000046   0x9000             STR      R0,[SP, #+0]
   1431              }
   1432          
   1433              /* populate the flashRegionAddress array with the start address of each flash region */
   1434              regionCounter = 0; /* make sure regionCounter is initialized to 0 first */
   \                     ??FLASH_IsProtected_4: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x4681             MOV      R9,R0
   1435          
   1436              /* populate up to 33rd element of array, this is the next address after end of flash array */
   1437              while (regionCounter <= FSL_FEATURE_FTFx_REGION_COUNT)
   \                     ??FLASH_IsProtected_5: (+1)
   \   0000004C   0xF1B9 0x0F21      CMP      R9,#+33
   \   00000050   0xD209             BCS.N    ??FLASH_IsProtected_6
   1438              {
   1439                  flashRegionAddress[regionCounter] = config->PFlashBlockBase + protectionRegionSize * regionCounter;
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x9900             LDR      R1,[SP, #+0]
   \   00000056   0xFB09 0x0001      MLA      R0,R9,R1,R0
   \   0000005A   0xA90A             ADD      R1,SP,#+40
   \   0000005C   0xF841 0x0029      STR      R0,[R1, R9, LSL #+2]
   1440                  regionCounter++;
   \   00000060   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000064   0xE7F2             B.N      ??FLASH_IsProtected_5
   1441              }
   1442          
   1443              /* populate flashRegionProtectStatus array with status information
   1444               * Protection status for each region is stored in the FPROT[3:0] registers
   1445               * Each bit represents one region of flash
   1446               * 4 registers * 8-bits-per-register = 32-bits (32-regions)
   1447               * The convention is:
   1448               * FPROT3[bit 0] is the first protection region (start of flash memory)
   1449               * FPROT0[bit 7] is the last protection region (end of flash memory)
   1450               * regionCounter is used to determine which FPROT[3:0] register to check for protection status
   1451               * Note: FPROT=1 means NOT protected, FPROT=0 means protected */
   1452              regionCounter = 0; /* make sure regionCounter is initialized to 0 first */
   \                     ??FLASH_IsProtected_6: (+1)
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x4681             MOV      R9,R0
   1453              while (regionCounter < FSL_FEATURE_FTFx_REGION_COUNT)
   \                     ??FLASH_IsProtected_7: (+1)
   \   0000006A   0xF1B9 0x0F20      CMP      R9,#+32
   \   0000006E   0xD243             BCS.N    ??FLASH_IsProtected_8
   1454              {
   1455                  if (regionCounter < 8)
   \   00000070   0xF1B9 0x0F08      CMP      R9,#+8
   \   00000074   0xD20B             BCS.N    ??FLASH_IsProtected_9
   1456                  {
   1457                      flashRegionProtectStatus[regionCounter] = ((FTFx->FPROT3) >> regionCounter) & (0x01u);
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable25_6  ;; 0x40020010
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0xFA50 0xF009      ASRS     R0,R0,R9
   \   00000082   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000086   0xA902             ADD      R1,SP,#+8
   \   00000088   0xF801 0x0009      STRB     R0,[R1, R9]
   \   0000008C   0xE031             B.N      ??FLASH_IsProtected_10
   1458                  }
   1459                  else if ((regionCounter >= 8) && (regionCounter < 16))
   \                     ??FLASH_IsProtected_9: (+1)
   \   0000008E   0xF1B9 0x0F08      CMP      R9,#+8
   \   00000092   0xD30F             BCC.N    ??FLASH_IsProtected_11
   \   00000094   0xF1B9 0x0F10      CMP      R9,#+16
   \   00000098   0xD20C             BCS.N    ??FLASH_IsProtected_11
   1460                  {
   1461                      flashRegionProtectStatus[regionCounter] = ((FTFx->FPROT2) >> (regionCounter - 8)) & (0x01u);
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable25_7  ;; 0x40020011
   \   0000009E   0x7800             LDRB     R0,[R0, #+0]
   \   000000A0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A2   0x4649             MOV      R1,R9
   \   000000A4   0x3908             SUBS     R1,R1,#+8
   \   000000A6   0x4108             ASRS     R0,R0,R1
   \   000000A8   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000AC   0xA902             ADD      R1,SP,#+8
   \   000000AE   0xF801 0x0009      STRB     R0,[R1, R9]
   \   000000B2   0xE01E             B.N      ??FLASH_IsProtected_10
   1462                  }
   1463                  else if ((regionCounter >= 16) && (regionCounter < 24))
   \                     ??FLASH_IsProtected_11: (+1)
   \   000000B4   0xF1B9 0x0F10      CMP      R9,#+16
   \   000000B8   0xD30F             BCC.N    ??FLASH_IsProtected_12
   \   000000BA   0xF1B9 0x0F18      CMP      R9,#+24
   \   000000BE   0xD20C             BCS.N    ??FLASH_IsProtected_12
   1464                  {
   1465                      flashRegionProtectStatus[regionCounter] = ((FTFx->FPROT1) >> (regionCounter - 16)) & (0x01u);
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable25_8  ;; 0x40020012
   \   000000C4   0x7800             LDRB     R0,[R0, #+0]
   \   000000C6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C8   0x4649             MOV      R1,R9
   \   000000CA   0x3910             SUBS     R1,R1,#+16
   \   000000CC   0x4108             ASRS     R0,R0,R1
   \   000000CE   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000D2   0xA902             ADD      R1,SP,#+8
   \   000000D4   0xF801 0x0009      STRB     R0,[R1, R9]
   \   000000D8   0xE00B             B.N      ??FLASH_IsProtected_10
   1466                  }
   1467                  else
   1468                  {
   1469                      flashRegionProtectStatus[regionCounter] = ((FTFx->FPROT0) >> (regionCounter - 24)) & (0x01u);
   \                     ??FLASH_IsProtected_12: (+1)
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable25_9  ;; 0x40020013
   \   000000DE   0x7800             LDRB     R0,[R0, #+0]
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E2   0x4649             MOV      R1,R9
   \   000000E4   0x3918             SUBS     R1,R1,#+24
   \   000000E6   0x4108             ASRS     R0,R0,R1
   \   000000E8   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000EC   0xA902             ADD      R1,SP,#+8
   \   000000EE   0xF801 0x0009      STRB     R0,[R1, R9]
   1470                  }
   1471                  regionCounter++;
   \                     ??FLASH_IsProtected_10: (+1)
   \   000000F2   0xF119 0x0901      ADDS     R9,R9,#+1
   \   000000F6   0xE7B8             B.N      ??FLASH_IsProtected_7
   1472              }
   1473          
   1474              /* loop through the flash regions and check
   1475               * desired flash address range for protection status
   1476               * loop stops when it is detected that start has exceeded the endAddress */
   1477              regionCounter = 0; /* make sure regionCounter is initialized to 0 first */
   \                     ??FLASH_IsProtected_8: (+1)
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0x4681             MOV      R9,R0
   1478              regionCheckedCounter = 0;
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0x4680             MOV      R8,R0
   1479              protectStatusCounter = 0; /* make sure protectStatusCounter is initialized to 0 first */
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x4682             MOV      R10,R0
   1480              while (start < endAddress)
   \                     ??FLASH_IsProtected_13: (+1)
   \   00000104   0x9801             LDR      R0,[SP, #+4]
   \   00000106   0x4285             CMP      R5,R0
   \   00000108   0xD218             BCS.N    ??FLASH_IsProtected_14
   1481              {
   1482                  /* check to see if the address falls within this protection region
   1483                   * Note that if the entire flash is to be checked, the last protection
   1484                   * region checked would consist of the last protection start address and
   1485                   * the start address following the end of flash */
   1486                  if ((start >= flashRegionAddress[regionCounter]) && (start < flashRegionAddress[regionCounter + 1]))
   \   0000010A   0xA80A             ADD      R0,SP,#+40
   \   0000010C   0xF850 0x0029      LDR      R0,[R0, R9, LSL #+2]
   \   00000110   0x4285             CMP      R5,R0
   \   00000112   0xD310             BCC.N    ??FLASH_IsProtected_15
   \   00000114   0xA80A             ADD      R0,SP,#+40
   \   00000116   0xEB00 0x0089      ADD      R0,R0,R9, LSL #+2
   \   0000011A   0x6840             LDR      R0,[R0, #+4]
   \   0000011C   0x4285             CMP      R5,R0
   \   0000011E   0xD20A             BCS.N    ??FLASH_IsProtected_15
   1487                  {
   1488                      /* increment regionCheckedCounter to indicate this region was checked */
   1489                      regionCheckedCounter++;
   \   00000120   0xF118 0x0801      ADDS     R8,R8,#+1
   1490          
   1491                      /* check the protection status of this region
   1492                       * Note: FPROT=1 means NOT protected, FPROT=0 means protected */
   1493                      if (!flashRegionProtectStatus[regionCounter])
   \   00000124   0xA802             ADD      R0,SP,#+8
   \   00000126   0xF810 0x0009      LDRB     R0,[R0, R9]
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD101             BNE.N    ??FLASH_IsProtected_16
   1494                      {
   1495                          /* increment protectStatusCounter to indicate this region is protected */
   1496                          protectStatusCounter++;
   \   0000012E   0xF11A 0x0A01      ADDS     R10,R10,#+1
   1497                      }
   1498                      start += protectionRegionSize; /* increment to an address within the next region */
   \                     ??FLASH_IsProtected_16: (+1)
   \   00000132   0x9800             LDR      R0,[SP, #+0]
   \   00000134   0x1945             ADDS     R5,R0,R5
   1499                  }
   1500                  regionCounter++; /* increment regionCounter to check for the next flash protection region */
   \                     ??FLASH_IsProtected_15: (+1)
   \   00000136   0xF119 0x0901      ADDS     R9,R9,#+1
   \   0000013A   0xE7E3             B.N      ??FLASH_IsProtected_13
   1501              }
   1502          
   1503              /* if protectStatusCounter == 0, then no region of the desired flash region is protected */
   1504              if (protectStatusCounter == 0)
   \                     ??FLASH_IsProtected_14: (+1)
   \   0000013C   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000140   0xD102             BNE.N    ??FLASH_IsProtected_17
   1505              {
   1506                  *protection_state = kFLASH_ProtectionStateUnprotected;
   \   00000142   0x2000             MOVS     R0,#+0
   \   00000144   0x7038             STRB     R0,[R7, #+0]
   \   00000146   0xE006             B.N      ??FLASH_IsProtected_18
   1507              }
   1508              /* if protectStatusCounter == regionCheckedCounter, then each region checked was protected */
   1509              else if (protectStatusCounter == regionCheckedCounter)
   \                     ??FLASH_IsProtected_17: (+1)
   \   00000148   0x45C2             CMP      R10,R8
   \   0000014A   0xD102             BNE.N    ??FLASH_IsProtected_19
   1510              {
   1511                  *protection_state = kFLASH_ProtectionStateProtected;
   \   0000014C   0x2001             MOVS     R0,#+1
   \   0000014E   0x7038             STRB     R0,[R7, #+0]
   \   00000150   0xE001             B.N      ??FLASH_IsProtected_18
   1512              }
   1513              /* if protectStatusCounter != regionCheckedCounter, then protection status is mixed
   1514               * In other words, some regions are protected while others are unprotected */
   1515              else
   1516              {
   1517                  *protection_state = kFLASH_ProtectionStateMixed;
   \                     ??FLASH_IsProtected_19: (+1)
   \   00000152   0x2002             MOVS     R0,#+2
   \   00000154   0x7038             STRB     R0,[R7, #+0]
   1518              }
   1519          
   1520              return (returnCode);
   \                     ??FLASH_IsProtected_18: (+1)
   \   00000156   0x4658             MOV      R0,R11
   \                     ??FLASH_IsProtected_1: (+1)
   \   00000158   0xB02B             ADD      SP,SP,#+172
   \   0000015A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1521          }
   1522          

   \                                 In section .text, align 2, keep-with-next
   1523          status_t FLASH_IsExecuteOnly(flash_config_t *config,
   1524                                       uint32_t start,
   1525                                       uint32_t lengthInBytes,
   1526                                       flash_execute_only_access_state_t *access_state)
   1527          {
   \                     FLASH_IsExecuteOnly: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1528              status_t returnCode;
   1529          
   1530              if (access_state == NULL)
   \   0000000C   0x2F00             CMP      R7,#+0
   \   0000000E   0xD101             BNE.N    ??FLASH_IsExecuteOnly_0
   1531              {
   1532                  return kStatus_FLASH_InvalidArgument;
   \   00000010   0x2004             MOVS     R0,#+4
   \   00000012   0xE00E             B.N      ??FLASH_IsExecuteOnly_1
   1533              }
   1534          
   1535              /* Check the supplied address range. */
   1536              returnCode = flash_check_range(config, start, lengthInBytes, FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
   \                     ??FLASH_IsExecuteOnly_0: (+1)
   \   00000014   0x2308             MOVS     R3,#+8
   \   00000016   0x0032             MOVS     R2,R6
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       flash_check_range
   \   00000020   0x4680             MOV      R8,R0
   1537              if (returnCode)
   \   00000022   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000026   0xD001             BEQ.N    ??FLASH_IsExecuteOnly_2
   1538              {
   1539                  return returnCode;
   \   00000028   0x4640             MOV      R0,R8
   \   0000002A   0xE002             B.N      ??FLASH_IsExecuteOnly_1
   1540              }
   1541          
   1542          #if defined(FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL) && FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
   1543              {
   1544                  uint32_t executeOnlySegmentCounter = 0;
   1545          
   1546                  /* calculating end address */
   1547                  uint32_t endAddress = start + lengthInBytes;
   1548          
   1549                  /* Aligning start address and end address */
   1550                  uint32_t alignedStartAddress = ALIGN_DOWN(start, config->PFlashAccessSegmentSize);
   1551                  uint32_t alignedEndAddress = ALIGN_UP(endAddress, config->PFlashAccessSegmentSize);
   1552          
   1553                  uint32_t segmentIndex = 0;
   1554                  uint32_t maxSupportedExecuteOnlySegmentCount =
   1555                      (alignedEndAddress - alignedStartAddress) / config->PFlashAccessSegmentSize;
   1556          
   1557                  while (start < endAddress)
   1558                  {
   1559                      uint32_t xacc;
   1560          
   1561                      segmentIndex = start / config->PFlashAccessSegmentSize;
   1562          
   1563                      if (segmentIndex < 32)
   1564                      {
   1565                          xacc = *(const volatile uint32_t *)&FTFx->XACCL3;
   1566                      }
   1567                      else if (segmentIndex < config->PFlashAccessSegmentCount)
   1568                      {
   1569                          xacc = *(const volatile uint32_t *)&FTFx->XACCH3;
   1570                          segmentIndex -= 32;
   1571                      }
   1572                      else
   1573                      {
   1574                          break;
   1575                      }
   1576          
   1577                      /* Determine if this address range is in a execute-only protection flash segment. */
   1578                      if ((~xacc) & (1u << segmentIndex))
   1579                      {
   1580                          executeOnlySegmentCounter++;
   1581                      }
   1582          
   1583                      start += config->PFlashAccessSegmentSize;
   1584                  }
   1585          
   1586                  if (executeOnlySegmentCounter < 1u)
   1587                  {
   1588                      *access_state = kFLASH_AccessStateUnLimited;
   1589                  }
   1590                  else if (executeOnlySegmentCounter < maxSupportedExecuteOnlySegmentCount)
   1591                  {
   1592                      *access_state = kFLASH_AccessStateMixed;
   1593                  }
   1594                  else
   1595                  {
   1596                      *access_state = kFLASH_AccessStateExecuteOnly;
   1597                  }
   1598              }
   1599          #else
   1600              *access_state = kFLASH_AccessStateUnLimited;
   \                     ??FLASH_IsExecuteOnly_2: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x7038             STRB     R0,[R7, #+0]
   1601          #endif /* FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL */
   1602          
   1603              return (returnCode);
   \   00000030   0x4640             MOV      R0,R8
   \                     ??FLASH_IsExecuteOnly_1: (+1)
   \   00000032   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1604          }
   1605          

   \                                 In section .text, align 2, keep-with-next
   1606          status_t FLASH_GetProperty(flash_config_t *config, flash_property_tag_t whichProperty, uint32_t *value)
   1607          {
   \                     FLASH_GetProperty: (+1)
   \   00000000   0x0003             MOVS     R3,R0
   1608              if ((config == NULL) || (value == NULL))
   \   00000002   0x2B00             CMP      R3,#+0
   \   00000004   0xD001             BEQ.N    ??FLASH_GetProperty_0
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD101             BNE.N    ??FLASH_GetProperty_1
   1609              {
   1610                  return kStatus_FLASH_InvalidArgument;
   \                     ??FLASH_GetProperty_0: (+1)
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0xE033             B.N      ??FLASH_GetProperty_2
   1611              }
   1612          
   1613              switch (whichProperty)
   \                     ??FLASH_GetProperty_1: (+1)
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD00E             BEQ.N    ??FLASH_GetProperty_3
   \   00000014   0x2902             CMP      R1,#+2
   \   00000016   0xD012             BEQ.N    ??FLASH_GetProperty_4
   \   00000018   0xD30E             BCC.N    ??FLASH_GetProperty_5
   \   0000001A   0x2904             CMP      R1,#+4
   \   0000001C   0xD016             BEQ.N    ??FLASH_GetProperty_6
   \   0000001E   0xD312             BCC.N    ??FLASH_GetProperty_7
   \   00000020   0x2906             CMP      R1,#+6
   \   00000022   0xD019             BEQ.N    ??FLASH_GetProperty_8
   \   00000024   0xD315             BCC.N    ??FLASH_GetProperty_9
   \   00000026   0x2908             CMP      R1,#+8
   \   00000028   0xD01C             BEQ.N    ??FLASH_GetProperty_10
   \   0000002A   0xD318             BCC.N    ??FLASH_GetProperty_11
   \   0000002C   0x2909             CMP      R1,#+9
   \   0000002E   0xD01C             BEQ.N    ??FLASH_GetProperty_12
   \   00000030   0xE01E             B.N      ??FLASH_GetProperty_13
   1614              {
   1615                  case kFLASH_PropertyPflashSectorSize:
   1616                      *value = config->PFlashSectorSize;
   \                     ??FLASH_GetProperty_3: (+1)
   \   00000032   0x68D8             LDR      R0,[R3, #+12]
   \   00000034   0x6010             STR      R0,[R2, #+0]
   1617                      break;
   \   00000036   0xE01D             B.N      ??FLASH_GetProperty_14
   1618          
   1619                  case kFLASH_PropertyPflashTotalSize:
   1620                      *value = config->PFlashTotalSize;
   \                     ??FLASH_GetProperty_5: (+1)
   \   00000038   0x6858             LDR      R0,[R3, #+4]
   \   0000003A   0x6010             STR      R0,[R2, #+0]
   1621                      break;
   \   0000003C   0xE01A             B.N      ??FLASH_GetProperty_14
   1622          
   1623                  case kFLASH_PropertyPflashBlockSize:
   1624                      *value = config->PFlashTotalSize / FSL_FEATURE_FLASH_PFLASH_BLOCK_COUNT;
   \                     ??FLASH_GetProperty_4: (+1)
   \   0000003E   0x6858             LDR      R0,[R3, #+4]
   \   00000040   0x0840             LSRS     R0,R0,#+1
   \   00000042   0x6010             STR      R0,[R2, #+0]
   1625                      break;
   \   00000044   0xE016             B.N      ??FLASH_GetProperty_14
   1626          
   1627                  case kFLASH_PropertyPflashBlockCount:
   1628                      *value = config->PFlashBlockCount;
   \                     ??FLASH_GetProperty_7: (+1)
   \   00000046   0x6898             LDR      R0,[R3, #+8]
   \   00000048   0x6010             STR      R0,[R2, #+0]
   1629                      break;
   \   0000004A   0xE013             B.N      ??FLASH_GetProperty_14
   1630          
   1631                  case kFLASH_PropertyPflashBlockBaseAddr:
   1632                      *value = config->PFlashBlockBase;
   \                     ??FLASH_GetProperty_6: (+1)
   \   0000004C   0x6818             LDR      R0,[R3, #+0]
   \   0000004E   0x6010             STR      R0,[R2, #+0]
   1633                      break;
   \   00000050   0xE010             B.N      ??FLASH_GetProperty_14
   1634          
   1635                  case kFLASH_PropertyPflashFacSupport:
   1636          #if defined(FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL)
   1637                      *value = FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL;
   \                     ??FLASH_GetProperty_9: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x6010             STR      R0,[R2, #+0]
   1638          #else
   1639                      *value = 0;
   1640          #endif /* FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL */
   1641                      break;
   \   00000056   0xE00D             B.N      ??FLASH_GetProperty_14
   1642          
   1643                  case kFLASH_PropertyPflashAccessSegmentSize:
   1644                      *value = config->PFlashAccessSegmentSize;
   \                     ??FLASH_GetProperty_8: (+1)
   \   00000058   0x6958             LDR      R0,[R3, #+20]
   \   0000005A   0x6010             STR      R0,[R2, #+0]
   1645                      break;
   \   0000005C   0xE00A             B.N      ??FLASH_GetProperty_14
   1646          
   1647                  case kFLASH_PropertyPflashAccessSegmentCount:
   1648                      *value = config->PFlashAccessSegmentCount;
   \                     ??FLASH_GetProperty_11: (+1)
   \   0000005E   0x6998             LDR      R0,[R3, #+24]
   \   00000060   0x6010             STR      R0,[R2, #+0]
   1649                      break;
   \   00000062   0xE007             B.N      ??FLASH_GetProperty_14
   1650          
   1651                  case kFLASH_PropertyFlexRamBlockBaseAddr:
   1652                      *value = config->FlexRAMBlockBase;
   \                     ??FLASH_GetProperty_10: (+1)
   \   00000064   0x6A18             LDR      R0,[R3, #+32]
   \   00000066   0x6010             STR      R0,[R2, #+0]
   1653                      break;
   \   00000068   0xE004             B.N      ??FLASH_GetProperty_14
   1654          
   1655                  case kFLASH_PropertyFlexRamTotalSize:
   1656                      *value = config->FlexRAMTotalSize;
   \                     ??FLASH_GetProperty_12: (+1)
   \   0000006A   0x6A58             LDR      R0,[R3, #+36]
   \   0000006C   0x6010             STR      R0,[R2, #+0]
   1657                      break;
   \   0000006E   0xE001             B.N      ??FLASH_GetProperty_14
   1658          
   1659          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   1660                  case kFLASH_PropertyDflashSectorSize:
   1661                      *value = FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_SECTOR_SIZE;
   1662                      break;
   1663                  case kFLASH_PropertyDflashTotalSize:
   1664                      *value = config->DFlashTotalSize;
   1665                      break;
   1666                  case kFLASH_PropertyDflashBlockSize:
   1667                      *value = FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_SIZE;
   1668                      break;
   1669                  case kFLASH_PropertyDflashBlockCount:
   1670                      *value = FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_COUNT;
   1671                      break;
   1672                  case kFLASH_PropertyDflashBlockBaseAddr:
   1673                      *value = config->DFlashBlockBase;
   1674                      break;
   1675                  case kFLASH_PropertyEepromTotalSize:
   1676                      *value = config->EEpromTotalSize;
   1677                      break;
   1678          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   1679          
   1680                  default: /* catch inputs that are not recognized */
   1681                      return kStatus_FLASH_UnknownProperty;
   \                     ??FLASH_GetProperty_13: (+1)
   \   00000070   0x206A             MOVS     R0,#+106
   \   00000072   0xE000             B.N      ??FLASH_GetProperty_2
   1682              }
   1683          
   1684              return kStatus_FLASH_Success;
   \                     ??FLASH_GetProperty_14: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \                     ??FLASH_GetProperty_2: (+1)
   \   00000076   0x4770             BX       LR               ;; return
   1685          }
   1686          
   1687          #if defined(FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD) && FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD
   1688          status_t FLASH_SetFlexramFunction(flash_config_t *config, flash_flexram_function_option_t option)
   1689          {
   1690              status_t status;
   1691          
   1692              if (config == NULL)
   1693              {
   1694                  return kStatus_FLASH_InvalidArgument;
   1695              }
   1696          
   1697              status = flasn_check_flexram_function_option_range(option);
   1698              if (status != kStatus_FLASH_Success)
   1699              {
   1700                  return status;
   1701              }
   1702          
   1703              /* preparing passing parameter to verify all block command */
   1704              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_1_2(FTFx_SET_FLEXRAM_FUNCTION, option, 0xFFFFU);
   1705          
   1706              /* calling flash command sequence function to execute the command */
   1707              return flash_command_sequence(config);
   1708          }
   1709          #endif /* FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD */
   1710          
   1711          #if defined(FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD) && FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD

   \                                 In section .text, align 2, keep-with-next
   1712          status_t FLASH_SwapControl(flash_config_t *config,
   1713                                     uint32_t address,
   1714                                     flash_swap_control_option_t option,
   1715                                     flash_swap_state_config_t *returnInfo)
   1716          {
   \                     FLASH_SwapControl: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1717              status_t returnCode;
   1718          
   1719              if ((config == NULL) || (returnInfo == NULL))
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD001             BEQ.N    ??FLASH_SwapControl_0
   \   00000010   0x2F00             CMP      R7,#+0
   \   00000012   0xD101             BNE.N    ??FLASH_SwapControl_1
   1720              {
   1721                  return kStatus_FLASH_InvalidArgument;
   \                     ??FLASH_SwapControl_0: (+1)
   \   00000014   0x2004             MOVS     R0,#+4
   \   00000016   0xE038             B.N      ??FLASH_SwapControl_2
   1722              }
   1723          
   1724              if (address & (FSL_FEATURE_FLASH_PFLASH_SWAP_CONTROL_CMD_ADDRESS_ALIGMENT - 1))
   \                     ??FLASH_SwapControl_1: (+1)
   \   00000018   0xF015 0x0F0F      TST      R5,#0xF
   \   0000001C   0xD001             BEQ.N    ??FLASH_SwapControl_3
   1725              {
   1726                  return kStatus_FLASH_AlignmentError;
   \   0000001E   0x2065             MOVS     R0,#+101
   \   00000020   0xE033             B.N      ??FLASH_SwapControl_2
   1727              }
   1728          
   1729              /* Make sure address provided is in the lower half of Program flash but not in the Flash Configuration Field */
   1730              if ((address >= (config->PFlashTotalSize / 2)) ||
   1731                  ((address >= kFLASH_ConfigAreaStart) && (address <= kFLASH_ConfigAreaEnd)))
   \                     ??FLASH_SwapControl_3: (+1)
   \   00000022   0x6860             LDR      R0,[R4, #+4]
   \   00000024   0xEBB5 0x0F50      CMP      R5,R0, LSR #+1
   \   00000028   0xD205             BCS.N    ??FLASH_SwapControl_4
   \   0000002A   0xF5B5 0x6F80      CMP      R5,#+1024
   \   0000002E   0xD304             BCC.N    ??FLASH_SwapControl_5
   \   00000030   0xF5B5 0x6F82      CMP      R5,#+1040
   \   00000034   0xD201             BCS.N    ??FLASH_SwapControl_5
   1732              {
   1733                  return kStatus_FLASH_SwapIndicatorAddressError;
   \                     ??FLASH_SwapControl_4: (+1)
   \   00000036   0x2075             MOVS     R0,#+117
   \   00000038   0xE027             B.N      ??FLASH_SwapControl_2
   1734              }
   1735          
   1736              /* Check the option. */
   1737              returnCode = flash_check_swap_control_option(option);
   \                     ??FLASH_SwapControl_5: (+1)
   \   0000003A   0x0030             MOVS     R0,R6
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0x.... 0x....      BL       flash_check_swap_control_option
   \   00000042   0x4680             MOV      R8,R0
   1738              if (returnCode)
   \   00000044   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000048   0xD001             BEQ.N    ??FLASH_SwapControl_6
   1739              {
   1740                  return returnCode;
   \   0000004A   0x4640             MOV      R0,R8
   \   0000004C   0xE01D             B.N      ??FLASH_SwapControl_2
   1741              }
   1742          
   1743              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_SWAP_CONTROL, address);
   \                     ??FLASH_SwapControl_6: (+1)
   \   0000004E   0xF025 0x407F      BIC      R0,R5,#0xFF000000
   \   00000052   0xF050 0x408C      ORRS     R0,R0,#0x46000000
   \   00000056   0x....             LDR.N    R1,??DataTable25
   \   00000058   0x6809             LDR      R1,[R1, #+0]
   \   0000005A   0x6008             STR      R0,[R1, #+0]
   1744              kFCCOBx[1] = BYTES_JOIN_TO_WORD_1_3(option, 0xFFFFFFU);
   \   0000005C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005E   0x0630             LSLS     R0,R6,#+24
   \   00000060   0xF070 0x407F      ORNS     R0,R0,#-16777216
   \   00000064   0x....             LDR.N    R1,??DataTable25
   \   00000066   0x6809             LDR      R1,[R1, #+0]
   \   00000068   0x6048             STR      R0,[R1, #+4]
   1745          
   1746              returnCode = flash_command_sequence(config);
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0x.... 0x....      BL       flash_command_sequence
   \   00000070   0x4680             MOV      R8,R0
   1747          
   1748              returnInfo->flashSwapState = (flash_swap_state_t)FTFx->FCCOB5;
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable25_10  ;; 0x4002000a
   \   00000076   0x7800             LDRB     R0,[R0, #+0]
   \   00000078   0x7038             STRB     R0,[R7, #+0]
   1749              returnInfo->currentSwapBlockStatus = (flash_swap_block_status_t)FTFx->FCCOB6;
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable25_11  ;; 0x40020009
   \   0000007E   0x7800             LDRB     R0,[R0, #+0]
   \   00000080   0x7078             STRB     R0,[R7, #+1]
   1750              returnInfo->nextSwapBlockStatus = (flash_swap_block_status_t)FTFx->FCCOB7;
   \   00000082   0x....             LDR.N    R0,??DataTable25_12  ;; 0x40020008
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x70B8             STRB     R0,[R7, #+2]
   1751          
   1752              return returnCode;
   \   00000088   0x4640             MOV      R0,R8
   \                     ??FLASH_SwapControl_2: (+1)
   \   0000008A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1753          }
   1754          #endif /* FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD */
   1755          
   1756          #if defined(FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP) && FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP

   \                                 In section .text, align 2, keep-with-next
   1757          status_t FLASH_Swap(flash_config_t *config, uint32_t address, flash_swap_function_option_t option)
   1758          {
   \                     FLASH_Swap: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   1759              flash_swap_state_config_t returnInfo;
   1760              status_t returnCode;
   1761          
   1762              memset(&returnInfo, 0xFFU, sizeof(returnInfo));
   \   0000000C   0xF05F 0x0803      MOVS     R8,#+3
   \   00000010   0xF04F 0x09FF      MOV      R9,#+255
   \   00000014   0x46EA             MOV      R10,SP
   \   00000016   0x464A             MOV      R2,R9
   \   00000018   0x4641             MOV      R1,R8
   \   0000001A   0x4650             MOV      R0,R10
   \   0000001C   0x.... 0x....      BL       __aeabi_memset
   1763          
   1764              do
   1765              {
   1766                  returnCode = FLASH_SwapControl(config, address, kFLASH_SwapControlOptionReportStatus, &returnInfo);
   \                     ??FLASH_Swap_0: (+1)
   \   00000020   0x466B             MOV      R3,SP
   \   00000022   0x2208             MOVS     R2,#+8
   \   00000024   0x0029             MOVS     R1,R5
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       FLASH_SwapControl
   \   0000002C   0x0007             MOVS     R7,R0
   1767                  if (returnCode != kStatus_FLASH_Success)
   \   0000002E   0x2F00             CMP      R7,#+0
   \   00000030   0xD001             BEQ.N    ??FLASH_Swap_1
   1768                  {
   1769                      return returnCode;
   \   00000032   0x0038             MOVS     R0,R7
   \   00000034   0xE05C             B.N      ??FLASH_Swap_2
   1770                  }
   1771          
   1772                  if (kFLASH_SwapFunctionOptionDisable == option)
   \                     ??FLASH_Swap_1: (+1)
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x2E01             CMP      R6,#+1
   \   0000003A   0xD113             BNE.N    ??FLASH_Swap_3
   1773                  {
   1774                      if (returnInfo.flashSwapState == kFLASH_SwapStateDisabled)
   \   0000003C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000040   0x2805             CMP      R0,#+5
   \   00000042   0xD101             BNE.N    ??FLASH_Swap_4
   1775                      {
   1776                          return kStatus_FLASH_Success;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE053             B.N      ??FLASH_Swap_2
   1777                      }
   1778                      else if (returnInfo.flashSwapState == kFLASH_SwapStateUninitialized)
   \                     ??FLASH_Swap_4: (+1)
   \   00000048   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD107             BNE.N    ??FLASH_Swap_5
   1779                      {
   1780                          /* The swap system changed to the DISABLED state with Program flash block 0
   1781                           * located at relative flash address 0x0_0000 */
   1782                          returnCode = FLASH_SwapControl(config, address, kFLASH_SwapControlOptionDisableSystem, &returnInfo);
   \   00000050   0x466B             MOV      R3,SP
   \   00000052   0x2210             MOVS     R2,#+16
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      BL       FLASH_SwapControl
   \   0000005C   0x0007             MOVS     R7,R0
   \   0000005E   0xE03D             B.N      ??FLASH_Swap_6
   1783                      }
   1784                      else
   1785                      {
   1786                          /* Swap disable should be requested only when swap system is in the uninitialized state */
   1787                          return kStatus_FLASH_SwapSystemNotInUninitialized;
   \                     ??FLASH_Swap_5: (+1)
   \   00000060   0x2074             MOVS     R0,#+116
   \   00000062   0xE045             B.N      ??FLASH_Swap_2
   1788                      }
   1789                  }
   1790                  else
   1791                  {
   1792                      /* When first swap: the initial swap state is Uninitialized, flash swap inidicator address is unset,
   1793                       *    the swap procedure should be Uninitialized -> Update-Erased -> Complete.
   1794                       * After the first swap has been completed, the flash swap inidicator address cannot be modified
   1795                       *    unless EraseAllBlocks command is issued, the swap procedure is changed to Update -> Update-Erased ->
   1796                       *    Complete. */
   1797                      switch (returnInfo.flashSwapState)
   \                     ??FLASH_Swap_3: (+1)
   \   00000064   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD008             BEQ.N    ??FLASH_Swap_7
   \   0000006C   0x2802             CMP      R0,#+2
   \   0000006E   0xD01D             BEQ.N    ??FLASH_Swap_8
   \   00000070   0xD30D             BCC.N    ??FLASH_Swap_9
   \   00000072   0x2804             CMP      R0,#+4
   \   00000074   0xD02C             BEQ.N    ??FLASH_Swap_10
   \   00000076   0xD323             BCC.N    ??FLASH_Swap_11
   \   00000078   0x2805             CMP      R0,#+5
   \   0000007A   0xD02A             BEQ.N    ??FLASH_Swap_12
   \   0000007C   0xE02C             B.N      ??FLASH_Swap_13
   1798                      {
   1799                          case kFLASH_SwapStateUninitialized:
   1800                              /* If current swap mode is Uninitialized, Initialize Swap to Initialized/READY state. */
   1801                              returnCode =
   1802                                  FLASH_SwapControl(config, address, kFLASH_SwapControlOptionIntializeSystem, &returnInfo);
   \                     ??FLASH_Swap_7: (+1)
   \   0000007E   0x466B             MOV      R3,SP
   \   00000080   0x2201             MOVS     R2,#+1
   \   00000082   0x0029             MOVS     R1,R5
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       FLASH_SwapControl
   \   0000008A   0x0007             MOVS     R7,R0
   1803                              break;
   \   0000008C   0xE026             B.N      ??FLASH_Swap_6
   1804                          case kFLASH_SwapStateReady:
   1805                              /* Validate whether the address provided to the swap system is matched to
   1806                               * swap indicator address in the IFR */
   1807                              returnCode = flash_validate_swap_indicator_address(config, address);
   \                     ??FLASH_Swap_9: (+1)
   \   0000008E   0x0029             MOVS     R1,R5
   \   00000090   0x0020             MOVS     R0,R4
   \   00000092   0x.... 0x....      BL       flash_validate_swap_indicator_address
   \   00000096   0x0007             MOVS     R7,R0
   1808                              if (returnCode == kStatus_FLASH_Success)
   \   00000098   0x2F00             CMP      R7,#+0
   \   0000009A   0xD106             BNE.N    ??FLASH_Swap_14
   1809                              {
   1810                                  /* If current swap mode is Initialized/Ready, Initialize Swap to UPDATE state. */
   1811                                  returnCode =
   1812                                      FLASH_SwapControl(config, address, kFLASH_SwapControlOptionSetInUpdateState, &returnInfo);
   \   0000009C   0x466B             MOV      R3,SP
   \   0000009E   0x2202             MOVS     R2,#+2
   \   000000A0   0x0029             MOVS     R1,R5
   \   000000A2   0x0020             MOVS     R0,R4
   \   000000A4   0x.... 0x....      BL       FLASH_SwapControl
   \   000000A8   0x0007             MOVS     R7,R0
   1813                              }
   1814                              break;
   \                     ??FLASH_Swap_14: (+1)
   \   000000AA   0xE017             B.N      ??FLASH_Swap_6
   1815                          case kFLASH_SwapStateUpdate:
   1816                              /* If current swap mode is Update, Erase indicator sector in non active block
   1817                               * to proceed swap system to update-erased state */
   1818                              returnCode = FLASH_Erase(config, address + (config->PFlashTotalSize >> 1),
   1819                                                       FSL_FEATURE_FLASH_PFLASH_SECTOR_CMD_ADDRESS_ALIGMENT, kFLASH_ApiEraseKey);
   \                     ??FLASH_Swap_8: (+1)
   \   000000AC   0x....             LDR.N    R3,??DataTable25_13  ;; 0x6b65666b
   \   000000AE   0x2210             MOVS     R2,#+16
   \   000000B0   0x6860             LDR      R0,[R4, #+4]
   \   000000B2   0xEB15 0x0150      ADDS     R1,R5,R0, LSR #+1
   \   000000B6   0x0020             MOVS     R0,R4
   \   000000B8   0x.... 0x....      BL       FLASH_Erase
   \   000000BC   0x0007             MOVS     R7,R0
   1820                              break;
   \   000000BE   0xE00D             B.N      ??FLASH_Swap_6
   1821                          case kFLASH_SwapStateUpdateErased:
   1822                              /* If current swap mode is Update or Update-Erased, progress Swap to COMPLETE State */
   1823                              returnCode =
   1824                                  FLASH_SwapControl(config, address, kFLASH_SwapControlOptionSetInCompleteState, &returnInfo);
   \                     ??FLASH_Swap_11: (+1)
   \   000000C0   0x466B             MOV      R3,SP
   \   000000C2   0x2204             MOVS     R2,#+4
   \   000000C4   0x0029             MOVS     R1,R5
   \   000000C6   0x0020             MOVS     R0,R4
   \   000000C8   0x.... 0x....      BL       FLASH_SwapControl
   \   000000CC   0x0007             MOVS     R7,R0
   1825                              break;
   \   000000CE   0xE005             B.N      ??FLASH_Swap_6
   1826                          case kFLASH_SwapStateComplete:
   1827                              break;
   \                     ??FLASH_Swap_10: (+1)
   \   000000D0   0xE004             B.N      ??FLASH_Swap_6
   1828                          case kFLASH_SwapStateDisabled:
   1829                              /* When swap system is in disabled state, We need to clear swap system back to uninitialized
   1830                               * by issuing EraseAllBlocks command */
   1831                              returnCode = kStatus_FLASH_SwapSystemNotInUninitialized;
   \                     ??FLASH_Swap_12: (+1)
   \   000000D2   0x2074             MOVS     R0,#+116
   \   000000D4   0x0007             MOVS     R7,R0
   1832                              break;
   \   000000D6   0xE001             B.N      ??FLASH_Swap_6
   1833                          default:
   1834                              returnCode = kStatus_FLASH_InvalidArgument;
   \                     ??FLASH_Swap_13: (+1)
   \   000000D8   0x2004             MOVS     R0,#+4
   \   000000DA   0x0007             MOVS     R7,R0
   1835                              break;
   1836                      }
   1837                  }
   1838                  if (returnCode != kStatus_FLASH_Success)
   \                     ??FLASH_Swap_6: (+1)
   \   000000DC   0x2F00             CMP      R7,#+0
   \   000000DE   0xD106             BNE.N    ??FLASH_Swap_15
   1839                  {
   1840                      break;
   1841                  }
   1842              } while (!((kFLASH_SwapStateComplete == returnInfo.flashSwapState) && (kFLASH_SwapFunctionOptionEnable == option)));
   \                     ??FLASH_Swap_16: (+1)
   \   000000E0   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000E4   0x2804             CMP      R0,#+4
   \   000000E6   0xD19B             BNE.N    ??FLASH_Swap_0
   \   000000E8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000EA   0x2E00             CMP      R6,#+0
   \   000000EC   0xD198             BNE.N    ??FLASH_Swap_0
   1843          
   1844              return returnCode;
   \                     ??FLASH_Swap_15: (+1)
   \   000000EE   0x0038             MOVS     R0,R7
   \                     ??FLASH_Swap_2: (+1)
   \   000000F0   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   1845          }
   1846          #endif /* FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP */
   1847          
   1848          #if defined(FSL_FEATURE_FLASH_HAS_PROGRAM_PARTITION_CMD) && FSL_FEATURE_FLASH_HAS_PROGRAM_PARTITION_CMD
   1849          status_t FLASH_ProgramPartition(flash_config_t *config,
   1850                                          flash_partition_flexram_load_option_t option,
   1851                                          uint32_t eepromDataSizeCode,
   1852                                          uint32_t flexnvmPartitionCode)
   1853          {
   1854              status_t returnCode;
   1855          
   1856              if (config == NULL)
   1857              {
   1858                  return kStatus_FLASH_InvalidArgument;
   1859              }
   1860          
   1861              /* eepromDataSizeCode[7:6], flexnvmPartitionCode[7:4] should be all 1'b0
   1862               *  or it will cause access error. */
   1863              /* eepromDataSizeCode &= 0x3FU;  */
   1864              /* flexnvmPartitionCode &= 0x0FU; */
   1865          
   1866              /* preparing passing parameter to program the flash block */
   1867              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_2_1(FTFx_PROGRAM_PARTITION, 0xFFFFU, option);
   1868              kFCCOBx[1] = BYTES_JOIN_TO_WORD_1_1_2(eepromDataSizeCode, flexnvmPartitionCode, 0xFFFFU);
   1869          
   1870              /* calling flash command sequence function to execute the command */
   1871              returnCode = flash_command_sequence(config);
   1872          
   1873              flash_cache_clear(config);
   1874          
   1875          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   1876              /* Data flash IFR will be updated by program partition command during reset sequence,
   1877               * so we just set reserved values for partitioned FlexNVM size here */
   1878              config->EEpromTotalSize = FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_RESERVED;
   1879              config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   1880          #endif
   1881          
   1882              return (returnCode);
   1883          }
   1884          #endif /* FSL_FEATURE_FLASH_HAS_PROGRAM_PARTITION_CMD */
   1885          

   \                                 In section .text, align 2, keep-with-next
   1886          status_t FLASH_PflashSetProtection(flash_config_t *config, uint32_t protectStatus)
   1887          {
   \                     FLASH_PflashSetProtection: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   1888              if (config == NULL)
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD101             BNE.N    ??FLASH_PflashSetProtection_0
   1889              {
   1890                  return kStatus_FLASH_InvalidArgument;
   \   00000006   0x2004             MOVS     R0,#+4
   \   00000008   0xE00A             B.N      ??FLASH_PflashSetProtection_1
   1891              }
   1892          
   1893              *kFPROT = protectStatus;
   \                     ??FLASH_PflashSetProtection_0: (+1)
   \   0000000A   0x....             LDR.N    R0,??DataTable25_14
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x6001             STR      R1,[R0, #+0]
   1894          
   1895              if (protectStatus != *kFPROT)
   \   00000010   0x....             LDR.N    R0,??DataTable25_14
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x4281             CMP      R1,R0
   \   00000018   0xD001             BEQ.N    ??FLASH_PflashSetProtection_2
   1896              {
   1897                  return kStatus_FLASH_CommandFailure;
   \   0000001A   0x2069             MOVS     R0,#+105
   \   0000001C   0xE000             B.N      ??FLASH_PflashSetProtection_1
   1898              }
   1899          
   1900              return kStatus_FLASH_Success;
   \                     ??FLASH_PflashSetProtection_2: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \                     ??FLASH_PflashSetProtection_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
   1901          }
   1902          

   \                                 In section .text, align 2, keep-with-next
   1903          status_t FLASH_PflashGetProtection(flash_config_t *config, uint32_t *protectStatus)
   1904          {
   \                     FLASH_PflashGetProtection: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   1905              if ((config == NULL) || (protectStatus == NULL))
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD001             BEQ.N    ??FLASH_PflashGetProtection_0
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD101             BNE.N    ??FLASH_PflashGetProtection_1
   1906              {
   1907                  return kStatus_FLASH_InvalidArgument;
   \                     ??FLASH_PflashGetProtection_0: (+1)
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0xE004             B.N      ??FLASH_PflashGetProtection_2
   1908              }
   1909          
   1910              *protectStatus = *kFPROT;
   \                     ??FLASH_PflashGetProtection_1: (+1)
   \   0000000E   0x....             LDR.N    R0,??DataTable25_14
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x6008             STR      R0,[R1, #+0]
   1911          
   1912              return kStatus_FLASH_Success;
   \   00000016   0x2000             MOVS     R0,#+0
   \                     ??FLASH_PflashGetProtection_2: (+1)
   \   00000018   0x4770             BX       LR               ;; return
   1913          }
   1914          
   1915          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   1916          status_t FLASH_DflashSetProtection(flash_config_t *config, uint8_t protectStatus)
   1917          {
   1918              if (config == NULL)
   1919              {
   1920                  return kStatus_FLASH_InvalidArgument;
   1921              }
   1922          
   1923              if ((config->DFlashTotalSize == 0) || (config->DFlashTotalSize == FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED))
   1924              {
   1925                  return kStatus_FLASH_CommandNotSupported;
   1926              }
   1927          
   1928              FTFx->FDPROT = protectStatus;
   1929          
   1930              if (FTFx->FDPROT != protectStatus)
   1931              {
   1932                  return kStatus_FLASH_CommandFailure;
   1933              }
   1934          
   1935              return kStatus_FLASH_Success;
   1936          }
   1937          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   1938          
   1939          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   1940          status_t FLASH_DflashGetProtection(flash_config_t *config, uint8_t *protectStatus)
   1941          {
   1942              if ((config == NULL) || (protectStatus == NULL))
   1943              {
   1944                  return kStatus_FLASH_InvalidArgument;
   1945              }
   1946          
   1947              if ((config->DFlashTotalSize == 0) || (config->DFlashTotalSize == FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED))
   1948              {
   1949                  return kStatus_FLASH_CommandNotSupported;
   1950              }
   1951          
   1952              *protectStatus = FTFx->FDPROT;
   1953          
   1954              return kStatus_FLASH_Success;
   1955          }
   1956          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   1957          
   1958          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   1959          status_t FLASH_EepromSetProtection(flash_config_t *config, uint8_t protectStatus)
   1960          {
   1961              if (config == NULL)
   1962              {
   1963                  return kStatus_FLASH_InvalidArgument;
   1964              }
   1965          
   1966              if ((config->EEpromTotalSize == 0) || (config->EEpromTotalSize == FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_RESERVED))
   1967              {
   1968                  return kStatus_FLASH_CommandNotSupported;
   1969              }
   1970          
   1971              FTFx->FEPROT = protectStatus;
   1972          
   1973              if (FTFx->FEPROT != protectStatus)
   1974              {
   1975                  return kStatus_FLASH_CommandFailure;
   1976              }
   1977          
   1978              return kStatus_FLASH_Success;
   1979          }
   1980          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   1981          
   1982          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   1983          status_t FLASH_EepromGetProtection(flash_config_t *config, uint8_t *protectStatus)
   1984          {
   1985              if ((config == NULL) || (protectStatus == NULL))
   1986              {
   1987                  return kStatus_FLASH_InvalidArgument;
   1988              }
   1989          
   1990              if ((config->EEpromTotalSize == 0) || (config->EEpromTotalSize == FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_RESERVED))
   1991              {
   1992                  return kStatus_FLASH_CommandNotSupported;
   1993              }
   1994          
   1995              *protectStatus = FTFx->FEPROT;
   1996          
   1997              return kStatus_FLASH_Success;
   1998          }
   1999          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   2000          
   2001          #if FLASH_DRIVER_IS_FLASH_RESIDENT
   2002          /*!
   2003           * @brief Copy PIC of flash_run_command() to RAM
   2004           */

   \                                 In section .text, align 2, keep-with-next
   2005          static void copy_flash_run_command(uint32_t *flashRunCommand)
   2006          {
   \                     copy_flash_run_command: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2007              assert(sizeof(s_flashRunCommandFunctionCode) <= (kFLASH_ExecuteInRamFunctionMaxSizeInWords * 4));
   2008          
   2009              /* Since the value of ARM function pointer is always odd, but the real start address
   2010               * of function memory should be even, that's why +1 operation exist. */
   2011              memcpy((void *)flashRunCommand, (void *)s_flashRunCommandFunctionCode, sizeof(s_flashRunCommandFunctionCode));
   \   00000004   0x250C             MOVS     R5,#+12
   \   00000006   0x....             LDR.N    R6,??DataTable25_15
   \   00000008   0x002A             MOVS     R2,R5
   \   0000000A   0x0031             MOVS     R1,R6
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy
   2012              callFlashRunCommand = (void (*)(FTFx_REG_ACCESS_TYPE ftfx_fstat))((uint32_t)flashRunCommand + 1);
   \   00000012   0x1C60             ADDS     R0,R4,#+1
   \   00000014   0x....             LDR.N    R1,??DataTable25_16
   \   00000016   0x6008             STR      R0,[R1, #+0]
   2013          }
   \   00000018   0xBD70             POP      {R4-R6,PC}       ;; return
   2014          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
   2015          
   2016          /*!
   2017           * @brief Flash Command Sequence
   2018           *
   2019           * This function is used to perform the command write sequence to the flash.
   2020           *
   2021           * @param driver Pointer to storage for the driver runtime state.
   2022           * @return An error code or kStatus_FLASH_Success
   2023           */

   \                                 In section .text, align 2, keep-with-next
   2024          static status_t flash_command_sequence(flash_config_t *config)
   2025          {
   \                     flash_command_sequence: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2026              uint8_t registerValue;
   2027          
   2028          #if FLASH_DRIVER_IS_FLASH_RESIDENT
   2029              /* clear RDCOLERR & ACCERR & FPVIOL flag in flash status register */
   2030              FTFx->FSTAT = FTFx_FSTAT_RDCOLERR_MASK | FTFx_FSTAT_ACCERR_MASK | FTFx_FSTAT_FPVIOL_MASK;
   \   00000004   0x2070             MOVS     R0,#+112
   \   00000006   0x....             LDR.N    R1,??DataTable25_17  ;; 0x40020000
   \   00000008   0x7008             STRB     R0,[R1, #+0]
   2031          
   2032              status_t returnCode = flash_check_execute_in_ram_function_info(config);
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       flash_check_execute_in_ram_function_info
   \   00000010   0x0006             MOVS     R6,R0
   2033              if (kStatus_FLASH_Success != returnCode)
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD001             BEQ.N    ??flash_command_sequence_0
   2034              {
   2035                  return returnCode;
   \   00000016   0x0030             MOVS     R0,R6
   \   00000018   0xE013             B.N      ??flash_command_sequence_1
   2036              }
   2037          
   2038              /* We pass the ftfx_fstat address as a parameter to flash_run_comamnd() instead of using
   2039               * pre-processed MICRO sentences or operating global variable in flash_run_comamnd()
   2040               * to make sure that flash_run_command() will be compiled into position-independent code (PIC). */
   2041              callFlashRunCommand((FTFx_REG_ACCESS_TYPE)(&FTFx->FSTAT));
   \                     ??flash_command_sequence_0: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable25_17  ;; 0x40020000
   \   0000001C   0x....             LDR.N    R1,??DataTable25_16
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x4788             BLX      R1
   2042          #else
   2043              /* clear RDCOLERR & ACCERR & FPVIOL flag in flash status register */
   2044              FTFx->FSTAT = FTFx_FSTAT_RDCOLERR_MASK | FTFx_FSTAT_ACCERR_MASK | FTFx_FSTAT_FPVIOL_MASK;
   2045          
   2046              /* clear CCIF bit */
   2047              FTFx->FSTAT = FTFx_FSTAT_CCIF_MASK;
   2048          
   2049              /* Check CCIF bit of the flash status register, wait till it is set.
   2050               * IP team indicates that this loop will always complete. */
   2051              while (!(FTFx->FSTAT & FTFx_FSTAT_CCIF_MASK))
   2052              {
   2053              }
   2054          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
   2055          
   2056              /* Check error bits */
   2057              /* Get flash status register value */
   2058              registerValue = FTFx->FSTAT;
   \   00000022   0x....             LDR.N    R0,??DataTable25_17  ;; 0x40020000
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x0005             MOVS     R5,R0
   2059          
   2060              /* checking access error */
   2061              if (registerValue & FTFx_FSTAT_ACCERR_MASK)
   \   00000028   0x06A8             LSLS     R0,R5,#+26
   \   0000002A   0xD501             BPL.N    ??flash_command_sequence_2
   2062              {
   2063                  return kStatus_FLASH_AccessError;
   \   0000002C   0x2067             MOVS     R0,#+103
   \   0000002E   0xE008             B.N      ??flash_command_sequence_1
   2064              }
   2065              /* checking protection error */
   2066              else if (registerValue & FTFx_FSTAT_FPVIOL_MASK)
   \                     ??flash_command_sequence_2: (+1)
   \   00000030   0x06E8             LSLS     R0,R5,#+27
   \   00000032   0xD501             BPL.N    ??flash_command_sequence_3
   2067              {
   2068                  return kStatus_FLASH_ProtectionViolation;
   \   00000034   0x2068             MOVS     R0,#+104
   \   00000036   0xE004             B.N      ??flash_command_sequence_1
   2069              }
   2070              /* checking MGSTAT0 non-correctable error */
   2071              else if (registerValue & FTFx_FSTAT_MGSTAT0_MASK)
   \                     ??flash_command_sequence_3: (+1)
   \   00000038   0x07E8             LSLS     R0,R5,#+31
   \   0000003A   0xD501             BPL.N    ??flash_command_sequence_4
   2072              {
   2073                  return kStatus_FLASH_CommandFailure;
   \   0000003C   0x2069             MOVS     R0,#+105
   \   0000003E   0xE000             B.N      ??flash_command_sequence_1
   2074              }
   2075              else
   2076              {
   2077                  return kStatus_FLASH_Success;
   \                     ??flash_command_sequence_4: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??flash_command_sequence_1: (+1)
   \   00000042   0xBD70             POP      {R4-R6,PC}       ;; return
   2078              }
   2079          }
   2080          
   2081          #if FLASH_DRIVER_IS_FLASH_RESIDENT
   2082          /*!
   2083           * @brief Copy PIC of flash_cache_clear_command() to RAM
   2084           *
   2085           */

   \                                 In section .text, align 2, keep-with-next
   2086          static void copy_flash_cache_clear_command(uint32_t *flashCacheClearCommand)
   2087          {
   \                     copy_flash_cache_clear_command: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2088              assert(sizeof(s_flashCacheClearCommandFunctionCode) <= (kFLASH_ExecuteInRamFunctionMaxSizeInWords * 4));
   2089          
   2090              /* Since the value of ARM function pointer is always odd, but the real start address
   2091               * of function memory should be even, that's why +1 operation exist. */
   2092              memcpy((void *)flashCacheClearCommand, (void *)s_flashCacheClearCommandFunctionCode,
   2093                     sizeof(s_flashCacheClearCommandFunctionCode));
   \   00000004   0x2514             MOVS     R5,#+20
   \   00000006   0x....             LDR.N    R6,??DataTable25_18
   \   00000008   0x002A             MOVS     R2,R5
   \   0000000A   0x0031             MOVS     R1,R6
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy
   2094              callFlashCacheClearCommand = (void (*)(FTFx_REG32_ACCESS_TYPE ftfx_reg))((uint32_t)flashCacheClearCommand + 1);
   \   00000012   0x1C60             ADDS     R0,R4,#+1
   \   00000014   0x....             LDR.N    R1,??DataTable25_19
   \   00000016   0x6008             STR      R0,[R1, #+0]
   2095          }
   \   00000018   0xBD70             POP      {R4-R6,PC}       ;; return
   2096          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
   2097          
   2098          /*!
   2099           * @brief Flash Cache Clear
   2100           *
   2101           * This function is used to perform the cache clear to the flash.
   2102           */
   2103          #if (defined(__GNUC__))
   2104          /* #pragma GCC push_options */
   2105          /* #pragma GCC optimize("O0") */
   2106          void __attribute__((optimize("O0"))) flash_cache_clear(flash_config_t *config)
   2107          #else
   2108          #if (defined(__ICCARM__))
   2109          #pragma optimize = none
   2110          #endif
   2111          #if (defined(__CC_ARM))
   2112          #pragma push
   2113          #pragma O0
   2114          #endif

   \                                 In section .text, align 2, keep-with-next
   2115          void flash_cache_clear(flash_config_t *config)
   2116          #endif
   2117          {
   \                     flash_cache_clear: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2118          #if FLASH_DRIVER_IS_FLASH_RESIDENT
   2119              status_t returnCode = flash_check_execute_in_ram_function_info(config);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       flash_check_execute_in_ram_function_info
   \   0000000A   0x0005             MOVS     R5,R0
   2120              if (kStatus_FLASH_Success != returnCode)
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xD103             BNE.N    ??flash_cache_clear_0
   2121              {
   2122                  return;
   2123              }
   2124          
   2125          /* We pass the ftfx register address as a parameter to flash_cache_clear_comamnd() instead of using
   2126           * pre-processed MACROs or a global variable in flash_cache_clear_comamnd()
   2127           * to make sure that flash_cache_clear_command() will be compiled into position-independent code (PIC). */
   2128          #if defined(FSL_FEATURE_FLASH_HAS_MCM_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_MCM_FLASH_CACHE_CONTROLS
   2129          #if defined(MCM)
   2130              callFlashCacheClearCommand((FTFx_REG32_ACCESS_TYPE)&MCM->PLACR);
   2131          #endif
   2132          #if defined(MCM0)
   2133              callFlashCacheClearCommand((FTFx_REG32_ACCESS_TYPE)&MCM0->PLACR);
   2134          #endif
   2135          #if defined(MCM1)
   2136              callFlashCacheClearCommand((FTFx_REG32_ACCESS_TYPE)&MCM1->PLACR);
   2137          #endif
   2138          #elif defined(FSL_FEATURE_FLASH_HAS_FMC_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_FMC_FLASH_CACHE_CONTROLS
   2139          #if defined(FMC_PFB01CR_CINV_WAY_MASK)
   2140              callFlashCacheClearCommand((FTFx_REG32_ACCESS_TYPE)&FMC->PFB01CR);
   2141          #else
   2142              callFlashCacheClearCommand((FTFx_REG32_ACCESS_TYPE)&FMC->PFB0CR);
   \                     ??flash_cache_clear_1: (+1)
   \   00000010   0x....             LDR.N    R0,??DataTable25_20  ;; 0x4001f004
   \   00000012   0x....             LDR.N    R1,??DataTable25_19
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x4788             BLX      R1
   2143          #endif
   2144          #elif defined(FSL_FEATURE_FLASH_HAS_MSCM_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_MSCM_FLASH_CACHE_CONTROLS
   2145              callFlashCacheClearCommand((FTFx_REG32_ACCESS_TYPE)&MSCM->OCMDR[0]);
   2146          #else
   2147          #if defined(FMC_PFB0CR_S_INV_MASK)
   2148              callFlashCacheClearCommand((FTFx_REG32_ACCESS_TYPE)&FMC->PFB0CR);
   2149          #elif defined(FMC_PFB01CR_S_INV_MASK)
   2150              callFlashCacheClearCommand((FTFx_REG32_ACCESS_TYPE)&FMC->PFB01CR);
   2151          #else
   2152              /* meaningless code, just a workaround to solve warning*/
   2153              callFlashCacheClearCommand((FTFx_REG32_ACCESS_TYPE)0);
   2154          #endif
   2155          /* #error "Unknown flash cache controller" */
   2156          #endif /* FSL_FEATURE_FTFx_MCM_FLASH_CACHE_CONTROLS */
   2157          
   2158          #else
   2159          
   2160          #if defined(FSL_FEATURE_FLASH_HAS_MCM_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_MCM_FLASH_CACHE_CONTROLS
   2161          #if defined(MCM)
   2162              MCM->PLACR |= MCM_PLACR_CFCC_MASK;
   2163          #endif
   2164          #if defined(MCM0)
   2165              MCM0->PLACR |= MCM_PLACR_CFCC_MASK;
   2166          #endif
   2167          #if defined(MCM1)
   2168              MCM1->PLACR |= MCM_PLACR_CFCC_MASK;
   2169          #endif
   2170          #elif defined(FSL_FEATURE_FLASH_HAS_FMC_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_FMC_FLASH_CACHE_CONTROLS
   2171          #if defined(FMC_PFB01CR_CINV_WAY_MASK)
   2172              FMC->PFB01CR = (FMC->PFB01CR & ~FMC_PFB01CR_CINV_WAY_MASK) | FMC_PFB01CR_CINV_WAY(~0);
   2173          #else
   2174              FMC->PFB0CR = (FMC->PFB0CR & ~FMC_PFB0CR_CINV_WAY_MASK) | FMC_PFB0CR_CINV_WAY(~0);
   2175          #endif
   2176          #elif defined(FSL_FEATURE_FLASH_HAS_MSCM_FLASH_CACHE_CONTROLS) && FSL_FEATURE_FLASH_HAS_MSCM_FLASH_CACHE_CONTROLS
   2177              MSCM->OCMDR[0] |= MSCM_OCMDR_OCMC1(2);
   2178              MSCM->OCMDR[0] |= MSCM_OCMDR_OCMC1(1);
   2179          #else
   2180          #if defined(FMC_PFB0CR_S_INV_MASK)
   2181              FMC->PFB0CR |= FMC_PFB0CR_S_INV_MASK;
   2182          #elif defined(FMC_PFB01CR_S_INV_MASK)
   2183              FMC->PFB01CR |= FMC_PFB01CR_S_INV_MASK;
   2184          #endif
   2185          /*    #error "Unknown flash cache controller" */
   2186          #endif /* FSL_FEATURE_FTFx_MCM_FLASH_CACHE_CONTROLS */
   2187          
   2188              /* Memory barriers for good measure.
   2189               * All Cache, Branch predictor and TLB maintenance operations before this instruction complete */
   2190              __ISB();
   2191              __DSB();
   2192          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
   2193          }
   \                     ??flash_cache_clear_0: (+1)
   \   00000018   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2194          #if (defined(__CC_ARM))
   2195          #pragma pop
   2196          #endif
   2197          #if (defined(__GNUC__))
   2198          /* #pragma GCC pop_options */
   2199          #endif
   2200          
   2201          #if FLASH_DRIVER_IS_FLASH_RESIDENT
   2202          /*! @brief Check whether flash execute-in-ram functions are ready  */

   \                                 In section .text, align 2, keep-with-next
   2203          static status_t flash_check_execute_in_ram_function_info(flash_config_t *config)
   2204          {
   \                     flash_check_execute_in_ram_function_info: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   2205              flash_execute_in_ram_function_config_t *flashExecuteInRamFunctionInfo;
   2206          
   2207              if (config == NULL)
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD101             BNE.N    ??flash_check_execute_in_ram_function_info_0
   2208              {
   2209                  return kStatus_FLASH_InvalidArgument;
   \   00000006   0x2004             MOVS     R0,#+4
   \   00000008   0xE00A             B.N      ??flash_check_execute_in_ram_function_info_1
   2210              }
   2211          
   2212              flashExecuteInRamFunctionInfo = (flash_execute_in_ram_function_config_t *)config->flashExecuteInRamFunctionInfo;
   \                     ??flash_check_execute_in_ram_function_info_0: (+1)
   \   0000000A   0x69C8             LDR      R0,[R1, #+28]
   \   0000000C   0x0002             MOVS     R2,R0
   2213          
   2214              if ((config->flashExecuteInRamFunctionInfo) &&
   2215                  (kFLASH_ExecuteInRamFunctionTotalNum == flashExecuteInRamFunctionInfo->activeFunctionCount))
   \   0000000E   0x69C8             LDR      R0,[R1, #+28]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD004             BEQ.N    ??flash_check_execute_in_ram_function_info_2
   \   00000014   0x6810             LDR      R0,[R2, #+0]
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD101             BNE.N    ??flash_check_execute_in_ram_function_info_2
   2216              {
   2217                  return kStatus_FLASH_Success;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE000             B.N      ??flash_check_execute_in_ram_function_info_1
   2218              }
   2219          
   2220              return kStatus_FLASH_ExecuteInRamFunctionNotReady;
   \                     ??flash_check_execute_in_ram_function_info_2: (+1)
   \   0000001E   0x206D             MOVS     R0,#+109
   \                     ??flash_check_execute_in_ram_function_info_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
   2221          }
   2222          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
   2223          
   2224          /*! @brief Validates the range and alignment of the given address range.*/

   \                                 In section .text, align 2, keep-with-next
   2225          static status_t flash_check_range(flash_config_t *config,
   2226                                            uint32_t startAddress,
   2227                                            uint32_t lengthInBytes,
   2228                                            uint32_t alignmentBaseline)
   2229          {
   \                     flash_check_range: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0004             MOVS     R4,R0
   2230              if (config == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??flash_check_range_0
   2231              {
   2232                  return kStatus_FLASH_InvalidArgument;
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0xE013             B.N      ??flash_check_range_1
   2233              }
   2234          
   2235              /* Verify the start and length are alignmentBaseline aligned. */
   2236              if ((startAddress & (alignmentBaseline - 1)) || (lengthInBytes & (alignmentBaseline - 1)))
   \                     ??flash_check_range_0: (+1)
   \   0000000C   0x1E58             SUBS     R0,R3,#+1
   \   0000000E   0x4201             TST      R1,R0
   \   00000010   0xD102             BNE.N    ??flash_check_range_2
   \   00000012   0x1E58             SUBS     R0,R3,#+1
   \   00000014   0x4202             TST      R2,R0
   \   00000016   0xD001             BEQ.N    ??flash_check_range_3
   2237              {
   2238                  return kStatus_FLASH_AlignmentError;
   \                     ??flash_check_range_2: (+1)
   \   00000018   0x2065             MOVS     R0,#+101
   \   0000001A   0xE00B             B.N      ??flash_check_range_1
   2239              }
   2240          
   2241          /* check for valid range of the target addresses */
   2242          #if !FLASH_SSD_IS_FLEXNVM_ENABLED
   2243              if ((startAddress < config->PFlashBlockBase) ||
   2244                  ((startAddress + lengthInBytes) > (config->PFlashBlockBase + config->PFlashTotalSize)))
   \                     ??flash_check_range_3: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x4281             CMP      R1,R0
   \   00000020   0xD305             BCC.N    ??flash_check_range_4
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6865             LDR      R5,[R4, #+4]
   \   00000026   0x1828             ADDS     R0,R5,R0
   \   00000028   0x1855             ADDS     R5,R2,R1
   \   0000002A   0x42A8             CMP      R0,R5
   \   0000002C   0xD201             BCS.N    ??flash_check_range_5
   2245          #else
   2246              if (!(((startAddress >= config->PFlashBlockBase) &&
   2247                     ((startAddress + lengthInBytes) <= (config->PFlashBlockBase + config->PFlashTotalSize))) ||
   2248                    ((startAddress >= config->DFlashBlockBase) &&
   2249                     ((startAddress + lengthInBytes) <= (config->DFlashBlockBase + config->DFlashTotalSize)))))
   2250          #endif
   2251              {
   2252                  return kStatus_FLASH_AddressError;
   \                     ??flash_check_range_4: (+1)
   \   0000002E   0x2066             MOVS     R0,#+102
   \   00000030   0xE000             B.N      ??flash_check_range_1
   2253              }
   2254          
   2255              return kStatus_FLASH_Success;
   \                     ??flash_check_range_5: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??flash_check_range_1: (+1)
   \   00000034   0xBC30             POP      {R4,R5}
   \   00000036   0x4770             BX       LR               ;; return
   2256          }
   2257          
   2258          /*! @brief Gets the right address, sector and block size of current flash type which is indicated by address.*/

   \                                 In section .text, align 2, keep-with-next
   2259          static status_t flash_get_matched_operation_info(flash_config_t *config,
   2260                                                           uint32_t address,
   2261                                                           flash_operation_config_t *info)
   2262          {
   \                     flash_get_matched_operation_info: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   2263              if (config == NULL)
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD101             BNE.N    ??flash_get_matched_operation_info_0
   2264              {
   2265                  return kStatus_FLASH_InvalidArgument;
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0xE01C             B.N      ??flash_get_matched_operation_info_1
   2266              }
   2267          
   2268              /* Clean up info Structure*/
   2269              memset(info, 0, sizeof(flash_operation_config_t));
   \                     ??flash_get_matched_operation_info_0: (+1)
   \   00000012   0x2720             MOVS     R7,#+32
   \   00000014   0xF05F 0x0800      MOVS     R8,#+0
   \   00000018   0x4642             MOV      R2,R8
   \   0000001A   0x0039             MOVS     R1,R7
   \   0000001C   0x0030             MOVS     R0,R6
   \   0000001E   0x.... 0x....      BL       __aeabi_memset
   2270          
   2271          /* When required by the command, address bit 23 selects between program flash memory
   2272           * (=0) and data flash memory (=1).*/
   2273          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   2274              if ((address >= config->DFlashBlockBase) && (address <= (config->DFlashBlockBase + config->DFlashTotalSize)))
   2275              {
   2276                  info->convertedAddress = address - config->DFlashBlockBase + 0x800000U;
   2277                  info->activeSectorSize = FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_SECTOR_SIZE;
   2278                  info->activeBlockSize = config->DFlashTotalSize / FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_COUNT;
   2279          
   2280                  info->blockWriteUnitSize = FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_WRITE_UNIT_SIZE;
   2281                  info->sectorCmdAddressAligment = FSL_FEATURE_FLASH_FLEX_NVM_SECTOR_CMD_ADDRESS_ALIGMENT;
   2282                  info->sectionCmdAddressAligment = FSL_FEATURE_FLASH_FLEX_NVM_SECTION_CMD_ADDRESS_ALIGMENT;
   2283                  info->resourceCmdAddressAligment = FSL_FEATURE_FLASH_FLEX_NVM_RESOURCE_CMD_ADDRESS_ALIGMENT;
   2284                  info->checkCmdAddressAligment = FSL_FEATURE_FLASH_FLEX_NVM_CHECK_CMD_ADDRESS_ALIGMENT;
   2285              }
   2286              else
   2287          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   2288              {
   2289                  info->convertedAddress = address - config->PFlashBlockBase;
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x1A28             SUBS     R0,R5,R0
   \   00000026   0x6030             STR      R0,[R6, #+0]
   2290                  info->activeSectorSize = config->PFlashSectorSize;
   \   00000028   0x68E0             LDR      R0,[R4, #+12]
   \   0000002A   0x6070             STR      R0,[R6, #+4]
   2291                  info->activeBlockSize = config->PFlashTotalSize / config->PFlashBlockCount;
   \   0000002C   0x6860             LDR      R0,[R4, #+4]
   \   0000002E   0x68A1             LDR      R1,[R4, #+8]
   \   00000030   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000034   0x60B0             STR      R0,[R6, #+8]
   2292          
   2293                  info->blockWriteUnitSize = FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE;
   \   00000036   0x2008             MOVS     R0,#+8
   \   00000038   0x60F0             STR      R0,[R6, #+12]
   2294                  info->sectorCmdAddressAligment = FSL_FEATURE_FLASH_PFLASH_SECTOR_CMD_ADDRESS_ALIGMENT;
   \   0000003A   0x2010             MOVS     R0,#+16
   \   0000003C   0x6130             STR      R0,[R6, #+16]
   2295                  info->sectionCmdAddressAligment = FSL_FEATURE_FLASH_PFLASH_SECTION_CMD_ADDRESS_ALIGMENT;
   \   0000003E   0x2010             MOVS     R0,#+16
   \   00000040   0x6170             STR      R0,[R6, #+20]
   2296                  info->resourceCmdAddressAligment = FSL_FEATURE_FLASH_PFLASH_RESOURCE_CMD_ADDRESS_ALIGMENT;
   \   00000042   0x2008             MOVS     R0,#+8
   \   00000044   0x61B0             STR      R0,[R6, #+24]
   2297                  info->checkCmdAddressAligment = FSL_FEATURE_FLASH_PFLASH_CHECK_CMD_ADDRESS_ALIGMENT;
   \   00000046   0x2004             MOVS     R0,#+4
   \   00000048   0x61F0             STR      R0,[R6, #+28]
   2298              }
   2299          
   2300              return kStatus_FLASH_Success;
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??flash_get_matched_operation_info_1: (+1)
   \   0000004C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2301          }
   2302          
   2303          /*! @brief Validates the given user key for flash erase APIs.*/

   \                                 In section .text, align 2, keep-with-next
   2304          static status_t flash_check_user_key(uint32_t key)
   2305          {
   \                     flash_check_user_key: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   2306              /* Validate the user key */
   2307              if (key != kFLASH_ApiEraseKey)
   \   00000002   0x....             LDR.N    R0,??DataTable25_13  ;; 0x6b65666b
   \   00000004   0x4281             CMP      R1,R0
   \   00000006   0xD001             BEQ.N    ??flash_check_user_key_0
   2308              {
   2309                  return kStatus_FLASH_EraseKeyError;
   \   00000008   0x206B             MOVS     R0,#+107
   \   0000000A   0xE000             B.N      ??flash_check_user_key_1
   2310              }
   2311          
   2312              return kStatus_FLASH_Success;
   \                     ??flash_check_user_key_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \                     ??flash_check_user_key_1: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
   2313          }
   2314          
   2315          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   2316          /*! @brief Updates FlexNVM memory partition status according to data flash 0 IFR.*/
   2317          static status_t flash_update_flexnvm_memory_partition_status(flash_config_t *config)
   2318          {
   2319              struct
   2320              {
   2321                  uint32_t reserved0;
   2322                  uint8_t FlexNVMPartitionCode;
   2323                  uint8_t EEPROMDataSetSize;
   2324                  uint16_t reserved1;
   2325              } dataIFRReadOut;
   2326              status_t returnCode;
   2327          
   2328              if (config == NULL)
   2329              {
   2330                  return kStatus_FLASH_InvalidArgument;
   2331              }
   2332          
   2333              /* Get FlexNVM memory partition info from data flash IFR */
   2334              returnCode = FLASH_ReadResource(config, DFLASH_IFR_READRESOURCE_START_ADDRESS, (uint32_t *)&dataIFRReadOut,
   2335                                              sizeof(dataIFRReadOut), kFLASH_ResourceOptionFlashIfr);
   2336              if (returnCode != kStatus_FLASH_Success)
   2337              {
   2338                  return kStatus_FLASH_PartitionStatusUpdateFailure;
   2339              }
   2340          
   2341              /* Fill out partitioned EEPROM size */
   2342              dataIFRReadOut.EEPROMDataSetSize &= 0x0FU;
   2343              switch (dataIFRReadOut.EEPROMDataSetSize)
   2344              {
   2345                  case 0x00U:
   2346                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0000;
   2347                      break;
   2348                  case 0x01U:
   2349                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0001;
   2350                      break;
   2351                  case 0x02U:
   2352                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0010;
   2353                      break;
   2354                  case 0x03U:
   2355                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0011;
   2356                      break;
   2357                  case 0x04U:
   2358                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0100;
   2359                      break;
   2360                  case 0x05U:
   2361                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0101;
   2362                      break;
   2363                  case 0x06U:
   2364                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0110;
   2365                      break;
   2366                  case 0x07U:
   2367                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0111;
   2368                      break;
   2369                  case 0x08U:
   2370                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1000;
   2371                      break;
   2372                  case 0x09U:
   2373                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1001;
   2374                      break;
   2375                  case 0x0AU:
   2376                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1010;
   2377                      break;
   2378                  case 0x0BU:
   2379                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1011;
   2380                      break;
   2381                  case 0x0CU:
   2382                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1100;
   2383                      break;
   2384                  case 0x0DU:
   2385                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1101;
   2386                      break;
   2387                  case 0x0EU:
   2388                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1110;
   2389                      break;
   2390                  case 0x0FU:
   2391                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1111;
   2392                      break;
   2393                  default:
   2394                      config->EEpromTotalSize = FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_RESERVED;
   2395                      break;
   2396              }
   2397          
   2398              /* Fill out partitioned DFlash size */
   2399              dataIFRReadOut.FlexNVMPartitionCode &= 0x0FU;
   2400              switch (dataIFRReadOut.FlexNVMPartitionCode)
   2401              {
   2402                  case 0x00U:
   2403          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0000 != 0xFFFFFFFF)
   2404                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0000;
   2405          #else
   2406                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2407          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0000 */
   2408                      break;
   2409                  case 0x01U:
   2410          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0001 != 0xFFFFFFFF)
   2411                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0001;
   2412          #else
   2413                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2414          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0001 */
   2415                      break;
   2416                  case 0x02U:
   2417          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0010 != 0xFFFFFFFF)
   2418                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0010;
   2419          #else
   2420                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2421          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0010 */
   2422                      break;
   2423                  case 0x03U:
   2424          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0011 != 0xFFFFFFFF)
   2425                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0011;
   2426          #else
   2427                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2428          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0011 */
   2429                      break;
   2430                  case 0x04U:
   2431          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0100 != 0xFFFFFFFF)
   2432                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0100;
   2433          #else
   2434                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2435          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0100 */
   2436                      break;
   2437                  case 0x05U:
   2438          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0101 != 0xFFFFFFFF)
   2439                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0101;
   2440          #else
   2441                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2442          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0101 */
   2443                      break;
   2444                  case 0x06U:
   2445          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0110 != 0xFFFFFFFF)
   2446                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0110;
   2447          #else
   2448                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2449          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0110 */
   2450                      break;
   2451                  case 0x07U:
   2452          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0111 != 0xFFFFFFFF)
   2453                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0111;
   2454          #else
   2455                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2456          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0111 */
   2457                      break;
   2458                  case 0x08U:
   2459          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1000 != 0xFFFFFFFF)
   2460                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1000;
   2461          #else
   2462                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2463          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1000 */
   2464                      break;
   2465                  case 0x09U:
   2466          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1001 != 0xFFFFFFFF)
   2467                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1001;
   2468          #else
   2469                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2470          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1001 */
   2471                      break;
   2472                  case 0x0AU:
   2473          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1010 != 0xFFFFFFFF)
   2474                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1010;
   2475          #else
   2476                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2477          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1010 */
   2478                      break;
   2479                  case 0x0BU:
   2480          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1011 != 0xFFFFFFFF)
   2481                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1011;
   2482          #else
   2483                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2484          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1011 */
   2485                      break;
   2486                  case 0x0CU:
   2487          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1100 != 0xFFFFFFFF)
   2488                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1100;
   2489          #else
   2490                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2491          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1100 */
   2492                      break;
   2493                  case 0x0DU:
   2494          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1101 != 0xFFFFFFFF)
   2495                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1101;
   2496          #else
   2497                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2498          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1101 */
   2499                      break;
   2500                  case 0x0EU:
   2501          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1110 != 0xFFFFFFFF)
   2502                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1110;
   2503          #else
   2504                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2505          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1110 */
   2506                      break;
   2507                  case 0x0FU:
   2508          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1111 != 0xFFFFFFFF)
   2509                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1111;
   2510          #else
   2511                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2512          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1111 */
   2513                      break;
   2514                  default:
   2515                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2516                      break;
   2517              }
   2518          
   2519              return kStatus_FLASH_Success;
   2520          }
   2521          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   2522          
   2523          #if defined(FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD) && FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD
   2524          /*! @brief Validates the range of the given resource address.*/

   \                                 In section .text, align 2, keep-with-next
   2525          static status_t flash_check_resource_range(uint32_t start,
   2526                                                     uint32_t lengthInBytes,
   2527                                                     uint32_t alignmentBaseline,
   2528                                                     flash_read_resource_option_t option)
   2529          {
   \                     flash_check_resource_range: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0004             MOVS     R4,R0
   2530              status_t status;
   2531              uint32_t maxReadbleAddress;
   2532          
   2533              if ((start & (alignmentBaseline - 1)) || (lengthInBytes & (alignmentBaseline - 1)))
   \   00000004   0x1E50             SUBS     R0,R2,#+1
   \   00000006   0x4204             TST      R4,R0
   \   00000008   0xD102             BNE.N    ??flash_check_resource_range_0
   \   0000000A   0x1E50             SUBS     R0,R2,#+1
   \   0000000C   0x4201             TST      R1,R0
   \   0000000E   0xD001             BEQ.N    ??flash_check_resource_range_1
   2534              {
   2535                  return kStatus_FLASH_AlignmentError;
   \                     ??flash_check_resource_range_0: (+1)
   \   00000010   0x2065             MOVS     R0,#+101
   \   00000012   0xE028             B.N      ??flash_check_resource_range_2
   2536              }
   2537          
   2538              status = kStatus_FLASH_Success;
   \                     ??flash_check_resource_range_1: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0005             MOVS     R5,R0
   2539          
   2540              maxReadbleAddress = start + lengthInBytes - 1;
   \   00000018   0x1908             ADDS     R0,R1,R4
   \   0000001A   0x1E40             SUBS     R0,R0,#+1
   \   0000001C   0x0006             MOVS     R6,R0
   2541              if (option == kFLASH_ResourceOptionVersionId)
   \   0000001E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000020   0x2B01             CMP      R3,#+1
   \   00000022   0xD108             BNE.N    ??flash_check_resource_range_3
   2542              {
   2543                  if ((start != kFLASH_ResourceRangeVersionIdStart) ||
   2544                      ((start + lengthInBytes - 1) != kFLASH_ResourceRangeVersionIdEnd))
   \   00000024   0x2C08             CMP      R4,#+8
   \   00000026   0xD103             BNE.N    ??flash_check_resource_range_4
   \   00000028   0x1908             ADDS     R0,R1,R4
   \   0000002A   0x1E40             SUBS     R0,R0,#+1
   \   0000002C   0x280F             CMP      R0,#+15
   \   0000002E   0xD019             BEQ.N    ??flash_check_resource_range_5
   2545                  {
   2546                      status = kStatus_FLASH_InvalidArgument;
   \                     ??flash_check_resource_range_4: (+1)
   \   00000030   0x2004             MOVS     R0,#+4
   \   00000032   0x0005             MOVS     R5,R0
   \   00000034   0xE016             B.N      ??flash_check_resource_range_5
   2547                  }
   2548              }
   2549              else if (option == kFLASH_ResourceOptionFlashIfr)
   \                     ??flash_check_resource_range_3: (+1)
   \   00000036   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000038   0x2B00             CMP      R3,#+0
   \   0000003A   0xD111             BNE.N    ??flash_check_resource_range_6
   2550              {
   2551                  if (maxReadbleAddress < kFLASH_ResourceRangePflashIfrSizeInBytes)
   \   0000003C   0xF5B6 0x6F80      CMP      R6,#+1024
   \   00000040   0xD310             BCC.N    ??flash_check_resource_range_5
   2552                  {
   2553                  }
   2554          #if defined(FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP) && FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP
   2555                  else if ((start >= kFLASH_ResourceRangePflashSwapIfrStart) &&
   2556                           (maxReadbleAddress <= kFLASH_ResourceRangePflashSwapIfrEnd))
   \   00000042   0xF5B4 0x2F80      CMP      R4,#+262144
   \   00000046   0xD302             BCC.N    ??flash_check_resource_range_7
   \   00000048   0x....             LDR.N    R0,??DataTable25_21  ;; 0x40400
   \   0000004A   0x4286             CMP      R6,R0
   \   0000004C   0xD30A             BCC.N    ??flash_check_resource_range_5
   2557                  {
   2558                  }
   2559          #endif /* FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP */
   2560                  else if ((start >= kFLASH_ResourceRangeDflashIfrStart) &&
   2561                           (maxReadbleAddress <= kFLASH_ResourceRangeDflashIfrEnd))
   \                     ??flash_check_resource_range_7: (+1)
   \   0000004E   0xF5B4 0x0F00      CMP      R4,#+8388608
   \   00000052   0xD302             BCC.N    ??flash_check_resource_range_8
   \   00000054   0x....             LDR.N    R0,??DataTable25_22  ;; 0x800400
   \   00000056   0x4286             CMP      R6,R0
   \   00000058   0xD304             BCC.N    ??flash_check_resource_range_5
   2562                  {
   2563                  }
   2564                  else
   2565                  {
   2566                      status = kStatus_FLASH_InvalidArgument;
   \                     ??flash_check_resource_range_8: (+1)
   \   0000005A   0x2004             MOVS     R0,#+4
   \   0000005C   0x0005             MOVS     R5,R0
   \   0000005E   0xE001             B.N      ??flash_check_resource_range_5
   2567                  }
   2568              }
   2569              else
   2570              {
   2571                  status = kStatus_FLASH_InvalidArgument;
   \                     ??flash_check_resource_range_6: (+1)
   \   00000060   0x2004             MOVS     R0,#+4
   \   00000062   0x0005             MOVS     R5,R0
   2572              }
   2573          
   2574              return status;
   \                     ??flash_check_resource_range_5: (+1)
   \   00000064   0x0028             MOVS     R0,R5
   \                     ??flash_check_resource_range_2: (+1)
   \   00000066   0xBC70             POP      {R4-R6}
   \   00000068   0x4770             BX       LR               ;; return
   2575          }
   2576          #endif /* FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD */
   2577          
   2578          #if defined(FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD) && FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD
   2579          /*! @brief Validates the gived swap control option.*/

   \                                 In section .text, align 2, keep-with-next
   2580          static status_t flash_check_swap_control_option(flash_swap_control_option_t option)
   2581          {
   \                     flash_check_swap_control_option: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   2582              if ((option == kFLASH_SwapControlOptionIntializeSystem) || (option == kFLASH_SwapControlOptionSetInUpdateState) ||
   2583                  (option == kFLASH_SwapControlOptionSetInCompleteState) || (option == kFLASH_SwapControlOptionReportStatus) ||
   2584                  (option == kFLASH_SwapControlOptionDisableSystem))
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD00B             BEQ.N    ??flash_check_swap_control_option_0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x2902             CMP      R1,#+2
   \   0000000C   0xD008             BEQ.N    ??flash_check_swap_control_option_0
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x2904             CMP      R1,#+4
   \   00000012   0xD005             BEQ.N    ??flash_check_swap_control_option_0
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x2908             CMP      R1,#+8
   \   00000018   0xD002             BEQ.N    ??flash_check_swap_control_option_0
   \   0000001A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   0x2910             CMP      R1,#+16
   \   0000001E   0xD101             BNE.N    ??flash_check_swap_control_option_1
   2585              {
   2586                  return kStatus_FLASH_Success;
   \                     ??flash_check_swap_control_option_0: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE000             B.N      ??flash_check_swap_control_option_2
   2587              }
   2588          
   2589              return kStatus_FLASH_InvalidArgument;
   \                     ??flash_check_swap_control_option_1: (+1)
   \   00000024   0x2004             MOVS     R0,#+4
   \                     ??flash_check_swap_control_option_2: (+1)
   \   00000026   0x4770             BX       LR               ;; return
   2590          }
   2591          #endif /* FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD */
   2592          
   2593          #if defined(FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP) && FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP
   2594          /*! @brief Validates the gived address to see if it is equal to swap indicator address in pflash swap IFR.*/

   \                                 In section .text, align 2, keep-with-next
   2595          static status_t flash_validate_swap_indicator_address(flash_config_t *config, uint32_t address)
   2596          {
   \                     flash_validate_swap_indicator_address: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   2597              flash_swap_ifr_field_data_t flashSwapIfrFieldData;
   2598              uint32_t swapIndicatorAddress;
   2599          
   2600              status_t returnCode;
   2601              returnCode =
   2602                  FLASH_ReadResource(config, kFLASH_ResourceRangePflashSwapIfrStart, flashSwapIfrFieldData.flashSwapIfrData,
   2603                                     sizeof(flashSwapIfrFieldData.flashSwapIfrData), kFLASH_ResourceOptionFlashIfr);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0x2308             MOVS     R3,#+8
   \   0000000E   0xAA01             ADD      R2,SP,#+4
   \   00000010   0xF45F 0x2180      MOVS     R1,#+262144
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       FLASH_ReadResource
   \   0000001A   0x0007             MOVS     R7,R0
   2604          
   2605              if (returnCode != kStatus_FLASH_Success)
   \   0000001C   0x2F00             CMP      R7,#+0
   \   0000001E   0xD001             BEQ.N    ??flash_validate_swap_indicator_address_0
   2606              {
   2607                  return returnCode;
   \   00000020   0x0038             MOVS     R0,R7
   \   00000022   0xE008             B.N      ??flash_validate_swap_indicator_address_1
   2608              }
   2609          
   2610              /* The high bits value of Swap Indicator Address is stored in Program Flash Swap IFR Field,
   2611               * the low severval bit value of Swap Indicator Address is always 1'b0 */
   2612              swapIndicatorAddress = (uint32_t)flashSwapIfrFieldData.flashSwapIfrField.swapIndicatorAddress *
   2613                                     FSL_FEATURE_FLASH_PFLASH_SWAP_CONTROL_CMD_ADDRESS_ALIGMENT;
   \                     ??flash_validate_swap_indicator_address_0: (+1)
   \   00000024   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   00000028   0x0100             LSLS     R0,R0,#+4
   \   0000002A   0x0006             MOVS     R6,R0
   2614              if (address != swapIndicatorAddress)
   \   0000002C   0x42B5             CMP      R5,R6
   \   0000002E   0xD001             BEQ.N    ??flash_validate_swap_indicator_address_2
   2615              {
   2616                  return kStatus_FLASH_SwapIndicatorAddressError;
   \   00000030   0x2075             MOVS     R0,#+117
   \   00000032   0xE000             B.N      ??flash_validate_swap_indicator_address_1
   2617              }
   2618          
   2619              return returnCode;
   \                     ??flash_validate_swap_indicator_address_2: (+1)
   \   00000034   0x0038             MOVS     R0,R7
   \                     ??flash_validate_swap_indicator_address_1: (+1)
   \   00000036   0xB005             ADD      SP,SP,#+20
   \   00000038   0xBDF0             POP      {R4-R7,PC}       ;; return
   2620          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x4004804C         DC32     0x4004804c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x........         DC32     kPFlashDensities

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x........         DC32     kFCCOBx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \   00000000   0x4300FFFF         DC32     0x4300ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \   00000000   0x4100FFFF         DC32     0x4100ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_3:
   \   00000000   0x40020002         DC32     0x40020002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_4:
   \   00000000   0x4000FFFF         DC32     0x4000ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_5:
   \   00000000   0x4A00FFFF         DC32     0x4a00ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_6:
   \   00000000   0x40020010         DC32     0x40020010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_7:
   \   00000000   0x40020011         DC32     0x40020011

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_8:
   \   00000000   0x40020012         DC32     0x40020012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_9:
   \   00000000   0x40020013         DC32     0x40020013

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_10:
   \   00000000   0x4002000A         DC32     0x4002000a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_11:
   \   00000000   0x40020009         DC32     0x40020009

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_12:
   \   00000000   0x40020008         DC32     0x40020008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_13:
   \   00000000   0x6B65666B         DC32     0x6b65666b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_14:
   \   00000000   0x........         DC32     kFPROT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_15:
   \   00000000   0x........         DC32     s_flashRunCommandFunctionCode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_16:
   \   00000000   0x........         DC32     callFlashRunCommand

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_17:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_18:
   \   00000000   0x........         DC32     s_flashCacheClearCommandFunctionCode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_19:
   \   00000000   0x........         DC32     callFlashCacheClearCommand

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_20:
   \   00000000   0x4001F004         DC32     0x4001f004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_21:
   \   00000000   0x00040400         DC32     0x40400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_22:
   \   00000000   0x00800400         DC32     0x800400
   2621          #endif /* FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP */
   2622          
   2623          #if defined(FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD) && FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD
   2624          /*! @brief Validates the gived flexram function option.*/
   2625          static inline status_t flasn_check_flexram_function_option_range(flash_flexram_function_option_t option)
   2626          {
   2627              if ((option != kFLASH_FlexramFunctionOptionAvailableAsRam) &&
   2628                  (option != kFLASH_FlexramFunctionOptionAvailableForEeprom))
   2629              {
   2630                  return kStatus_FLASH_InvalidArgument;
   2631              }
   2632          
   2633              return kStatus_FLASH_Success;
   2634          }
   2635          #endif /* FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      72   FLASH_Erase
        72   -- Indirect call
        72   -> flash_cache_clear
        72   -> flash_check_range
        72   -> flash_check_user_key
        72   -> flash_command_sequence
        72   -> flash_get_matched_operation_info
      16   FLASH_EraseAll
        16   -> flash_cache_clear
        16   -> flash_check_user_key
        16   -> flash_command_sequence
      16   FLASH_EraseAllExecuteOnlySegments
        16   -> flash_cache_clear
        16   -> flash_check_user_key
        16   -> flash_command_sequence
       0   FLASH_GetProperty
       0   FLASH_GetSecurityState
       0   FLASH_Init
      24   FLASH_IsExecuteOnly
        24   -> flash_check_range
     208   FLASH_IsProtected
       208   -> flash_check_range
       0   FLASH_PflashGetProtection
       0   FLASH_PflashSetProtection
      16   FLASH_PrepareExecuteInRamFunctions
        16   -> copy_flash_cache_clear_command
        16   -> copy_flash_run_command
      56   FLASH_Program
        56   -- Indirect call
        56   -> flash_cache_clear
        56   -> flash_check_range
        56   -> flash_command_sequence
        56   -> flash_get_matched_operation_info
      24   FLASH_ProgramOnce
        24   -> flash_cache_clear
        24   -> flash_command_sequence
      88   FLASH_ProgramSection
        88   -- Indirect call
        88   -> __aeabi_memcpy
        88   -> flash_cache_clear
        88   -> flash_check_range
        88   -> flash_command_sequence
        88   -> flash_get_matched_operation_info
      24   FLASH_ReadOnce
        24   -> flash_command_sequence
      64   FLASH_ReadResource
        64   -> flash_check_resource_range
        64   -> flash_command_sequence
        64   -> flash_get_matched_operation_info
      24   FLASH_SecurityBypass
        24   -> flash_command_sequence
       0   FLASH_SetCallback
      40   FLASH_Swap
        40   -> FLASH_Erase
        40   -> FLASH_SwapControl
        40   -> __aeabi_memset
        40   -> flash_validate_swap_indicator_address
      24   FLASH_SwapControl
        24   -> flash_check_swap_control_option
        24   -> flash_command_sequence
      80   FLASH_VerifyErase
        80   -> flash_check_range
        80   -> flash_command_sequence
        80   -> flash_get_matched_operation_info
      16   FLASH_VerifyEraseAll
        16   -> flash_command_sequence
      16   FLASH_VerifyEraseAllExecuteOnlySegments
        16   -> flash_command_sequence
      72   FLASH_VerifyProgram
        72   -> flash_check_range
        72   -> flash_command_sequence
        72   -> flash_get_matched_operation_info
      16   copy_flash_cache_clear_command
        16   -> __aeabi_memcpy
      16   copy_flash_run_command
        16   -> __aeabi_memcpy
      16   flash_cache_clear
        16   -- Indirect call
        16   -> flash_check_execute_in_ram_function_info
       0   flash_check_execute_in_ram_function_info
       8   flash_check_range
      12   flash_check_resource_range
       0   flash_check_swap_control_option
       0   flash_check_user_key
      16   flash_command_sequence
        16   -- Indirect call
        16   -> flash_check_execute_in_ram_function_info
      24   flash_get_matched_operation_info
        24   -> __aeabi_memset
      40   flash_validate_swap_indicator_address
        40   -> FLASH_ReadResource


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable23
       4  ??DataTable24
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_10
       4  ??DataTable25_11
       4  ??DataTable25_12
       4  ??DataTable25_13
       4  ??DataTable25_14
       4  ??DataTable25_15
       4  ??DataTable25_16
       4  ??DataTable25_17
       4  ??DataTable25_18
       4  ??DataTable25_19
       4  ??DataTable25_2
       4  ??DataTable25_20
       4  ??DataTable25_21
       4  ??DataTable25_22
       4  ??DataTable25_3
       4  ??DataTable25_4
       4  ??DataTable25_5
       4  ??DataTable25_6
       4  ??DataTable25_7
       4  ??DataTable25_8
       4  ??DataTable25_9
     172  FLASH_Erase
      60  FLASH_EraseAll
      60  FLASH_EraseAllExecuteOnlySegments
     120  FLASH_GetProperty
      62  FLASH_GetSecurityState
      94  FLASH_Init
      54  FLASH_IsExecuteOnly
     350  FLASH_IsProtected
      26  FLASH_PflashGetProtection
      34  FLASH_PflashSetProtection
      36  FLASH_PrepareExecuteInRamFunctions
     182  FLASH_Program
      84  FLASH_ProgramOnce
     280  FLASH_ProgramSection
      84  FLASH_ReadOnce
     196  FLASH_ReadResource
     120  FLASH_SecurityBypass
      16  FLASH_SetCallback
     244  FLASH_Swap
     142  FLASH_SwapControl
     194  FLASH_VerifyErase
      40  FLASH_VerifyEraseAll
      40  FLASH_VerifyEraseAllExecuteOnlySegments
     184  FLASH_VerifyProgram
       4  callFlashCacheClearCommand
       4  callFlashRunCommand
      26  copy_flash_cache_clear_command
      26  copy_flash_run_command
      26  flash_cache_clear
      34  flash_check_execute_in_ram_function_info
      56  flash_check_range
     106  flash_check_resource_range
      40  flash_check_swap_control_option
      16  flash_check_user_key
      68  flash_command_sequence
      80  flash_get_matched_operation_info
      58  flash_validate_swap_indicator_address
       4  kFCCOBx
       4  kFPROT
      32  kPFlashDensities
      20  s_flashCacheClearCommandFunctionCode
      12  s_flashRunCommandFunctionCode

 
     8 bytes in section .bss
    72 bytes in section .rodata
 3 510 bytes in section .text
 
 3 510 bytes of CODE  memory
    72 bytes of CONST memory
     8 bytes of DATA  memory

Errors: none
Warnings: none
