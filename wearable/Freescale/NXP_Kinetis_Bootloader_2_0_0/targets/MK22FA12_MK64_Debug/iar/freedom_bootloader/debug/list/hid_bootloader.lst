###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:04
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bm_usb\hid_bootloader.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bm_usb\hid_bootloader.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\hid_bootloader.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\hid_bootloader.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bm_usb\hid_bootloader.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "usb_device_config.h"
     32          #include "usb.h"
     33          #include "usb_device.h"
     34          
     35          #include "usb_device_class.h"
     36          #include "usb_device_hid.h"
     37          #include "usb_device_ch9.h"
     38          #include "usb_descriptor.h"
     39          #include "hid_bootloader.h"
     40          
     41          #include "fsl_device_registers.h"
     42          #include "bootloader_hid_report_ids.h"
     43          #include "utilities/fsl_rtos_abstraction.h"
     44          
     45          #include <stdio.h>
     46          #include <stdlib.h>
     47          #include <string.h>
     48          
     49          #include "composite.h"
     50          
     51          #if (BL_CONFIG_USB_HID || BL_CONFIG_HS_USB_HID)
     52          
     53          /*******************************************************************************
     54           * Variables
     55           ******************************************************************************/
     56          extern usb_device_endpoint_struct_t g_hid_generic_endpoints[];

   \                                 In section .bss, align 4
     57          static usb_device_composite_struct_t *g_device_composite;
   \                     g_device_composite:
   \   00000000                      DS8 4
     58          
     59          /* The hid class callback */

   \                                 In section .text, align 2, keep-with-next
     60          usb_status_t usb_device_hid_generic_callback(class_handle_t handle, uint32_t event, void *param)
     61          {
   \                     usb_device_hid_generic_callback: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
     62              usb_status_t error = kStatus_USB_Error;
   \   0000000A   0x2701             MOVS     R7,#+1
     63          
     64              usb_device_hid_report_struct_t *hid_report_param;
     65          
     66              hid_report_param = (usb_device_hid_report_struct_t *)param;
   \   0000000C   0x46B0             MOV      R8,R6
     67          
     68              const bl_hid_header_t *header;
     69          
     70              switch (event)
   \   0000000E   0x2D01             CMP      R5,#+1
   \   00000010   0xD012             BEQ.N    ??usb_device_hid_generic_callback_0
   \   00000012   0xF0C0 0x8099      BCC.W    ??usb_device_hid_generic_callback_1
   \   00000016   0x2D03             CMP      R5,#+3
   \   00000018   0xD048             BEQ.N    ??usb_device_hid_generic_callback_2
   \   0000001A   0xD32B             BCC.N    ??usb_device_hid_generic_callback_3
   \   0000001C   0x2D05             CMP      R5,#+5
   \   0000001E   0xF000 0x8086      BEQ.W    ??usb_device_hid_generic_callback_4
   \   00000022   0xF0C0 0x8084      BCC.W    ??usb_device_hid_generic_callback_4
   \   00000026   0x2D07             CMP      R5,#+7
   \   00000028   0xF000 0x8081      BEQ.W    ??usb_device_hid_generic_callback_4
   \   0000002C   0xD350             BCC.N    ??usb_device_hid_generic_callback_5
   \   0000002E   0x2D09             CMP      R5,#+9
   \   00000030   0xD07A             BEQ.N    ??usb_device_hid_generic_callback_6
   \   00000032   0xF0C0 0x8089      BCC.W    ??usb_device_hid_generic_callback_7
   \   00000036   0xE087             B.N      ??usb_device_hid_generic_callback_1
     71              {
     72                  case kUSB_DeviceHidEventSendResponse:
     73                      /*!< Send data completed */
     74                      if ((hid_report_param->reportLength == 0xFFFFFFFF) || (hid_report_param->reportLength == 0x0))
   \                     ??usb_device_hid_generic_callback_0: (+1)
   \   00000038   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   0000003C   0xF110 0x0F01      CMN      R0,#+1
   \   00000040   0xD003             BEQ.N    ??usb_device_hid_generic_callback_8
   \   00000042   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD101             BNE.N    ??usb_device_hid_generic_callback_9
     75                      {
     76                          return kStatus_USB_Success;
   \                     ??usb_device_hid_generic_callback_8: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xE07E             B.N      ??usb_device_hid_generic_callback_10
     77                      }
     78                      if ((g_device_composite->hid_generic.hid_packet.sendSync > 0) &&
     79                          (g_device_composite->hid_generic.attach == 1))
   \                     ??usb_device_hid_generic_callback_9: (+1)
   \   0000004E   0x....             LDR.N    R0,??DataTable4
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x6980             LDR      R0,[R0, #+24]
   \   00000054   0x2801             CMP      R0,#+1
   \   00000056   0xDB0A             BLT.N    ??usb_device_hid_generic_callback_11
   \   00000058   0x....             LDR.N    R0,??DataTable4
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0xF890 0x0046      LDRB     R0,[R0, #+70]
   \   00000060   0x2801             CMP      R0,#+1
   \   00000062   0xD104             BNE.N    ??usb_device_hid_generic_callback_11
     80                      // Protect against extra complete due to data abort.
     81                      {
     82                          // Signal that write has completed.
     83                          sync_signal(&g_device_composite->hid_generic.hid_packet.sendSync);
   \   00000064   0x....             LDR.N    R0,??DataTable4
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x3018             ADDS     R0,R0,#+24
   \   0000006A   0x.... 0x....      BL       sync_signal
     84                      }
     85                      error = kStatus_USB_Success;
   \                     ??usb_device_hid_generic_callback_11: (+1)
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x0007             MOVS     R7,R0
     86          
     87                      break;
   \   00000072   0xE069             B.N      ??usb_device_hid_generic_callback_1
     88                  case kUSB_DeviceHidEventRecvResponse:
     89                      /*!< Data received */
     90                      // Save the report size.
     91                      if ((hid_report_param->reportLength == 0xFFFFFFFF) || (hid_report_param->reportLength == 0x0))
   \                     ??usb_device_hid_generic_callback_3: (+1)
   \   00000074   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000078   0xF110 0x0F01      CMN      R0,#+1
   \   0000007C   0xD003             BEQ.N    ??usb_device_hid_generic_callback_12
   \   0000007E   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD101             BNE.N    ??usb_device_hid_generic_callback_13
     92                      {
     93                          return kStatus_USB_Success;
   \                     ??usb_device_hid_generic_callback_12: (+1)
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xE060             B.N      ??usb_device_hid_generic_callback_10
     94                      }
     95                      g_device_composite->hid_generic.hid_packet.reportSize = hid_report_param->reportLength;
   \                     ??usb_device_hid_generic_callback_13: (+1)
   \   0000008A   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   0000008E   0x....             LDR.N    R1,??DataTable4
   \   00000090   0x6809             LDR      R1,[R1, #+0]
   \   00000092   0x61C8             STR      R0,[R1, #+28]
     96          
     97                      g_device_composite->hid_generic.hid_packet.didReceiveFirstReport = true;
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0x....             LDR.N    R1,??DataTable4
   \   00000098   0x6809             LDR      R1,[R1, #+0]
   \   0000009A   0x7308             STRB     R0,[R1, #+12]
     98          
     99                      // Wake up the read packet handler.
    100                      sync_signal(&g_device_composite->hid_generic.hid_packet.receiveSync);
   \   0000009C   0x....             LDR.N    R0,??DataTable4
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0x3014             ADDS     R0,R0,#+20
   \   000000A2   0x.... 0x....      BL       sync_signal
    101                      error = kStatus_USB_Success;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x0007             MOVS     R7,R0
    102          
    103                      break;
   \   000000AA   0xE04D             B.N      ??usb_device_hid_generic_callback_1
    104                  case kUSB_DeviceHidEventGetReport:
    105                      /*!< Get report request */
    106                      // Send an empty report. The host should only be reading reports via the interrupt pipe.
    107                      memset(&g_device_composite->hid_generic.hid_packet.report, 0,
    108                             sizeof(g_device_composite->hid_generic.hid_packet.report));
   \                     ??usb_device_hid_generic_callback_2: (+1)
   \   000000AC   0xF05F 0x0924      MOVS     R9,#+36
   \   000000B0   0xF05F 0x0A00      MOVS     R10,#+0
   \   000000B4   0x....             LDR.N    R0,??DataTable4
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0xF110 0x0B20      ADDS     R11,R0,#+32
   \   000000BC   0x4652             MOV      R2,R10
   \   000000BE   0x4649             MOV      R1,R9
   \   000000C0   0x4658             MOV      R0,R11
   \   000000C2   0x.... 0x....      BL       __aeabi_memset
    109                      param = (uint8_t *)&g_device_composite->hid_generic.hid_packet.report.header; // point to the report to send
   \   000000C6   0x....             LDR.N    R0,??DataTable4
   \   000000C8   0x6800             LDR      R0,[R0, #+0]
   \   000000CA   0x3020             ADDS     R0,R0,#+32
   \   000000CC   0x0006             MOVS     R6,R0
    110                      // size is set to 0 above
    111                      break;
   \   000000CE   0xE03B             B.N      ??usb_device_hid_generic_callback_1
    112                  case kUSB_DeviceHidEventSetReport:
    113                      // Check for data phase abort packet.
    114                      header = (bl_hid_header_t *)param;
   \                     ??usb_device_hid_generic_callback_5: (+1)
   \   000000D0   0x9600             STR      R6,[SP, #+0]
    115                      if ((header->packetLengthLsb == 0) && (header->packetLengthMsb == 0) &&
    116                          (header->reportID == kBootloaderReportID_CommandOut))
   \   000000D2   0x9800             LDR      R0,[SP, #+0]
   \   000000D4   0x7880             LDRB     R0,[R0, #+2]
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD10C             BNE.N    ??usb_device_hid_generic_callback_14
   \   000000DA   0x9800             LDR      R0,[SP, #+0]
   \   000000DC   0x78C0             LDRB     R0,[R0, #+3]
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD108             BNE.N    ??usb_device_hid_generic_callback_14
   \   000000E2   0x9800             LDR      R0,[SP, #+0]
   \   000000E4   0x7800             LDRB     R0,[R0, #+0]
   \   000000E6   0x2801             CMP      R0,#+1
   \   000000E8   0xD104             BNE.N    ??usb_device_hid_generic_callback_14
    117                      {
    118                          g_device_composite->hid_generic.hid_packet.didReceiveDataPhaseAbort = true;
   \   000000EA   0x2001             MOVS     R0,#+1
   \   000000EC   0x....             LDR.N    R1,??DataTable4
   \   000000EE   0x6809             LDR      R1,[R1, #+0]
   \   000000F0   0x7348             STRB     R0,[R1, #+13]
    119                          break;
   \   000000F2   0xE029             B.N      ??usb_device_hid_generic_callback_1
    120                      }
    121          
    122                      // Copy the report data into our local buffer.
    123                      memcpy(&g_device_composite->hid_generic.hid_packet.report.header, param, hid_report_param->reportLength);
   \                     ??usb_device_hid_generic_callback_14: (+1)
   \   000000F4   0xF8D8 0x9004      LDR      R9,[R8, #+4]
   \   000000F8   0x....             LDR.N    R0,??DataTable4
   \   000000FA   0x6800             LDR      R0,[R0, #+0]
   \   000000FC   0xF110 0x0A20      ADDS     R10,R0,#+32
   \   00000100   0x464A             MOV      R2,R9
   \   00000102   0x0031             MOVS     R1,R6
   \   00000104   0x4650             MOV      R0,R10
   \   00000106   0x.... 0x....      BL       __aeabi_memcpy
    124          
    125                      // Save the report size.
    126                      g_device_composite->hid_generic.hid_packet.reportSize = hid_report_param->reportLength;
   \   0000010A   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   0000010E   0x....             LDR.N    R1,??DataTable4
   \   00000110   0x6809             LDR      R1,[R1, #+0]
   \   00000112   0x61C8             STR      R0,[R1, #+28]
    127          
    128                      // Remember that we received a report.
    129                      g_device_composite->hid_generic.hid_packet.didReceiveFirstReport = true;
   \   00000114   0x2001             MOVS     R0,#+1
   \   00000116   0x....             LDR.N    R1,??DataTable4
   \   00000118   0x6809             LDR      R1,[R1, #+0]
   \   0000011A   0x7308             STRB     R0,[R1, #+12]
    130          
    131                      // Wake up the read packet handler.
    132                      sync_signal(&g_device_composite->hid_generic.hid_packet.receiveSync);
   \   0000011C   0x....             LDR.N    R0,??DataTable4
   \   0000011E   0x6800             LDR      R0,[R0, #+0]
   \   00000120   0x3014             ADDS     R0,R0,#+20
   \   00000122   0x.... 0x....      BL       sync_signal
    133                      break;
   \   00000126   0xE00F             B.N      ??usb_device_hid_generic_callback_1
    134                  case kUSB_DeviceHidEventRequestReportBuffer:
    135                      error = kStatus_USB_InvalidRequest;
   \                     ??usb_device_hid_generic_callback_6: (+1)
   \   00000128   0x2005             MOVS     R0,#+5
   \   0000012A   0x0007             MOVS     R7,R0
    136                      break;
   \   0000012C   0xE00C             B.N      ??usb_device_hid_generic_callback_1
    137                  case kUSB_DeviceHidEventGetIdle:
    138                  case kUSB_DeviceHidEventGetProtocol:
    139                  case kUSB_DeviceHidEventSetIdle:
    140                      sync_init(&g_device_composite->hid_generic.hid_packet.receiveSync, false);
   \                     ??usb_device_hid_generic_callback_4: (+1)
   \   0000012E   0x2100             MOVS     R1,#+0
   \   00000130   0x....             LDR.N    R0,??DataTable4
   \   00000132   0x6800             LDR      R0,[R0, #+0]
   \   00000134   0x3014             ADDS     R0,R0,#+20
   \   00000136   0x.... 0x....      BL       sync_init
    141                      sync_init(&g_device_composite->hid_generic.hid_packet.sendSync, false);
   \   0000013A   0x2100             MOVS     R1,#+0
   \   0000013C   0x....             LDR.N    R0,??DataTable4
   \   0000013E   0x6800             LDR      R0,[R0, #+0]
   \   00000140   0x3018             ADDS     R0,R0,#+24
   \   00000142   0x.... 0x....      BL       sync_init
    142                      break;
   \   00000146   0xE7FF             B.N      ??usb_device_hid_generic_callback_1
    143                  case kUSB_DeviceHidEventSetProtocol:
    144                      break;
    145              }
    146          
    147              return error;
   \                     ??usb_device_hid_generic_callback_7: (+1)
   \                     ??usb_device_hid_generic_callback_1: (+1)
   \   00000148   0x0038             MOVS     R0,R7
   \   0000014A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??usb_device_hid_generic_callback_10: (+1)
   \   0000014C   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    148          }
    149          
    150          /*!
    151           * @brief HID device set configuration function.
    152           *
    153           * This function sets configuration for HID class.
    154           *
    155           * @param handle The HID class handle.
    156           * @param configure The HID class configure index.
    157           *
    158           * @return A USB error code or kStatus_USB_Success.
    159           */

   \                                 In section .text, align 2, keep-with-next
    160          usb_status_t usb_device_hid_generic_set_configure(class_handle_t handle, uint8_t configure)
    161          {
   \                     usb_device_hid_generic_set_configure: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    162              usb_status_t error = kStatus_USB_Success;
   \   00000006   0x2600             MOVS     R6,#+0
    163              if (USB_COMPOSITE_CONFIGURE_INDEX == configure)
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0x2D01             CMP      R5,#+1
   \   0000000C   0xD114             BNE.N    ??usb_device_hid_generic_set_configure_0
    164              {
    165                  g_device_composite->hid_generic.attach = 1;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x....             LDR.N    R1,??DataTable4
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0xF881 0x0046      STRB     R0,[R1, #+70]
    166          
    167                  /* Set device configuration request */
    168                  error = USB_DeviceHidRecv(g_device_composite->hid_generic.hid_handle, USB_HID_GENERIC_ENDPOINT_OUT,
    169                                            (uint8_t *)&g_device_composite->hid_generic.hid_packet.report.header,
    170                                            sizeof(g_device_composite->hid_generic.hid_packet.report));
   \   00000018   0x2324             MOVS     R3,#+36
   \   0000001A   0x....             LDR.N    R0,??DataTable4
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF110 0x0220      ADDS     R2,R0,#+32
   \   00000022   0x2102             MOVS     R1,#+2
   \   00000024   0x....             LDR.N    R0,??DataTable4
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x6880             LDR      R0,[R0, #+8]
   \   0000002A   0x.... 0x....      BL       USB_DeviceHidRecv
   \   0000002E   0x0006             MOVS     R6,R0
    171                  g_device_composite->hid_generic.current_configuration = configure;
   \   00000030   0x....             LDR.N    R0,??DataTable4
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xF880 0x5047      STRB     R5,[R0, #+71]
    172              }
    173              return error;
   \                     ??usb_device_hid_generic_set_configure_0: (+1)
   \   00000038   0x0030             MOVS     R0,R6
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
    174          }
    175          

   \                                 In section .text, align 2, keep-with-next
    176          usb_status_t usb_device_hid_generic_set_interface(class_handle_t handle, uint8_t interface, uint8_t alternate_setting)
    177          {
   \                     usb_device_hid_generic_set_interface: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    178              usb_status_t error = kStatus_USB_Success;
   \   00000008   0x2700             MOVS     R7,#+0
    179              if (interface < USB_HID_GENERIC_INTERFACE_COUNT)
   \   0000000A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xD111             BNE.N    ??usb_device_hid_generic_set_interface_0
    180              {
    181                  g_device_composite->hid_generic.current_interface_alternate_setting[interface] = alternate_setting;
   \   00000010   0x....             LDR.N    R0,??DataTable4
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x4428             ADD      R0,R0,R5
   \   00000018   0xF880 0x6048      STRB     R6,[R0, #+72]
    182                  error = USB_DeviceHidRecv(g_device_composite->hid_generic.hid_handle, USB_HID_GENERIC_ENDPOINT_OUT,
    183                                            (uint8_t *)&g_device_composite->hid_generic.hid_packet.report.header,
    184                                            sizeof(g_device_composite->hid_generic.hid_packet.report));
   \   0000001C   0x2324             MOVS     R3,#+36
   \   0000001E   0x....             LDR.N    R0,??DataTable4
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF110 0x0220      ADDS     R2,R0,#+32
   \   00000026   0x2102             MOVS     R1,#+2
   \   00000028   0x....             LDR.N    R0,??DataTable4
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x6880             LDR      R0,[R0, #+8]
   \   0000002E   0x.... 0x....      BL       USB_DeviceHidRecv
   \   00000032   0x0007             MOVS     R7,R0
    185              }
    186              return error;
   \                     ??usb_device_hid_generic_set_interface_0: (+1)
   \   00000034   0x0038             MOVS     R0,R7
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    187          }
    188          

   \                                 In section .text, align 2, keep-with-next
    189          usb_status_t usb_device_hid_generic_init(usb_device_composite_struct_t *device_composite)
    190          {
   \                     usb_device_hid_generic_init: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    191              g_device_composite = device_composite;
   \   00000002   0x....             LDR.N    R0,??DataTable4
   \   00000004   0x6001             STR      R1,[R0, #+0]
    192              return kStatus_USB_Success;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x4770             BX       LR               ;; return
    193          }
    194          

   \                                 In section .text, align 2, keep-with-next
    195          usb_status_t usb_device_hid_generic_deinit(usb_device_composite_struct_t *device_composite)
    196          {
   \                     usb_device_hid_generic_deinit: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    197              g_device_composite = device_composite;
   \   00000002   0x....             LDR.N    R0,??DataTable4
   \   00000004   0x6001             STR      R1,[R0, #+0]
    198              g_device_composite->hid_generic.hid_handle = (class_handle_t)NULL;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x....             LDR.N    R2,??DataTable4
   \   0000000A   0x6812             LDR      R2,[R2, #+0]
   \   0000000C   0x6090             STR      R0,[R2, #+8]
    199              return kStatus_USB_Success;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4770             BX       LR               ;; return
    200          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     g_device_composite
    201          
    202          #endif //  BL_CONFIG_USB_HID

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   usb_device_hid_generic_callback
        40   -> __aeabi_memcpy
        40   -> __aeabi_memset
        40   -> sync_init
        40   -> sync_signal
       0   usb_device_hid_generic_deinit
       0   usb_device_hid_generic_init
      16   usb_device_hid_generic_set_configure
        16   -> USB_DeviceHidRecv
      24   usb_device_hid_generic_set_interface
        24   -> USB_DeviceHidRecv


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  g_device_composite
     336  usb_device_hid_generic_callback
      18  usb_device_hid_generic_deinit
      10  usb_device_hid_generic_init
      62  usb_device_hid_generic_set_configure
      58  usb_device_hid_generic_set_interface

 
   4 bytes in section .bss
 488 bytes in section .text
 
 488 bytes of CODE memory
   4 bytes of DATA memory

Errors: none
Warnings: none
