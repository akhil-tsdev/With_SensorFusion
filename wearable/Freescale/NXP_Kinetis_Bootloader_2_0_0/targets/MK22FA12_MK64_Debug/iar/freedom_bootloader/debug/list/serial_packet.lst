###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:10
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\packet\src\serial_packet.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\packet\src\serial_packet.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\serial_packet.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\serial_packet.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\packet\src\serial_packet.c
      1          /*
      2           * Copyright (c) 2013, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include <string.h>
     32          #include "bootloader_common.h"
     33          #include "bootloader/bl_context.h"
     34          #include "bootloader/bootloader.h"
     35          #include "packet/command_packet.h"
     36          #include "packet/serial_packet.h"
     37          #include "crc/crc16.h"
     38          #include "utilities/fsl_assert.h"
     39          
     40          #ifndef BOOTLOADER_HOST
     41          #include "microseconds/microseconds.h"
     42          #endif
     43          
     44          //! @addtogroup packet
     45          //! @{
     46          
     47          ////////////////////////////////////////////////////////////////////////////////
     48          // Definitions
     49          ////////////////////////////////////////////////////////////////////////////////
     50          
     51          //#define TEST_NAK
     52          
     53          ////////////////////////////////////////////////////////////////////////////////
     54          // Prototypes
     55          ////////////////////////////////////////////////////////////////////////////////
     56          
     57          static status_t write_data(const uint8_t *buffer, uint32_t byteCount);
     58          static status_t read_data(uint8_t *buffer, uint32_t byteCount, uint32_t timeoutMs);
     59          static status_t read_data_packet(framing_data_packet_t *packet, uint8_t *data, packet_type_t packetType);
     60          static status_t read_start_byte(framing_header_t *header);
     61          static status_t read_header(framing_header_t *header);
     62          static status_t read_length(framing_data_packet_t *packet);
     63          static status_t read_crc16(framing_data_packet_t *packet);
     64          static status_t wait_for_ack_packet(void);
     65          static status_t send_deferred_ack(void);
     66          static uint16_t calculate_framing_crc16(framing_data_packet_t *packet, const uint8_t *data);
     67          
     68          ////////////////////////////////////////////////////////////////////////////////
     69          // Variables
     70          ////////////////////////////////////////////////////////////////////////////////
     71          
     72          // See peripharal.h for documentation on this interface.

   \                                 In section .rodata, align 4
     73          const peripheral_packet_interface_t g_framingPacketInterface = {
   \                     g_framingPacketInterface:
   \   00000000   0x........         DC32 serial_packet_init, serial_packet_read, serial_packet_write
   \              0x........   
   \              0x........   
   \   0000000C   0x........         DC32 serial_packet_abort, serial_packet_finalize
   \              0x........   
   \   00000014   0x........         DC32 serial_packet_get_max_packet_size, serial_packet_queue_byte
   \              0x........   
     74              serial_packet_init,      serial_packet_read,     serial_packet_write,
     75              serial_packet_abort,     serial_packet_finalize, serial_packet_get_max_packet_size,
     76              serial_packet_queue_byte
     77          };
     78          
     79          //! @brief Ping response.
     80          #if defined(__cplusplus)
     81          const ping_response_t k_PingResponse = {
     82              MAKE_VERSION(kSerialProtocol_Version_Bugfix,
     83                           kSerialProtocol_Version_Minor,
     84                           kSerialProtocol_Version_Major,
     85                           kSerialProtocol_Version_Name),
     86              0,     // options, recalculate crc16 if this value changes
     87              0xeaaa // crc16 of start byte, packet type, version and options.
     88                     // i.e. [5a a7 00 00 01 50 00 00]
     89                     // Calculated using CRC-16/XMODEM.
     90          };
     91          #else

   \                                 In section .rodata, align 4
     92          const ping_response_t k_PingResponse = {
   \                     k_PingResponse:
   \   00000000   0x00 0x02          DC8 0, 2, 1, 80
   \              0x01 0x50    
   \   00000004   0x0000 0xEAAA      DC16 0, 60074
     93              { { kSerialProtocol_Version_Bugfix, kSerialProtocol_Version_Minor, kSerialProtocol_Version_Major,
     94                  kSerialProtocol_Version_Name } },
     95              0,     // options, recalculate crc16 if this value changes
     96              0xeaaa // crc16 of start byte, packet type, version and options.
     97                     // i.e. [5a a7 00 00 01 50 00 00]
     98                     // Calculated using CRC-16/XMODEM.
     99          };
    100          #endif
    101          
    102          //! @brief Global context data.

   \                                 In section .bss, align 4
    103          static serial_data_t g_serialContext;
   \                     g_serialContext:
   \   00000000                      DS8 148
    104          
    105          ////////////////////////////////////////////////////////////////////////////////
    106          // Code
    107          ////////////////////////////////////////////////////////////////////////////////
    108          
    109          // See serial_packet.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    110          void serial_packet_queue_byte(uint8_t byte)
    111          {
    112              g_serialContext.callbackBuffer[g_serialContext.writeOffset++] = byte;
   \                     serial_packet_queue_byte: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000004   0xF8D1 0x1088      LDR      R1,[R1, #+136]
   \   00000008   0x1C4A             ADDS     R2,R1,#+1
   \   0000000A   0x.... 0x....      LDR.W    R3,??DataTable10
   \   0000000E   0xF8C3 0x2088      STR      R2,[R3, #+136]
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable10
   \   00000016   0x4411             ADD      R1,R2,R1
   \   00000018   0xF881 0x0020      STRB     R0,[R1, #+32]
    113              g_serialContext.writeOffset &= kCallbackBufferSize - 1;
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000020   0xF8D1 0x1088      LDR      R1,[R1, #+136]
   \   00000024   0xF011 0x013F      ANDS     R1,R1,#0x3F
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable10
   \   0000002C   0xF8C2 0x1088      STR      R1,[R2, #+136]
    114          }
   \   00000030   0x4770             BX       LR               ;; return
    115          
    116          // See serial_packet.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    117          status_t serial_packet_init(const peripheral_descriptor_t *self)
    118          {
   \                     serial_packet_init: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    119              return kStatus_Success;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
    120          }
    121          
    122          // See serial_packet.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    123          status_t serial_packet_finalize(const peripheral_descriptor_t *self)
    124          {
   \                     serial_packet_finalize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    125              return send_deferred_ack();
   \   00000004   0x.... 0x....      BL       send_deferred_ack
   \   00000008   0xBD10             POP      {R4,PC}          ;; return
    126          }
    127          
    128          // See serial_packet.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    129          status_t serial_packet_read(const peripheral_descriptor_t *self,
    130                                      uint8_t **packet,
    131                                      uint32_t *packetLength,
    132                                      packet_type_t packetType)
    133          {
   \                     serial_packet_read: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    134              if (!packet || !packetLength)
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xD001             BEQ.N    ??serial_packet_read_0
   \   00000010   0x2E00             CMP      R6,#+0
   \   00000012   0xD101             BNE.N    ??serial_packet_read_1
    135              {
    136                  debug_printf("Error: invalid packet\r\n");
    137                  return kStatus_InvalidArgument;
   \                     ??serial_packet_read_0: (+1)
   \   00000014   0x2004             MOVS     R0,#+4
   \   00000016   0xE051             B.N      ??serial_packet_read_2
    138              }
    139              *packetLength = 0;
   \                     ??serial_packet_read_1: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6030             STR      R0,[R6, #+0]
    140              status_t status;
    141          
    142              g_serialContext.isBackToBackWrite = false;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000022   0xF881 0x0091      STRB     R0,[R1, #+145]
    143          
    144              // Send ACK if needed.
    145              status = send_deferred_ack();
   \   00000026   0x.... 0x....      BL       send_deferred_ack
   \   0000002A   0x9000             STR      R0,[SP, #+0]
    146              if (status != kStatus_Success)
   \   0000002C   0x9800             LDR      R0,[SP, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD001             BEQ.N    ??serial_packet_read_3
    147              {
    148                  return status;
   \   00000032   0x9800             LDR      R0,[SP, #+0]
   \   00000034   0xE042             B.N      ??serial_packet_read_2
    149              }
    150          
    151              framing_data_packet_t framingPacket;
    152          
    153              bool isPacketOk;
    154              do
    155              {
    156                  // Clear the packet data area so unsent parameters default to zero.
    157                  memset(g_serialContext.data, 0, sizeof(g_serialContext.data));
   \                     ??serial_packet_read_3: (+1)
   \                     ??serial_packet_read_4: (+1)
   \   00000036   0xF05F 0x0A20      MOVS     R10,#+32
   \   0000003A   0xF05F 0x0B00      MOVS     R11,#+0
   \   0000003E   0x.... 0x....      LDR.W    R9,??DataTable10
   \   00000042   0x465A             MOV      R2,R11
   \   00000044   0x4651             MOV      R1,R10
   \   00000046   0x4648             MOV      R0,R9
   \   00000048   0x.... 0x....      BL       __aeabi_memset
    158          
    159                  // Receive the framing data packet.
    160                  isPacketOk = true;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x4680             MOV      R8,R0
    161                  status_t status = read_data_packet(&framingPacket, g_serialContext.data, packetType);
   \   00000050   0x003A             MOVS     R2,R7
   \   00000052   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000058   0xA801             ADD      R0,SP,#+4
   \   0000005A   0x.... 0x....      BL       read_data_packet
   \   0000005E   0x4681             MOV      R9,R0
    162                  if (status != kStatus_Success)
   \   00000060   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000064   0xD003             BEQ.N    ??serial_packet_read_5
    163                  {
    164                      // No packet available.
    165                      *packetLength = 0;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x6030             STR      R0,[R6, #+0]
    166                      return status;
   \   0000006A   0x4648             MOV      R0,R9
   \   0000006C   0xE026             B.N      ??serial_packet_read_2
    167                  }
    168          
    169                  // Verify crc.
    170                  uint16_t calculated_crc = calculate_framing_crc16(&framingPacket, g_serialContext.data);
   \                     ??serial_packet_read_5: (+1)
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000072   0xA801             ADD      R0,SP,#+4
   \   00000074   0x.... 0x....      BL       calculate_framing_crc16
   \   00000078   0x4682             MOV      R10,R0
    171                  if (framingPacket.crc16 != calculated_crc)
   \   0000007A   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   0000007E   0x4651             MOV      R1,R10
   \   00000080   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000082   0x4288             CMP      R0,R1
   \   00000084   0xD001             BEQ.N    ??serial_packet_read_6
    172                  {
    173                      debug_printf("Error: invalid crc 0x%x, expected 0x%x\r\n", framingPacket.crc16, calculated_crc);
    174                      isPacketOk = false;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x4680             MOV      R8,R0
    175                  }
    176          
    177                  // Send Nak if necessary.
    178                  if (!isPacketOk)
   \                     ??serial_packet_read_6: (+1)
   \   0000008A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000008E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000092   0xD102             BNE.N    ??serial_packet_read_7
    179                  {
    180                      serial_packet_send_sync(kFramingPacketType_Nak);
   \   00000094   0x20A2             MOVS     R0,#+162
   \   00000096   0x.... 0x....      BL       serial_packet_send_sync
    181                  }
    182              } while (!isPacketOk);
   \                     ??serial_packet_read_7: (+1)
   \   0000009A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000009E   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000A2   0xD0C8             BEQ.N    ??serial_packet_read_4
    183          
    184              // Indicate an ACK must be sent.
    185              g_serialContext.isAckNeeded = true;
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable10
   \   000000AA   0xF881 0x0090      STRB     R0,[R1, #+144]
    186          
    187              // Set caller's data buffer and length
    188              *packet = g_serialContext.data;
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable10
   \   000000B2   0x6028             STR      R0,[R5, #+0]
    189              *packetLength = framingPacket.length;
   \   000000B4   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \   000000B8   0x6030             STR      R0,[R6, #+0]
    190          
    191              return kStatus_Success;
   \   000000BA   0x2000             MOVS     R0,#+0
   \                     ??serial_packet_read_2: (+1)
   \   000000BC   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    192          }
    193          
    194          // See serial_packet.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    195          status_t serial_packet_write(const peripheral_descriptor_t *self,
    196                                       const uint8_t *packet,
    197                                       uint32_t byteCount,
    198                                       packet_type_t packetType)
    199          {
   \                     serial_packet_write: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    200              if (!packet || (byteCount > kOutgoingPacketBufferSize))
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xD001             BEQ.N    ??serial_packet_write_0
   \   00000010   0x2E21             CMP      R6,#+33
   \   00000012   0xD301             BCC.N    ??serial_packet_write_1
    201              {
    202                  debug_printf("Error: invalid packet or packet size %d\r\n", byteCount);
    203                  return kStatus_InvalidArgument;
   \                     ??serial_packet_write_0: (+1)
   \   00000014   0x2004             MOVS     R0,#+4
   \   00000016   0xE03C             B.N      ??serial_packet_write_2
    204              }
    205          
    206              // Send ACK if needed.
    207              status_t status = send_deferred_ack();
   \                     ??serial_packet_write_1: (+1)
   \   00000018   0x.... 0x....      BL       send_deferred_ack
   \   0000001C   0x4680             MOV      R8,R0
    208              if (status != kStatus_Success)
   \   0000001E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000022   0xD001             BEQ.N    ??serial_packet_write_3
    209              {
    210                  return status;
   \   00000024   0x4640             MOV      R0,R8
   \   00000026   0xE034             B.N      ??serial_packet_write_2
    211              }
    212          
    213              // Back-to-back writes require delay for receiver to enter peripheral read routine.
    214              if (g_serialContext.isBackToBackWrite)
   \                     ??serial_packet_write_3: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable10
   \   0000002A   0xF890 0x0091      LDRB     R0,[R0, #+145]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD003             BEQ.N    ??serial_packet_write_4
    215              {
    216                  g_serialContext.isBackToBackWrite = false;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x....             LDR.N    R1,??DataTable10
   \   00000036   0xF881 0x0091      STRB     R0,[R1, #+145]
    217          
    218          #if defined(BOOTLOADER_HOST)
    219                  host_delay(100);
    220          #endif
    221              }
    222          
    223              // Initialize the framing data packet.
    224              serial_framing_packet_t *framingPacket = &g_serialContext.framingPacket;
   \                     ??serial_packet_write_4: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R9,??DataTable10_1
    225              framingPacket->dataPacket.header.startByte = kFramingPacketStartByte;
   \   0000003E   0x205A             MOVS     R0,#+90
   \   00000040   0xF889 0x0000      STRB     R0,[R9, #+0]
    226              framingPacket->dataPacket.header.packetType = kFramingPacketType_Command;
   \   00000044   0x20A4             MOVS     R0,#+164
   \   00000046   0xF889 0x0001      STRB     R0,[R9, #+1]
    227              if (packetType != kPacketType_Command)
   \   0000004A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000004C   0x2F00             CMP      R7,#+0
   \   0000004E   0xD002             BEQ.N    ??serial_packet_write_5
    228              {
    229                  framingPacket->dataPacket.header.packetType = kFramingPacketType_Data;
   \   00000050   0x20A5             MOVS     R0,#+165
   \   00000052   0xF889 0x0001      STRB     R0,[R9, #+1]
    230              }
    231              framingPacket->dataPacket.length = (uint16_t)byteCount;
   \                     ??serial_packet_write_5: (+1)
   \   00000056   0xF8A9 0x6002      STRH     R6,[R9, #+2]
    232          
    233              // Copy the caller's data buffer into the framing packet.
    234              if (byteCount)
   \   0000005A   0x2E00             CMP      R6,#+0
   \   0000005C   0xD006             BEQ.N    ??serial_packet_write_6
    235              {
    236                  memcpy(framingPacket->data, packet, byteCount);
   \   0000005E   0xF119 0x0A06      ADDS     R10,R9,#+6
   \   00000062   0x0032             MOVS     R2,R6
   \   00000064   0x0029             MOVS     R1,R5
   \   00000066   0x4650             MOV      R0,R10
   \   00000068   0x.... 0x....      BL       __aeabi_memcpy
    237              }
    238          
    239              // Calculate and set the framing packet crc.
    240              framingPacket->dataPacket.crc16 =
    241                  calculate_framing_crc16(&framingPacket->dataPacket, (uint8_t *)framingPacket->data);
   \                     ??serial_packet_write_6: (+1)
   \   0000006C   0xF119 0x0106      ADDS     R1,R9,#+6
   \   00000070   0x4648             MOV      R0,R9
   \   00000072   0x.... 0x....      BL       calculate_framing_crc16
   \   00000076   0xF8A9 0x0004      STRH     R0,[R9, #+4]
    242          #if defined(TEST_NAK)
    243              ++framingPacket->dataPacket.crc16;
    244          #endif // TEST_NAK
    245          
    246              // Send the framing data packet.
    247              status = write_data((uint8_t *)framingPacket, sizeof(framing_data_packet_t) + byteCount);
   \   0000007A   0x1DB1             ADDS     R1,R6,#+6
   \   0000007C   0x4648             MOV      R0,R9
   \   0000007E   0x.... 0x....      BL       write_data
   \   00000082   0x4680             MOV      R8,R0
    248              if (status != kStatus_Success)
   \   00000084   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000088   0xD001             BEQ.N    ??serial_packet_write_7
    249              {
    250                  return status;
   \   0000008A   0x4640             MOV      R0,R8
   \   0000008C   0xE001             B.N      ??serial_packet_write_2
    251              }
    252          
    253              return wait_for_ack_packet();
   \                     ??serial_packet_write_7: (+1)
   \   0000008E   0x.... 0x....      BL       wait_for_ack_packet
   \                     ??serial_packet_write_2: (+1)
   \   00000092   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    254          }
    255          
    256          // See serial_packet.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    257          void serial_packet_abort(const peripheral_descriptor_t *self)
    258          {
    259              assert(g_serialContext.isAckNeeded);
    260              g_serialContext.isAckAbortNeeded = true;
   \                     serial_packet_abort: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x....             LDR.N    R2,??DataTable10
   \   00000004   0xF882 0x1092      STRB     R1,[R2, #+146]
    261              g_serialContext.isAckNeeded = false;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x....             LDR.N    R2,??DataTable10
   \   0000000C   0xF882 0x1090      STRB     R1,[R2, #+144]
    262          }
   \   00000010   0x4770             BX       LR               ;; return
    263          
    264          // See serial_packet.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    265          uint32_t serial_packet_get_max_packet_size(const peripheral_descriptor_t *self)
    266          {
   \                     serial_packet_get_max_packet_size: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    267              return kMinPacketBufferSize;
   \   00000002   0x2020             MOVS     R0,#+32
   \   00000004   0x4770             BX       LR               ;; return
    268          }
    269          
    270          // See serial_packet.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    271          status_t serial_packet_send_sync(uint8_t framingPacketType)
    272          {
   \                     serial_packet_send_sync: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    273              framing_sync_packet_t sync;
    274              sync.header.startByte = kFramingPacketStartByte;
   \   00000006   0x205A             MOVS     R0,#+90
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
    275              sync.header.packetType = framingPacketType;
   \   0000000C   0xF88D 0x4001      STRB     R4,[SP, #+1]
    276          
    277              // Indicate last transaction was a write.
    278              g_serialContext.isBackToBackWrite = true;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x....             LDR.N    R1,??DataTable10
   \   00000014   0xF881 0x0091      STRB     R0,[R1, #+145]
    279          
    280              status_t status = write_data((uint8_t *)&sync, sizeof(sync));
   \   00000018   0x2102             MOVS     R1,#+2
   \   0000001A   0x4668             MOV      R0,SP
   \   0000001C   0x.... 0x....      BL       write_data
    281              if (status != kStatus_Success)
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD1FF             BNE.N    ??serial_packet_send_sync_0
    282              {
    283                  debug_printf("Error: cannot send sync packet 0x%x, status = 0x%x\r\n", framingPacketType, status);
    284                  return status;
    285              }
    286          
    287              return status;
   \                     ??serial_packet_send_sync_1: (+1)
   \                     ??serial_packet_send_sync_0: (+1)
   \   00000024   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    288          }
    289          
    290          //! @brief Wait for an ACK, handling NAKs as needed.

   \                                 In section .text, align 2, keep-with-next
    291          static status_t wait_for_ack_packet()
    292          {
   \                     wait_for_ack_packet: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    293              framing_sync_packet_t sync;
    294              do
    295              {
    296                  // Receive the sync packet.
    297                  status_t status = read_header(&sync.header);
   \                     ??wait_for_ack_packet_0: (+1)
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x.... 0x....      BL       read_header
   \   0000000A   0x0004             MOVS     R4,R0
    298                  if (status != kStatus_Success)
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD001             BEQ.N    ??wait_for_ack_packet_1
    299                  {
    300                      return status;
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0xE029             B.N      ??wait_for_ack_packet_2
    301                  }
    302          
    303                  if ((sync.header.packetType != kFramingPacketType_Ack) && (sync.header.packetType != kFramingPacketType_Nak) &&
    304                      (sync.header.packetType != kFramingPacketType_AckAbort))
   \                     ??wait_for_ack_packet_1: (+1)
   \   00000014   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000018   0x28A1             CMP      R0,#+161
   \   0000001A   0xD009             BEQ.N    ??wait_for_ack_packet_3
   \   0000001C   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000020   0x28A2             CMP      R0,#+162
   \   00000022   0xD005             BEQ.N    ??wait_for_ack_packet_3
   \   00000024   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000028   0x28A3             CMP      R0,#+163
   \   0000002A   0xD001             BEQ.N    ??wait_for_ack_packet_3
    305                  {
    306                      debug_printf("Error: Unexpected sync byte 0x%x received, expected Ack, AckAbort or Nak\r\n",
    307                                   sync.header.packetType);
    308                      return kStatus_InvalidArgument;
   \   0000002C   0x2004             MOVS     R0,#+4
   \   0000002E   0xE01B             B.N      ??wait_for_ack_packet_2
    309                  }
    310          
    311                  if (sync.header.packetType == kFramingPacketType_AckAbort)
   \                     ??wait_for_ack_packet_3: (+1)
   \   00000030   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000034   0x28A3             CMP      R0,#+163
   \   00000036   0xD102             BNE.N    ??wait_for_ack_packet_4
    312                  {
    313                      return kStatus_AbortDataPhase;
   \   00000038   0xF242 0x7012      MOVW     R0,#+10002
   \   0000003C   0xE014             B.N      ??wait_for_ack_packet_2
    314                  }
    315          
    316                  if (sync.header.packetType == kFramingPacketType_Nak)
   \                     ??wait_for_ack_packet_4: (+1)
   \   0000003E   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000042   0x28A2             CMP      R0,#+162
   \   00000044   0xD10B             BNE.N    ??wait_for_ack_packet_5
    317                  {
    318          // Re-transmit the last packet.
    319          #if defined(TEST_NAK)
    320                      --g_serialContext.framingPacket.dataPacket.crc16;
    321          #endif // TEST_NAK
    322                      status = write_data((uint8_t *)&g_serialContext.framingPacket,
    323                                          sizeof(framing_data_packet_t) + g_serialContext.framingPacket.dataPacket.length);
   \   00000046   0x....             LDR.N    R0,??DataTable10
   \   00000048   0xF8B0 0x0062      LDRH     R0,[R0, #+98]
   \   0000004C   0x1D81             ADDS     R1,R0,#+6
   \   0000004E   0x....             LDR.N    R0,??DataTable10_1
   \   00000050   0x.... 0x....      BL       write_data
   \   00000054   0x0004             MOVS     R4,R0
    324                      if (status != kStatus_Success)
   \   00000056   0x2C00             CMP      R4,#+0
   \   00000058   0xD001             BEQ.N    ??wait_for_ack_packet_5
    325                      {
    326                          return status;
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0xE004             B.N      ??wait_for_ack_packet_2
    327                      }
    328                  }
    329              } while (sync.header.packetType == kFramingPacketType_Nak);
   \                     ??wait_for_ack_packet_5: (+1)
   \   0000005E   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000062   0x28A2             CMP      R0,#+162
   \   00000064   0xD0CE             BEQ.N    ??wait_for_ack_packet_0
    330          
    331              return kStatus_Success;
   \   00000066   0x2000             MOVS     R0,#+0
   \                     ??wait_for_ack_packet_2: (+1)
   \   00000068   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    332          }
    333          
    334          // See serial_packet.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    335          status_t serial_send_ping_response(const peripheral_descriptor_t *peripheral)
    336          {
   \                     serial_send_ping_response: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    337              assert(peripheral);
    338          
    339              // Only reply if we're in an idle state
    340              if (!g_serialContext.isAckNeeded || !g_serialContext.isBackToBackWrite || !g_serialContext.isAckAbortNeeded)
   \   00000006   0x....             LDR.N    R0,??DataTable10
   \   00000008   0xF890 0x0090      LDRB     R0,[R0, #+144]
   \   0000000C   0x....             LDR.N    R1,??DataTable10
   \   0000000E   0xF891 0x1091      LDRB     R1,[R1, #+145]
   \   00000012   0x4008             ANDS     R0,R1,R0
   \   00000014   0x....             LDR.N    R1,??DataTable10
   \   00000016   0xF891 0x1092      LDRB     R1,[R1, #+146]
   \   0000001A   0x4208             TST      R0,R1
   \   0000001C   0xD10F             BNE.N    ??serial_send_ping_response_0
    341              {
    342                  const uint8_t header[] = { kFramingPacketStartByte, kFramingPacketType_PingResponse };
   \   0000001E   0x....             LDR.N    R0,??DataTable10_2
   \   00000020   0x8800             LDRH     R0,[R0, #+0]
   \   00000022   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    343                  peripheral->byteInterface->write(peripheral, (const uint8_t *)&header, sizeof(header));
   \   00000026   0x2202             MOVS     R2,#+2
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x6923             LDR      R3,[R4, #+16]
   \   0000002E   0x685B             LDR      R3,[R3, #+4]
   \   00000030   0x4798             BLX      R3
    344                  peripheral->byteInterface->write(peripheral, (uint8_t *)&k_PingResponse, sizeof(k_PingResponse));
   \   00000032   0x2208             MOVS     R2,#+8
   \   00000034   0x....             LDR.N    R1,??DataTable10_3
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x6923             LDR      R3,[R4, #+16]
   \   0000003A   0x685B             LDR      R3,[R3, #+4]
   \   0000003C   0x4798             BLX      R3
    345              }
    346          
    347              return kStatus_Ping;
   \                     ??serial_send_ping_response_0: (+1)
   \   0000003E   0xF242 0x7013      MOVW     R0,#+10003
   \   00000042   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    348          }
    349          
    350          //! @brief Send ACK if needed.

   \                                 In section .text, align 2, keep-with-next
    351          static status_t send_deferred_ack()
    352          {
   \                     send_deferred_ack: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    353              if (g_serialContext.isAckNeeded)
   \   00000002   0x....             LDR.N    R0,??DataTable10
   \   00000004   0xF890 0x0090      LDRB     R0,[R0, #+144]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD007             BEQ.N    ??send_deferred_ack_0
    354              {
    355                  // Send Ack for last received packet.
    356                  g_serialContext.isAckNeeded = false;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x....             LDR.N    R1,??DataTable10
   \   00000010   0xF881 0x0090      STRB     R0,[R1, #+144]
    357                  return serial_packet_send_sync(kFramingPacketType_Ack);
   \   00000014   0x20A1             MOVS     R0,#+161
   \   00000016   0x.... 0x....      BL       serial_packet_send_sync
   \   0000001A   0xE00D             B.N      ??send_deferred_ack_1
    358              }
    359              else if (g_serialContext.isAckAbortNeeded)
   \                     ??send_deferred_ack_0: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable10
   \   0000001E   0xF890 0x0092      LDRB     R0,[R0, #+146]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD007             BEQ.N    ??send_deferred_ack_2
    360              {
    361                  // Send AckAbort for last received packet.
    362                  g_serialContext.isAckAbortNeeded = false;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x....             LDR.N    R1,??DataTable10
   \   0000002A   0xF881 0x0092      STRB     R0,[R1, #+146]
    363                  return serial_packet_send_sync(kFramingPacketType_AckAbort);
   \   0000002E   0x20A3             MOVS     R0,#+163
   \   00000030   0x.... 0x....      BL       serial_packet_send_sync
   \   00000034   0xE000             B.N      ??send_deferred_ack_1
    364              }
    365              else
    366              {
    367                  return kStatus_Success;
   \                     ??send_deferred_ack_2: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??send_deferred_ack_1: (+1)
   \   00000038   0xBD02             POP      {R1,PC}          ;; return
    368              }
    369          }
    370          
    371          //! @brief Write buffer to peripheral until all bytes sent.

   \                                 In section .text, align 2, keep-with-next
    372          static status_t write_data(const uint8_t *buffer, uint32_t byteCount)
    373          {
   \                     write_data: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    374              status_t retVal;
    375          
    376              retVal = g_bootloaderContext.activePeripheral->byteInterface->write(g_bootloaderContext.activePeripheral, buffer,
    377                                                                                  byteCount);
   \   00000006   0x002A             MOVS     R2,R5
   \   00000008   0x0021             MOVS     R1,R4
   \   0000000A   0x....             LDR.N    R0,??DataTable10_4
   \   0000000C   0x69C0             LDR      R0,[R0, #+28]
   \   0000000E   0x....             LDR.N    R3,??DataTable10_4
   \   00000010   0x69DB             LDR      R3,[R3, #+28]
   \   00000012   0x691B             LDR      R3,[R3, #+16]
   \   00000014   0x685B             LDR      R3,[R3, #+4]
   \   00000016   0x4798             BLX      R3
   \   00000018   0x0006             MOVS     R6,R0
    378          
    379              return retVal;
   \   0000001A   0x0030             MOVS     R0,R6
   \   0000001C   0xBD70             POP      {R4-R6,PC}       ;; return
    380          }
    381          
    382          //! @brief Read from peripheral until specified number of bytes received.

   \                                 In section .text, align 2, keep-with-next
    383          static status_t read_data(uint8_t *buffer, uint32_t byteCount, uint32_t timeoutMs)
    384          {
   \                     read_data: (+1)
   \   00000000   0xE92D 0x4FF5      PUSH     {R0,R2,R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4689             MOV      R9,R1
    385          #ifdef BOOTLOADER_HOST
    386              // Host will not be relying on interrupts for reads so manually read the data out
    387              return g_bootloaderContext.activePeripheral->byteInterface->read(g_bootloaderContext.activePeripheral, buffer,
    388                                                                               byteCount);
    389          #else
    390              // On the target we read from our interrupt buffer
    391              uint32_t currentBytesRead = 0;
   \   00000008   0xF05F 0x0800      MOVS     R8,#+0
    392              uint64_t startTicks = microseconds_get_ticks();
   \   0000000C   0x.... 0x....      BL       microseconds_get_ticks
   \   00000010   0x0004             MOVS     R4,R0
   \   00000012   0x000D             MOVS     R5,R1
    393              uint64_t timeOutTicks = microseconds_convert_to_ticks(timeoutMs * 1000);
   \   00000014   0x9804             LDR      R0,[SP, #+16]
   \   00000016   0xF44F 0x717A      MOV      R1,#+1000
   \   0000001A   0x4348             MULS     R0,R1,R0
   \   0000001C   0x.... 0x....      BL       microseconds_convert_to_ticks
   \   00000020   0x4682             MOV      R10,R0
   \   00000022   0x468B             MOV      R11,R1
    394              uint64_t endTicks = startTicks;
   \   00000024   0xE9CD 0x4500      STRD     R4,R5,[SP, #+0]
    395              uint64_t deltaTicks = 0;
   \   00000028   0x2600             MOVS     R6,#+0
   \   0000002A   0x2700             MOVS     R7,#+0
    396          
    397              while (currentBytesRead != byteCount)
   \                     ??read_data_0: (+1)
   \   0000002C   0x45C8             CMP      R8,R9
   \   0000002E   0xD04C             BEQ.N    ??read_data_1
    398              {
    399                  endTicks = microseconds_get_ticks();
   \   00000030   0x.... 0x....      BL       microseconds_get_ticks
   \   00000034   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
    400                  deltaTicks = endTicks - startTicks;
   \   00000038   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   0000003C   0x1B00             SUBS     R0,R0,R4
   \   0000003E   0x41A9             SBCS     R1,R1,R5
   \   00000040   0x0006             MOVS     R6,R0
   \   00000042   0x000F             MOVS     R7,R1
    401          
    402                  // Check timer roll over
    403                  if (endTicks < startTicks)
   \   00000044   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   00000048   0x42A9             CMP      R1,R5
   \   0000004A   0xD80D             BHI.N    ??read_data_2
   \   0000004C   0xD301             BCC.N    ??read_data_3
   \   0000004E   0x42A0             CMP      R0,R4
   \   00000050   0xD20A             BCS.N    ??read_data_2
    404                  {
    405                      deltaTicks = endTicks + (~startTicks) + 1;
   \                     ??read_data_3: (+1)
   \   00000052   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \   00000056   0x43E0             MVNS     R0,R4
   \   00000058   0x43E9             MVNS     R1,R5
   \   0000005A   0x1810             ADDS     R0,R2,R0
   \   0000005C   0x4159             ADCS     R1,R3,R1
   \   0000005E   0x1C40             ADDS     R0,R0,#+1
   \   00000060   0xF171 0x31FF      SBCS     R1,R1,#-1
   \   00000064   0x0006             MOVS     R6,R0
   \   00000066   0x000F             MOVS     R7,R1
    406                  }
    407          
    408                  if (timeOutTicks && (deltaTicks >= timeOutTicks))
   \                     ??read_data_2: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x458B             CMP      R11,R1
   \   0000006E   0xD101             BNE.N    ??read_data_4
   \   00000070   0x4582             CMP      R10,R0
   \   00000072   0xD006             BEQ.N    ??read_data_5
   \                     ??read_data_4: (+1)
   \   00000074   0x455F             CMP      R7,R11
   \   00000076   0xD304             BCC.N    ??read_data_5
   \   00000078   0xD801             BHI.N    ??read_data_6
   \   0000007A   0x4556             CMP      R6,R10
   \   0000007C   0xD301             BCC.N    ??read_data_5
    409                  {
    410                      return kStatus_Timeout;
   \                     ??read_data_6: (+1)
   \   0000007E   0x2005             MOVS     R0,#+5
   \   00000080   0xE024             B.N      ??read_data_7
    411                  }
    412          
    413                  if (g_serialContext.readOffset != g_serialContext.writeOffset)
   \                     ??read_data_5: (+1)
   \   00000082   0x....             LDR.N    R0,??DataTable10
   \   00000084   0xF8D0 0x008C      LDR      R0,[R0, #+140]
   \   00000088   0x....             LDR.N    R1,??DataTable10
   \   0000008A   0xF8D1 0x1088      LDR      R1,[R1, #+136]
   \   0000008E   0x4288             CMP      R0,R1
   \   00000090   0xD0CC             BEQ.N    ??read_data_0
    414                  {
    415                      buffer[currentBytesRead++] = g_serialContext.callbackBuffer[g_serialContext.readOffset++];
   \   00000092   0x....             LDR.N    R0,??DataTable10
   \   00000094   0x....             LDR.N    R1,??DataTable10
   \   00000096   0xF8D1 0x108C      LDR      R1,[R1, #+140]
   \   0000009A   0x4408             ADD      R0,R0,R1
   \   0000009C   0xF890 0x0020      LDRB     R0,[R0, #+32]
   \   000000A0   0x9903             LDR      R1,[SP, #+12]
   \   000000A2   0xF801 0x0008      STRB     R0,[R1, R8]
   \   000000A6   0x....             LDR.N    R0,??DataTable10
   \   000000A8   0xF8D0 0x008C      LDR      R0,[R0, #+140]
   \   000000AC   0x1C40             ADDS     R0,R0,#+1
   \   000000AE   0x....             LDR.N    R1,??DataTable10
   \   000000B0   0xF8C1 0x008C      STR      R0,[R1, #+140]
   \   000000B4   0xF118 0x0801      ADDS     R8,R8,#+1
    416          
    417                      g_serialContext.readOffset &= kCallbackBufferSize - 1;
   \   000000B8   0x....             LDR.N    R0,??DataTable10
   \   000000BA   0xF890 0x008C      LDRB     R0,[R0, #+140]
   \   000000BE   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   000000C2   0x....             LDR.N    R1,??DataTable10
   \   000000C4   0xF8C1 0x008C      STR      R0,[R1, #+140]
   \   000000C8   0xE7B0             B.N      ??read_data_0
    418                  }
    419              }
    420          
    421              return kStatus_Success;
   \                     ??read_data_1: (+1)
   \   000000CA   0x2000             MOVS     R0,#+0
   \                     ??read_data_7: (+1)
   \   000000CC   0xB005             ADD      SP,SP,#+20
   \   000000CE   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    422          #endif
    423          }
    424          
    425          //! @brief Read from peripheral until entire data framing packet read.

   \                                 In section .text, align 2, keep-with-next
    426          static status_t read_data_packet(framing_data_packet_t *packet, uint8_t *data, packet_type_t packetType)
    427          {
   \                     read_data_packet: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    428              // Read the packet header.
    429              status_t status = read_header(&packet->header);
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       read_header
   \   00000010   0x0007             MOVS     R7,R0
    430              if (status != kStatus_Success)
   \   00000012   0x2F00             CMP      R7,#+0
   \   00000014   0xD001             BEQ.N    ??read_data_packet_0
    431              {
    432                  return status;
   \   00000016   0x0038             MOVS     R0,R7
   \   00000018   0xE042             B.N      ??read_data_packet_1
    433              }
    434          
    435              if (packet->header.packetType == kFramingPacketType_Ping)
   \                     ??read_data_packet_0: (+1)
   \   0000001A   0x7860             LDRB     R0,[R4, #+1]
   \   0000001C   0x28A6             CMP      R0,#+166
   \   0000001E   0xD104             BNE.N    ??read_data_packet_2
    436              {
    437                  return serial_send_ping_response(g_bootloaderContext.activePeripheral);
   \   00000020   0x....             LDR.N    R0,??DataTable10_4
   \   00000022   0x69C0             LDR      R0,[R0, #+28]
   \   00000024   0x.... 0x....      BL       serial_send_ping_response
   \   00000028   0xE03A             B.N      ??read_data_packet_1
    438              }
    439          
    440              uint8_t expectedPacketType = kFramingPacketType_Command;
   \                     ??read_data_packet_2: (+1)
   \   0000002A   0xF05F 0x08A4      MOVS     R8,#+164
    441          
    442              if (packetType != kPacketType_Command)
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x2E00             CMP      R6,#+0
   \   00000032   0xD001             BEQ.N    ??read_data_packet_3
    443              {
    444                  expectedPacketType = kFramingPacketType_Data;
   \   00000034   0x20A5             MOVS     R0,#+165
   \   00000036   0x4680             MOV      R8,R0
    445              }
    446              if (packet->header.packetType != expectedPacketType)
   \                     ??read_data_packet_3: (+1)
   \   00000038   0x7860             LDRB     R0,[R4, #+1]
   \   0000003A   0x4641             MOV      R1,R8
   \   0000003C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD001             BEQ.N    ??read_data_packet_4
    447              {
    448                  debug_printf("Error: read_data_packet found unexpected packet type 0x%x\r\n", packet->header.packetType);
    449                  return kStatus_Fail;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xE02C             B.N      ??read_data_packet_1
    450              }
    451          
    452              // Read the packet length.
    453              status = read_length(packet);
   \                     ??read_data_packet_4: (+1)
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       read_length
   \   0000004C   0x0007             MOVS     R7,R0
    454              if (status != kStatus_Success)
   \   0000004E   0x2F00             CMP      R7,#+0
   \   00000050   0xD001             BEQ.N    ??read_data_packet_5
    455              {
    456                  return status;
   \   00000052   0x0038             MOVS     R0,R7
   \   00000054   0xE024             B.N      ??read_data_packet_1
    457              }
    458          
    459              // Make sure the packet doesn't exceed the allocated buffer size.
    460              packet->length = MIN(kIncomingPacketBufferSize, packet->length);
   \                     ??read_data_packet_5: (+1)
   \   00000056   0x8860             LDRH     R0,[R4, #+2]
   \   00000058   0x2821             CMP      R0,#+33
   \   0000005A   0xDB01             BLT.N    ??read_data_packet_6
   \   0000005C   0x2020             MOVS     R0,#+32
   \   0000005E   0xE000             B.N      ??read_data_packet_7
   \                     ??read_data_packet_6: (+1)
   \   00000060   0x8860             LDRH     R0,[R4, #+2]
   \                     ??read_data_packet_7: (+1)
   \   00000062   0x8060             STRH     R0,[R4, #+2]
    461          
    462              // Read the crc
    463              status = read_crc16(packet);
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       read_crc16
   \   0000006A   0x0007             MOVS     R7,R0
    464              if (status != kStatus_Success)
   \   0000006C   0x2F00             CMP      R7,#+0
   \   0000006E   0xD001             BEQ.N    ??read_data_packet_8
    465              {
    466                  return status;
   \   00000070   0x0038             MOVS     R0,R7
   \   00000072   0xE015             B.N      ??read_data_packet_1
    467              }
    468          
    469              // Read the data.
    470              if (packet->length > 0)
   \                     ??read_data_packet_8: (+1)
   \   00000074   0x8860             LDRH     R0,[R4, #+2]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD011             BEQ.N    ??read_data_packet_9
    471              {
    472                  // Clear the data area so unsent parameters default to zero.
    473                  memset(data, 0, packet->length);
   \   0000007A   0xF8B4 0x9002      LDRH     R9,[R4, #+2]
   \   0000007E   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000082   0x4652             MOV      R2,R10
   \   00000084   0x4649             MOV      R1,R9
   \   00000086   0x0028             MOVS     R0,R5
   \   00000088   0x.... 0x....      BL       __aeabi_memset
    474          
    475                  status = read_data(data, packet->length, kDefaultByteReadTimeoutMs * packet->length);
   \   0000008C   0x8860             LDRH     R0,[R4, #+2]
   \   0000008E   0x210A             MOVS     R1,#+10
   \   00000090   0xFB01 0xF200      MUL      R2,R1,R0
   \   00000094   0x8861             LDRH     R1,[R4, #+2]
   \   00000096   0x0028             MOVS     R0,R5
   \   00000098   0x.... 0x....      BL       read_data
   \   0000009C   0x0007             MOVS     R7,R0
    476              }
    477          
    478              return status;
   \                     ??read_data_packet_9: (+1)
   \   0000009E   0x0038             MOVS     R0,R7
   \                     ??read_data_packet_1: (+1)
   \   000000A0   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    479          }
    480          
    481          //! @brief Read from peripheral until start byte found.

   \                                 In section .text, align 2, keep-with-next
    482          static status_t read_start_byte(framing_header_t *header)
    483          {
   \                     read_start_byte: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    484          #if defined(BOOTLOADER_HOST)
    485              uint32_t startByteReadCount = 0;
    486          #endif
    487          
    488              // Read until start byte found.
    489              do
    490              {
    491                  status_t status = read_data(&header->startByte, 1, 0); // no timeout for first byte of packet
   \                     ??read_start_byte_0: (+1)
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       read_data
    492                  if (status != kStatus_Success)
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD103             BNE.N    ??read_start_byte_1
    493                  {
    494                      return status;
    495                  }
    496          
    497          #if defined(BOOTLOADER_HOST)
    498                  if (startByteReadCount++ > kHostMaxStartByteReadCount)
    499                  {
    500                      return kStatus_Timeout;
    501                  }
    502          
    503                  if (header->startByte != kFramingPacketStartByte)
    504                  {
    505                      // This will keep us from doing non necessary delays in case the byte received
    506                      // is actually the start byte, this delay and retry scenario is for cases when waiting
    507                      // for a response from a device that was issued a long running command like a flash-erase-region
    508                      // that may take several seconds to complete.
    509                      host_delay(kDefaultByteReadTimeoutMs);
    510                  }
    511          #endif
    512              } while (header->startByte != kFramingPacketStartByte);
   \                     ??read_start_byte_2: (+1)
   \   00000012   0x7820             LDRB     R0,[R4, #+0]
   \   00000014   0x285A             CMP      R0,#+90
   \   00000016   0xD1F5             BNE.N    ??read_start_byte_0
    513          
    514              return kStatus_Success;
   \   00000018   0x2000             MOVS     R0,#+0
   \                     ??read_start_byte_1: (+1)
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    515          }
    516          
    517          //! @brief Read from peripheral until packet header found.

   \                                 In section .text, align 2, keep-with-next
    518          static status_t read_header(framing_header_t *header)
    519          {
   \                     read_header: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    520              // Wait for start byte.
    521              status_t status = read_start_byte(header);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       read_start_byte
   \   0000000A   0x0005             MOVS     R5,R0
    522              if (status != kStatus_Success)
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xD001             BEQ.N    ??read_header_0
    523              {
    524                  return status;
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0xE004             B.N      ??read_header_1
    525              }
    526          
    527              return read_data(&header->packetType, sizeof(header->packetType),
    528                               kDefaultByteReadTimeoutMs * sizeof(header->packetType));
   \                     ??read_header_0: (+1)
   \   00000014   0x220A             MOVS     R2,#+10
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x1C60             ADDS     R0,R4,#+1
   \   0000001A   0x.... 0x....      BL       read_data
   \                     ??read_header_1: (+1)
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    529          }
    530          
    531          //! @brief Read from peripheral until packet length found.

   \                                 In section .text, align 2, keep-with-next
    532          static status_t read_length(framing_data_packet_t *packet)
    533          {
   \                     read_length: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    534              union
    535              {
    536                  uint8_t bytes[sizeof(uint16_t)];
    537                  uint16_t halfword;
    538              } buffer;
    539          
    540              status_t status = read_data((uint8_t *)&buffer.bytes, sizeof(buffer), kDefaultByteReadTimeoutMs * sizeof(buffer));
   \   00000006   0x2214             MOVS     R2,#+20
   \   00000008   0x2102             MOVS     R1,#+2
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       read_data
    541          
    542              packet->length = buffer.halfword;
   \   00000010   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000014   0x8061             STRH     R1,[R4, #+2]
    543              return status;
   \   00000016   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    544          }
    545          
    546          //! @brief Read from peripheral until crc16 is found.

   \                                 In section .text, align 2, keep-with-next
    547          static status_t read_crc16(framing_data_packet_t *packet)
    548          {
   \                     read_crc16: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    549              union
    550              {
    551                  uint8_t bytes[sizeof(uint16_t)];
    552                  uint16_t halfword;
    553              } buffer;
    554          
    555              status_t status = read_data((uint8_t *)&buffer.bytes, sizeof(buffer), kDefaultByteReadTimeoutMs * sizeof(buffer));
   \   00000006   0x2214             MOVS     R2,#+20
   \   00000008   0x2102             MOVS     R1,#+2
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       read_data
    556          
    557              packet->crc16 = buffer.halfword;
   \   00000010   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000014   0x80A1             STRH     R1,[R4, #+4]
    558              return status;
   \   00000016   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    559          }
    560          
    561          //! @brief Calculate crc over framing data packet.

   \                                 In section .text, align 2, keep-with-next
    562          static uint16_t calculate_framing_crc16(framing_data_packet_t *packet, const uint8_t *data)
    563          {
   \                     calculate_framing_crc16: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    564              uint16_t crc16;
    565          
    566              // Initialize the CRC16 information
    567              crc16_data_t crcInfo;
    568              crc16_init(&crcInfo);
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x.... 0x....      BL       crc16_init
    569          
    570              // Run CRC on all header bytes besides the CRC field
    571              crc16_update(&crcInfo, (uint8_t *)&packet->header.startByte, sizeof(framing_data_packet_t) - sizeof(uint16_t));
   \   0000000E   0x2204             MOVS     R2,#+4
   \   00000010   0x0021             MOVS     R1,R4
   \   00000012   0x4668             MOV      R0,SP
   \   00000014   0x.... 0x....      BL       crc16_update
    572          
    573              // Continue running CRC on any payload bytes
    574              crc16_update(&crcInfo, data, packet->length);
   \   00000018   0x8862             LDRH     R2,[R4, #+2]
   \   0000001A   0x0029             MOVS     R1,R5
   \   0000001C   0x4668             MOV      R0,SP
   \   0000001E   0x.... 0x....      BL       crc16_update
    575          
    576              // Finalize the CRC calculations
    577              crc16_finalize(&crcInfo, &crc16);
   \   00000022   0xA901             ADD      R1,SP,#+4
   \   00000024   0x4668             MOV      R0,SP
   \   00000026   0x.... 0x....      BL       crc16_finalize
    578          
    579              return crc16;
   \   0000002A   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   0000002E   0xBD3E             POP      {R1-R5,PC}       ;; return
    580          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     g_serialContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     g_serialContext+0x60

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     k_PingResponse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     g_bootloaderContext

   \                                 In section .rodata, align 2
   \                     ?_0:
   \   00000000   0x5A 0xA7          DC8 90, 167
    581          
    582          //! @}
    583          
    584          ////////////////////////////////////////////////////////////////////////////////
    585          // EOF
    586          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   calculate_framing_crc16
        24   -> crc16_finalize
        24   -> crc16_init
        24   -> crc16_update
      16   read_crc16
        16   -> read_data
      56   read_data
        56   -> microseconds_convert_to_ticks
        56   -> microseconds_get_ticks
      32   read_data_packet
        32   -> __aeabi_memset
        32   -> read_crc16
        32   -> read_data
        32   -> read_header
        32   -> read_length
        32   -> serial_send_ping_response
      16   read_header
        16   -> read_data
        16   -> read_start_byte
      16   read_length
        16   -> read_data
       8   read_start_byte
         8   -> read_data
       8   send_deferred_ack
         8   -> serial_packet_send_sync
       0   serial_packet_abort
       8   serial_packet_finalize
         8   -> send_deferred_ack
       0   serial_packet_get_max_packet_size
       0   serial_packet_init
       0   serial_packet_queue_byte
      48   serial_packet_read
        48   -> __aeabi_memset
        48   -> calculate_framing_crc16
        48   -> read_data_packet
        48   -> send_deferred_ack
        48   -> serial_packet_send_sync
      16   serial_packet_send_sync
        16   -> write_data
      32   serial_packet_write
        32   -> __aeabi_memcpy
        32   -> calculate_framing_crc16
        32   -> send_deferred_ack
        32   -> wait_for_ack_packet
        32   -> write_data
      16   serial_send_ping_response
        16   -- Indirect call
      16   wait_for_ack_packet
        16   -> read_header
        16   -> write_data
      16   write_data
        16   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       2  ?_0
      48  calculate_framing_crc16
      28  g_framingPacketInterface
     148  g_serialContext
       8  k_PingResponse
      24  read_crc16
     210  read_data
     164  read_data_packet
      32  read_header
      24  read_length
      28  read_start_byte
      58  send_deferred_ack
      18  serial_packet_abort
      10  serial_packet_finalize
       6  serial_packet_get_max_packet_size
       6  serial_packet_init
      50  serial_packet_queue_byte
     192  serial_packet_read
      38  serial_packet_send_sync
     150  serial_packet_write
      68  serial_send_ping_response
     106  wait_for_ack_packet
      30  write_data

 
   148 bytes in section .bss
    38 bytes in section .rodata
 1 282 bytes in section .text
 
 1 282 bytes of CODE  memory
    38 bytes of CONST memory
   148 bytes of DATA  memory

Errors: none
Warnings: none
