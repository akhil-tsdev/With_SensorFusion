###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:09
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\scuart_peripheral_interface.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\scuart_peripheral_interface.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\scuart_peripheral_interface.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\scuart_peripheral_interface.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\scuart_peripheral_interface.c
      1          /*
      2           * Copyright (c) 2013, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "bootloader/bl_context.h"
     32          #include "bootloader/bl_irq_common.h"
     33          #include "bootloader_common.h"
     34          #include "autobaud/autobaud.h"
     35          #include "packet/serial_packet.h"
     36          #include "fsl_device_registers.h"
     37          #include "uart/fsl_uart.h"
     38          #include "utilities/fsl_assert.h"
     39          
     40          #if BL_CONFIG_SCUART
     41          
     42          //! @addtogroup scuart_peripheral
     43          //! @{
     44          
     45          ////////////////////////////////////////////////////////////////////////////////
     46          // Definitions
     47          ////////////////////////////////////////////////////////////////////////////////
     48          
     49          ////////////////////////////////////////////////////////////////////////////////
     50          // Prototypes
     51          ////////////////////////////////////////////////////////////////////////////////
     52          
     53          static bool scuart_poll_for_activity(const peripheral_descriptor_t *self);
     54          static status_t scuart_full_init(const peripheral_descriptor_t *self, serial_byte_receive_func_t function);
     55          static void scuart_full_shutdown(const peripheral_descriptor_t *self);
     56          
     57          static status_t scuart_write(const peripheral_descriptor_t *self, const uint8_t *buffer, uint32_t byteCount);
     58          
     59          ////////////////////////////////////////////////////////////////////////////////
     60          // Variables
     61          ////////////////////////////////////////////////////////////////////////////////
     62          

   \                                 In section .rodata, align 4
     63          const peripheral_control_interface_t g_scuartControlInterface = {
   \                     g_scuartControlInterface:
   \   00000000   0x........         DC32 scuart_poll_for_activity, scuart_full_init, scuart_full_shutdown
   \              0x........   
   \              0x........   
   \   0000000C   0x00000000         DC32 0H
     64              .pollForActivity = scuart_poll_for_activity, .init = scuart_full_init, .shutdown = scuart_full_shutdown, .pump = 0
     65          };
     66          

   \                                 In section .rodata, align 4
     67          const peripheral_byte_inteface_t g_scuartByteInterface = {.init = NULL, .write = scuart_write };
   \                     g_scuartByteInterface:
   \   00000000   0x00000000         DC32 0H, scuart_write
   \              0x........   
     68          

   \                                 In section .bss, align 4
     69          static serial_byte_receive_func_t s_scuart_byte_receive_callback;
   \                     s_scuart_byte_receive_callback:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     70          static bool g_uartInitDone = false;
   \                     g_uartInitDone:
   \   00000000                      DS8 1
     71          
     72          ////////////////////////////////////////////////////////////////////////////////
     73          // Code
     74          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
     75          static UART_Type *get_uart_baseAddr(uint32_t instance)
     76          {
   \                     get_uart_baseAddr: (+1)
   \   00000000   0x0001             MOVS     R1,R0
     77              switch (instance)
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD008             BEQ.N    ??get_uart_baseAddr_0
   \   00000006   0xD305             BCC.N    ??get_uart_baseAddr_1
   \   00000008   0x2903             CMP      R1,#+3
   \   0000000A   0xD009             BEQ.N    ??get_uart_baseAddr_2
   \   0000000C   0xD306             BCC.N    ??get_uart_baseAddr_3
   \   0000000E   0x2905             CMP      R1,#+5
   \   00000010   0xD00A             BEQ.N    ??get_uart_baseAddr_4
   \   00000012   0xD307             BCC.N    ??get_uart_baseAddr_5
     78              {
     79                  default:
     80                  case 0:
     81                      return UART0;
   \                     ??get_uart_baseAddr_1: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable9  ;; 0x4006a000
   \   00000016   0xE008             B.N      ??get_uart_baseAddr_6
     82                  case 1:
     83                      return UART1;
   \                     ??get_uart_baseAddr_0: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable9_1  ;; 0x4006b000
   \   0000001A   0xE006             B.N      ??get_uart_baseAddr_6
     84          #if (FSL_FEATURE_SOC_UART_COUNT > 2U)
     85                  case 2:
     86                      return UART2;
   \                     ??get_uart_baseAddr_3: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable9_2  ;; 0x4006c000
   \   0000001E   0xE004             B.N      ??get_uart_baseAddr_6
     87          #if (FSL_FEATURE_SOC_UART_COUNT > 3U)
     88                  case 3:
     89                      return UART3;
   \                     ??get_uart_baseAddr_2: (+1)
   \   00000020   0x....             LDR.N    R0,??DataTable9_3  ;; 0x4006d000
   \   00000022   0xE002             B.N      ??get_uart_baseAddr_6
     90          #if (FSL_FEATURE_SOC_UART_COUNT > 4U)
     91                  case 4:
     92                      return UART4;
   \                     ??get_uart_baseAddr_5: (+1)
   \   00000024   0x....             LDR.N    R0,??DataTable9_4  ;; 0x400ea000
   \   00000026   0xE000             B.N      ??get_uart_baseAddr_6
     93          #if (FSL_FEATURE_SOC_UART_COUNT > 5U)
     94                  case 5:
     95                      return UART5;
   \                     ??get_uart_baseAddr_4: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable9_5  ;; 0x400eb000
   \                     ??get_uart_baseAddr_6: (+1)
   \   0000002A   0x4770             BX       LR               ;; return
     96          #endif // (FSL_FEATURE_SOC_UART_COUNT > 5U)
     97          #endif // (FSL_FEATURE_SOC_UART_COUNT > 4U)
     98          #endif // (FSL_FEATURE_SOC_UART_COUNT > 3U)
     99          #endif // (FSL_FEATURE_SOC_UART_COUNT > 2U)
    100              }
    101          }
    102          

   \                                 In section .text, align 2, keep-with-next
    103          bool scuart_poll_for_activity(const peripheral_descriptor_t *self)
    104          {
   \                     scuart_poll_for_activity: (+1)
   \   00000000   0xB57F             PUSH     {R0-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    105              uint32_t baud;
    106              status_t autoBaudCompleted = autobaud_get_rate(self->instance, &baud);
   \   00000004   0x4669             MOV      R1,SP
   \   00000006   0x6860             LDR      R0,[R4, #+4]
   \   00000008   0x.... 0x....      BL       autobaud_get_rate
   \   0000000C   0x0005             MOVS     R5,R0
    107          
    108              if (autoBaudCompleted == kStatus_Success)
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD135             BNE.N    ??scuart_poll_for_activity_0
    109              {
    110                  uart_config_t userConfig;
    111                  UART_Type *base = get_uart_baseAddr(self->instance);
   \   00000012   0x6860             LDR      R0,[R4, #+4]
   \   00000014   0x.... 0x....      BL       get_uart_baseAddr
   \   00000018   0x0006             MOVS     R6,R0
    112                  UART_GetDefaultConfig(&userConfig);
   \   0000001A   0xA801             ADD      R0,SP,#+4
   \   0000001C   0x.... 0x....      BL       UART_GetDefaultConfig
    113          
    114                  userConfig.baudRate_Bps = baud;
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x9001             STR      R0,[SP, #+4]
    115                  userConfig.enableTx = true;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xF88D 0x000B      STRB     R0,[SP, #+11]
    116                  userConfig.enableRx = true;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xF88D 0x000C      STRB     R0,[SP, #+12]
    117          
    118                  if (UART_Init(base, &userConfig, get_uart_clock(self->instance)) == kStatus_Success)
   \   00000030   0x6860             LDR      R0,[R4, #+4]
   \   00000032   0x.... 0x....      BL       get_uart_clock
   \   00000036   0x0002             MOVS     R2,R0
   \   00000038   0xA901             ADD      R1,SP,#+4
   \   0000003A   0x0030             MOVS     R0,R6
   \   0000003C   0x.... 0x....      BL       UART_Init
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD119             BNE.N    ??scuart_poll_for_activity_1
    119                  {
    120                      UART_SetSystemIRQ(self->instance, kPeripheralEnableIRQ);
   \   00000044   0x2101             MOVS     R1,#+1
   \   00000046   0x6860             LDR      R0,[R4, #+4]
   \   00000048   0x.... 0x....      BL       UART_SetSystemIRQ
    121                      UART_EnableInterrupts(base, kUART_RxDataRegFullInterruptEnable);
   \   0000004C   0xF44F 0x5100      MOV      R1,#+8192
   \   00000050   0x0030             MOVS     R0,R6
   \   00000052   0x.... 0x....      BL       UART_EnableInterrupts
    122                      // Configure selected pin as uart peripheral interface
    123                      self->pinmuxConfig(self->instance, kPinmuxType_Peripheral);
   \   00000056   0x2102             MOVS     R1,#+2
   \   00000058   0x6860             LDR      R0,[R4, #+4]
   \   0000005A   0x68A2             LDR      R2,[R4, #+8]
   \   0000005C   0x4790             BLX      R2
    124          
    125                      // This was the byte pattern identified in autobaud detection, inform the command layer
    126                      s_scuart_byte_receive_callback(kFramingPacketStartByte);
   \   0000005E   0x205A             MOVS     R0,#+90
   \   00000060   0x....             LDR.N    R1,??DataTable9_6
   \   00000062   0x6809             LDR      R1,[R1, #+0]
   \   00000064   0x4788             BLX      R1
    127                      s_scuart_byte_receive_callback(kFramingPacketType_Ping);
   \   00000066   0x20A6             MOVS     R0,#+166
   \   00000068   0x....             LDR.N    R1,??DataTable9_6
   \   0000006A   0x6809             LDR      R1,[R1, #+0]
   \   0000006C   0x4788             BLX      R1
    128          
    129                      g_uartInitDone = true;
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0x....             LDR.N    R1,??DataTable9_7
   \   00000072   0x7008             STRB     R0,[R1, #+0]
    130          
    131                      return true;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xE003             B.N      ??scuart_poll_for_activity_2
    132                  }
    133                  else
    134                  {
    135                      autobaud_init(self->instance);
   \                     ??scuart_poll_for_activity_1: (+1)
   \   00000078   0x6860             LDR      R0,[R4, #+4]
   \   0000007A   0x.... 0x....      BL       autobaud_init
    136                  }  
    137              }
    138          
    139              return false;
   \                     ??scuart_poll_for_activity_0: (+1)
   \   0000007E   0x2000             MOVS     R0,#+0
   \                     ??scuart_poll_for_activity_2: (+1)
   \   00000080   0xB004             ADD      SP,SP,#+16
   \   00000082   0xBD70             POP      {R4-R6,PC}       ;; return
    140          }
    141          

   \                                 In section .text, align 2, keep-with-next
    142          status_t scuart_full_init(const peripheral_descriptor_t *self, serial_byte_receive_func_t function)
    143          {
   \                     scuart_full_init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    144              s_scuart_byte_receive_callback = function;
   \   00000006   0x....             LDR.N    R0,??DataTable9_6
   \   00000008   0x6005             STR      R5,[R0, #+0]
    145          
    146              // Since we are using autobaud once the detection is completed
    147              // it will call the UART initialization and remux the pins when it completes
    148              self->pinmuxConfig(self->instance, kPinmuxType_GPIO);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x6860             LDR      R0,[R4, #+4]
   \   0000000E   0x68A2             LDR      R2,[R4, #+8]
   \   00000010   0x4790             BLX      R2
    149          
    150              // Init autobaud detector.
    151              autobaud_init(self->instance);
   \   00000012   0x6860             LDR      R0,[R4, #+4]
   \   00000014   0x.... 0x....      BL       autobaud_init
    152          
    153              return kStatus_Success;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    154          }
    155          

   \                                 In section .text, align 2, keep-with-next
    156          void scuart_full_shutdown(const peripheral_descriptor_t *self)
    157          {
   \                     scuart_full_shutdown: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    158              if (g_uartInitDone)
   \   00000004   0x....             LDR.N    R0,??DataTable9_7
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD008             BEQ.N    ??scuart_full_shutdown_0
    159              {
    160                  UART_SetSystemIRQ(self->instance, kPeripheralDisableIRQ);
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6860             LDR      R0,[R4, #+4]
   \   00000010   0x.... 0x....      BL       UART_SetSystemIRQ
    161                  UART_Deinit(get_uart_baseAddr(self->instance));
   \   00000014   0x6860             LDR      R0,[R4, #+4]
   \   00000016   0x.... 0x....      BL       get_uart_baseAddr
   \   0000001A   0x.... 0x....      BL       UART_Deinit
    162              }
    163          
    164          //! Note: if not deinit autobaud(IRQ method), user app may encounters hardfault
    165          //! if it doesn't provide related pin interrupt service routine.
    166          #if BL_FEATURE_UART_AUTOBAUD_IRQ
    167              // De-init autobaud detector.
    168              autobaud_deinit(self->instance);
   \                     ??scuart_full_shutdown_0: (+1)
   \   0000001E   0x6860             LDR      R0,[R4, #+4]
   \   00000020   0x.... 0x....      BL       autobaud_deinit
    169          #endif
    170              // Restore selected pin to default state to reduce IDD.
    171              self->pinmuxConfig(self->instance, kPinmuxType_Default);
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x6860             LDR      R0,[R4, #+4]
   \   00000028   0x68A2             LDR      R2,[R4, #+8]
   \   0000002A   0x4790             BLX      R2
    172          }
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    173          

   \                                 In section .text, align 2, keep-with-next
    174          status_t scuart_write(const peripheral_descriptor_t *self, const uint8_t *buffer, uint32_t byteCount)
    175          {
   \                     scuart_write: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    176              UART_WriteBlocking(get_uart_baseAddr(self->instance), buffer, byteCount);
   \   00000008   0x6860             LDR      R0,[R4, #+4]
   \   0000000A   0x.... 0x....      BL       get_uart_baseAddr
   \   0000000E   0x0032             MOVS     R2,R6
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0x.... 0x....      BL       UART_WriteBlocking
    177              return kStatus_Success;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD70             POP      {R4-R6,PC}       ;; return
    178          }
    179          
    180          /********************************************************************/
    181          /*
    182           * UART0 IRQ Handler
    183           *
    184           */
    185          

   \                                 In section .text, align 2, keep-with-next
    186          void UART0_RX_TX_IRQHandler(void)
    187          {
   \                     UART0_RX_TX_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    188              if (UART0->S1 & UART_S1_RDRF_MASK)
   \   00000002   0x....             LDR.N    R0,??DataTable9_8  ;; 0x4006a004
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x0680             LSLS     R0,R0,#+26
   \   00000008   0xD505             BPL.N    ??UART0_RX_TX_IRQHandler_0
    189              {
    190                  s_scuart_byte_receive_callback(UART0->D);
   \   0000000A   0x....             LDR.N    R0,??DataTable9_9  ;; 0x4006a007
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x....             LDR.N    R1,??DataTable9_6
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x4788             BLX      R1
    191              }
    192          }
   \                     ??UART0_RX_TX_IRQHandler_0: (+1)
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    193          
    194          /********************************************************************/
    195          /*
    196           * UART1 IRQ Handler
    197           *
    198           */
    199          

   \                                 In section .text, align 2, keep-with-next
    200          void UART1_RX_TX_IRQHandler(void)
    201          {
   \                     UART1_RX_TX_IRQHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    202              uint8_t s1 = UART1->S1;
   \   00000002   0x....             LDR.N    R0,??DataTable9_10  ;; 0x4006b004
   \   00000004   0x7804             LDRB     R4,[R0, #+0]
    203              uint8_t d;
    204          
    205              if (s1 & UART_S1_FE_MASK)
   \   00000006   0x07A0             LSLS     R0,R4,#+30
   \   00000008   0xD503             BPL.N    ??UART1_RX_TX_IRQHandler_0
    206              {
    207                  d = UART1->D;
   \   0000000A   0x....             LDR.N    R0,??DataTable9_11  ;; 0x4006b007
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x0005             MOVS     R5,R0
   \   00000010   0xE009             B.N      ??UART1_RX_TX_IRQHandler_1
    208              }
    209              else if (s1 & UART_S1_RDRF_MASK)
   \                     ??UART1_RX_TX_IRQHandler_0: (+1)
   \   00000012   0x06A0             LSLS     R0,R4,#+26
   \   00000014   0xD507             BPL.N    ??UART1_RX_TX_IRQHandler_1
    210              {
    211                  d = UART1->D;
   \   00000016   0x....             LDR.N    R0,??DataTable9_11  ;; 0x4006b007
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x0005             MOVS     R5,R0
    212                  s_scuart_byte_receive_callback(d);
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x....             LDR.N    R1,??DataTable9_6
   \   00000022   0x6809             LDR      R1,[R1, #+0]
   \   00000024   0x4788             BLX      R1
    213              }
    214          }
   \                     ??UART1_RX_TX_IRQHandler_1: (+1)
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    215          
    216          #if (FSL_FEATURE_SOC_UART_COUNT > 2U)
    217          /********************************************************************/
    218          /*
    219           * UART2 IRQ Handler
    220           *
    221           */
    222          

   \                                 In section .text, align 2, keep-with-next
    223          void UART2_RX_TX_IRQHandler(void)
    224          {
   \                     UART2_RX_TX_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    225              if (UART2->S1 & UART_S1_RDRF_MASK)
   \   00000002   0x....             LDR.N    R0,??DataTable9_12  ;; 0x4006c004
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x0680             LSLS     R0,R0,#+26
   \   00000008   0xD505             BPL.N    ??UART2_RX_TX_IRQHandler_0
    226              {
    227                  s_scuart_byte_receive_callback(UART2->D);
   \   0000000A   0x....             LDR.N    R0,??DataTable9_13  ;; 0x4006c007
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x....             LDR.N    R1,??DataTable9_6
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x4788             BLX      R1
    228              }
    229          }
   \                     ??UART2_RX_TX_IRQHandler_0: (+1)
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    230          
    231          #if (FSL_FEATURE_SOC_UART_COUNT > 3U)
    232          
    233          /********************************************************************/
    234          /*
    235           * UART3 IRQ Handler
    236           *
    237           */
    238          

   \                                 In section .text, align 2, keep-with-next
    239          void UART3_RX_TX_IRQHandler(void)
    240          {
   \                     UART3_RX_TX_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    241              if (UART3->S1 & UART_S1_RDRF_MASK)
   \   00000002   0x....             LDR.N    R0,??DataTable9_14  ;; 0x4006d004
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x0680             LSLS     R0,R0,#+26
   \   00000008   0xD505             BPL.N    ??UART3_RX_TX_IRQHandler_0
    242              {
    243                  s_scuart_byte_receive_callback(UART3->D);
   \   0000000A   0x....             LDR.N    R0,??DataTable9_15  ;; 0x4006d007
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x....             LDR.N    R1,??DataTable9_6
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x4788             BLX      R1
    244              }
    245          }
   \                     ??UART3_RX_TX_IRQHandler_0: (+1)
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    246          
    247          /********************************************************************/
    248          /*
    249           * UART4 IRQ Handler
    250           *
    251           */
    252          

   \                                 In section .text, align 2, keep-with-next
    253          void UART4_RX_TX_IRQHandler(void)
    254          {
   \                     UART4_RX_TX_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    255              if (UART4->S1 & UART_S1_RDRF_MASK)
   \   00000002   0x....             LDR.N    R0,??DataTable9_16  ;; 0x400ea004
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x0680             LSLS     R0,R0,#+26
   \   00000008   0xD505             BPL.N    ??UART4_RX_TX_IRQHandler_0
    256              {
    257                  s_scuart_byte_receive_callback(UART4->D);
   \   0000000A   0x....             LDR.N    R0,??DataTable9_17  ;; 0x400ea007
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x....             LDR.N    R1,??DataTable9_6
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x4788             BLX      R1
    258              }
    259          }
   \                     ??UART4_RX_TX_IRQHandler_0: (+1)
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    260          
    261          #if (FSL_FEATURE_SOC_UART_COUNT > 5U)
    262          /********************************************************************/
    263          /*
    264           * UART5 IRQ Handler
    265           *
    266           */
    267          

   \                                 In section .text, align 2, keep-with-next
    268          void UART5_RX_TX_IRQHandler(void)
    269          {
   \                     UART5_RX_TX_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    270              if (UART5->S1 & UART_S1_RDRF_MASK)
   \   00000002   0x....             LDR.N    R0,??DataTable9_18  ;; 0x400eb004
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x0680             LSLS     R0,R0,#+26
   \   00000008   0xD505             BPL.N    ??UART5_RX_TX_IRQHandler_0
    271              {
    272                  s_scuart_byte_receive_callback(UART5->D);
   \   0000000A   0x....             LDR.N    R0,??DataTable9_19  ;; 0x400eb007
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x....             LDR.N    R1,??DataTable9_6
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x4788             BLX      R1
    273              }
    274          }
   \                     ??UART5_RX_TX_IRQHandler_0: (+1)
   \   00000016   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x4006A000         DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x4006B000         DC32     0x4006b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x4006C000         DC32     0x4006c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x4006D000         DC32     0x4006d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x400EA000         DC32     0x400ea000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x400EB000         DC32     0x400eb000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     s_scuart_byte_receive_callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     g_uartInitDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x4006A004         DC32     0x4006a004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x4006A007         DC32     0x4006a007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x4006B004         DC32     0x4006b004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x4006B007         DC32     0x4006b007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x4006C004         DC32     0x4006c004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x4006C007         DC32     0x4006c007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x4006D004         DC32     0x4006d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   0x4006D007         DC32     0x4006d007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \   00000000   0x400EA004         DC32     0x400ea004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \   00000000   0x400EA007         DC32     0x400ea007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_18:
   \   00000000   0x400EB004         DC32     0x400eb004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_19:
   \   00000000   0x400EB007         DC32     0x400eb007
    275          
    276          #endif // (FSL_FEATURE_SOC_UART_COUNT > 5U)
    277          #endif // (FSL_FEATURE_SOC_UART_COUNT > 3U)
    278          #endif // (FSL_FEATURE_SOC_UART_COUNT > 2U)
    279          
    280          //! @}
    281          
    282          #endif // BL_CONFIG_SCUART
    283          
    284          ////////////////////////////////////////////////////////////////////////////////
    285          // EOF
    286          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   UART0_RX_TX_IRQHandler
         8   -- Indirect call
      16   UART1_RX_TX_IRQHandler
        16   -- Indirect call
       8   UART2_RX_TX_IRQHandler
         8   -- Indirect call
       8   UART3_RX_TX_IRQHandler
         8   -- Indirect call
       8   UART4_RX_TX_IRQHandler
         8   -- Indirect call
       8   UART5_RX_TX_IRQHandler
         8   -- Indirect call
       0   get_uart_baseAddr
      16   scuart_full_init
        16   -- Indirect call
        16   -> autobaud_init
       8   scuart_full_shutdown
         8   -- Indirect call
         8   -> UART_Deinit
         8   -> UART_SetSystemIRQ
         8   -> autobaud_deinit
         8   -> get_uart_baseAddr
      32   scuart_poll_for_activity
        32   -- Indirect call
        32   -> UART_EnableInterrupts
        32   -> UART_GetDefaultConfig
        32   -> UART_Init
        32   -> UART_SetSystemIRQ
        32   -> autobaud_get_rate
        32   -> autobaud_init
        32   -> get_uart_baseAddr
        32   -> get_uart_clock
      16   scuart_write
        16   -> UART_WriteBlocking
        16   -> get_uart_baseAddr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_18
       4  ??DataTable9_19
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      24  UART0_RX_TX_IRQHandler
      40  UART1_RX_TX_IRQHandler
      24  UART2_RX_TX_IRQHandler
      24  UART3_RX_TX_IRQHandler
      24  UART4_RX_TX_IRQHandler
      24  UART5_RX_TX_IRQHandler
       8  g_scuartByteInterface
      16  g_scuartControlInterface
       1  g_uartInitDone
      44  get_uart_baseAddr
       4  s_scuart_byte_receive_callback
      28  scuart_full_init
      46  scuart_full_shutdown
     132  scuart_poll_for_activity
      26  scuart_write

 
   5 bytes in section .bss
  24 bytes in section .rodata
 516 bytes in section .text
 
 516 bytes of CODE  memory
  24 bytes of CONST memory
   5 bytes of DATA  memory

Errors: none
Warnings: none
