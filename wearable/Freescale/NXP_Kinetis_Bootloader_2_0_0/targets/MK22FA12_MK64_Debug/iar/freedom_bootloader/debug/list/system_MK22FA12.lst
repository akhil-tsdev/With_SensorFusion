###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:12
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\src\startup\system_MK22FA12.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\src\startup\system_MK22FA12.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\system_MK22FA12.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\system_MK22FA12.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\src\startup\system_MK22FA12.c
      1          /*
      2          ** ###################################################################
      3          **     Processors:          MK22FN1M0AVLH12
      4          **                          MK22FX512AVLH12
      5          **                          MK22FN1M0AVLK12
      6          **                          MK22FX512AVLK12
      7          **                          MK22FN1M0AVLL12
      8          **                          MK22FX512AVLL12
      9          **                          MK22FN1M0AVLQ12
     10          **                          MK22FX512AVLQ12
     11          **                          MK22FN1M0AVMC12
     12          **                          MK22FX512AVMC12
     13          **                          MK22FN1M0AVMD12
     14          **                          MK22FX512AVMD12
     15          **
     16          **     Compilers:           Keil ARM C/C++ Compiler
     17          **                          Freescale C/C++ for Embedded ARM
     18          **                          GNU C Compiler
     19          **                          GNU C Compiler - CodeSourcery Sourcery G++
     20          **                          IAR ANSI C/C++ Compiler for ARM
     21          **
     22          **     Reference manuals:   K22P64M120SF5V2RM, Rev.5, March 2015
     23          **                          K22P80M120SF5V2RM, Rev.5, March 2015
     24          **                          K22P100M120SF5V2RM, Rev.5, March 2015
     25          **                          K22P144M120SF5V2RM, Rev.5, March 2015
     26          **
     27          **     Version:             rev. 1.0, 2015-04-07
     28          **     Build:               b150408
     29          **
     30          **     Abstract:
     31          **         Provides a system configuration function and a global variable that
     32          **         contains the system frequency. It configures the device and initializes
     33          **         the oscillator (PLL) that is part of the microcontroller device.
     34          **
     35          **     Copyright (c) 2015 Freescale Semiconductor, Inc.
     36          **     All rights reserved.
     37          **
     38          **     Redistribution and use in source and binary forms, with or without modification,
     39          **     are permitted provided that the following conditions are met:
     40          **
     41          **     o Redistributions of source code must retain the above copyright notice, this list
     42          **       of conditions and the following disclaimer.
     43          **
     44          **     o Redistributions in binary form must reproduce the above copyright notice, this
     45          **       list of conditions and the following disclaimer in the documentation and/or
     46          **       other materials provided with the distribution.
     47          **
     48          **     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     49          **       contributors may be used to endorse or promote products derived from this
     50          **       software without specific prior written permission.
     51          **
     52          **     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     53          **     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     54          **     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     55          **     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     56          **     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     57          **     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     58          **     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     59          **     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     60          **     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     61          **     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     62          **
     63          **     http:                 www.freescale.com
     64          **     mail:                 support@freescale.com
     65          **
     66          **     Revisions:
     67          **     - rev. 1.0 (2015-04-07)
     68          **         Initial version
     69          **
     70          ** ###################################################################
     71          */
     72          
     73          /*!
     74           * @file MK22FA12
     75           * @version 1.0
     76           * @date 2015-04-07
     77           * @brief Device specific configuration file for MK22FA12 (implementation file)
     78           *
     79           * Provides a system configuration function and a global variable that contains
     80           * the system frequency. It configures the device and initializes the oscillator
     81           * (PLL) that is part of the microcontroller device.
     82           */
     83          
     84          #include <stdint.h>
     85          #include "fsl_device_registers.h"
     86          
     87          
     88          
     89          /* ----------------------------------------------------------------------------
     90             -- Core clock
     91             ---------------------------------------------------------------------------- */
     92          

   \                                 In section .data, align 4
     93          uint32_t SystemCoreClock = DEFAULT_SYSTEM_CLOCK;
   \                     SystemCoreClock:
   \   00000000   0x01400000         DC32 20971520
     94          
     95          /* ----------------------------------------------------------------------------
     96             -- SystemInit()
     97             ---------------------------------------------------------------------------- */
     98          

   \                                 In section .text, align 2, keep-with-next
     99          void SystemInit (void) {
    100          #if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
    101            SCB->CPACR |= ((3UL << 10*2) | (3UL << 11*2));    /* set CP10, CP11 Full Access */
   \                     SystemInit: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable1  ;; 0xe000ed88
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF450 0x0070      ORRS     R0,R0,#0xF00000
   \   00000008   0x....             LDR.N    R1,??DataTable1  ;; 0xe000ed88
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    102          #endif /* ((__FPU_PRESENT == 1) && (__FPU_USED == 1)) */
    103          
    104          #if (DISABLE_WDOG)
    105            /* WDOG->UNLOCK: WDOGUNLOCK=0xC520 */
    106            WDOG->UNLOCK = WDOG_UNLOCK_WDOGUNLOCK(0xC520); /* Key 1 */
   \   0000000C   0xF24C 0x5020      MOVW     R0,#+50464
   \   00000010   0x....             LDR.N    R1,??DataTable1_1  ;; 0x4005200e
   \   00000012   0x8008             STRH     R0,[R1, #+0]
    107            /* WDOG->UNLOCK: WDOGUNLOCK=0xD928 */
    108            WDOG->UNLOCK = WDOG_UNLOCK_WDOGUNLOCK(0xD928); /* Key 2 */
   \   00000014   0xF64D 0x1028      MOVW     R0,#+55592
   \   00000018   0x....             LDR.N    R1,??DataTable1_1  ;; 0x4005200e
   \   0000001A   0x8008             STRH     R0,[R1, #+0]
    109            /* WDOG->STCTRLH: ?=0,DISTESTWDOG=0,BYTESEL=0,TESTSEL=0,TESTWDOG=0,?=0,?=1,WAITEN=1,STOPEN=1,DBGEN=0,ALLOWUPDATE=1,WINEN=0,IRQRSTEN=0,CLKSRC=1,WDOGEN=0 */
    110            WDOG->STCTRLH = WDOG_STCTRLH_BYTESEL(0x00) |
    111                           WDOG_STCTRLH_WAITEN_MASK |
    112                           WDOG_STCTRLH_STOPEN_MASK |
    113                           WDOG_STCTRLH_ALLOWUPDATE_MASK |
    114                           WDOG_STCTRLH_CLKSRC_MASK |
    115                           0x0100U;
   \   0000001C   0xF44F 0x70E9      MOV      R0,#+466
   \   00000020   0x....             LDR.N    R1,??DataTable1_2  ;; 0x40052000
   \   00000022   0x8008             STRH     R0,[R1, #+0]
    116          #endif /* (DISABLE_WDOG) */
    117          #ifdef CLOCK_SETUP
    118            if((RCM->SRS0 & RCM_SRS0_WAKEUP_MASK) != 0x00U)
    119            {
    120              if((PMC->REGSC & PMC_REGSC_ACKISO_MASK) != 0x00U)
    121              {
    122                 PMC->REGSC |= PMC_REGSC_ACKISO_MASK; /* Release hold with ACKISO:  Only has an effect if recovering from VLLSx.*/
    123              }
    124            } else {
    125          #ifdef SYSTEM_RTC_CR_VALUE
    126              SIM_SCGC6 |= SIM_SCGC6_RTC_MASK;
    127              if ((RTC_CR & RTC_CR_OSCE_MASK) == 0x00U) { /* Only if the OSCILLATOR is not already enabled */
    128                RTC_CR = (uint32_t)((RTC_CR & (uint32_t)~(uint32_t)(RTC_CR_SC2P_MASK | RTC_CR_SC4P_MASK | RTC_CR_SC8P_MASK | RTC_CR_SC16P_MASK)) | (uint32_t)SYSTEM_RTC_CR_VALUE);
    129                RTC_CR |= (uint32_t)RTC_CR_OSCE_MASK;
    130                RTC_CR &= (uint32_t)~(uint32_t)RTC_CR_CLKO_MASK;
    131              }
    132          #endif
    133            }
    134          
    135            /* Power mode protection initialization */
    136          #ifdef SYSTEM_SMC_PMPROT_VALUE
    137            SMC->PMPROT = SYSTEM_SMC_PMPROT_VALUE;
    138          #endif
    139          
    140            /* System clock initialization */
    141            /* Internal reference clock trim initialization */
    142          #if defined(SLOW_TRIM_ADDRESS)
    143            if ( *((uint8_t*)SLOW_TRIM_ADDRESS) != 0xFFU) {                              /* Skip if non-volatile flash memory is erased */
    144              MCG->C3 = *((uint8_t*)SLOW_TRIM_ADDRESS);
    145            #endif /* defined(SLOW_TRIM_ADDRESS) */
    146            #if defined(SLOW_FINE_TRIM_ADDRESS)
    147              MCG->C4 = (MCG->C4 & ~(MCG_C4_SCFTRIM_MASK)) | ((*((uint8_t*) SLOW_FINE_TRIM_ADDRESS)) & MCG_C4_SCFTRIM_MASK);
    148            #endif
    149            #if defined(FAST_TRIM_ADDRESS)
    150              MCG->C4 = (MCG->C4 & ~(MCG_C4_FCTRIM_MASK)) |((*((uint8_t*) FAST_TRIM_ADDRESS)) & MCG_C4_FCTRIM_MASK);
    151            #endif
    152          #if defined(SLOW_TRIM_ADDRESS)
    153            }
    154            #endif /* defined(SLOW_TRIM_ADDRESS) */
    155          
    156            /* Set system prescalers and clock sources */
    157            SIM->CLKDIV1 = SYSTEM_SIM_CLKDIV1_VALUE; /* Set system prescalers */
    158            SIM->SOPT1 = ((SIM->SOPT1) & (uint32_t)(~(SIM_SOPT1_OSC32KSEL_MASK))) | ((SYSTEM_SIM_SOPT1_VALUE) & (SIM_SOPT1_OSC32KSEL_MASK)); /* Set 32 kHz clock source (ERCLK32K) */
    159            SIM->SOPT2 = ((SIM->SOPT2) & (uint32_t)(~(SIM_SOPT2_PLLFLLSEL_MASK))) | ((SYSTEM_SIM_SOPT2_VALUE) & (SIM_SOPT2_PLLFLLSEL_MASK)); /* Selects the high frequency clock for various peripheral clocking options. */
    160          #if ((MCG_MODE == MCG_MODE_FEI) || (MCG_MODE == MCG_MODE_FBI) || (MCG_MODE == MCG_MODE_BLPI))
    161            /* Set MCG and OSC */
    162          #if  ((((SYSTEM_OSC_CR_VALUE) & OSC_CR_ERCLKEN_MASK) != 0x00U) || ((((SYSTEM_MCG_C5_VALUE) & MCG_C5_PLLCLKEN0_MASK) != 0x00U) && (((SYSTEM_MCG_C7_VALUE) & MCG_C7_OSCSEL_MASK) == 0x00U)))
    163            /* SIM_SCGC5: PORTA=1 */
    164            SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
    165            /* PORTA_PCR18: ISF=0,MUX=0 */
    166            PORTA_PCR18 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
    167            if (((SYSTEM_MCG_C2_VALUE) & MCG_C2_EREFS0_MASK) != 0x00U) {
    168            /* PORTA_PCR19: ISF=0,MUX=0 */
    169            PORTA_PCR19 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
    170            }
    171          #endif
    172            MCG->SC = SYSTEM_MCG_SC_VALUE;       /* Set SC (fast clock internal reference divider) */
    173            MCG->C1 = SYSTEM_MCG_C1_VALUE;       /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) */
    174            /* Check that the source of the FLL reference clock is the requested one. */
    175            if (((SYSTEM_MCG_C1_VALUE) & MCG_C1_IREFS_MASK) != 0x00U) {
    176              while((MCG->S & MCG_S_IREFST_MASK) == 0x00U) {
    177              }
    178            } else {
    179              while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) {
    180              }
    181            }
    182            MCG->C2 = (SYSTEM_MCG_C2_VALUE) & (uint8_t)(~(MCG_C2_LP_MASK)); /* Set C2 (freq. range, ext. and int. reference selection etc.; low power bit is set later) */
    183            MCG->C4 = ((SYSTEM_MCG_C4_VALUE) & (uint8_t)(~(MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK))) | (MCG->C4 & (MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK)); /* Set C4 (FLL output; trim values not changed) */
    184            OSC->CR = SYSTEM_OSC_CR_VALUE;       /* Set OSC_CR (OSCERCLK enable, oscillator capacitor load) */
    185            MCG->C7 = SYSTEM_MCG_C7_VALUE;       /* Set C7 (OSC Clock Select) */
    186            #if (MCG_MODE == MCG_MODE_BLPI)
    187            /* BLPI specific */
    188            MCG->C2 |= (MCG_C2_LP_MASK);         /* Disable FLL and PLL in bypass mode */
    189            #endif
    190          
    191          #else /* MCG_MODE */
    192            /* Set MCG and OSC */
    193          #if  (((SYSTEM_OSC_CR_VALUE) & OSC_CR_ERCLKEN_MASK) != 0x00U) || (((SYSTEM_MCG_C7_VALUE) & MCG_C7_OSCSEL_MASK) == 0x00U)
    194            /* SIM_SCGC5: PORTA=1 */
    195            SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
    196            /* PORTA_PCR18: ISF=0,MUX=0 */
    197            PORTA_PCR18 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
    198            if (((SYSTEM_MCG_C2_VALUE) & MCG_C2_EREFS0_MASK) != 0x00U) {
    199            /* PORTA_PCR19: ISF=0,MUX=0 */
    200            PORTA_PCR19 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
    201            }
    202          #endif
    203            MCG->SC = SYSTEM_MCG_SC_VALUE;       /* Set SC (fast clock internal reference divider) */
    204            MCG->C2 = SYSTEM_MCG_C2_VALUE;       /* Set C2 (freq. range, ext. and int. reference selection etc.) */
    205            OSC->CR = SYSTEM_OSC_CR_VALUE;       /* Set OSC_CR (OSCERCLK enable, oscillator capacitor load) */
    206            MCG->C7 = SYSTEM_MCG_C7_VALUE;       /* Set C7 (OSC Clock Select) */
    207            #if (MCG_MODE == MCG_MODE_PEE)
    208            MCG->C1 = (SYSTEM_MCG_C1_VALUE) | MCG_C1_CLKS(0x02); /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) - PBE mode*/
    209            #else
    210            MCG->C1 = SYSTEM_MCG_C1_VALUE;       /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) */
    211            #endif
    212            if ((((SYSTEM_MCG_C2_VALUE) & MCG_C2_EREFS0_MASK) != 0x00U) && (((SYSTEM_MCG_C7_VALUE) & MCG_C7_OSCSEL_MASK) == 0x00U)) {
    213              while((MCG->S & MCG_S_OSCINIT0_MASK) == 0x00U) { /* Check that the oscillator is running */
    214              }
    215            }
    216            /* Check that the source of the FLL reference clock is the requested one. */
    217            if (((SYSTEM_MCG_C1_VALUE) & MCG_C1_IREFS_MASK) != 0x00U) {
    218              while((MCG->S & MCG_S_IREFST_MASK) == 0x00U) {
    219              }
    220            } else {
    221              while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) {
    222              }
    223            }
    224            MCG->C4 = ((SYSTEM_MCG_C4_VALUE)  & (uint8_t)(~(MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK))) | (MCG->C4 & (MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK)); /* Set C4 (FLL output; trim values not changed) */
    225          #endif /* MCG_MODE */
    226          
    227            /* Common for all MCG modes */
    228          
    229            /* PLL clock can be used to generate clock for some devices regardless of clock generator (MCGOUTCLK) mode. */
    230            MCG->C5 = (SYSTEM_MCG_C5_VALUE) & (uint8_t)(~(MCG_C5_PLLCLKEN0_MASK)); /* Set C5 (PLL settings, PLL reference divider etc.) */
    231            MCG->C6 = (SYSTEM_MCG_C6_VALUE) & (uint8_t)~(MCG_C6_PLLS_MASK); /* Set C6 (PLL select, VCO divider etc.) */
    232            if ((SYSTEM_MCG_C5_VALUE) & MCG_C5_PLLCLKEN0_MASK) {
    233              MCG->C5 |= MCG_C5_PLLCLKEN0_MASK;  /* PLL clock enable in mode other than PEE or PBE */
    234            }
    235            /* BLPE, PEE and PBE MCG mode specific */
    236          
    237          #if (MCG_MODE == MCG_MODE_BLPE)
    238            MCG->C2 |= (MCG_C2_LP_MASK);         /* Disable FLL and PLL in bypass mode */
    239          #elif ((MCG_MODE == MCG_MODE_PBE) || (MCG_MODE == MCG_MODE_PEE))
    240            MCG->C6 |= (MCG_C6_PLLS_MASK);       /* Set C6 (PLL select, VCO divider etc.) */
    241            while((MCG->S & MCG_S_LOCK0_MASK) == 0x00U) { /* Wait until PLL is locked*/
    242            }
    243            #if (MCG_MODE == MCG_MODE_PEE)
    244            MCG->C1 &= (uint8_t)~(MCG_C1_CLKS_MASK);
    245            #endif
    246          #endif
    247          #if ((MCG_MODE == MCG_MODE_FEI) || (MCG_MODE == MCG_MODE_FEE))
    248            while((MCG->S & MCG_S_CLKST_MASK) != 0x00U) { /* Wait until output of the FLL is selected */
    249            }
    250          #elif ((MCG_MODE == MCG_MODE_FBI) || (MCG_MODE == MCG_MODE_BLPI))
    251            while((MCG->S & MCG_S_CLKST_MASK) != 0x04U) { /* Wait until internal reference clock is selected as MCG output */
    252            }
    253          #elif ((MCG_MODE == MCG_MODE_FBE) || (MCG_MODE == MCG_MODE_PBE) || (MCG_MODE == MCG_MODE_BLPE))
    254            while((MCG->S & MCG_S_CLKST_MASK) != 0x08U) { /* Wait until external reference clock is selected as MCG output */
    255            }
    256          #elif (MCG_MODE == MCG_MODE_PEE)
    257            while((MCG->S & MCG_S_CLKST_MASK) != 0x0CU) { /* Wait until output of the PLL is selected */
    258            }
    259          #endif
    260          #if (((SYSTEM_SMC_PMCTRL_VALUE) & SMC_PMCTRL_RUNM_MASK) == (0x02U << SMC_PMCTRL_RUNM_SHIFT))
    261            SMC->PMCTRL = (uint8_t)((SYSTEM_SMC_PMCTRL_VALUE) & (SMC_PMCTRL_RUNM_MASK)); /* Enable VLPR mode */
    262            while(SMC->PMSTAT != 0x04U) {        /* Wait until the system is in VLPR mode */
    263            }
    264          #endif
    265          
    266          #if defined(SYSTEM_SIM_CLKDIV2_VALUE)
    267            SIM->CLKDIV2 = ((SIM->CLKDIV2) & (uint32_t)(~(SIM_CLKDIV2_USBFRAC_MASK | SIM_CLKDIV2_USBDIV_MASK))) | ((SYSTEM_SIM_CLKDIV2_VALUE) & (SIM_CLKDIV2_USBFRAC_MASK | SIM_CLKDIV2_USBDIV_MASK)); /* Selects the USB clock divider. */
    268          #endif
    269          
    270            /* PLL loss of lock interrupt request initialization */
    271            if (((SYSTEM_MCG_C6_VALUE) & MCG_C6_LOLIE0_MASK) != 0U) {
    272              NVIC_EnableIRQ(MCG_IRQn);          /* Enable PLL loss of lock interrupt request */
    273            }
    274          #endif
    275          }
   \   00000024   0x4770             BX       LR               ;; return
    276          
    277          /* ----------------------------------------------------------------------------
    278             -- SystemCoreClockUpdate()
    279             ---------------------------------------------------------------------------- */
    280          

   \                                 In section .text, align 2, keep-with-next
    281          void SystemCoreClockUpdate (void) {
    282          
    283            uint32_t MCGOUTClock;                /* Variable to store output clock frequency of the MCG module */
    284            uint16_t Divider;
    285          
    286            if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x00U) {
   \                     SystemCoreClockUpdate: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable1_3  ;; 0x40064000
   \   00000002   0x7812             LDRB     R2,[R2, #+0]
   \   00000004   0x23C0             MOVS     R3,#+192
   \   00000006   0x421A             TST      R2,R3
   \   00000008   0xF040 0x8090      BNE.W    ??SystemCoreClockUpdate_0
    287              /* Output of FLL or PLL is selected */
    288              if ((MCG->C6 & MCG_C6_PLLS_MASK) == 0x00U) {
   \   0000000C   0x....             LDR.N    R2,??DataTable1_4  ;; 0x40064005
   \   0000000E   0x7812             LDRB     R2,[R2, #+0]
   \   00000010   0x0652             LSLS     R2,R2,#+25
   \   00000012   0xD475             BMI.N    ??SystemCoreClockUpdate_1
    289                /* FLL is selected */
    290                if ((MCG->C1 & MCG_C1_IREFS_MASK) == 0x00U) {
   \   00000014   0x....             LDR.N    R2,??DataTable1_3  ;; 0x40064000
   \   00000016   0x7812             LDRB     R2,[R2, #+0]
   \   00000018   0x0752             LSLS     R2,R2,#+29
   \   0000001A   0xD437             BMI.N    ??SystemCoreClockUpdate_2
    291                  /* External reference clock is selected */
    292                  if((MCG->C7 & MCG_C7_OSCSEL_MASK) == 0x00U) {
   \   0000001C   0x....             LDR.N    R2,??DataTable1_5  ;; 0x4006400c
   \   0000001E   0x7812             LDRB     R2,[R2, #+0]
   \   00000020   0x07D2             LSLS     R2,R2,#+31
   \   00000022   0xD402             BMI.N    ??SystemCoreClockUpdate_3
    293                    MCGOUTClock = CPU_XTAL_CLK_HZ; /* System oscillator drives MCG clock */
   \   00000024   0x....             LDR.N    R2,??DataTable1_6  ;; 0x7a1200
   \   00000026   0x0010             MOVS     R0,R2
   \   00000028   0xE002             B.N      ??SystemCoreClockUpdate_4
    294                  } else {
    295                    MCGOUTClock = CPU_XTAL32k_CLK_HZ; /* RTC 32 kHz oscillator drives MCG clock */
   \                     ??SystemCoreClockUpdate_3: (+1)
   \   0000002A   0xF44F 0x4200      MOV      R2,#+32768
   \   0000002E   0x0010             MOVS     R0,R2
    296                  }
    297                  if (((MCG->C2 & MCG_C2_RANGE0_MASK) != 0x00U) && ((MCG->C7 & MCG_C7_OSCSEL_MASK) != 0x01U)) {
   \                     ??SystemCoreClockUpdate_4: (+1)
   \   00000030   0x....             LDR.N    R2,??DataTable1_7  ;; 0x40064001
   \   00000032   0x7812             LDRB     R2,[R2, #+0]
   \   00000034   0x2330             MOVS     R3,#+48
   \   00000036   0x421A             TST      R2,R3
   \   00000038   0xD01D             BEQ.N    ??SystemCoreClockUpdate_5
   \   0000003A   0x....             LDR.N    R2,??DataTable1_5  ;; 0x4006400c
   \   0000003C   0x7812             LDRB     R2,[R2, #+0]
   \   0000003E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000040   0x07D2             LSLS     R2,R2,#+31
   \   00000042   0xD418             BMI.N    ??SystemCoreClockUpdate_5
    298                    switch (MCG->C1 & MCG_C1_FRDIV_MASK) {
   \   00000044   0x....             LDR.N    R2,??DataTable1_3  ;; 0x40064000
   \   00000046   0x7812             LDRB     R2,[R2, #+0]
   \   00000048   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000004A   0xF012 0x0238      ANDS     R2,R2,#0x38
   \   0000004E   0x2A30             CMP      R2,#+48
   \   00000050   0xD005             BEQ.N    ??SystemCoreClockUpdate_6
   \   00000052   0x2A38             CMP      R2,#+56
   \   00000054   0xD107             BNE.N    ??SystemCoreClockUpdate_7
    299                    case 0x38U:
    300                      Divider = 1536U;
   \                     ??SystemCoreClockUpdate_8: (+1)
   \   00000056   0xF44F 0x62C0      MOV      R2,#+1536
   \   0000005A   0x0011             MOVS     R1,R2
    301                      break;
   \   0000005C   0xE012             B.N      ??SystemCoreClockUpdate_9
    302                    case 0x30U:
    303                      Divider = 1280U;
   \                     ??SystemCoreClockUpdate_6: (+1)
   \   0000005E   0xF44F 0x62A0      MOV      R2,#+1280
   \   00000062   0x0011             MOVS     R1,R2
    304                      break;
   \   00000064   0xE00E             B.N      ??SystemCoreClockUpdate_9
    305                    default:
    306                      Divider = (uint16_t)(32LU << ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT));
   \                     ??SystemCoreClockUpdate_7: (+1)
   \   00000066   0x2220             MOVS     R2,#+32
   \   00000068   0x....             LDR.N    R3,??DataTable1_3  ;; 0x40064000
   \   0000006A   0x781B             LDRB     R3,[R3, #+0]
   \   0000006C   0xF3C3 0x03C2      UBFX     R3,R3,#+3,#+3
   \   00000070   0x409A             LSLS     R2,R2,R3
   \   00000072   0x0011             MOVS     R1,R2
    307                      break;
   \   00000074   0xE006             B.N      ??SystemCoreClockUpdate_9
    308                    }
    309                  } else {/* ((MCG->C2 & MCG_C2_RANGE_MASK) != 0x00U) */
    310                    Divider = (uint16_t)(1LU << ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT));
   \                     ??SystemCoreClockUpdate_5: (+1)
   \   00000076   0x2201             MOVS     R2,#+1
   \   00000078   0x....             LDR.N    R3,??DataTable1_3  ;; 0x40064000
   \   0000007A   0x781B             LDRB     R3,[R3, #+0]
   \   0000007C   0xF3C3 0x03C2      UBFX     R3,R3,#+3,#+3
   \   00000080   0x409A             LSLS     R2,R2,R3
   \   00000082   0x0011             MOVS     R1,R2
    311                  }
    312                  MCGOUTClock = (MCGOUTClock / Divider); /* Calculate the divided FLL reference clock */
   \                     ??SystemCoreClockUpdate_9: (+1)
   \   00000084   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000086   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000008A   0xE002             B.N      ??SystemCoreClockUpdate_10
    313                } else { /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x00U)) */
    314                  MCGOUTClock = CPU_INT_SLOW_CLK_HZ; /* The slow internal reference clock is selected */
   \                     ??SystemCoreClockUpdate_2: (+1)
   \   0000008C   0xF44F 0x4200      MOV      R2,#+32768
   \   00000090   0x0010             MOVS     R0,R2
    315                } /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x00U)) */
    316                /* Select correct multiplier to calculate the MCG output clock  */
    317                switch (MCG->C4 & (MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) {
   \                     ??SystemCoreClockUpdate_10: (+1)
   \   00000092   0x....             LDR.N    R2,??DataTable1_8  ;; 0x40064003
   \   00000094   0x7812             LDRB     R2,[R2, #+0]
   \   00000096   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000098   0xF012 0x02E0      ANDS     R2,R2,#0xE0
   \   0000009C   0x2A00             CMP      R2,#+0
   \   0000009E   0xD00E             BEQ.N    ??SystemCoreClockUpdate_11
   \   000000A0   0x2A20             CMP      R2,#+32
   \   000000A2   0xD010             BEQ.N    ??SystemCoreClockUpdate_12
   \   000000A4   0x2A40             CMP      R2,#+64
   \   000000A6   0xD012             BEQ.N    ??SystemCoreClockUpdate_13
   \   000000A8   0x2A60             CMP      R2,#+96
   \   000000AA   0xD014             BEQ.N    ??SystemCoreClockUpdate_14
   \   000000AC   0x2A80             CMP      R2,#+128
   \   000000AE   0xD016             BEQ.N    ??SystemCoreClockUpdate_15
   \   000000B0   0x2AA0             CMP      R2,#+160
   \   000000B2   0xD018             BEQ.N    ??SystemCoreClockUpdate_16
   \   000000B4   0x2AC0             CMP      R2,#+192
   \   000000B6   0xD01A             BEQ.N    ??SystemCoreClockUpdate_17
   \   000000B8   0x2AE0             CMP      R2,#+224
   \   000000BA   0xD01C             BEQ.N    ??SystemCoreClockUpdate_18
   \   000000BC   0xE01F             B.N      ??SystemCoreClockUpdate_19
    318                  case 0x00U:
    319                    MCGOUTClock *= 640U;
   \                     ??SystemCoreClockUpdate_11: (+1)
   \   000000BE   0xF44F 0x7220      MOV      R2,#+640
   \   000000C2   0x4350             MULS     R0,R2,R0
    320                    break;
   \   000000C4   0xE061             B.N      ??SystemCoreClockUpdate_20
    321                  case 0x20U:
    322                    MCGOUTClock *= 1280U;
   \                     ??SystemCoreClockUpdate_12: (+1)
   \   000000C6   0xF44F 0x62A0      MOV      R2,#+1280
   \   000000CA   0x4350             MULS     R0,R2,R0
    323                    break;
   \   000000CC   0xE05D             B.N      ??SystemCoreClockUpdate_20
    324                  case 0x40U:
    325                    MCGOUTClock *= 1920U;
   \                     ??SystemCoreClockUpdate_13: (+1)
   \   000000CE   0xF44F 0x62F0      MOV      R2,#+1920
   \   000000D2   0x4350             MULS     R0,R2,R0
    326                    break;
   \   000000D4   0xE059             B.N      ??SystemCoreClockUpdate_20
    327                  case 0x60U:
    328                    MCGOUTClock *= 2560U;
   \                     ??SystemCoreClockUpdate_14: (+1)
   \   000000D6   0xF44F 0x6220      MOV      R2,#+2560
   \   000000DA   0x4350             MULS     R0,R2,R0
    329                    break;
   \   000000DC   0xE055             B.N      ??SystemCoreClockUpdate_20
    330                  case 0x80U:
    331                    MCGOUTClock *= 732U;
   \                     ??SystemCoreClockUpdate_15: (+1)
   \   000000DE   0xF44F 0x7237      MOV      R2,#+732
   \   000000E2   0x4350             MULS     R0,R2,R0
    332                    break;
   \   000000E4   0xE051             B.N      ??SystemCoreClockUpdate_20
    333                  case 0xA0U:
    334                    MCGOUTClock *= 1464U;
   \                     ??SystemCoreClockUpdate_16: (+1)
   \   000000E6   0xF44F 0x62B7      MOV      R2,#+1464
   \   000000EA   0x4350             MULS     R0,R2,R0
    335                    break;
   \   000000EC   0xE04D             B.N      ??SystemCoreClockUpdate_20
    336                  case 0xC0U:
    337                    MCGOUTClock *= 2197U;
   \                     ??SystemCoreClockUpdate_17: (+1)
   \   000000EE   0xF640 0x0295      MOVW     R2,#+2197
   \   000000F2   0x4350             MULS     R0,R2,R0
    338                    break;
   \   000000F4   0xE049             B.N      ??SystemCoreClockUpdate_20
    339                  case 0xE0U:
    340                    MCGOUTClock *= 2929U;
   \                     ??SystemCoreClockUpdate_18: (+1)
   \   000000F6   0xF640 0x3271      MOVW     R2,#+2929
   \   000000FA   0x4350             MULS     R0,R2,R0
    341                    break;
   \   000000FC   0xE045             B.N      ??SystemCoreClockUpdate_20
    342                  default:
    343                    break;
   \                     ??SystemCoreClockUpdate_19: (+1)
   \   000000FE   0xE044             B.N      ??SystemCoreClockUpdate_20
    344                }
    345              } else { /* (!((MCG->C6 & MCG_C6_PLLS_MASK) == 0x00U)) */
    346                /* PLL is selected */
    347                Divider = (((uint16_t)MCG->C5 & MCG_C5_PRDIV0_MASK) + 0x01U);
   \                     ??SystemCoreClockUpdate_1: (+1)
   \   00000100   0x....             LDR.N    R2,??DataTable1_9  ;; 0x40064004
   \   00000102   0x7812             LDRB     R2,[R2, #+0]
   \   00000104   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000106   0xF012 0x021F      ANDS     R2,R2,#0x1F
   \   0000010A   0x1C52             ADDS     R2,R2,#+1
   \   0000010C   0x0011             MOVS     R1,R2
    348                MCGOUTClock = (uint32_t)(CPU_XTAL_CLK_HZ / Divider); /* Calculate the PLL reference clock */
   \   0000010E   0x....             LDR.N    R2,??DataTable1_6  ;; 0x7a1200
   \   00000110   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000112   0xFBB2 0xF2F1      UDIV     R2,R2,R1
   \   00000116   0x0010             MOVS     R0,R2
    349                Divider = (((uint16_t)MCG->C6 & MCG_C6_VDIV0_MASK) + 24U);
   \   00000118   0x....             LDR.N    R2,??DataTable1_4  ;; 0x40064005
   \   0000011A   0x7812             LDRB     R2,[R2, #+0]
   \   0000011C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000011E   0xF012 0x021F      ANDS     R2,R2,#0x1F
   \   00000122   0x3218             ADDS     R2,R2,#+24
   \   00000124   0x0011             MOVS     R1,R2
    350                MCGOUTClock *= Divider;          /* Calculate the MCG output clock */
   \   00000126   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000128   0x4348             MULS     R0,R1,R0
   \   0000012A   0xE02E             B.N      ??SystemCoreClockUpdate_20
    351              } /* (!((MCG->C6 & MCG_C6_PLLS_MASK) == 0x00U)) */
    352            } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x40U) {
   \                     ??SystemCoreClockUpdate_0: (+1)
   \   0000012C   0x....             LDR.N    R2,??DataTable1_3  ;; 0x40064000
   \   0000012E   0x7812             LDRB     R2,[R2, #+0]
   \   00000130   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000132   0xF012 0x02C0      ANDS     R2,R2,#0xC0
   \   00000136   0x2A40             CMP      R2,#+64
   \   00000138   0xD114             BNE.N    ??SystemCoreClockUpdate_21
    353              /* Internal reference clock is selected */
    354              if ((MCG->C2 & MCG_C2_IRCS_MASK) == 0x00U) {
   \   0000013A   0x....             LDR.N    R2,??DataTable1_7  ;; 0x40064001
   \   0000013C   0x7812             LDRB     R2,[R2, #+0]
   \   0000013E   0x07D2             LSLS     R2,R2,#+31
   \   00000140   0xD403             BMI.N    ??SystemCoreClockUpdate_22
    355                MCGOUTClock = CPU_INT_SLOW_CLK_HZ; /* Slow internal reference clock selected */
   \   00000142   0xF44F 0x4200      MOV      R2,#+32768
   \   00000146   0x0010             MOVS     R0,R2
   \   00000148   0xE01F             B.N      ??SystemCoreClockUpdate_20
    356              } else { /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x00U)) */
    357                Divider = (uint16_t)(0x01LU << ((MCG->SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT));
   \                     ??SystemCoreClockUpdate_22: (+1)
   \   0000014A   0x2201             MOVS     R2,#+1
   \   0000014C   0x....             LDR.N    R3,??DataTable1_10  ;; 0x40064008
   \   0000014E   0x781B             LDRB     R3,[R3, #+0]
   \   00000150   0xF3C3 0x0342      UBFX     R3,R3,#+1,#+3
   \   00000154   0x409A             LSLS     R2,R2,R3
   \   00000156   0x0011             MOVS     R1,R2
    358                MCGOUTClock = (uint32_t) (CPU_INT_FAST_CLK_HZ / Divider); /* Fast internal reference clock selected */
   \   00000158   0x....             LDR.N    R2,??DataTable1_11  ;; 0x3d0900
   \   0000015A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000015C   0xFBB2 0xF2F1      UDIV     R2,R2,R1
   \   00000160   0x0010             MOVS     R0,R2
   \   00000162   0xE012             B.N      ??SystemCoreClockUpdate_20
    359              } /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x00U)) */
    360            } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80U) {
   \                     ??SystemCoreClockUpdate_21: (+1)
   \   00000164   0x....             LDR.N    R2,??DataTable1_3  ;; 0x40064000
   \   00000166   0x7812             LDRB     R2,[R2, #+0]
   \   00000168   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000016A   0xF012 0x02C0      ANDS     R2,R2,#0xC0
   \   0000016E   0x2A80             CMP      R2,#+128
   \   00000170   0xD10A             BNE.N    ??SystemCoreClockUpdate_23
    361              /* External reference clock is selected */
    362              if((MCG->C7 & MCG_C7_OSCSEL_MASK) == 0x00U) {
   \   00000172   0x....             LDR.N    R2,??DataTable1_5  ;; 0x4006400c
   \   00000174   0x7812             LDRB     R2,[R2, #+0]
   \   00000176   0x07D2             LSLS     R2,R2,#+31
   \   00000178   0xD402             BMI.N    ??SystemCoreClockUpdate_24
    363                MCGOUTClock = CPU_XTAL_CLK_HZ;   /* System oscillator drives MCG clock */
   \   0000017A   0x....             LDR.N    R2,??DataTable1_6  ;; 0x7a1200
   \   0000017C   0x0010             MOVS     R0,R2
   \   0000017E   0xE004             B.N      ??SystemCoreClockUpdate_20
    364              } else {
    365                MCGOUTClock = CPU_XTAL32k_CLK_HZ; /* RTC 32 kHz oscillator drives MCG clock */
   \                     ??SystemCoreClockUpdate_24: (+1)
   \   00000180   0xF44F 0x4200      MOV      R2,#+32768
   \   00000184   0x0010             MOVS     R0,R2
   \   00000186   0xE000             B.N      ??SystemCoreClockUpdate_20
    366              }
    367            } else { /* (!((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80U)) */
    368              /* Reserved value */
    369              return;
   \                     ??SystemCoreClockUpdate_23: (+1)
   \   00000188   0xE007             B.N      ??SystemCoreClockUpdate_25
    370            } /* (!((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80U)) */
    371            SystemCoreClock = (MCGOUTClock / (0x01U + ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_SHIFT)));
   \                     ??SystemCoreClockUpdate_20: (+1)
   \   0000018A   0x....             LDR.N    R2,??DataTable1_12  ;; 0x40048044
   \   0000018C   0x6812             LDR      R2,[R2, #+0]
   \   0000018E   0x0F12             LSRS     R2,R2,#+28
   \   00000190   0x1C52             ADDS     R2,R2,#+1
   \   00000192   0xFBB0 0xF2F2      UDIV     R2,R0,R2
   \   00000196   0x....             LDR.N    R3,??DataTable1_13
   \   00000198   0x601A             STR      R2,[R3, #+0]
    372          }
   \                     ??SystemCoreClockUpdate_25: (+1)
   \   0000019A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0xE000ED88         DC32     0xe000ed88

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x4005200E         DC32     0x4005200e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x40052000         DC32     0x40052000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \   00000000   0x4006400C         DC32     0x4006400c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_6:
   \   00000000   0x007A1200         DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_7:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_8:
   \   00000000   0x40064003         DC32     0x40064003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_9:
   \   00000000   0x40064004         DC32     0x40064004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_10:
   \   00000000   0x40064008         DC32     0x40064008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_11:
   \   00000000   0x003D0900         DC32     0x3d0900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_12:
   \   00000000   0x40048044         DC32     0x40048044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_13:
   \   00000000   0x........         DC32     SystemCoreClock

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   SystemCoreClockUpdate
       0   SystemInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_10
       4  ??DataTable1_11
       4  ??DataTable1_12
       4  ??DataTable1_13
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       4  ??DataTable1_8
       4  ??DataTable1_9
       4  SystemCoreClock
     412  SystemCoreClockUpdate
      38  SystemInit

 
   4 bytes in section .data
 506 bytes in section .text
 
 506 bytes of CODE memory
   4 bytes of DATA memory

Errors: none
Warnings: none
