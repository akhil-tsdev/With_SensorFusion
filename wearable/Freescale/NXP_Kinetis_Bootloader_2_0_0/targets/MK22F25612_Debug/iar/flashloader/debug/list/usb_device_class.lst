###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Aug/2016  13:16:01
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_class.c
#    Command line =  
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_class.c"
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN256VDC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D BL_TARGET_RAM -lC
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj"
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices/MK22F25612\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/autobaud\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/osa\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device/class\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/bm_usb\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/CMSIS/Include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers/common\"
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list\usb_device_class.lst
#    Object file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj\usb_device_class.o
#
###############################################################################

C:\Users\cwati\Documents\My Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_class.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "usb_device_config.h"
     32          #include "usb.h"
     33          
     34          #include "usb_device.h"
     35          #include "usb_device_ch9.h"
     36          #include "usb_device_class.h"
     37          
     38          #if ((defined(USB_DEVICE_CONFIG_NUM)) && (USB_DEVICE_CONFIG_NUM > 0U))
     39          /* Include the class drivers according to the usb_device_config.h. */
     40          #if ((defined(USB_DEVICE_CONFIG_HID)) && (USB_DEVICE_CONFIG_HID > 0U))
     41          #include "usb_device_hid.h"
     42          #endif
     43          
     44          #if ((defined(USB_DEVICE_CONFIG_CDC_ACM)) && (USB_DEVICE_CONFIG_CDC_ACM > 0U))
     45          #include "usb_device_cdc_acm.h"
     46          #endif
     47          
     48          #if ((defined(USB_DEVICE_CONFIG_MSC)) && (USB_DEVICE_CONFIG_MSC > 0U))
     49          #include "usb_device_msc.h"
     50          #endif
     51          
     52          #if ((defined(USB_DEVICE_CONFIG_AUDIO)) && (USB_DEVICE_CONFIG_AUDIO > 0U))
     53          #include "usb_device_audio.h"
     54          #endif
     55          
     56          #if ((defined(USB_DEVICE_CONFIG_PHDC)) && (USB_DEVICE_CONFIG_PHDC > 0U))
     57          #include "usb_device_phdc.h"
     58          #endif
     59          
     60          #if ((defined(USB_DEVICE_CONFIG_VIDEO)) && (USB_DEVICE_CONFIG_VIDEO > 0U))
     61          #include "usb_device_video.h"
     62          #endif
     63          
     64          #if ((defined(USB_DEVICE_CONFIG_PRINTER)) && (USB_DEVICE_CONFIG_PRINTER > 0U))
     65          #include "usb_device_printer_config.h"
     66          #include "usb_device_printer.h"
     67          #endif
     68          
     69          #if ((defined(USB_DEVICE_CONFIG_DFU)) && (USB_DEVICE_CONFIG_DFU > 0U))
     70          #include "usb_device_dfu_config.h"
     71          #include "usb_device_dfu.h"
     72          #endif
     73          
     74          #if ((defined(USB_DEVICE_CONFIG_CCID)) && (USB_DEVICE_CONFIG_CCID > 0U))
     75          #include "usb_device_ccid.h"
     76          #endif
     77          
     78          /*******************************************************************************
     79           * Definitions
     80           ******************************************************************************/
     81          
     82          /*******************************************************************************
     83           * Prototypes
     84           ******************************************************************************/
     85          static usb_status_t USB_DeviceClassAllocateHandle(uint8_t controllerId, usb_device_common_class_struct_t **handle);
     86          static usb_status_t USB_DeviceClassFreeHandle(uint8_t controllerId);
     87          static usb_status_t USB_DeviceClassGetHandleByControllerId(uint8_t controllerId,
     88                                                                     usb_device_common_class_struct_t **handle);
     89          static usb_status_t USB_DeviceClassGetHandleByDeviceHandle(usb_device_handle deviceHandle,
     90                                                                     usb_device_common_class_struct_t **handle);
     91          
     92          /*******************************************************************************
     93           * Variables
     94           ******************************************************************************/
     95          
     96          /* The device class driver list. */

   \                                 In section .text, align 4, keep-with-next
     97          static const usb_device_class_map_t s_UsbDeviceClassInterfaceMap[] = {
   \                     s_UsbDeviceClassInterfaceMap:
   \   00000000   0x........         DC32 USB_DeviceHidInit, USB_DeviceHidDeinit, USB_DeviceHidEvent
   \              0x........   
   \              0x........   
   \   0000000C   0x01 0x00          DC8 1, 0, 0, 0
   \              0x00 0x00    
   \   00000010   0x........         DC32 USB_DeviceMscInit, USB_DeviceMscDeinit, USB_DeviceMscEvent
   \              0x........   
   \              0x........   
   \   0000001C   0x03 0x00          DC8 3, 0, 0, 0
   \              0x00 0x00    
   \   00000020   0x00000000         DC32 0H, 0H, 0H
   \              0x00000000   
   \              0x00000000   
   \   0000002C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
     98          #if ((defined(USB_DEVICE_CONFIG_HID)) && (USB_DEVICE_CONFIG_HID > 0U))
     99              {USB_DeviceHidInit, USB_DeviceHidDeinit, USB_DeviceHidEvent, kUSB_DeviceClassTypeHid},
    100          #endif
    101          
    102          #if ((defined(USB_DEVICE_CONFIG_CDC_ACM)) && (USB_DEVICE_CONFIG_CDC_ACM > 0U))
    103              {USB_DeviceCdcAcmInit, USB_DeviceCdcAcmDeinit, USB_DeviceCdcAcmEvent, kUSB_DeviceClassTypeCdc},
    104          #endif
    105          
    106          #if ((defined(USB_DEVICE_CONFIG_MSC)) && (USB_DEVICE_CONFIG_MSC > 0U))
    107              {USB_DeviceMscInit, USB_DeviceMscDeinit, USB_DeviceMscEvent, kUSB_DeviceClassTypeMsc},
    108          #endif
    109          
    110          #if ((defined USB_DEVICE_CONFIG_AUDIO) && (USB_DEVICE_CONFIG_AUDIO > 0U))
    111              {USB_DeviceAudioInit, USB_DeviceAudioDeinit, USB_DeviceAudioEvent, kUSB_DeviceClassTypeAudio},
    112          #endif
    113          
    114          #if ((defined USB_DEVICE_CONFIG_PHDC) && (USB_DEVICE_CONFIG_PHDC > 0U))
    115              {USB_DevicePhdcInit, USB_DevicePhdcDeinit, USB_DevicePhdcEvent, kUSB_DeviceClassTypePhdc},
    116          #endif
    117          
    118          #if ((defined USB_DEVICE_CONFIG_VIDEO) && (USB_DEVICE_CONFIG_VIDEO > 0U))
    119              {USB_DeviceVideoInit, USB_DeviceVideoDeinit, USB_DeviceVideoEvent, kUSB_DeviceClassTypeVideo},
    120          #endif
    121          
    122          #if ((defined USB_DEVICE_CONFIG_PRINTER) && (USB_DEVICE_CONFIG_PRINTER > 0U))
    123              {usb_device_printer_init, usb_device_printer_deinit, usb_device_printer_event, kUSB_DeviceClassTypePrinter},
    124          #endif
    125          
    126          #if ((defined USB_DEVICE_CONFIG_DFU) && (USB_DEVICE_CONFIG_DFU > 0U))
    127              {usb_device_dfu_init, usb_device_dfu_deinit, usb_device_dfu_event, kUSB_DeviceClassTypeDfu},
    128          #endif
    129          
    130          #if ((defined USB_DEVICE_CONFIG_CCID) && (USB_DEVICE_CONFIG_CCID > 0U))
    131              {USB_DeviceCcidInit, USB_DeviceCcidDeinit, USB_DeviceCcidEvent, kUSB_DeviceClassTypeCcid},
    132          #endif
    133          
    134              {(usb_device_class_init_call_t)NULL, (usb_device_class_deinit_call_t)NULL, (usb_device_class_event_callback_t)NULL,
    135               (usb_device_class_type_t)0},
    136          };
    137          

   \                                 In section m_usb_global, align 4
    138          USB_GLOBAL static usb_device_common_class_struct_t s_UsbDeviceCommonClassStruct[USB_DEVICE_CONFIG_NUM];
   \                     s_UsbDeviceCommonClassStruct:
   \   00000000                      DS8 20
    139          
    140          /*******************************************************************************
    141           * Code
    142           ******************************************************************************/
    143          
    144          /*!
    145           * @brief Allocate a device common class handle.
    146           *
    147           * This function allocates a a device common class handle.
    148           *
    149           * @param controllerId   The controller id of the USB IP. Please refer to the enumeration usb_controller_index_t.
    150           * @param handle          It is out parameter, is used to return pointer of the device common class handle to the
    151           * caller.
    152           *
    153           * @retval kStatus_USB_Success              Get a device handle successfully.
    154           * @retval kStatus_USB_Busy                 Cannot allocate a common class handle.
    155           * @retval kStatus_USB_Error                The common class has been initialized.
    156           */
    157          static usb_status_t USB_DeviceClassAllocateHandle(uint8_t controllerId, usb_device_common_class_struct_t **handle)
    158          {
    159              int32_t count;
    160              USB_OSA_SR_ALLOC();
    161          
    162              USB_OSA_ENTER_CRITICAL();
    163              /* Check the controller is initialized or not. */
    164              for (count = 0U; count < USB_DEVICE_CONFIG_NUM; count++)
    165              {
    166                  if ((NULL != s_UsbDeviceCommonClassStruct[count].handle) &&
    167                      (controllerId == s_UsbDeviceCommonClassStruct[count].controllerId))
    168                  {
    169                      USB_OSA_EXIT_CRITICAL();
    170                      return kStatus_USB_Error;
    171                  }
    172              }
    173              /* Get a free common class handle. */
    174              for (count = 0U; count < USB_DEVICE_CONFIG_NUM; count++)
    175              {
    176                  if (NULL == s_UsbDeviceCommonClassStruct[count].handle)
    177                  {
    178                      s_UsbDeviceCommonClassStruct[count].controllerId = controllerId;
    179                      *handle = &s_UsbDeviceCommonClassStruct[count];
    180                      USB_OSA_EXIT_CRITICAL();
    181                      return kStatus_USB_Success;
    182                  }
    183              }
    184          
    185              USB_OSA_EXIT_CRITICAL();
    186              return kStatus_USB_Busy;
    187          }
    188          
    189          /*!
    190           * @brief Free a device common class handle.
    191           *
    192           * This function frees a device common class handle.
    193           *
    194           * @param controllerId   The controller id of the USB IP. Please refer to the enumeration usb_controller_index_t.
    195           *
    196           * @retval kStatus_USB_Success              Free device hanlde successfully.
    197           * @retval kStatus_USB_InvalidParameter     The common class can not be found.
    198           */

   \                                 In section .text, align 2, keep-with-next
    199          static usb_status_t USB_DeviceClassFreeHandle(uint8_t controllerId)
    200          {
   \                     USB_DeviceClassFreeHandle: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    201              int32_t count = 0U;
    202              USB_OSA_SR_ALLOC();
    203          
    204              USB_OSA_ENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       USB_BmEnterCritical
   \   00000008   0x.... 0x....      BL       ?Subroutine3
    205              for (; count < USB_DEVICE_CONFIG_NUM; count++)
    206              {
    207                  if ((NULL != s_UsbDeviceCommonClassStruct[count].handle) &&
    208                      (controllerId == s_UsbDeviceCommonClassStruct[count].controllerId))
   \                     ??CrossCallReturnLabel_3: (+1)
   \   0000000C   0xB151             CBZ.N    R1,??USB_DeviceClassFreeHandle_0
   \   0000000E   0x7C81             LDRB     R1,[R0, #+18]
   \   00000010   0x428C             CMP      R4,R1
   \   00000012   0xD107             BNE.N    ??USB_DeviceClassFreeHandle_0
    209                  {
    210                      s_UsbDeviceCommonClassStruct[count].handle = NULL;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6001             STR      R1,[R0, #+0]
    211                      s_UsbDeviceCommonClassStruct[count].configList = (usb_device_class_config_list_struct_t *)NULL;
   \   00000018   0x6041             STR      R1,[R0, #+4]
    212                      s_UsbDeviceCommonClassStruct[count].controllerId = 0U;
   \   0000001A   0x7481             STRB     R1,[R0, #+18]
    213                      USB_OSA_EXIT_CRITICAL();
   \   0000001C   0x.... 0x....      BL       USB_BmExitCritical
    214                      return kStatus_USB_Success;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD10             POP      {R4,PC}
    215                  }
    216              }
    217              USB_OSA_EXIT_CRITICAL();
   \                     ??USB_DeviceClassFreeHandle_0: (+1)
   \   00000024   0x.... 0x....      BL       USB_BmExitCritical
    218          
    219              return kStatus_USB_InvalidParameter;
   \   00000028   0x2004             MOVS     R0,#+4
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    220          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable2
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x4770             BX       LR
    221          
    222          /*!
    223           * @brief Get the device common class handle according to the controller id.
    224           *
    225           * This function gets the device common class handle according to the controller id.
    226           *
    227           * @param controllerId   The controller id of the USB IP. Please refer to the enumeration usb_controller_index_t.
    228           * @param handle          It is out parameter, is used to return pointer of the device common class handle to the
    229           * caller.
    230           *
    231           * @retval kStatus_USB_Success              Free device hanlde successfully.
    232           * @retval kStatus_USB_InvalidParameter     The common class can not be found.
    233           */

   \                                 In section .text, align 2, keep-with-next
    234          static usb_status_t USB_DeviceClassGetHandleByControllerId(uint8_t controllerId,
    235                                                                     usb_device_common_class_struct_t **handle)
    236          {
   \                     USB_DeviceClassGetHandleByControllerId: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine2
    237              int32_t count = 0U;
    238              USB_OSA_SR_ALLOC();
    239          
    240              USB_OSA_ENTER_CRITICAL();
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000006   0x.... 0x....      BL       ?Subroutine3
    241              for (; count < USB_DEVICE_CONFIG_NUM; count++)
    242              {
    243                  if ((NULL != s_UsbDeviceCommonClassStruct[count].handle) &&
    244                      (controllerId == s_UsbDeviceCommonClassStruct[count].controllerId))
   \                     ??CrossCallReturnLabel_4: (+1)
   \   0000000A   0xB119             CBZ.N    R1,??USB_DeviceClassGetHandleByControllerId_0
   \   0000000C   0x7C81             LDRB     R1,[R0, #+18]
   \   0000000E   0x428C             CMP      R4,R1
   \   00000010   0xD100             BNE.N    ??USB_DeviceClassGetHandleByControllerId_0
    245                  {
    246                      *handle = &s_UsbDeviceCommonClassStruct[count];
   \   00000012   0x....             B.N      ?Subroutine0
    247                      USB_OSA_EXIT_CRITICAL();
    248                      return kStatus_USB_Success;
    249                  }
    250              }
    251              USB_OSA_EXIT_CRITICAL();
   \                     ??USB_DeviceClassGetHandleByControllerId_0: (+1)
   \   00000014   0x....             B.N      ?Subroutine1
    252              return kStatus_USB_InvalidParameter;
    253          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x.... 0x....      BL       USB_BmExitCritical
   \   00000004   0x2004             MOVS     R0,#+4
   \   00000006   0xBD32             POP      {R1,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x.... 0x....      B.W      USB_BmEnterCritical

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x6028             STR      R0,[R5, #+0]
   \                     ??Subroutine0_0: (+1)
   \   00000002   0x.... 0x....      BL       USB_BmExitCritical
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}
    254          
    255          /*!
    256           * @brief Get the device common class handle according to the device handle.
    257           *
    258           * This function gets the device common class handle according to the device handle.
    259           *
    260           * @param deviceHandle          The device handle, got from the USB_DeviceInit.
    261           * @param handle                 It is out parameter, is used to return pointer of the device common class handle to the
    262           * caller.
    263           *
    264           * @retval kStatus_USB_Success              Free device hanlde successfully.
    265           * @retval kStatus_USB_InvalidParameter     The common class can not be found.
    266           */

   \                                 In section .text, align 2, keep-with-next
    267          static usb_status_t USB_DeviceClassGetHandleByDeviceHandle(usb_device_handle deviceHandle,
    268                                                                     usb_device_common_class_struct_t **handle)
    269          {
   \                     USB_DeviceClassGetHandleByDeviceHandle: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine2
    270              int32_t count = 0U;
    271              USB_OSA_SR_ALLOC();
    272          
    273              USB_OSA_ENTER_CRITICAL();
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000006   0x.... 0x....      BL       ?Subroutine3
    274              for (; count < USB_DEVICE_CONFIG_NUM; count++)
    275              {
    276                  if (deviceHandle == s_UsbDeviceCommonClassStruct[count].handle)
   \                     ??CrossCallReturnLabel_5: (+1)
   \   0000000A   0x428C             CMP      R4,R1
   \   0000000C   0xD100             BNE.N    ??USB_DeviceClassGetHandleByDeviceHandle_0
    277                  {
    278                      *handle = &s_UsbDeviceCommonClassStruct[count];
   \   0000000E   0x....             B.N      ?Subroutine0
    279                      USB_OSA_EXIT_CRITICAL();
    280                      return kStatus_USB_Success;
    281                  }
    282              }
    283              USB_OSA_EXIT_CRITICAL();
   \                     ??USB_DeviceClassGetHandleByDeviceHandle_0: (+1)
   \   00000010                      REQUIRE ?Subroutine1
   \   00000010                      ;; // Fall through to label ?Subroutine1
    284              return kStatus_USB_InvalidParameter;
    285          }
    286          
    287          /*!
    288           * @brief Get the device handle according to the controller id.
    289           *
    290           * This function gets the device handle according to the controller id.
    291           *
    292           * @param controllerId   The controller id of the USB IP. Please refer to the enumeration usb_controller_index_t.
    293           * @param handle          It is out parameter, is used to return pointer of the device handle to the caller.
    294           *
    295           * @retval kStatus_USB_Success              Free device hanlde successfully.
    296           * @retval kStatus_USB_InvalidParameter     The device handle not be found.
    297           */

   \                                 In section .text, align 2, keep-with-next
    298          usb_status_t USB_DeviceClassGetDeviceHandle(uint8_t controllerId, usb_device_handle *handle)
    299          {
   \                     USB_DeviceClassGetDeviceHandle: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine2
    300              int32_t count = 0U;
    301              USB_OSA_SR_ALLOC();
    302          
    303              USB_OSA_ENTER_CRITICAL();
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000006   0x.... 0x....      BL       ?Subroutine3
    304              for (; count < USB_DEVICE_CONFIG_NUM; count++)
    305              {
    306                  if ((NULL != s_UsbDeviceCommonClassStruct[count].handle) &&
    307                      (controllerId == s_UsbDeviceCommonClassStruct[count].controllerId))
   \                     ??CrossCallReturnLabel_6: (+1)
   \   0000000A   0xB121             CBZ.N    R1,??USB_DeviceClassGetDeviceHandle_0
   \   0000000C   0x7C80             LDRB     R0,[R0, #+18]
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD101             BNE.N    ??USB_DeviceClassGetDeviceHandle_0
    308                  {
    309                      *handle = s_UsbDeviceCommonClassStruct[count].handle;
   \   00000012   0x6029             STR      R1,[R5, #+0]
    310                      USB_OSA_EXIT_CRITICAL();
   \   00000014   0x....             B.N      ??Subroutine0_0
    311                      return kStatus_USB_Success;
    312                  }
    313              }
    314              USB_OSA_EXIT_CRITICAL();
   \                     ??USB_DeviceClassGetDeviceHandle_0: (+1)
   \   00000016   0x....             B.N      ?Subroutine1
    315              return kStatus_USB_InvalidParameter;
    316          }
    317          
    318          /*!
    319           * @brief Handle the event passed to the class drivers.
    320           *
    321           * This function handles the event passed to the class drivers.
    322           *
    323           * @param handle          The device handle, got from the USB_DeviceInit.
    324           * @param event           The event codes. Please refer to the enumeration usb_device_class_event_t.
    325           * @param param           The param type is determined by the event code.
    326           *
    327           * @return A USB error code or kStatus_USB_Success.
    328           * @retval kStatus_USB_Success              A valid request has been handled.
    329           * @retval kStatus_USB_InvalidParameter     The device handle not be found.
    330           * @retval kStatus_USB_InvalidRequest       The request is invalid, and the control pipe will be stalled by the caller.
    331           */

   \                                 In section .text, align 2, keep-with-next
    332          usb_status_t USB_DeviceClassEvent(usb_device_handle handle, usb_device_class_event_t event, void *param)
    333          {
   \                     USB_DeviceClassEvent: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
    334              usb_device_common_class_struct_t *classHandle;
    335              uint8_t mapIndex;
    336              uint8_t classIndex;
    337              usb_status_t errorReturn = kStatus_USB_Error;
    338              usb_status_t error = kStatus_USB_Error;
   \   00000006   0x2601             MOVS     R6,#+1
    339          
    340              if (NULL == param)
   \   00000008   0xB11D             CBZ.N    R5,??USB_DeviceClassEvent_0
    341              {
    342                  return kStatus_USB_InvalidParameter;
    343              }
    344          
    345              /* Get the common class handle according to the device handle. */
    346              errorReturn = USB_DeviceClassGetHandleByDeviceHandle(handle, &classHandle);
    347              if (kStatus_USB_Success != errorReturn)
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x.... 0x....      BL       USB_DeviceClassGetHandleByDeviceHandle
   \   00000010   0xB108             CBZ.N    R0,??USB_DeviceClassEvent_1
    348              {
    349                  return kStatus_USB_InvalidParameter;
   \                     ??USB_DeviceClassEvent_0: (+1)
   \   00000012   0x2004             MOVS     R0,#+4
   \   00000014   0xBDF2             POP      {R1,R4-R7,PC}
    350              }
    351          
    352              for (classIndex = 0U; classIndex < classHandle->configList->count; classIndex++)
   \                     ??USB_DeviceClassEvent_1: (+1)
   \   00000016   0x2700             MOVS     R7,#+0
   \   00000018   0xE005             B.N      ??USB_DeviceClassEvent_2
    353              {
    354                  for (mapIndex = 0U; mapIndex < (sizeof(s_UsbDeviceClassInterfaceMap) / sizeof(usb_device_class_map_t));
    355                       mapIndex++)
   \                     ??USB_DeviceClassEvent_3: (+1)
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \   0000001C   0xB2C9             UXTB     R1,R1
   \   0000001E   0x2903             CMP      R1,#+3
   \   00000020   0xD307             BCC.N    ??USB_DeviceClassEvent_4
   \                     ??USB_DeviceClassEvent_5: (+1)
   \   00000022   0x1C7F             ADDS     R7,R7,#+1
   \   00000024   0xB2FF             UXTB     R7,R7
   \                     ??USB_DeviceClassEvent_2: (+1)
   \   00000026   0x9800             LDR      R0,[SP, #+0]
   \   00000028   0x6840             LDR      R0,[R0, #+4]
   \   0000002A   0x7A01             LDRB     R1,[R0, #+8]
   \   0000002C   0x428F             CMP      R7,R1
   \   0000002E   0xDA1D             BGE.N    ??USB_DeviceClassEvent_6
   \   00000030   0x2100             MOVS     R1,#+0
    356                  {
    357                      if (s_UsbDeviceClassInterfaceMap[mapIndex].type ==
    358                          classHandle->configList->config[classIndex].classInfomation->type)
   \                     ??USB_DeviceClassEvent_4: (+1)
   \   00000032   0x6802             LDR      R2,[R0, #+0]
   \   00000034   0x230C             MOVS     R3,#+12
   \   00000036   0xFB13 0xF307      SMULBB   R3,R3,R7
   \   0000003A   0x4413             ADD      R3,R2,R3
   \   0000003C   0x.... 0x....      ADR.W    R2,s_UsbDeviceClassInterfaceMap
   \   00000040   0xF8D3 0xE008      LDR      LR,[R3, #+8]
   \   00000044   0xF89E 0xE004      LDRB     LR,[LR, #+4]
   \   00000048   0xEB02 0x1C01      ADD      R12,R2,R1, LSL #+4
   \   0000004C   0xF89C 0x200C      LDRB     R2,[R12, #+12]
   \   00000050   0x4572             CMP      R2,LR
   \   00000052   0xD1E2             BNE.N    ??USB_DeviceClassEvent_3
    359                      {
    360                          /* Call class event callback of supported class */
    361                          errorReturn = s_UsbDeviceClassInterfaceMap[mapIndex].classEventCallback(
    362                              (void *)classHandle->configList->config[classIndex].classHandle, event, param);
   \   00000054   0x6858             LDR      R0,[R3, #+4]
   \   00000056   0xF8DC 0x3008      LDR      R3,[R12, #+8]
   \   0000005A   0x462A             MOV      R2,R5
   \   0000005C   0x4621             MOV      R1,R4
   \   0000005E   0x4798             BLX      R3
    363                          /* Return the error code kStatus_USB_InvalidRequest immediately, when a class returns
    364                           * kStatus_USB_InvalidRequest. */
    365                          if (kStatus_USB_InvalidRequest == errorReturn)
   \   00000060   0x2805             CMP      R0,#+5
   \   00000062   0xD004             BEQ.N    ??USB_DeviceClassEvent_7
    366                          {
    367                              return kStatus_USB_InvalidRequest;
    368                          }
    369                          /* For composite device, it should return kStatus_USB_Success once a valid request has been handled */
    370                          if (kStatus_USB_Success == errorReturn)
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD1DC             BNE.N    ??USB_DeviceClassEvent_5
    371                          {
    372                              error = kStatus_USB_Success;
   \   00000068   0x2600             MOVS     R6,#+0
   \   0000006A   0xE7DA             B.N      ??USB_DeviceClassEvent_5
    373                          }
    374                          break;
    375                      }
    376                  }
    377              }
    378          
    379              return error;
   \                     ??USB_DeviceClassEvent_6: (+1)
   \   0000006C   0x4630             MOV      R0,R6
   \                     ??USB_DeviceClassEvent_7: (+1)
   \   0000006E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    380          }
    381          
    382          /*!
    383           * @brief Handle the common class callback.
    384           *
    385           * This function handles the common class callback.
    386           *
    387           * @param handle          The device handle, got from the USB_DeviceInit.
    388           * @param event           The event codes. Please refer to the enumeration usb_device_event_t.
    389           * @param param           The param type is determined by the event code.
    390           *
    391           * @return A USB error code or kStatus_USB_Success.
    392           */

   \                                 In section .text, align 2, keep-with-next
    393          usb_status_t USB_DeviceClassCallback(usb_device_handle handle, uint32_t event, void *param)
    394          {
   \                     USB_DeviceClassCallback: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4616             MOV      R6,R2
    395              usb_device_common_class_struct_t *classHandle;
    396              usb_status_t error = kStatus_USB_Error;
    397          
    398              /* Get the common class handle according to the device handle. */
    399              error = USB_DeviceClassGetHandleByDeviceHandle(handle, &classHandle);
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x.... 0x....      BL       USB_DeviceClassGetHandleByDeviceHandle
    400              if (kStatus_USB_Success != error)
   \   00000010   0x0001             MOVS     R1,R0
   \   00000012   0xD111             BNE.N    ??USB_DeviceClassCallback_0
    401              {
    402                  return error;
    403              }
    404          
    405              if (kUSB_DeviceEventBusReset == event)
   \   00000014   0x2D01             CMP      R5,#+1
   \   00000016   0xD108             BNE.N    ??USB_DeviceClassCallback_1
    406              {
    407                  /* Initialize the control pipes */
    408                  USB_DeviceControlPipeInit(handle, classHandle);
   \   00000018   0x9900             LDR      R1,[SP, #+0]
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       USB_DeviceControlPipeInit
    409          
    410                  /* Notify the classes the USB bus reset signal detected. */
    411                  USB_DeviceClassEvent(handle, kUSB_DeviceClassEventDeviceReset, classHandle);
   \   00000020   0x9A00             LDR      R2,[SP, #+0]
   \   00000022   0x2102             MOVS     R1,#+2
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       USB_DeviceClassEvent
    412              }
    413          
    414              /* Call the application device callback function. */
    415              error = classHandle->configList->deviceCallback(handle, event, param);
    416              return error;
   \                     ??USB_DeviceClassCallback_1: (+1)
   \   0000002A   0x9B00             LDR      R3,[SP, #+0]
   \   0000002C   0x685B             LDR      R3,[R3, #+4]
   \   0000002E   0x685B             LDR      R3,[R3, #+4]
   \   00000030   0x4632             MOV      R2,R6
   \   00000032   0x4629             MOV      R1,R5
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x4798             BLX      R3
   \                     ??USB_DeviceClassCallback_0: (+1)
   \   00000038   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    417          }
    418          
    419          /*!
    420           * @brief Initialize the common class and the supported classes.
    421           *
    422           * This function is used to initialize the common class and the supported classes.
    423           *
    424           * @param[in] controllerId   The controller id of the USB IP. Please refer to the enumeration #usb_controller_index_t.
    425           * @param[in] configList     The class configurations. The pointer must point to the goblal variable.
    426           *                           Please refer to the structure #usb_device_class_config_list_struct_t.
    427           * @param[out] handle        It is out parameter, is used to return pointer of the device handle to the caller.
    428           *                           The value of parameter is a pointer points the device handle, and this design is uesd to
    429           *                           make simple device align with composite device. For composite device, there are many
    430           *                           kinds of class handle, but there is only one device handle. So the handle points to
    431           *                           a device instead of a class. And the class handle can be got from the
    432           *                           #usb_device_class_config_struct_t::classHandle after the the function successfully.
    433           *
    434           * @return A USB error code or kStatus_USB_Success.
    435           */

   \                                 In section .text, align 2, keep-with-next
    436          usb_status_t USB_DeviceClassInit(
    437              uint8_t controllerId,                              /*!< [IN] Controller ID */
    438              usb_device_class_config_list_struct_t *configList, /*!< [IN] Pointer to class configuration list */
    439              usb_device_handle *handle                          /*!< [OUT] Pointer to the device handle */
    440              )
    441          {
   \                     USB_DeviceClassInit: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4691             MOV      R9,R2
    442              usb_device_common_class_struct_t *classHandle;
    443              usb_status_t error = kStatus_USB_Error;
   \   00000006   0x2401             MOVS     R4,#+1
   \   00000008   0x460F             MOV      R7,R1
    444              uint8_t mapIndex;
    445              uint8_t classIndex;
    446          
    447              if ((NULL == handle) || (NULL == configList) || ((usb_device_callback_t)NULL == configList->deviceCallback))
   \   0000000A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000000E   0xBF18             IT       NE 
   \   00000010   0x2F00             CMPNE    R7,#+0
   \   00000012   0x4680             MOV      R8,R0
   \   00000014   0xD001             BEQ.N    ??USB_DeviceClassInit_0
   \   00000016   0x6878             LDR      R0,[R7, #+4]
   \   00000018   0xB908             CBNZ.N   R0,??USB_DeviceClassInit_1
    448              {
    449                  return kStatus_USB_InvalidParameter;
   \                     ??USB_DeviceClassInit_0: (+1)
   \   0000001A   0x2004             MOVS     R0,#+4
   \   0000001C   0xE046             B.N      ??USB_DeviceClassInit_2
    450              }
    451          
    452              /* Allocate a common class driver handle. */
    453              error = USB_DeviceClassAllocateHandle(controllerId, &classHandle);
   \                     ??USB_DeviceClassInit_1: (+1)
   \   0000001E   0x.... 0x....      BL       USB_BmEnterCritical
   \   00000022   0x....             LDR.N    R6,??DataTable2
   \   00000024   0x6830             LDR      R0,[R6, #+0]
   \   00000026   0xB128             CBZ.N    R0,??USB_DeviceClassInit_3
   \   00000028   0x7CB2             LDRB     R2,[R6, #+18]
   \   0000002A   0x4590             CMP      R8,R2
   \   0000002C   0xD102             BNE.N    ??USB_DeviceClassInit_3
   \   0000002E   0x.... 0x....      BL       USB_BmExitCritical
    454              if (kStatus_USB_Success != error)
    455              {
    456                  return error;
   \   00000032   0xE016             B.N      ??USB_DeviceClassInit_4
    457              }
   \                     ??USB_DeviceClassInit_3: (+1)
   \   00000034   0xB118             CBZ.N    R0,??USB_DeviceClassInit_5
   \   00000036   0x.... 0x....      BL       USB_BmExitCritical
   \   0000003A   0x2402             MOVS     R4,#+2
   \   0000003C   0xE011             B.N      ??USB_DeviceClassInit_4
   \                     ??USB_DeviceClassInit_5: (+1)
   \   0000003E   0xF886 0x8012      STRB     R8,[R6, #+18]
   \   00000042   0x.... 0x....      BL       USB_BmExitCritical
    458              /* Save the configuration list */
    459              classHandle->configList = configList;
   \   00000046   0x6077             STR      R7,[R6, #+4]
    460          
    461              /* Initialize the device stack. */
    462              error = USB_DeviceInit(controllerId, USB_DeviceClassCallback, &classHandle->handle);
   \   00000048   0x4632             MOV      R2,R6
   \   0000004A   0x....             LDR.N    R1,??DataTable2_1
   \   0000004C   0x4640             MOV      R0,R8
   \   0000004E   0x.... 0x....      BL       USB_DeviceInit
   \   00000052   0x4604             MOV      R4,R0
    463          
    464              if (kStatus_USB_Success != error)
   \   00000054   0xB138             CBZ.N    R0,??USB_DeviceClassInit_6
    465              {
    466                  USB_DeviceDeinit(classHandle->handle);
   \   00000056   0x6830             LDR      R0,[R6, #+0]
   \   00000058   0x.... 0x....      BL       USB_DeviceDeinit
    467                  USB_DeviceClassFreeHandle(controllerId);
   \   0000005C   0x4640             MOV      R0,R8
   \   0000005E   0x.... 0x....      BL       USB_DeviceClassFreeHandle
    468                  return error;
   \                     ??USB_DeviceClassInit_4: (+1)
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0xE022             B.N      ??USB_DeviceClassInit_2
    469              }
    470          
    471              /* Initialize the all supported classes according to the configuration list. */
    472              for (classIndex = 0U; classIndex < classHandle->configList->count; classIndex++)
   \                     ??USB_DeviceClassInit_6: (+1)
   \   00000066   0x2700             MOVS     R7,#+0
   \   00000068   0x.... 0x....      ADR.W    R4,s_UsbDeviceClassInterfaceMap
   \   0000006C   0xE016             B.N      ??USB_DeviceClassInit_7
    473              {
    474                  for (mapIndex = 0U; mapIndex < (sizeof(s_UsbDeviceClassInterfaceMap) / sizeof(usb_device_class_map_t));
   \                     ??USB_DeviceClassInit_8: (+1)
   \   0000006E   0x2500             MOVS     R5,#+0
    475                       mapIndex++)
    476                  {
    477                      if (classHandle->configList->config[classIndex].classInfomation->type ==
    478                          s_UsbDeviceClassInterfaceMap[mapIndex].type)
   \                     ??USB_DeviceClassInit_9: (+1)
   \   00000070   0x6870             LDR      R0,[R6, #+4]
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x210C             MOVS     R1,#+12
   \   00000076   0xFB11 0xF107      SMULBB   R1,R1,R7
   \   0000007A   0x4401             ADD      R1,R0,R1
   \   0000007C   0x012B             LSLS     R3,R5,#+4
   \   0000007E   0x6888             LDR      R0,[R1, #+8]
   \   00000080   0x7900             LDRB     R0,[R0, #+4]
   \   00000082   0x18E2             ADDS     R2,R4,R3
   \   00000084   0x7B12             LDRB     R2,[R2, #+12]
   \   00000086   0x4290             CMP      R0,R2
   \   00000088   0xD103             BNE.N    ??USB_DeviceClassInit_10
    479                      {
    480                          (void)s_UsbDeviceClassInterfaceMap[mapIndex].classInit(
    481                              controllerId, &classHandle->configList->config[classIndex],
    482                              &classHandle->configList->config[classIndex].classHandle);
   \   0000008A   0x58E3             LDR      R3,[R4, R3]
   \   0000008C   0x1D0A             ADDS     R2,R1,#+4
   \   0000008E   0x4640             MOV      R0,R8
   \   00000090   0x4798             BLX      R3
    483                      }
    484                  }
   \                     ??USB_DeviceClassInit_10: (+1)
   \   00000092   0x1C6D             ADDS     R5,R5,#+1
   \   00000094   0x2D03             CMP      R5,#+3
   \   00000096   0xD3EB             BCC.N    ??USB_DeviceClassInit_9
    485              }
   \   00000098   0x1C7F             ADDS     R7,R7,#+1
   \   0000009A   0xB2FF             UXTB     R7,R7
   \                     ??USB_DeviceClassInit_7: (+1)
   \   0000009C   0x6870             LDR      R0,[R6, #+4]
   \   0000009E   0x7A00             LDRB     R0,[R0, #+8]
   \   000000A0   0x4287             CMP      R7,R0
   \   000000A2   0xDBE4             BLT.N    ??USB_DeviceClassInit_8
    486          
    487              *handle = classHandle->handle;
   \   000000A4   0x6830             LDR      R0,[R6, #+0]
   \   000000A6   0xF8C9 0x0000      STR      R0,[R9, #+0]
    488              return error;
   \   000000AA   0x2000             MOVS     R0,#+0
   \                     ??USB_DeviceClassInit_2: (+1)
   \   000000AC   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    489          }
    490          
    491          /*!
    492           * @brief De-initialize the common class and the supported classes.
    493           *
    494           * This function is used to de-initialize the common class and the supported classes.
    495           *
    496           * @param controllerId   The controller id of the USB IP. Please refer to the enumeration usb_controller_index_t.
    497           *
    498           * @return A USB error code or kStatus_USB_Success.
    499           */

   \                                 In section .text, align 2, keep-with-next
    500          usb_status_t USB_DeviceClassDeinit(uint8_t controllerId /*!< [IN] Controller ID */
    501                                             )
    502          {
   \                     USB_DeviceClassDeinit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    503              usb_device_common_class_struct_t *classHandle;
    504              usb_status_t error = kStatus_USB_Error;
    505              uint8_t mapIndex;
    506              uint8_t classIndex;
    507          
    508              /* Get the common class handle according to the controller id. */
    509              error = USB_DeviceClassGetHandleByControllerId(controllerId, &classHandle);
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x.... 0x....      BL       USB_DeviceClassGetHandleByControllerId
   \   0000000C   0x0005             MOVS     R5,R0
    510          
    511              if (kStatus_USB_Success != error)
   \   0000000E   0xD128             BNE.N    ??USB_DeviceClassDeinit_0
    512              {
    513                  return error;
    514              }
    515          
    516              /* De-initialize the all supported classes according to the configuration list. */
    517              for (classIndex = 0U; classIndex < classHandle->configList->count; classIndex++)
   \   00000010   0x2500             MOVS     R5,#+0
   \   00000012   0xE018             B.N      ??USB_DeviceClassDeinit_1
    518              {
    519                  for (mapIndex = 0U; mapIndex < (sizeof(s_UsbDeviceClassInterfaceMap) / sizeof(usb_device_class_map_t));
   \                     ??USB_DeviceClassDeinit_2: (+1)
   \   00000014   0x2600             MOVS     R6,#+0
    520                       mapIndex++)
    521                  {
    522                      if (classHandle->configList->config[classIndex].classInfomation->type ==
    523                          s_UsbDeviceClassInterfaceMap[mapIndex].type)
   \                     ??USB_DeviceClassDeinit_3: (+1)
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x6840             LDR      R0,[R0, #+4]
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x210C             MOVS     R1,#+12
   \   0000001E   0xFB11 0xF105      SMULBB   R1,R1,R5
   \   00000022   0x4408             ADD      R0,R0,R1
   \   00000024   0x.... 0x....      ADR.W    R1,s_UsbDeviceClassInterfaceMap
   \   00000028   0x6882             LDR      R2,[R0, #+8]
   \   0000002A   0x7912             LDRB     R2,[R2, #+4]
   \   0000002C   0xEB01 0x1106      ADD      R1,R1,R6, LSL #+4
   \   00000030   0x7B0B             LDRB     R3,[R1, #+12]
   \   00000032   0x429A             CMP      R2,R3
   \   00000034   0xD102             BNE.N    ??USB_DeviceClassDeinit_4
    524                      {
    525                          (void)s_UsbDeviceClassInterfaceMap[mapIndex].classDeinit(
    526                              classHandle->configList->config[classIndex].classHandle);
   \   00000036   0x6840             LDR      R0,[R0, #+4]
   \   00000038   0x6849             LDR      R1,[R1, #+4]
   \   0000003A   0x4788             BLX      R1
    527                      }
    528                  }
   \                     ??USB_DeviceClassDeinit_4: (+1)
   \   0000003C   0x1C76             ADDS     R6,R6,#+1
   \   0000003E   0x2E03             CMP      R6,#+3
   \   00000040   0xD3E9             BCC.N    ??USB_DeviceClassDeinit_3
    529              }
   \   00000042   0x1C6D             ADDS     R5,R5,#+1
   \   00000044   0xB2ED             UXTB     R5,R5
   \                     ??USB_DeviceClassDeinit_1: (+1)
   \   00000046   0x9800             LDR      R0,[SP, #+0]
   \   00000048   0x6840             LDR      R0,[R0, #+4]
   \   0000004A   0x7A00             LDRB     R0,[R0, #+8]
   \   0000004C   0x4285             CMP      R5,R0
   \   0000004E   0xDBE1             BLT.N    ??USB_DeviceClassDeinit_2
    530          
    531              /* De-initialize the USB device stack. */
    532              error = USB_DeviceDeinit(classHandle->handle);
   \   00000050   0x9800             LDR      R0,[SP, #+0]
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x.... 0x....      BL       USB_DeviceDeinit
   \   00000058   0x0005             MOVS     R5,R0
    533              if (kStatus_USB_Success == error)
   \   0000005A   0xBF04             ITT      EQ 
    534              {
    535                  /* Free the common class handle. */
    536                  (void)USB_DeviceClassFreeHandle(controllerId);
   \   0000005C   0x4620             MOVEQ    R0,R4
   \   0000005E   0x.... 0x....      BLEQ     USB_DeviceClassFreeHandle
    537              }
    538              return error;
   \                     ??USB_DeviceClassDeinit_0: (+1)
   \   00000062   0x4628             MOV      R0,R5
   \   00000064   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    539          }
    540          
    541          /*!
    542           * @brief Get the USB bus speed.
    543           *
    544           * This function is used to get the USB bus speed.
    545           *
    546           * @param controllerId   The controller id of the USB IP. Please refer to the enumeration usb_controller_index_t.
    547           * @param speed           It is an OUT parameter, return current speed of the controller.
    548           *
    549           * @return A USB error code or kStatus_USB_Success.
    550           */

   \                                 In section .text, align 2, keep-with-next
    551          usb_status_t USB_DeviceClassGetSpeed(uint8_t controllerId, /*!< [IN] Controller ID */
    552                                               uint8_t *speed        /*!< [OUT] Current speed */
    553                                               )
    554          {
   \                     USB_DeviceClassGetSpeed: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x460C             MOV      R4,R1
    555              usb_device_common_class_struct_t *classHandle;
    556              usb_status_t error = kStatus_USB_Error;
    557          
    558              /* Get the common class handle according to the controller id. */
    559              error = USB_DeviceClassGetHandleByControllerId(controllerId, &classHandle);
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x.... 0x....      BL       USB_DeviceClassGetHandleByControllerId
    560          
    561              if (kStatus_USB_Success != error)
   \   0000000C   0x0001             MOVS     R1,R0
   \   0000000E   0xD105             BNE.N    ??USB_DeviceClassGetSpeed_0
    562              {
    563                  return error;
    564              }
    565          
    566              /* Get the current speed. */
    567              error = USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusSpeed, speed);
    568          
    569              return error;
   \   00000010   0x9800             LDR      R0,[SP, #+0]
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x4622             MOV      R2,R4
   \   00000016   0x2102             MOVS     R1,#+2
   \   00000018   0x.... 0x....      BL       USB_DeviceGetStatus
   \                     ??USB_DeviceClassGetSpeed_0: (+1)
   \   0000001C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    570          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     s_UsbDeviceCommonClassStruct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     USB_DeviceClassCallback
    571          #endif /* USB_DEVICE_CONFIG_NUM */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   USB_DeviceClassCallback
        24   -- Indirect call
        24   -> USB_DeviceClassEvent
        24   -> USB_DeviceClassGetHandleByDeviceHandle
        24   -> USB_DeviceControlPipeInit
      24   USB_DeviceClassDeinit
        24   -- Indirect call
        24   -> USB_DeviceClassFreeHandle
        24   -> USB_DeviceClassGetHandleByControllerId
        24   -> USB_DeviceDeinit
      24   USB_DeviceClassEvent
        24   -- Indirect call
        24   -> USB_DeviceClassGetHandleByDeviceHandle
       8   USB_DeviceClassFreeHandle
         8   -> USB_BmEnterCritical
         8   -> USB_BmExitCritical
      16   USB_DeviceClassGetDeviceHandle
        16   -> USB_BmEnterCritical
        16   -> USB_BmExitCritical
      16   USB_DeviceClassGetHandleByControllerId
        16   -> USB_BmEnterCritical
        16   -> USB_BmExitCritical
      16   USB_DeviceClassGetHandleByDeviceHandle
        16   -> USB_BmEnterCritical
        16   -> USB_BmExitCritical
      16   USB_DeviceClassGetSpeed
        16   -> USB_DeviceClassGetHandleByControllerId
        16   -> USB_DeviceGetStatus
      32   USB_DeviceClassInit
        32   -- Indirect call
        32   -> USB_BmEnterCritical
        32   -> USB_BmExitCritical
        32   -> USB_DeviceClassFreeHandle
        32   -> USB_DeviceDeinit
        32   -> USB_DeviceInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
      10  ?Subroutine0
       8  ?Subroutine1
       8  ?Subroutine2
       6  ?Subroutine3
      58  USB_DeviceClassCallback
     102  USB_DeviceClassDeinit
     112  USB_DeviceClassEvent
      44  USB_DeviceClassFreeHandle
      24  USB_DeviceClassGetDeviceHandle
      22  USB_DeviceClassGetHandleByControllerId
      16  USB_DeviceClassGetHandleByDeviceHandle
      30  USB_DeviceClassGetSpeed
     176  USB_DeviceClassInit
      48  s_UsbDeviceClassInterfaceMap
      20  s_UsbDeviceCommonClassStruct

 
 672 bytes in section .text
  20 bytes in section m_usb_global
 
 672 bytes of CODE memory
  20 bytes of DATA memory

Errors: none
Warnings: none
