###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Aug/2016  13:15:58
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bm_usb\msc_disk.c
#    Command line =  
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bm_usb\msc_disk.c"
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN256VDC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D BL_TARGET_RAM -lC
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj"
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices/MK22F25612\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/autobaud\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/osa\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device/class\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/bm_usb\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/CMSIS/Include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers/common\"
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list\msc_disk.lst
#    Object file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj\msc_disk.o
#
###############################################################################

C:\Users\cwati\Documents\My Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bm_usb\msc_disk.c
      1          /*
      2           * Copyright (c) 2015-2016, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "usb_device_config.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void debug_printf(char const *, ...)
   \                     debug_printf: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB500             PUSH     {LR}
   \   00000004   0xA901             ADD      R1,SP,#+4
   \   00000006   0x.... 0x....      BL       vprintf
   \   0000000A   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
     32          #include "usb.h"
     33          #include "usb_device.h"
     34          
     35          #include "usb_device_class.h"
     36          #include "usb_device_msc.h"
     37          #include "usb_device_ch9.h"
     38          #include "usb_descriptor.h"
     39          #include "msc_disk.h"
     40          #include "sbloader/sbloader.h"
     41          #include "sbloader/sb_file_format.h"
     42          #include "bootloader/bootloader.h"
     43          #include "utilities/fsl_rtos_abstraction.h"
     44          #include "fsl_device_registers.h"
     45          #include "utilities/fsl_assert.h"
     46          #include "utilities/fsl_rtos_abstraction.h"
     47          #include "bootloader/bl_peripheral_interface.h"
     48          #include "bootloader/bl_context.h"
     49          #include "fat_directory_entry.h"
     50          #include <stdio.h>
     51          #include <stdlib.h>
     52          #include <string.h>
     53          
     54          #include "composite.h"
     55          
     56          #if (BL_CONFIG_USB_MSC || BL_CONFIG_HS_USB_MSC)
     57          

   \                                 In section .bss, align 4
     58          static usb_device_composite_struct_t *g_device_composite;
   \                     g_device_composite:
   \   00000000                      DS8 4
     59          
     60          usb_status_t usb_msd_write_sector(uint32_t sector, const usb_device_lba_app_struct_t *lbaData);
     61          usb_status_t usb_msd_read_sector(uint32_t sector, usb_device_lba_app_struct_t *lbaData);
     62          bool is_valid_sb_file_header(const uint8_t *data, uint32_t *fileLength);
     63          status_t feed_sbloader(void);
     64          void usb_msd_start_transfer(uint32_t length);
     65          void reset_usb_msd_state(uint8_t loaderStatus);
     66          void format_hex_string(char *s, uint32_t value);
     67          void usb_msd_update_info_file(uint8_t *buffer);
     68          
     69          ////////////////////////////////////////////////////////////////////////////////
     70          // Definitions
     71          ////////////////////////////////////////////////////////////////////////////////
     72          
     73          //! @brief Date and time constants for directory entries.
     74          enum _date_time_constants
     75          {
     76              kFileDate = MAKE_FAT_DATE(12, 1, 2013), //!< 01-Dec-2013
     77              kFileTime = MAKE_FAT_TIME(12, 0, 0)     //!< 12:00:00 noon
     78          };
     79          
     80          ////////////////////////////////////////////////////////////////////////////////
     81          // Variables
     82          ////////////////////////////////////////////////////////////////////////////////
     83          //! @brief Used by format_hex_string().

   \                                 In section .text, align 4, keep-with-next
     84          static const char kHexChars[] = "0123456789abcdef";
   \                     kHexChars:
   \   00000000   0x30 0x31          DC8 "0123456789abcdef"
   \              0x32 0x33    
   \              0x34 0x35    
   \              0x36 0x37    
   \              0x38 0x39    
   \              0x61 0x62    
   \              0x63 0x64    
   \              0x65 0x66    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     85          
     86          //! @brief Messages corresponding to the various transfer statuses.

   \                                 In section .text, align 4, keep-with-next
     87          static const char *const kStatusMessages[] = {
   \                     kStatusMessages:
   \   00000000   0x........         DC32 ?_0, ?_1, ?_2, ?_3
   \              0x........   
   \              0x........   
   \              0x........   
     88              "Ready\r\n",        // kReadyStatus
     89              "Transferring\r\n", // kTransferringStatus
     90              "Success\r\n",      // kSuccessStatus
     91              "Failure\r\n"       // kFailureStatus
     92          };
     93          
     94          //! @brief Format for contents of the info.txt file.

   \                                 In section .text, align 4, keep-with-next
     95          static const char kInfoFileFormat[] =
   \                     kInfoFileFormat:
   \   00000000   0x4B 0x69          DC8 4BH, 69H, 6EH, 65H, 74H, 69H, 73H, 20H
   \              0x6E 0x65    
   \              0x74 0x69    
   \              0x73 0x20    
   \   00000008   0x42 0x6F          DC8 42H, 6FH, 6FH, 74H, 6CH, 6FH, 61H, 64H
   \              0x6F 0x74    
   \              0x6C 0x6F    
   \              0x61 0x64    
   \   00000010   0x65 0x72          DC8 65H, 72H, 20H, 25H, 63H, 25H, 64H, 2EH
   \              0x20 0x25    
   \              0x63 0x25    
   \              0x64 0x2E    
   \   00000018   0x25 0x64          DC8 25H, 64H, 2EH, 25H, 64H, 0DH, 0AH, 0DH
   \              0x2E 0x25    
   \              0x64 0x0D    
   \              0x0A 0x0D    
   \   00000020   0x0A 0x53          DC8 0AH, 53H, 79H, 73H, 74H, 65H, 6DH, 20H
   \              0x79 0x73    
   \              0x74 0x65    
   \              0x6D 0x20    
   \   00000028   0x64 0x65          DC8 64H, 65H, 76H, 69H, 63H, 65H, 20H, 49H
   \              0x76 0x69    
   \              0x63 0x65    
   \              0x20 0x49    
   \   00000030   0x44 0x3A          DC8 44H, 3AH, 20H, 25H, 73H, 0DH, 0AH, 46H
   \              0x20 0x25    
   \              0x73 0x0D    
   \              0x0A 0x46    
   \   00000038   0x6C 0x61          DC8 6CH, 61H, 73H, 68H, 20H, 73H, 69H, 7AH
   \              0x73 0x68    
   \              0x20 0x73    
   \              0x69 0x7A    
   \   00000040   0x65 0x3A          DC8 65H, 3AH, 20H, 25H, 73H, 20H, 62H, 79H
   \              0x20 0x25    
   \              0x73 0x20    
   \              0x62 0x79    
   \   00000048   0x74 0x65          DC8 74H, 65H, 73H, 0DH, 0AH, 46H, 6CH, 61H
   \              0x73 0x0D    
   \              0x0A 0x46    
   \              0x6C 0x61    
   \   00000050   0x73 0x68          DC8 73H, 68H, 20H, 72H, 61H, 6EH, 67H, 65H
   \              0x20 0x72    
   \              0x61 0x6E    
   \              0x67 0x65    
   \   00000058   0x3A 0x20          DC8 3AH, 20H, 25H, 73H, 2DH, 25H, 73H, 0DH
   \              0x25 0x73    
   \              0x2D 0x25    
   \              0x73 0x0D    
   \   00000060   0x0A 0x46          DC8 0AH, 46H, 6CH, 61H, 73H, 68H, 20H, 73H
   \              0x6C 0x61    
   \              0x73 0x68    
   \              0x20 0x73    
   \   00000068   0x65 0x63          DC8 65H, 63H, 74H, 6FH, 72H, 20H, 73H, 69H
   \              0x74 0x6F    
   \              0x72 0x20    
   \              0x73 0x69    
   \   00000070   0x7A 0x65          DC8 7AH, 65H, 3AH, 20H, 25H, 73H, 20H, 62H
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x20 0x62    
   \   00000078   0x79 0x74          DC8 79H, 74H, 65H, 73H, 0DH, 0AH, 46H, 6CH
   \              0x65 0x73    
   \              0x0D 0x0A    
   \              0x46 0x6C    
   \   00000080   0x61 0x73          DC8 61H, 73H, 68H, 20H, 62H, 6CH, 6FH, 63H
   \              0x68 0x20    
   \              0x62 0x6C    
   \              0x6F 0x63    
   \   00000088   0x6B 0x73          DC8 6BH, 73H, 3AH, 20H, 25H, 73H, 0DH, 0AH
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0D 0x0A    
   \   00000090   0x52 0x41          DC8 52H, 41H, 4DH, 20H, 73H, 69H, 7AH, 65H
   \              0x4D 0x20    
   \              0x73 0x69    
   \              0x7A 0x65    
   \   00000098   0x3A 0x20          DC8 3AH, 20H, 25H, 73H, 20H, 62H, 79H, 74H
   \              0x25 0x73    
   \              0x20 0x62    
   \              0x79 0x74    
   \   000000A0   0x65 0x73          DC8 65H, 73H, 0DH, 0AH, 52H, 41H, 4DH, 20H
   \              0x0D 0x0A    
   \              0x52 0x41    
   \              0x4D 0x20    
   \   000000A8   0x72 0x61          DC8 72H, 61H, 6EH, 67H, 65H, 3AH, 20H, 25H
   \              0x6E 0x67    
   \              0x65 0x3A    
   \              0x20 0x25    
   \   000000B0   0x73 0x2D          DC8 73H, 2DH, 25H, 73H, 0DH, 0AH, 52H, 65H
   \              0x25 0x73    
   \              0x0D 0x0A    
   \              0x52 0x65    
   \   000000B8   0x73 0x65          DC8 73H, 65H, 72H, 76H, 65H, 64H, 20H, 72H
   \              0x72 0x76    
   \              0x65 0x64    
   \              0x20 0x72    
   \   000000C0   0x65 0x67          DC8 65H, 67H, 69H, 6FH, 6EH, 20H, 30H, 3AH
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x30 0x3A    
   \   000000C8   0x20 0x25          DC8 20H, 25H, 73H, 2DH, 25H, 73H, 0DH, 0AH
   \              0x73 0x2D    
   \              0x25 0x73    
   \              0x0D 0x0A    
   \   000000D0   0x52 0x65          DC8 52H, 65H, 73H, 65H, 72H, 76H, 65H, 64H
   \              0x73 0x65    
   \              0x72 0x76    
   \              0x65 0x64    
   \   000000D8   0x20 0x72          DC8 20H, 72H, 65H, 67H, 69H, 6FH, 6EH, 20H
   \              0x65 0x67    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \   000000E0   0x31 0x3A          DC8 31H, 3AH, 20H, 25H, 73H, 2DH, 25H, 73H
   \              0x20 0x25    
   \              0x73 0x2D    
   \              0x25 0x73    
   \   000000E8   0x0D 0x0A          DC8 0DH, 0AH, 56H, 65H, 72H, 69H, 66H, 79H
   \              0x56 0x65    
   \              0x72 0x69    
   \              0x66 0x79    
   \   000000F0   0x20 0x77          DC8 20H, 77H, 72H, 69H, 74H, 65H, 73H, 3AH
   \              0x72 0x69    
   \              0x74 0x65    
   \              0x73 0x3A    
   \   000000F8   0x20 0x25          DC8 20H, 25H, 73H, 0DH, 0AH, 43H, 68H, 65H
   \              0x73 0x0D    
   \              0x0A 0x43    
   \              0x68 0x65    
   \   00000100   0x63 0x6B          DC8 63H, 6BH, 20H, 72H, 65H, 73H, 65H, 72H
   \              0x20 0x72    
   \              0x65 0x73    
   \              0x65 0x72    
   \   00000108   0x76 0x65          DC8 76H, 65H, 64H, 20H, 72H, 65H, 67H, 69H
   \              0x64 0x20    
   \              0x72 0x65    
   \              0x67 0x69    
   \   00000110   0x6F 0x6E          DC8 6FH, 6EH, 73H, 3AH, 20H, 25H, 73H, 0DH
   \              0x73 0x3A    
   \              0x20 0x25    
   \              0x73 0x0D    
   \   00000118   0x0A 0x42          DC8 0AH, 42H, 6FH, 6FH, 74H, 20H, 63H, 6FH
   \              0x6F 0x6F    
   \              0x74 0x20    
   \              0x63 0x6F    
   \   00000120   0x6E 0x66          DC8 6EH, 66H, 69H, 67H, 20H, 70H, 72H, 65H
   \              0x69 0x67    
   \              0x20 0x70    
   \              0x72 0x65    
   \   00000128   0x73 0x65          DC8 73H, 65H, 6EH, 74H, 3AH, 20H, 25H, 73H
   \              0x6E 0x74    
   \              0x3A 0x20    
   \              0x25 0x73    
   \   00000130   0x0D 0x0A          DC8 0DH, 0AH, 50H, 65H, 72H, 69H, 70H, 68H
   \              0x50 0x65    
   \              0x72 0x69    
   \              0x70 0x68    
   \   00000138   0x65 0x72          DC8 65H, 72H, 61H, 6CH, 20H, 64H, 65H, 74H
   \              0x61 0x6C    
   \              0x20 0x64    
   \              0x65 0x74    
   \   00000140   0x65 0x63          DC8 65H, 63H, 74H, 69H, 6FH, 6EH, 20H, 74H
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x20 0x74    
   \   00000148   0x69 0x6D          DC8 69H, 6DH, 65H, 6FH, 75H, 74H, 3AH, 20H
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x3A 0x20    
   \   00000150   0x25 0x73          DC8 25H, 73H, 20H, 6DH, 73H, 0DH, 0AH, 43H
   \              0x20 0x6D    
   \              0x73 0x0D    
   \              0x0A 0x43    
   \   00000158   0x50 0x55          DC8 50H, 55H, 20H, 63H, 6CH, 6FH, 63H, 6BH
   \              0x20 0x63    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \   00000160   0x3A 0x20          DC8 3AH, 20H, 25H, 73H, 20H, 48H, 7AH, 0DH
   \              0x25 0x73    
   \              0x20 0x48    
   \              0x7A 0x0D    
   \   00000168   0x0A 0x00          DC8 0AH, 0
   \   0000016A   0x00 0x00          DC8 0, 0
     96              "Kinetis Bootloader %c%d.%d.%d\r\n"
     97              "\r\n"
     98              "System device ID: %s\r\n"
     99              "Flash size: %s bytes\r\n"
    100              "Flash range: %s-%s\r\n"
    101              "Flash sector size: %s bytes\r\n"
    102              "Flash blocks: %s\r\n"
    103              "RAM size: %s bytes\r\n"
    104              "RAM range: %s-%s\r\n"
    105              "Reserved region 0: %s-%s\r\n"
    106              "Reserved region 1: %s-%s\r\n"
    107              "Verify writes: %s\r\n"
    108              "Check reserved regions: %s\r\n"
    109              "Boot config present: %s\r\n"
    110              "Peripheral detection timeout: %s ms\r\n"
    111              "CPU clock: %s Hz\r\n";
    112          
    113          //! @brief Partition boot sector.
    114          //!
    115          //! Defines the FAT16 file system.
    116          //!
    117          //! The 0xaa55 signature at the end of the sector is not stored in this data. Instead, it is
    118          //! filled in at runtime. This is done in order to save const data space.

   \                                 In section .rodata, align 4, keep-with-next
    119          static const uint8_t k_pbs[] = {
   \                     k_pbs:
   \   00000000   0xEB 0x3C          DC8 235, 60, 144, 77, 83, 87, 73, 78, 52, 46, 49, 0, 2, 1, 1, 0, 2, 32
   \              0x90 0x4D    
   \              0x53 0x57    
   \              0x49 0x4E    
   \              0x34 0x2E    
   \              0x31 0x00    
   \              0x02 0x01    
   \              0x01 0x00    
   \              0x02 0x20    
   \   00000012   0x00 0xFF          DC8 0, 255, 127, 240, 128, 0, 1, 0, 1, 0, 1, 0, 0, 0, 255, 127, 0, 0, 0
   \              0x7F 0xF0    
   \              0x80 0x00    
   \              0x01 0x00    
   \              0x01 0x00    
   \              0x01 0x00    
   \              0x00 0x00    
   \              0xFF 0x7F    
   \              0x00 0x00    
   \              0x00         
   \   00000025   0x00 0x29          DC8 0, 41, 49, 50, 51, 52, 75, 105, 110, 101, 116, 105, 115, 32, 85, 83
   \              0x31 0x32    
   \              0x33 0x34    
   \              0x4B 0x69    
   \              0x6E 0x65    
   \              0x74 0x69    
   \              0x73 0x20    
   \              0x55 0x53    
   \   00000035   0x42 0x00          DC8 66, 0, 0
   \              0x00         
    120              0xEB,
    121              0x3C,
    122              0x90, // x86 JMP instruction
    123              'M',
    124              'S',
    125              'W',
    126              'I',
    127              'N',
    128              '4',
    129              '.',
    130              '1',                                 // 'MSWIN4.1'
    131              U16_LE(kDiskSectorSize),             // bytes per sector = 512
    132              0x01,                                // sectors per cluster = 1
    133              U16_LE(1),                           // number of reserved sectors = 1 (FAT12/16)
    134              0x02,                                // number of FATs = 2
    135              U16_LE(32),                          // maximum number of root directory entries = 32
    136              U16_LE(kDiskTotalLogicalBlocks - 1), // total volume sectors starting with PBS (16-bit count)
    137              0xF0,                                // media type, must match FAT[0] = 0xf0 (removable media)
    138              U16_LE(kDiskSectorsPerFat),          // sectors per FAT = 1
    139              U16_LE(1),                           // sectors per track = 1
    140              U16_LE(1),                           // number of heads = 1
    141              U32_LE(1),                           // sectors before start of PBS including MBR = 1
    142              U32_LE(kDiskTotalLogicalBlocks - 1), // total volume sectors starting with PBS
    143              0x00,                                // driver number (0x80 for hard disks) = 0
    144              0x00,                                // reserved
    145              0x29,                                // boot signature
    146              '1',
    147              '2',
    148              '3',
    149              '4', // volume ID = '1234'
    150              'K',
    151              'i',
    152              'n',
    153              'e',
    154              't',
    155              'i',
    156              's',
    157              ' ',
    158              'U',
    159              'S',
    160              'B', // volume label = 'Kinetis USB'
    161              // ..448 reserved bytes
    162              // 0x55,0xaa signature bytes - must be filled in at runtime
    163          };
    164          

   \                                 In section .rodata, align 4, keep-with-next
    165          static const uint16_t k_fat1[] = {
   \                     k_fat1:
   \   00000000   0xFFF0 0xFFFF      DC16 65520, 65535, 65535, 65535, 65535, 65535, 65535
   \              0xFFFF 0xFFFF
   \              0xFFFF 0xFFFF
   \              0xFFFF       
   \   0000000E   0x00 0x00          DC8 0, 0
    166              0xfff0, // unused cluster 0 (low byte must match media type in PBS)
    167              0xffff, // unused cluster 1
    168              0xffff, // '.fseventsd' directory
    169              0xffff, // 'System Volume Information' directory
    170              0xffff, // 'IndexerVolumeGuid' file
    171              0xffff, // 'info.txt' file
    172              0xffff, // 'status.txt' file
    173          };
    174          
    175          //! @brief Root directory.
    176          //!
    177          //! Volume label: FSL Loader
    178          //!
    179          //! Contents:
    180          //! - .fseventsd (FSEVEN~1)
    181          //! - .metadata_never_index (METADA~1)
    182          //! - .Trashes (TRASHE~1)
    183          //! - System Volume Information (SYSTEM~1)
    184          //! - info.txt
    185          //! - status.txt

   \                                 In section .rodata, align 4, keep-with-next
    186          static const fat_directory_entry_t k_rootDir[] = {
   \                     k_rootDir:
   \   00000000   0x46 0x53          DC8 70, 83, 76, 32, 76, 111, 97, 100, 101, 114, 32, 8, 0, 0
   \              0x4C 0x20    
   \              0x4C 0x6F    
   \              0x61 0x64    
   \              0x65 0x72    
   \              0x20 0x08    
   \              0x00 0x00    
   \   0000000E   0x0000 0x0000      DC16 0, 0, 0, 0, 24576, 16940
   \              0x0000 0x0000
   \              0x6000 0x422C
   \   0000001A   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 65
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x41         
   \   00000021   0x002E 0x0066      DC16 46, 102, 115, 101, 118
   \              0x0073 0x0065
   \              0x0076       
   \   0000002B   0x0F 0x00          DC8 15, 0, 218
   \              0xDA         
   \   0000002E   0x0065 0x006E      DC16 101, 110, 116, 115, 100, 0, 0, 65535, 65535
   \              0x0074 0x0073
   \              0x0064 0x0000
   \              0x0000 0xFFFF
   \              0xFFFF       
   \   00000040   0x46 0x53          DC8 70, 83, 69, 86, 69, 78, 126, 49, 32, 32, 32, 18, 0, 0
   \              0x45 0x56    
   \              0x45 0x4E    
   \              0x7E 0x31    
   \              0x20 0x20    
   \              0x20 0x12    
   \              0x00 0x00    
   \   0000004E   0x6000 0x422C      DC16 24576, 16940, 16940, 0, 24576, 16940, 2
   \              0x422C 0x0000
   \              0x6000 0x422C
   \              0x0002       
   \   0000005C   0x00000000         DC32 0
   \   00000060   0x42               DC8 66
   \   00000061   0x0065 0x0072      DC16 101, 114, 95, 105, 110
   \              0x005F 0x0069
   \              0x006E       
   \   0000006B   0x0F 0x00          DC8 15, 0, 168
   \              0xA8         
   \   0000006E   0x0064 0x0065      DC16 100, 101, 120, 0, 65535, 65535, 0, 65535, 65535
   \              0x0078 0x0000
   \              0xFFFF 0xFFFF
   \              0x0000 0xFFFF
   \              0xFFFF       
   \   00000080   0x01               DC8 1
   \   00000081   0x002E 0x006D      DC16 46, 109, 101, 116, 97
   \              0x0065 0x0074
   \              0x0061       
   \   0000008B   0x0F 0x00          DC8 15, 0, 168
   \              0xA8         
   \   0000008E   0x0064 0x0061      DC16 100, 97, 116, 97, 95, 110, 0, 101, 118
   \              0x0074 0x0061
   \              0x005F 0x006E
   \              0x0000 0x0065
   \              0x0076       
   \   000000A0   0x4D 0x45          DC8 77, 69, 84, 65, 68, 65, 126, 49, 32, 32, 32, 34, 0, 0
   \              0x54 0x41    
   \              0x44 0x41    
   \              0x7E 0x31    
   \              0x20 0x20    
   \              0x20 0x22    
   \              0x00 0x00    
   \   000000AE   0x6000 0x422C      DC16 24576, 16940, 16940, 0, 24576, 16940, 0
   \              0x422C 0x0000
   \              0x6000 0x422C
   \              0x0000       
   \   000000BC   0x00000000         DC32 0
   \   000000C0   0x41               DC8 65
   \   000000C1   0x002E 0x0054      DC16 46, 84, 114, 97, 115
   \              0x0072 0x0061
   \              0x0073       
   \   000000CB   0x0F 0x00          DC8 15, 0, 37
   \              0x25         
   \   000000CE   0x0068 0x0065      DC16 104, 101, 115, 0, 65535, 65535, 0, 65535, 65535
   \              0x0073 0x0000
   \              0xFFFF 0xFFFF
   \              0x0000 0xFFFF
   \              0xFFFF       
   \   000000E0   0x54 0x52          DC8 84, 82, 65, 83, 72, 69, 126, 49, 32, 32, 32, 34, 0, 0
   \              0x41 0x53    
   \              0x48 0x45    
   \              0x7E 0x31    
   \              0x20 0x20    
   \              0x20 0x22    
   \              0x00 0x00    
   \   000000EE   0x6000 0x422C      DC16 24576, 16940, 16940, 0, 24576, 16940, 0
   \              0x422C 0x0000
   \              0x6000 0x422C
   \              0x0000       
   \   000000FC   0x00000000         DC32 0
   \   00000100   0x42               DC8 66
   \   00000101   0x0020 0x0049      DC16 32, 73, 110, 102, 111
   \              0x006E 0x0066
   \              0x006F       
   \   0000010B   0x0F 0x00          DC8 15, 0, 114
   \              0x72         
   \   0000010E   0x0072 0x006D      DC16 114, 109, 97, 116, 105, 111, 0, 110, 0
   \              0x0061 0x0074
   \              0x0069 0x006F
   \              0x0000 0x006E
   \              0x0000       
   \   00000120   0x01               DC8 1
   \   00000121   0x0053 0x0079      DC16 83, 121, 115, 116, 101
   \              0x0073 0x0074
   \              0x0065       
   \   0000012B   0x0F 0x00          DC8 15, 0, 114
   \              0x72         
   \   0000012E   0x006D 0x0020      DC16 109, 32, 86, 111, 108, 117, 0, 109, 101
   \              0x0056 0x006F
   \              0x006C 0x0075
   \              0x0000 0x006D
   \              0x0065       
   \   00000140   0x53 0x59          DC8 83, 89, 83, 84, 69, 77, 126, 49, 32, 32, 32, 22, 0, 0
   \              0x53 0x54    
   \              0x45 0x4D    
   \              0x7E 0x31    
   \              0x20 0x20    
   \              0x20 0x16    
   \              0x00 0x00    
   \   0000014E   0x6000 0x422C      DC16 24576, 16940, 16940, 0, 24576, 16940, 3
   \              0x422C 0x0000
   \              0x6000 0x422C
   \              0x0003       
   \   0000015C   0x00000000         DC32 0
   \   00000160   0x49 0x4E          DC8 73, 78, 70, 79, 32, 32, 32, 32, 84, 88, 84, 32, 0, 0
   \              0x46 0x4F    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x54 0x58    
   \              0x54 0x20    
   \              0x00 0x00    
   \   0000016E   0x6000 0x422C      DC16 24576, 16940, 16940, 0, 24576, 16940, 5
   \              0x422C 0x0000
   \              0x6000 0x422C
   \              0x0005       
   \   0000017C   0x00000001         DC32 1
   \   00000180   0x53 0x54          DC8 83, 84, 65, 84, 85, 83, 32, 32, 84, 88, 84, 32, 0, 0
   \              0x41 0x54    
   \              0x55 0x53    
   \              0x20 0x20    
   \              0x54 0x58    
   \              0x54 0x20    
   \              0x00 0x00    
   \   0000018E   0x6000 0x422C      DC16 24576, 16940, 16940, 0, 24576, 16940, 6
   \              0x422C 0x0000
   \              0x6000 0x422C
   \              0x0006       
   \   0000019C   0x00000001         DC32 1
    187              // Volume label 'FSL Loader'
    188              MAKE_FAT_VOLUME_LABEL('F', 'S', 'L', ' ', 'L', 'o', 'a', 'd', 'e', 'r', ' ', kFileTime, kFileDate),
    189          
    190              // Mac OS X '.fseventsd' directory
    191              MAKE_FAT_LONG_NAME(
    192                  1, L'.', L'f', L's', L'e', L'v', L'e', L'n', L't', L's', L'd', 0, 0xffff, 0xffff, 0xda, kLastLongNameEntry),
    193              MAKE_FAT_DIR_ENTRY('F',
    194                                 'S',
    195                                 'E',
    196                                 'V',
    197                                 'E',
    198                                 'N',
    199                                 '~',
    200                                 '1',
    201                                 ' ',
    202                                 ' ',
    203                                 ' ',
    204                                 (kDirectoryAttribute | kHiddenAttribute),
    205                                 kFileTime,
    206                                 kFileDate,
    207                                 CLUSTER_FROM_SECTOR(kMacFseventsdDirSector),
    208                                 0),
    209          
    210              // Mac OS X '.metadata_never_index' file
    211              MAKE_FAT_LONG_NAME(
    212                  2, L'e', L'r', L'_', L'i', L'n', L'd', L'e', L'x', 0, 0xffff, 0xffff, 0xffff, 0xffff, 0xa8, kLastLongNameEntry),
    213              MAKE_FAT_LONG_NAME(1, L'.', L'm', L'e', L't', L'a', L'd', L'a', L't', L'a', L'_', L'n', L'e', L'v', 0xa8, 0),
    214              MAKE_FAT_DIR_ENTRY('M',
    215                                 'E',
    216                                 'T',
    217                                 'A',
    218                                 'D',
    219                                 'A',
    220                                 '~',
    221                                 '1',
    222                                 ' ',
    223                                 ' ',
    224                                 ' ',
    225                                 (kArchiveAttribute | kHiddenAttribute),
    226                                 kFileTime,
    227                                 kFileDate,
    228                                 0,
    229                                 0),
    230          
    231              // Mac OS X '.Trashes' file
    232              MAKE_FAT_LONG_NAME(
    233                  1, L'.', L'T', L'r', L'a', L's', L'h', L'e', L's', 0, 0xffff, 0xffff, 0xffff, 0xffff, 0x25, kLastLongNameEntry),
    234              MAKE_FAT_DIR_ENTRY('T',
    235                                 'R',
    236                                 'A',
    237                                 'S',
    238                                 'H',
    239                                 'E',
    240                                 '~',
    241                                 '1',
    242                                 ' ',
    243                                 ' ',
    244                                 ' ',
    245                                 (kArchiveAttribute | kHiddenAttribute),
    246                                 kFileTime,
    247                                 kFileDate,
    248                                 0,
    249                                 0),
    250          
    251              // Windows 'System Volume Information' directory
    252              MAKE_FAT_LONG_NAME(
    253                  2, L' ', L'I', L'n', L'f', L'o', L'r', L'm', L'a', L't', L'i', L'o', L'n', 0, 0x72, kLastLongNameEntry),
    254              MAKE_FAT_LONG_NAME(1, L'S', L'y', L's', L't', L'e', L'm', L' ', L'V', L'o', L'l', L'u', L'm', L'e', 0x72, 0),
    255              MAKE_FAT_DIR_ENTRY('S',
    256                                 'Y',
    257                                 'S',
    258                                 'T',
    259                                 'E',
    260                                 'M',
    261                                 '~',
    262                                 '1',
    263                                 ' ',
    264                                 ' ',
    265                                 ' ',
    266                                 (kDirectoryAttribute | kSystemAttribute | kHiddenAttribute),
    267                                 kFileTime,
    268                                 kFileDate,
    269                                 CLUSTER_FROM_SECTOR(kWindowsSysVolInfoDirSector),
    270                                 0),
    271          
    272              // Info and status files
    273              MAKE_FAT_DIR_ENTRY('I',
    274                                 'N',
    275                                 'F',
    276                                 'O',
    277                                 ' ',
    278                                 ' ',
    279                                 ' ',
    280                                 ' ',
    281                                 'T',
    282                                 'X',
    283                                 'T',
    284                                 kArchiveAttribute,
    285                                 kFileTime,
    286                                 kFileDate,
    287                                 CLUSTER_FROM_SECTOR(kInfoFileSector),
    288                                 1), // File size is filled in at runtime
    289              MAKE_FAT_DIR_ENTRY('S',
    290                                 'T',
    291                                 'A',
    292                                 'T',
    293                                 'U',
    294                                 'S',
    295                                 ' ',
    296                                 ' ',
    297                                 'T',
    298                                 'X',
    299                                 'T',
    300                                 kArchiveAttribute,
    301                                 kFileTime,
    302                                 kFileDate,
    303                                 CLUSTER_FROM_SECTOR(kStatusFileSector),
    304                                 1), // File size is filled in at runtime
    305          };
    306          
    307          //! @brief .fseventsd directory.
    308          //!
    309          //! Contents:
    310          //! - .
    311          //! - ..
    312          //! - no_log

   \                                 In section .rodata, align 4, keep-with-next
    313          static const fat_directory_entry_t k_fseventsdDir[] = {
   \                     k_fseventsdDir:
   \   00000000   0x2E 0x20          DC8 46, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 50, 0, 0
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x32    
   \              0x00 0x00    
   \   0000000E   0x6000 0x422C      DC16 24576, 16940, 16940, 0, 24576, 16940, 2
   \              0x422C 0x0000
   \              0x6000 0x422C
   \              0x0002       
   \   0000001C   0x00000000         DC32 0
   \   00000020   0x2E 0x2E          DC8 46, 46, 32, 32, 32, 32, 32, 32, 32, 32, 32, 16, 0, 0
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x10    
   \              0x00 0x00    
   \   0000002E   0x6000 0x422C      DC16 24576, 16940, 16940, 0, 24576, 16940, 0
   \              0x422C 0x0000
   \              0x6000 0x422C
   \              0x0000       
   \   0000003C   0x00000000         DC32 0
   \   00000040   0x4E 0x4F          DC8 78, 79, 95, 76, 79, 71, 32, 32, 32, 32, 32, 32, 8, 0
   \              0x5F 0x4C    
   \              0x4F 0x47    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x08 0x00    
   \   0000004E   0x6000 0x422C      DC16 24576, 16940, 16940, 0, 24576, 16940, 0
   \              0x422C 0x0000
   \              0x6000 0x422C
   \              0x0000       
   \   0000005C   0x00000000         DC32 0
    314              // . and .. directories
    315              MAKE_FAT_DIR_ENTRY('.',
    316                                 ' ',
    317                                 ' ',
    318                                 ' ',
    319                                 ' ',
    320                                 ' ',
    321                                 ' ',
    322                                 ' ',
    323                                 ' ',
    324                                 ' ',
    325                                 ' ',
    326                                 (kDirectoryAttribute | kArchiveAttribute | kHiddenAttribute),
    327                                 kFileTime,
    328                                 kFileDate,
    329                                 CLUSTER_FROM_SECTOR(kMacFseventsdDirSector),
    330                                 0),
    331              MAKE_FAT_DIR_ENTRY(
    332                  '.', '.', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', kDirectoryAttribute, kFileTime, kFileDate, 0, 0),
    333          
    334              // Special 'no_log' file with reserved byte set to 0x08.
    335              {.entry = {.name = { 'N', 'O', '_', 'L', 'O', 'G', ' ', ' ', ' ', ' ', ' ' },
    336                         .attributes = kArchiveAttribute,
    337                         .ntReserved = 0x08,
    338                         .creationTime = kFileTime,
    339                         .creationDate = kFileDate,
    340                         .lastAccessDate = kFileDate,
    341                         .firstClusterHigh = 0,
    342                         .writeTime = kFileTime,
    343                         .writeDate = kFileDate,
    344                         .firstClusterLow = 0,
    345                         .fileSize = 0 } },
    346          };
    347          

   \                                 In section .rodata, align 4, keep-with-next
    348          static const wchar_t k_indexerVolumeGuidFile[] = L"{37203BF8-FD83-4321-A4C4-9A9ABF8FBCFD}";
   \                     k_indexerVolumeGuidFile:
   \   00000000   0x7B 0x00          DC8 7BH, 0, 33H, 0, 37H, 0, 32H, 0
   \              0x33 0x00    
   \              0x37 0x00    
   \              0x32 0x00    
   \   00000008   0x30 0x00          DC8 30H, 0, 33H, 0, 42H, 0, 46H, 0
   \              0x33 0x00    
   \              0x42 0x00    
   \              0x46 0x00    
   \   00000010   0x38 0x00          DC8 38H, 0, 2DH, 0, 46H, 0, 44H, 0
   \              0x2D 0x00    
   \              0x46 0x00    
   \              0x44 0x00    
   \   00000018   0x38 0x00          DC8 38H, 0, 33H, 0, 2DH, 0, 34H, 0
   \              0x33 0x00    
   \              0x2D 0x00    
   \              0x34 0x00    
   \   00000020   0x33 0x00          DC8 33H, 0, 32H, 0, 31H, 0, 2DH, 0
   \              0x32 0x00    
   \              0x31 0x00    
   \              0x2D 0x00    
   \   00000028   0x41 0x00          DC8 41H, 0, 34H, 0, 43H, 0, 34H, 0
   \              0x34 0x00    
   \              0x43 0x00    
   \              0x34 0x00    
   \   00000030   0x2D 0x00          DC8 2DH, 0, 39H, 0, 41H, 0, 39H, 0
   \              0x39 0x00    
   \              0x41 0x00    
   \              0x39 0x00    
   \   00000038   0x41 0x00          DC8 41H, 0, 42H, 0, 46H, 0, 38H, 0
   \              0x42 0x00    
   \              0x46 0x00    
   \              0x38 0x00    
   \   00000040   0x46 0x00          DC8 46H, 0, 42H, 0, 43H, 0, 46H, 0
   \              0x42 0x00    
   \              0x43 0x00    
   \              0x46 0x00    
   \   00000048   0x44 0x00          DC8 44H, 0, 7DH, 0, 0, 0
   \              0x7D 0x00    
   \              0x00 0x00    
   \   0000004E   0x00 0x00          DC8 0, 0
    349          
    350          //! @brief System Volume Information directory.
    351          //!
    352          //! Contents:
    353          //! - .
    354          //! - ..
    355          //! - IndexerVolumeGuid (INDEXE~1)

   \                                 In section .rodata, align 4, keep-with-next
    356          static const fat_directory_entry_t k_sysVolInfoDir[] = {
   \                     k_sysVolInfoDir:
   \   00000000   0x2E 0x20          DC8 46, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 50, 0, 0
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x32    
   \              0x00 0x00    
   \   0000000E   0x6000 0x422C      DC16 24576, 16940, 16940, 0, 24576, 16940, 3
   \              0x422C 0x0000
   \              0x6000 0x422C
   \              0x0003       
   \   0000001C   0x00000000         DC32 0
   \   00000020   0x2E 0x2E          DC8 46, 46, 32, 32, 32, 32, 32, 32, 32, 32, 32, 16, 0, 0
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x10    
   \              0x00 0x00    
   \   0000002E   0x6000 0x422C      DC16 24576, 16940, 16940, 0, 24576, 16940, 0
   \              0x422C 0x0000
   \              0x6000 0x422C
   \              0x0000       
   \   0000003C   0x00000000         DC32 0
   \   00000040   0x42               DC8 66
   \   00000041   0x0047 0x0075      DC16 71, 117, 105, 100, 0
   \              0x0069 0x0064
   \              0x0000       
   \   0000004B   0x0F 0x00          DC8 15, 0, 255
   \              0xFF         
   \   0000004E   0xFFFF 0xFFFF      DC16 65535, 65535, 65535, 65535, 65535, 65535, 0, 0, 0
   \              0xFFFF 0xFFFF
   \              0xFFFF 0xFFFF
   \              0x0000 0x0000
   \              0x0000       
   \   00000060   0x01               DC8 1
   \   00000061   0x0049 0x006E      DC16 73, 110, 100, 101, 120
   \              0x0064 0x0065
   \              0x0078       
   \   0000006B   0x0F 0x00          DC8 15, 0, 255
   \              0xFF         
   \   0000006E   0x0065 0x0072      DC16 101, 114, 86, 111, 108, 117, 0, 109, 101
   \              0x0056 0x006F
   \              0x006C 0x0075
   \              0x0000 0x006D
   \              0x0065       
   \   00000080   0x49 0x4E          DC8 73, 78, 68, 69, 88, 69, 126, 49, 32, 32, 32, 32, 0, 0
   \              0x44 0x45    
   \              0x58 0x45    
   \              0x7E 0x31    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00 0x00    
   \   0000008E   0x6000 0x422C      DC16 24576, 16940, 16940, 0, 24576, 16940, 4
   \              0x422C 0x0000
   \              0x6000 0x422C
   \              0x0004       
   \   0000009C   0x0000004D         DC32 77
    357              // . and .. directories
    358              MAKE_FAT_DIR_ENTRY('.',
    359                                 ' ',
    360                                 ' ',
    361                                 ' ',
    362                                 ' ',
    363                                 ' ',
    364                                 ' ',
    365                                 ' ',
    366                                 ' ',
    367                                 ' ',
    368                                 ' ',
    369                                 (kDirectoryAttribute | kArchiveAttribute | kHiddenAttribute),
    370                                 kFileTime,
    371                                 kFileDate,
    372                                 CLUSTER_FROM_SECTOR(kWindowsSysVolInfoDirSector),
    373                                 0),
    374              MAKE_FAT_DIR_ENTRY(
    375                  '.', '.', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', kDirectoryAttribute, kFileTime, kFileDate, 0, 0),
    376          
    377              // 'IndexerVolumeGuid' file
    378              MAKE_FAT_LONG_NAME(
    379                  2, L'G', L'u', L'i', L'd', 0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0, 0, 0xff, kLastLongNameEntry),
    380              MAKE_FAT_LONG_NAME(1, L'I', L'n', L'd', L'e', L'x', L'e', L'r', L'V', L'o', L'l', L'u', L'm', L'e', 0xff, 0),
    381              MAKE_FAT_DIR_ENTRY('I',
    382                                 'N',
    383                                 'D',
    384                                 'E',
    385                                 'X',
    386                                 'E',
    387                                 '~',
    388                                 '1',
    389                                 ' ',
    390                                 ' ',
    391                                 ' ',
    392                                 kArchiveAttribute,
    393                                 kFileTime,
    394                                 kFileDate,
    395                                 CLUSTER_FROM_SECTOR(kWindowsIndexerVolumeGuidSector),
    396                                 (sizeof(k_indexerVolumeGuidFile) - 1)), // subtract 1 to remove the trailing null byte
    397          };
    398          

   \                                 In section .text, align 4, keep-with-next
    399          const sector_info_t g_msdDiskSectors[] = {
   \                     g_msdDiskSectors:
   \   00000000   0x00000000         DC32 0, k_pbs, 54, 1, k_fat1, 14, 257, k_rootDir, 416, 259
   \              0x........   
   \              0x00000036   
   \              0x00000001   
   \              0x........   
   \              0x0000000E   
   \              0x00000101   
   \              0x........   
   \              0x000001A0   
   \              0x00000103   
   \   00000028   0x........         DC32 k_fseventsdDir, 96, 260, k_sysVolInfoDir, 160, 261
   \              0x00000060   
   \              0x00000104   
   \              0x........   
   \              0x000000A0   
   \              0x00000105   
   \   00000040   0x........         DC32 k_indexerVolumeGuidFile, 77, 0
   \              0x0000004D   
   \              0x00000000   
   \   0000004C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    400              { kPbsSector, k_pbs, sizeof(k_pbs) },
    401              { kFat1Sector, (const uint8_t *)k_fat1, sizeof(k_fat1) },
    402              { kRootDir1Sector, (const uint8_t *)k_rootDir, sizeof(k_rootDir) },
    403          
    404              // Support for Mac OS X: .fseventsd directory
    405              { kMacFseventsdDirSector, (const uint8_t *)k_fseventsdDir, sizeof(k_fseventsdDir) },
    406          
    407              // Support for Window 8.1: System Volume Information directory
    408              { kWindowsSysVolInfoDirSector, (const uint8_t *)k_sysVolInfoDir, sizeof(k_sysVolInfoDir) },
    409              { kWindowsIndexerVolumeGuidSector, (const uint8_t *)k_indexerVolumeGuidFile,
    410                sizeof(k_indexerVolumeGuidFile) - 1 }, // subtract 1 to remove the trailing null byte
    411          
    412              // contains info.txt
    413              //     { kInfoFileSector, (const uint8_t *)((const uint8_t *)BlockBuf + 512), 512 },
    414              //
    415              //     // contains status.txt
    416              //     { kStatusFileSector, (const uint8_t *)((const uint8_t *)BlockBuf + 1024), 512 },
    417          
    418              // Terminator
    419              { 0 }
    420          };
    421          
    422          /*!
    423           * @brief device msc callback function.
    424           *
    425           * This function handle the disk class specified event.
    426           * @param handle          The USB class  handle.
    427           * @param event           The USB device event type.
    428           * @param param           The parameter of the class specific event.
    429           * @return kStatus_USB_Success or error.
    430           */

   \                                 In section .text, align 4, keep-with-next
    431          usb_status_t usb_device_msc_callback(class_handle_t handle, uint32_t event, void *param)
    432          {
   \                     usb_device_msc_callback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460B             MOV      R3,R1
    433              usb_status_t error = kStatus_USB_Error;
    434              usb_device_lba_information_struct_t *lba_info_structure_ptr;
    435              usb_device_lba_app_struct_t *lba_data_ptr;
    436              uint8_t *prevent_removal_ptr;
    437              uint32_t sector;
    438          
    439              switch (event)
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable30_2
   \   00000008   0x4611             MOV      R1,R2
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x1E5B             SUBS     R3,R3,#+1
   \   0000000E   0x6822             LDR      R2,[R4, #+0]
   \   00000010   0x2B06             CMP      R3,#+6
   \   00000012   0xD82F             BHI.N    ??usb_device_msc_callback_1
   \   00000014   0xE8DF 0xF003      TBB      [PC, R3]
   \                     ??usb_device_msc_callback_0:
   \   00000018   0x04 0x0A          DC8      0x4,0xA,0x16,0x1A
   \              0x16 0x1A    
   \   0000001C   0x23 0x2E          DC8      0x23,0x2E,0x2D,0x0
   \              0x2D 0x00    
    440              {
    441                  case kUSB_DeviceMscEventReadResponse:
    442                      /*!< Send data completed */
    443                      lba_data_ptr = (usb_device_lba_app_struct_t *)param;
    444          
    445                      if (lba_data_ptr != NULL)
   \                     ??usb_device_msc_callback_2: (+1)
   \   00000020   0xB341             CBZ.N    R1,??usb_device_msc_callback_1
    446                      {
    447                          sector = lba_data_ptr->offset / kDiskSectorSize;
    448                          error = usb_msd_read_sector(sector, lba_data_ptr);
   \   00000022   0x6808             LDR      R0,[R1, #+0]
   \   00000024   0x0A40             LSRS     R0,R0,#+9
   \   00000026   0x.... 0x....      BL       usb_msd_read_sector
    449                          if (error != kStatus_USB_Success)
   \   0000002A   0xE004             B.N      ??usb_device_msc_callback_3
    450                          {
    451                              g_device_composite->msc_disk.msc_state.read_write_error = 1;
    452                          }
    453                      }
    454          
    455                      break;
    456                  case kUSB_DeviceMscEventWriteResponse:
    457                      /*!< Data received */
    458                      lba_data_ptr = (usb_device_lba_app_struct_t *)param;
    459          
    460                      if (lba_data_ptr != NULL)
   \                     ??usb_device_msc_callback_4: (+1)
   \   0000002C   0xB311             CBZ.N    R1,??usb_device_msc_callback_1
    461                      {
    462                          sector = lba_data_ptr->offset / kDiskSectorSize;
    463                          error = usb_msd_write_sector(sector, lba_data_ptr);
   \   0000002E   0x6808             LDR      R0,[R1, #+0]
   \   00000030   0x0A40             LSRS     R0,R0,#+9
   \   00000032   0x.... 0x....      BL       usb_msd_write_sector
    464                          if (error != kStatus_USB_Success)
   \                     ??usb_device_msc_callback_3: (+1)
   \   00000036   0x0001             MOVS     R1,R0
   \   00000038   0xD01C             BEQ.N    ??usb_device_msc_callback_1
    465                          {
    466                              g_device_composite->msc_disk.msc_state.read_write_error = 1;
   \   0000003A   0x6822             LDR      R2,[R4, #+0]
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0xF882 0x1459      STRB     R1,[R2, #+1113]
   \   00000042   0xBD10             POP      {R4,PC}
    467                          }
    468                      }
    469                      break;
    470                  case kUSB_DeviceMscEventWriteRequest:
    471                      /*!< Host write data*/
    472                      lba_data_ptr = (usb_device_lba_app_struct_t *)param;
    473          
    474                      /*offset is the write start address get from write command, refer to class driver*/
    475                      // RAM disk
    476                      //        lba_data_ptr->buff_ptr = g_device_composite->msc_disk.storage_disk + lba_data_ptr->offset;
    477                      if (lba_data_ptr != NULL)
   \                     ??usb_device_msc_callback_5: (+1)
   \   00000044   0xB1B1             CBZ.N    R1,??usb_device_msc_callback_1
    478                      {
    479                          lba_data_ptr->buffer = (uint8_t *)g_device_composite->msc_disk.msc_state.buffer;
   \   00000046   0x3258             ADDS     R2,R2,#+88
   \   00000048   0x608A             STR      R2,[R1, #+8]
   \   0000004A   0xBD10             POP      {R4,PC}
    480                      }
    481          
    482                      break;
    483                  case kUSB_DeviceMscEventReadRequest:
    484                      /*!< Host read data*/
    485                      lba_data_ptr = (usb_device_lba_app_struct_t *)param;
    486                      /*offset is the read start address get from read command, refer to class driver*/
    487                      // RAM disk
    488                      //        lba_data_ptr->buff_ptr = g_device_composite->msc_disk.storage_disk + lba_data_ptr->offset;
    489          
    490                      if (lba_data_ptr != NULL)
   \                     ??usb_device_msc_callback_6: (+1)
   \   0000004C   0xB191             CBZ.N    R1,??usb_device_msc_callback_1
    491                      {
    492                          lba_data_ptr->buffer = (uint8_t *)g_device_composite->msc_disk.msc_state.buffer;
   \   0000004E   0xF102 0x0058      ADD      R0,R2,#+88
   \   00000052   0x6088             STR      R0,[R1, #+8]
    493                          sector = lba_data_ptr->offset / kDiskSectorSize;
    494                          error = usb_msd_read_sector(sector, lba_data_ptr);
   \   00000054   0x6808             LDR      R0,[R1, #+0]
   \   00000056   0xE8BD 0x4010      POP      {R4,LR}
   \   0000005A   0x0A40             LSRS     R0,R0,#+9
   \   0000005C   0x....             B.N      usb_msd_read_sector
    495                      }
    496          
    497                      break;
    498                  case kUSB_DeviceMscEventGetLbaInformation:
    499                      lba_info_structure_ptr = (usb_device_lba_information_struct_t *)param;
    500                      lba_info_structure_ptr->totalLbaNumberSupports = kDiskTotalLogicalBlocks;
   \                     ??usb_device_msc_callback_7: (+1)
   \   0000005E   0xF44F 0x4000      MOV      R0,#+32768
   \   00000062   0x6008             STR      R0,[R1, #+0]
    501                      lba_info_structure_ptr->lengthOfEachLba = kDiskSectorSize;
    502                      lba_info_structure_ptr->logicalUnitNumberSupported = kDiskLogicalUnits;
   \   00000064   0x2201             MOVS     R2,#+1
   \   00000066   0xF44F 0x7000      MOV      R0,#+512
   \   0000006A   0x6048             STR      R0,[R1, #+4]
   \   0000006C   0x740A             STRB     R2,[R1, #+16]
    503                      lba_info_structure_ptr->bulkInBufferSize = USB_DEVICE_MSC_WRITE_BUFF_SIZE;
   \   0000006E   0x6088             STR      R0,[R1, #+8]
    504                      lba_info_structure_ptr->bulkOutBufferSize = USB_DEVICE_MSC_READ_BUFF_SIZE;
   \   00000070   0x60C8             STR      R0,[R1, #+12]
    505                      error = kStatus_USB_Success;
    506                      break;
    507                  case kUSB_DeviceMscEventFormatComplete:
    508                      break;
    509                  case kUSB_DeviceMscEventRemovalRequest:
    510                      prevent_removal_ptr = (uint8_t *)param;
    511                      if (USB_DEVICE_CONFIG_MSC_SUPPORT_DISK_LOCKING_MECHANISM)
    512                      {
    513                          g_device_composite->msc_disk.msc_state.isDiskLocked = *prevent_removal_ptr;
    514                      }
    515                      else if ((!USB_DEVICE_CONFIG_MSC_SUPPORT_DISK_LOCKING_MECHANISM) && (!(*prevent_removal_ptr)))
    516                      {
    517                          /*there is no support for disk locking and removal of medium is enabled*/
    518                          /* code to be added here for this condition, if required */
    519                      }
    520                      error = kStatus_USB_Success;
   \                     ??usb_device_msc_callback_8: (+1)
   \   00000072   0x2000             MOVS     R0,#+0
    521                      break;
    522              }
    523              return error;
   \                     ??usb_device_msc_callback_1: (+1)
   \   00000074   0xBD10             POP      {R4,PC}          ;; return
    524          }
    525          
    526          /*!
    527           * @brief msc device set configuration function.
    528           *
    529           * This function sets configuration for msc class.
    530           *
    531           * @param handle The msc class handle.
    532           * @param configure The msc class configure index.
    533           *
    534           * @return A USB error code or kStatus_USB_Success.
    535           */

   \                                 In section .text, align 2, keep-with-next
    536          usb_status_t usb_device_msc_disk_set_configure(class_handle_t handle, uint8_t configure)
    537          {
    538              //   g_device_composite->msc_disk.current_configuration = configure;
    539              return kStatus_USB_Success;
   \                     usb_device_msc_disk_set_configure: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    540          }
    541          /*!
    542           * @brief device msc init function.
    543           *
    544           * This function initializes the device with the composite device class information.
    545           *
    546           * @param device_composite          The pointer to the composite device structure.
    547           * @return kStatus_USB_Success .
    548           */

   \                                 In section .text, align 2, keep-with-next
    549          usb_status_t usb_device_msc_disk_init(usb_device_composite_struct_t *device_composite)
    550          {
   \                     usb_device_msc_disk_init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    551              g_device_composite = device_composite;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable30_2
   \   00000006   0x6020             STR      R0,[R4, #+0]
    552              //    g_device_composite->msc_disk.storage_disk[0] = 0x01;   // RAM disk
    553          
    554              // Get the length of the info.txt file by writing it to a buffer temporarily.
    555              usb_msd_update_info_file(g_device_composite->msc_disk.msc_state.buffer);
   \   00000008   0x3058             ADDS     R0,R0,#+88
   \   0000000A   0x.... 0x....      BL       usb_msd_update_info_file
    556              uint32_t length = strlen((char *)g_device_composite->msc_disk.msc_state.buffer);
   \   0000000E   0x6824             LDR      R4,[R4, #+0]
   \   00000010   0xF104 0x0058      ADD      R0,R4,#+88
   \   00000014   0x.... 0x....      BL       strlen
   \   00000018   0x4605             MOV      R5,R0
    557          
    558              // Init the state info. This also clears the sector buffers.
    559              memset(&g_device_composite->msc_disk.msc_state, 0, sizeof(g_device_composite->msc_disk.msc_state));
   \   0000001A   0xF44F 0x6184      MOV      R1,#+1056
   \   0000001E   0xF104 0x0054      ADD      R0,R4,#+84
   \   00000022   0x.... 0x....      BL       __aeabi_memclr4
    560          
    561              g_device_composite->msc_disk.msc_state.infoFileLength = length;
   \   00000026   0xF8C4 0x5460      STR      R5,[R4, #+1120]
    562          
    563              g_device_composite->msc_disk.msc_state.start_app = false;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x6560             STR      R0,[R4, #+84]
    564              return kStatus_USB_Success;
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    565          }
    566          
    567          /*!
    568           * @brief device msc init function.
    569           *
    570           * This function initializes the device with the composite device class information.
    571           *
    572           * @param device_composite          The pointer to the composite device structure.
    573           * @return kStatus_USB_Success .
    574           */

   \                                 In section .text, align 2, keep-with-next
    575          usb_status_t usb_device_msc_disk_deinit(usb_device_composite_struct_t *device_composite)
    576          {
    577              g_device_composite = device_composite;
   \                     usb_device_msc_disk_deinit: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable30_2
   \   00000004   0x6008             STR      R0,[R1, #+0]
    578              // RAM Disk
    579              // g_device_composite->msc_disk.storage_disk[0] = 0x01;
    580              g_device_composite->msc_disk.msc_handle = (class_handle_t)NULL;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x6508             STR      R0,[R1, #+80]
    581              return kStatus_USB_Success;
   \   0000000C   0x4770             BX       LR               ;; return
    582          }
    583          
    584          //! @brief Run the sbloader state machine.
    585          //!
    586          //! This function is called repeatedly by the main application loop. We use it
    587          //! to run the sbloader state machine from non-interrupt context.

   \                                 In section .text, align 2, keep-with-next
    588          void usb_device_msc_disk_pump(void)
    589          {
   \                     usb_device_msc_disk_pump: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    590              status_t status = kStatus_Success;
    591          
    592              // Init the sb loader state machine.
    593              if (g_device_composite->msc_disk.msc_state.sbLoaderStatus == kSbLoaderFree)
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable30_2
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0xF890 0x045C      LDRB     R0,[R0, #+1116]
   \   0000000C   0xB930             CBNZ.N   R0,??usb_device_msc_disk_pump_0
    594              {
    595                  sbloader_init();
   \   0000000E   0x.... 0x....      BL       sbloader_init
    596                  g_device_composite->msc_disk.msc_state.sbLoaderStatus = kSbLoaderInited;
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0xF880 0x145C      STRB     R1,[R0, #+1116]
    597                  g_device_composite->msc_disk.msc_state.start_app = true;
   \   0000001A   0x6541             STR      R1,[R0, #+84]
    598              }
    599          
    600              if (g_device_composite->msc_disk.msc_state.isProcessing)
   \                     ??usb_device_msc_disk_pump_0: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0xF890 0x045D      LDRB     R0,[R0, #+1117]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD041             BEQ.N    ??usb_device_msc_disk_pump_1
    601              {
    602                  // Process the SB file. This loop will exit under four conditions:
    603                  //  - Error during SB file command execution.
    604                  //  - Underrun: more data needed.
    605                  //  - Jump command encountered.
    606                  do
    607                  {
    608                      g_device_composite->msc_disk.msc_state.sbLoaderStatus = kSbLoaderLoading;
   \                     ??usb_device_msc_disk_pump_2: (+1)
   \   00000026   0x6821             LDR      R1,[R4, #+0]
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xF881 0x045C      STRB     R0,[R1, #+1116]
    609                      status = feed_sbloader();
   \   0000002E   0x.... 0x....      BL       feed_sbloader
   \   00000032   0x0005             MOVS     R5,R0
    610                  } while (status == kStatus_Success);
   \   00000034   0xD0F7             BEQ.N    ??usb_device_msc_disk_pump_2
    611                  if ((g_device_composite->msc_disk.msc_state.remainingFileLength == 0) &&
    612                      (g_device_composite->msc_disk.msc_state.sbLoaderStatus == kSbLoaderLoading))
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0xF200 0x405C      ADDW     R0,R0,#+1116
   \   0000003C   0x68C1             LDR      R1,[R0, #+12]
   \   0000003E   0x2900             CMP      R1,#+0
   \   00000040   0xBF04             ITT      EQ 
   \   00000042   0x7801             LDRBEQ   R1,[R0, #+0]
   \   00000044   0x2902             CMPEQ    R1,#+2
   \   00000046   0xD103             BNE.N    ??usb_device_msc_disk_pump_3
    613                  {
    614                      reset_usb_msd_state(kSbLoaderFinal);
   \   00000048   0x2003             MOVS     R0,#+3
   \   0000004A   0x.... 0x....      BL       reset_usb_msd_state
   \   0000004E   0xE001             B.N      ??usb_device_msc_disk_pump_4
    615                  }
    616                  else
    617                  {
    618                      g_device_composite->msc_disk.msc_state.isProcessing = true;
   \                     ??usb_device_msc_disk_pump_3: (+1)
   \   00000050   0x2101             MOVS     R1,#+1
   \   00000052   0x7041             STRB     R1,[R0, #+1]
    619                  }
    620                  // kStatusRomLdrDataUnderrun means need more data. This is OK to continue on.
    621                  if (status == kStatusRomLdrDataUnderrun)
   \                     ??usb_device_msc_disk_pump_4: (+1)
   \   00000054   0xF242 0x707D      MOVW     R0,#+10109
   \   00000058   0x4285             CMP      R5,R0
   \   0000005A   0xD026             BEQ.N    ??usb_device_msc_disk_pump_1
    622                  {
    623                      status = kStatus_Success;
    624                  }
    625          
    626                  // Stop saving SB data if we got an error.
    627                  if (status != kStatus_Success)
    628                  {
    629                      g_device_composite->msc_disk.msc_state.isProcessing = false;
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0xF200 0x405D      ADDW     R0,R0,#+1117
   \   00000062   0x2100             MOVS     R1,#+0
   \   00000064   0x7001             STRB     R1,[R0, #+0]
    630          
    631                      if (status == kStatusRomLdrSectionOverrun)
   \   00000066   0xF242 0x7174      MOVW     R1,#+10100
   \   0000006A   0x428D             CMP      R5,R1
   \   0000006C   0xD106             BNE.N    ??usb_device_msc_disk_pump_5
    632                      {
    633                          g_device_composite->msc_disk.msc_state.transferStatus = kSuccessStatus;
   \   0000006E   0x2102             MOVS     R1,#+2
   \   00000070   0x74C1             STRB     R1,[R0, #+19]
    634                          debug_printf("SB processing done: section overrun\r\n");
   \   00000072   0x.... 0x....      ADR.W    R0,?_4
   \   00000076   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000007A   0x....             B.N      debug_printf
    635                      }
    636                      else if (status == kStatus_AbortDataPhase)
   \                     ??usb_device_msc_disk_pump_5: (+1)
   \   0000007C   0xF242 0x7112      MOVW     R1,#+10002
   \   00000080   0x428D             CMP      R5,R1
   \   00000082   0xD107             BNE.N    ??usb_device_msc_disk_pump_6
    637                      {
    638                          g_device_composite->msc_disk.msc_state.transferStatus = kSuccessStatus;
   \   00000084   0x2102             MOVS     R1,#+2
   \   00000086   0x74C1             STRB     R1,[R0, #+19]
    639          
    640                          debug_printf("SB processing done: hit jump command\r\n");
   \   00000088   0x.... 0x....      ADR.W    R0,?_5
   \   0000008C   0x.... 0x....      BL       debug_printf
    641                          reset_usb_msd_state(kSbLoaderFinal);
   \   00000090   0x2003             MOVS     R0,#+3
   \   00000092   0xE007             B.N      ??usb_device_msc_disk_pump_7
    642                      }
    643                      else
    644                      {
    645                          g_device_composite->msc_disk.msc_state.transferStatus = kFailureStatus;
   \                     ??usb_device_msc_disk_pump_6: (+1)
   \   00000094   0x2103             MOVS     R1,#+3
   \   00000096   0x74C1             STRB     R1,[R0, #+19]
    646                          debug_printf("SB processing done: error %d\r\n", status);
   \   00000098   0x4629             MOV      R1,R5
   \   0000009A   0x.... 0x....      ADR.W    R0,?_6
   \   0000009E   0x.... 0x....      BL       debug_printf
    647                          reset_usb_msd_state(kSbLoaderFree);
   \   000000A2   0x2000             MOVS     R0,#+0
   \                     ??usb_device_msc_disk_pump_7: (+1)
   \   000000A4   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   000000A8   0x....             B.N      reset_usb_msd_state
    648                      }
    649                  }
    650              }
    651              return;
   \                     ??usb_device_msc_disk_pump_1: (+1)
   \   000000AA   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    652          }
    653          

   \                                 In section .text, align 2, keep-with-next
    654          usb_status_t usb_msd_write_sector(uint32_t sector, const usb_device_lba_app_struct_t *lbaData)
    655          {
   \                     usb_msd_write_sector: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    656              if (sector >= kFirstUnusedSector)
   \   00000004   0xF5B4 0x7F84      CMP      R4,#+264
   \   00000008   0xB082             SUB      SP,SP,#+8
   \   0000000A   0x460D             MOV      R5,R1
   \   0000000C   0xD336             BCC.N    ??usb_msd_write_sector_0
    657              {
    658                  bool saveSbData = false;
    659          
    660                  if (!g_device_composite->msc_disk.msc_state.isTransferring)
   \   0000000E   0x....             LDR.N    R6,??DataTable30_2
   \   00000010   0x6830             LDR      R0,[R6, #+0]
   \   00000012   0xF200 0x415B      ADDW     R1,R0,#+1115
   \   00000016   0x780A             LDRB     R2,[R1, #+0]
   \   00000018   0xB98A             CBNZ.N   R2,??usb_msd_write_sector_1
    661                  {
    662                      if (g_device_composite->msc_disk.msc_state.isProcessing)
   \   0000001A   0x7888             LDRB     R0,[R1, #+2]
   \   0000001C   0xB130             CBZ.N    R0,??usb_msd_write_sector_2
    663                      {
    664                          debug_printf("write_sector: ignoring sector %u write while SB processing continues...\r\n", sector);
   \   0000001E   0x4621             MOV      R1,R4
   \   00000020   0x.... 0x....      ADR.W    R0,?_7
   \   00000024   0x.... 0x....      BL       debug_printf
    665                          return kStatus_USB_BandwidthFail;
   \   00000028   0x200F             MOVS     R0,#+15
   \   0000002A   0xBD76             POP      {R1,R2,R4-R6,PC}
    666                      }
    667          
    668                      // Check if this is an .sb file by looking for signatures in the header. This call
    669                      // also returns the total size in bytes of the SB file.
    670                      uint32_t sbLength;
    671                      if (is_valid_sb_file_header(lbaData->buffer, &sbLength))
   \                     ??usb_msd_write_sector_2: (+1)
   \   0000002C   0x68A8             LDR      R0,[R5, #+8]
   \   0000002E   0x4669             MOV      R1,SP
   \   00000030   0x.... 0x....      BL       is_valid_sb_file_header
   \   00000034   0xB310             CBZ.N    R0,??usb_msd_write_sector_0
    672                      {
    673                          //                debug_printf("write_sector: started receiving SB file on sector %u (length=%u
    674                          //                bytes)\r\n", sector, sbLength);
    675                          // This is a valid .sb file header
    676                          usb_msd_start_transfer(sbLength);
   \   00000036   0x9800             LDR      R0,[SP, #+0]
   \   00000038   0x.... 0x....      BL       usb_msd_start_transfer
    677                          // Save the sector data.
    678                          saveSbData = true;
   \   0000003C   0xE003             B.N      ??usb_msd_write_sector_3
    679                      }
    680                  }
    681                  else if (sector == g_device_composite->msc_disk.msc_state.nextSector)
   \                     ??usb_msd_write_sector_1: (+1)
   \   0000003E   0xF8D0 0x0464      LDR      R0,[R0, #+1124]
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD11A             BNE.N    ??usb_msd_write_sector_0
    682                  {
    683                      saveSbData = true;
    684                  }
    685                  else
    686                  {
    687                      // Out of order sector write.
    688                      // debug_printf("Out of order sector write during transfer (%u)\r\n", sector);
    689                  }
    690          
    691                  // Save the SB file contents for processing by the main bootloader run loop (outside
    692                  // of interrupt context).
    693                  if (saveSbData)
    694                  {
    695                      // Update state information.
    696                      uint32_t count = MIN(g_device_composite->msc_disk.msc_state.remainingFileLength, lbaData->size);
   \                     ??usb_msd_write_sector_3: (+1)
   \   00000046   0x6830             LDR      R0,[R6, #+0]
   \   00000048   0x686A             LDR      R2,[R5, #+4]
   \   0000004A   0xF200 0x4164      ADDW     R1,R0,#+1124
   \   0000004E   0x684B             LDR      R3,[R1, #+4]
    697                      g_device_composite->msc_disk.msc_state.dataBytesAvailable += count;
   \   00000050   0x688E             LDR      R6,[R1, #+8]
   \   00000052   0x4293             CMP      R3,R2
   \   00000054   0xBF38             IT       CC 
   \   00000056   0x461A             MOVCC    R2,R3
    698                      g_device_composite->msc_disk.msc_state.remainingFileLength -= count;
   \   00000058   0x1A9B             SUBS     R3,R3,R2
   \   0000005A   0x604B             STR      R3,[R1, #+4]
   \   0000005C   0x1996             ADDS     R6,R2,R6
    699          
    700                      g_device_composite->msc_disk.msc_state.nextSector = sector + 1;
   \   0000005E   0x1C63             ADDS     R3,R4,#+1
   \   00000060   0x608E             STR      R6,[R1, #+8]
   \   00000062   0x600B             STR      R3,[R1, #+0]
    701          
    702                      if (g_device_composite->msc_disk.msc_state.remainingFileLength == 0)
   \   00000064   0x6849             LDR      R1,[R1, #+4]
   \   00000066   0xB909             CBNZ.N   R1,??usb_msd_write_sector_4
    703                      {
    704                          g_device_composite->msc_disk.msc_state.isTransferring = false;
   \   00000068   0xF880 0x145B      STRB     R1,[R0, #+1115]
    705                      }
    706          
    707                      memcpy(g_device_composite->msc_disk.msc_state.sbBuffer, lbaData->buffer, count);
   \                     ??usb_msd_write_sector_4: (+1)
   \   0000006C   0x68A9             LDR      R1,[R5, #+8]
   \   0000006E   0xF44F 0x7316      MOV      R3,#+600
   \   00000072   0x4418             ADD      R0,R0,R3
   \   00000074   0x.... 0x....      BL       __aeabi_memcpy
    708          
    709                      usb_device_msc_disk_pump();
   \   00000078   0x.... 0x....      BL       usb_device_msc_disk_pump
    710                  }
    711              }
    712              return kStatus_USB_Success;
   \                     ??usb_msd_write_sector_0: (+1)
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    713          }
    714          

   \                                 In section .text, align 2, keep-with-next
    715          usb_status_t usb_msd_read_sector(uint32_t sector, usb_device_lba_app_struct_t *lbaData)
    716          {
   \                     usb_msd_read_sector: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4605             MOV      R5,R0
    717              // Clear the sector contents (all zeroes).
    718              memset(lbaData->buffer, 0, lbaData->size);
   \   00000006   0x6861             LDR      R1,[R4, #+4]
   \   00000008   0x68A0             LDR      R0,[R4, #+8]
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr
    719          
    720              // Search for a sector entry in our table.
    721              const sector_info_t *sectorInfo = g_msdDiskSectors;
   \   0000000E   0x.... 0x....      ADR.W    R0,g_msdDiskSectors
   \   00000012   0xE000             B.N      ??usb_msd_read_sector_0
    722              for (; sectorInfo->data; ++sectorInfo)
   \                     ??usb_msd_read_sector_1: (+1)
   \   00000014   0x300C             ADDS     R0,R0,#+12
   \                     ??usb_msd_read_sector_0: (+1)
   \   00000016   0x6841             LDR      R1,[R0, #+4]
   \   00000018   0xB131             CBZ.N    R1,??usb_msd_read_sector_2
    723              {
    724                  if (sectorInfo->sector == sector)
   \   0000001A   0x6802             LDR      R2,[R0, #+0]
   \   0000001C   0x42AA             CMP      R2,R5
   \   0000001E   0xD1F9             BNE.N    ??usb_msd_read_sector_1
    725                  {
    726                      // Copy sector data into output buffer.
    727                      memcpy(lbaData->buffer, sectorInfo->data, sectorInfo->length);
   \   00000020   0x6882             LDR      R2,[R0, #+8]
   \   00000022   0x68A0             LDR      R0,[R4, #+8]
   \   00000024   0x.... 0x....      BL       __aeabi_memcpy
    728                      break;
    729                  }
    730              }
    731          
    732              // Special handling for certain sectors.
    733              switch (sector)
   \                     ??usb_msd_read_sector_2: (+1)
   \   00000028   0x.... 0x....      ADR.W    R0,kStatusMessages
   \   0000002C   0xB145             CBZ.N    R5,??usb_msd_read_sector_3
   \   0000002E   0xF240 0x1101      MOVW     R1,#+257
   \   00000032   0x1A6D             SUBS     R5,R5,R1
   \   00000034   0xD00D             BEQ.N    ??usb_msd_read_sector_4
   \   00000036   0x1F6D             SUBS     R5,R5,#+5
   \   00000038   0xD01A             BEQ.N    ??usb_msd_read_sector_5
   \   0000003A   0x1E6D             SUBS     R5,R5,#+1
   \   0000003C   0xD01C             BEQ.N    ??usb_msd_read_sector_6
   \   0000003E   0xE028             B.N      ??usb_msd_read_sector_7
    734              {
    735                  case kPbsSector:
    736                      // Fill in signature bytes for PBS, so we don't have to have the full 512 bytes as const data.
    737                      lbaData->buffer[510] = 0x55;
   \                     ??usb_msd_read_sector_3: (+1)
   \   00000040   0x68A1             LDR      R1,[R4, #+8]
   \   00000042   0x2055             MOVS     R0,#+85
   \   00000044   0xF881 0x01FE      STRB     R0,[R1, #+510]
    738                      lbaData->buffer[511] = 0xaa;
   \   00000048   0x20AA             MOVS     R0,#+170
   \   0000004A   0x68A1             LDR      R1,[R4, #+8]
   \   0000004C   0xF881 0x01FF      STRB     R0,[R1, #+511]
    739                      break;
   \   00000050   0xE01F             B.N      ??usb_msd_read_sector_7
    740          
    741                  case kRootDir1Sector:
    742                  {
    743                      // Update info.txt and status.txt file sizes in root directory.
    744                      fat_directory_entry_t *rootDir = (fat_directory_entry_t *)lbaData->buffer;
   \                     ??usb_msd_read_sector_4: (+1)
   \   00000052   0x68A1             LDR      R1,[R4, #+8]
    745          
    746                      rootDir[kInfoFileDirEntry].entry.fileSize = g_device_composite->msc_disk.msc_state.infoFileLength;
   \   00000054   0xF44F 0x72BE      MOV      R2,#+380
   \   00000058   0x188C             ADDS     R4,R1,R2
   \   0000005A   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000005E   0x680A             LDR      R2,[R1, #+0]
   \   00000060   0x6022             STR      R2,[R4, #+0]
    747          
    748                      const char *statusMessage = kStatusMessages[g_device_composite->msc_disk.msc_state.transferStatus];
    749                      rootDir[kStatusFileDirEntry].entry.fileSize = strlen(statusMessage);
   \   00000062   0x7C09             LDRB     R1,[R1, #+16]
   \   00000064   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000068   0x.... 0x....      BL       strlen
   \   0000006C   0x6220             STR      R0,[R4, #+32]
    750          
    751                      break;
   \   0000006E   0xE010             B.N      ??usb_msd_read_sector_7
    752                  }
    753          
    754                  case kInfoFileSector:
    755                      usb_msd_update_info_file(lbaData->buffer);
   \                     ??usb_msd_read_sector_5: (+1)
   \   00000070   0x68A0             LDR      R0,[R4, #+8]
   \   00000072   0x.... 0x....      BL       usb_msd_update_info_file
    756                      break;
   \   00000076   0xE00C             B.N      ??usb_msd_read_sector_7
    757          
    758                  case kStatusFileSector:
    759                  {
    760                      const char *statusMessage = kStatusMessages[g_device_composite->msc_disk.msc_state.transferStatus];
   \                     ??usb_msd_read_sector_6: (+1)
   \   00000078   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000007C   0x7C09             LDRB     R1,[R1, #+16]
   \   0000007E   0xF850 0x5021      LDR      R5,[R0, R1, LSL #+2]
    761                      uint32_t statusLength = strlen(statusMessage);
   \   00000082   0x4628             MOV      R0,R5
   \   00000084   0x.... 0x....      BL       strlen
    762                      memcpy(lbaData->buffer, statusMessage, statusLength);
   \   00000088   0x4602             MOV      R2,R0
   \   0000008A   0x68A0             LDR      R0,[R4, #+8]
   \   0000008C   0x4629             MOV      R1,R5
   \   0000008E   0x.... 0x....      BL       __aeabi_memcpy
    763                      break;
    764                  }
    765              }
    766          
    767              return kStatus_USB_Success;
   \                     ??usb_msd_read_sector_7: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    768          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable30_2
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xF44F 0x628C      MOV      R2,#+1120
   \   00000008   0x4411             ADD      R1,R1,R2
   \   0000000A   0x4770             BX       LR
    769          

   \                                 In section .text, align 2, keep-with-next
    770          bool is_valid_sb_file_header(const uint8_t *data, uint32_t *fileLength)
    771          {
    772              sb_image_header_t *header = (sb_image_header_t *)data;
    773          
    774              if ((header->m_signature == BOOT_SIGNATURE) && (header->m_signature2 == BOOT_SIGNATURE2) &&
    775                  (header->m_majorVersion == SB_FILE_MAJOR_VERSION))
   \                     is_valid_sb_file_header: (+1)
   \   00000000   0x6942             LDR      R2,[R0, #+20]
   \   00000002   0x....             LDR.N    R3,??DataTable30_3  ;; 0x504d5453
   \   00000004   0x429A             CMP      R2,R3
   \   00000006   0xBF02             ITTT     EQ 
   \   00000008   0x6B42             LDREQ    R2,[R0, #+52]
   \   0000000A   0x....             LDREQ.N  R3,??DataTable30_4  ;; 0x6c746773
   \   0000000C   0x429A             CMPEQ    R2,R3
   \   0000000E   0xBF04             ITT      EQ 
   \   00000010   0x7E02             LDRBEQ   R2,[R0, #+24]
   \   00000012   0x2A01             CMPEQ    R2,#+1
   \   00000014   0xD104             BNE.N    ??is_valid_sb_file_header_0
    776              {
    777                  assert(fileLength);
    778                  *fileLength = header->m_imageBlocks * BYTES_PER_CHUNK;
   \   00000016   0x69C0             LDR      R0,[R0, #+28]
   \   00000018   0x0100             LSLS     R0,R0,#+4
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    779          
    780                  return true;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x4770             BX       LR
    781              }
    782              else
    783              {
    784                  return false;
   \                     ??is_valid_sb_file_header_0: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x4770             BX       LR               ;; return
    785              }
    786          }
    787          
    788          //! @brief Push data that has been received from host during data phase.

   \                                 In section .text, align 2, keep-with-next
    789          status_t feed_sbloader(void)
    790          {
    791              status_t status = kStatus_Success;
    792          
    793              // Get the number of bytes we can give to sbloader. If there is no available data,
    794              // then there is nothing else for us to do here and we can return an underrun meaning waiting for more data
    795              uint32_t available = MIN(g_device_composite->msc_disk.msc_state.dataBytesAvailable, kDiskSectorSize);
   \                     feed_sbloader: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable30_2
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF8D0 0x246C      LDR      R2,[R0, #+1132]
   \   00000008   0xF5B2 0x7F00      CMP      R2,#+512
   \   0000000C   0xD204             BCS.N    ??feed_sbloader_0
   \   0000000E   0x0011             MOVS     R1,R2
    796          
    797              if (!available)
   \   00000010   0xD104             BNE.N    ??feed_sbloader_1
    798              {
    799                  status = kStatusRomLdrDataUnderrun;
   \   00000012   0xF242 0x707D      MOVW     R0,#+10109
   \   00000016   0x4770             BX       LR
    800              }
   \                     ??feed_sbloader_0: (+1)
   \   00000018   0xF44F 0x7100      MOV      R1,#+512
    801              else
    802              {
    803                  g_device_composite->msc_disk.msc_state.dataBytesAvailable -= available;
   \                     ??feed_sbloader_1: (+1)
   \   0000001C   0x1A52             SUBS     R2,R2,R1
   \   0000001E   0xF8C0 0x246C      STR      R2,[R0, #+1132]
    804          
    805                  // Give the data to sbloader.
    806                  status = sbloader_pump(g_device_composite->msc_disk.msc_state.sbBuffer, available);
   \   00000022   0xF44F 0x7216      MOV      R2,#+600
   \   00000026   0x4410             ADD      R0,R0,R2
   \   00000028   0x.... 0x....      B.W      sbloader_pump
    807              }
    808          
    809              return status;
    810          }
    811          
    812          //! @brief Prepare for a new SB file transfer.

   \                                 In section .text, align 2, keep-with-next
    813          void usb_msd_start_transfer(uint32_t length)
    814          {
    815              g_device_composite->msc_disk.msc_state.isActive = true;
   \                     usb_msd_start_transfer: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable30_2
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xF201 0x425A      ADDW     R2,R1,#+1114
   \   00000008   0x2301             MOVS     R3,#+1
   \   0000000A   0x7013             STRB     R3,[R2, #+0]
    816              g_device_composite->msc_disk.msc_state.isTransferring = true;
   \   0000000C   0x7053             STRB     R3,[R2, #+1]
    817              g_device_composite->msc_disk.msc_state.sbLoaderStatus = kSbLoaderFree;
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x7093             STRB     R3,[R2, #+2]
    818              g_device_composite->msc_disk.msc_state.isProcessing = true;
   \   00000012   0x2301             MOVS     R3,#+1
   \   00000014   0x70D3             STRB     R3,[R2, #+3]
    819              g_device_composite->msc_disk.msc_state.isReceivePending = false;
   \   00000016   0x2300             MOVS     R3,#+0
   \   00000018   0x7113             STRB     R3,[R2, #+4]
    820              g_device_composite->msc_disk.msc_state.dataBytesAvailable = 0;
   \   0000001A   0xF44F 0x628D      MOV      R2,#+1128
   \   0000001E   0x4411             ADD      R1,R1,R2
    821              g_device_composite->msc_disk.msc_state.remainingFileLength = length;
   \   00000020   0x6008             STR      R0,[R1, #+0]
    822              g_device_composite->msc_disk.msc_state.transferStatus = kTransferringStatus;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x604B             STR      R3,[R1, #+4]
   \   00000026   0x7208             STRB     R0,[R1, #+8]
    823          }
   \   00000028   0x4770             BX       LR               ;; return
    824          
    825          //! @brief Prepare for a new SB file transfer.

   \                                 In section .text, align 2, keep-with-next
    826          void reset_usb_msd_state(uint8_t loaderStatus)
    827          {
    828              g_device_composite->msc_disk.msc_state.isActive = true;
   \                     reset_usb_msd_state: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable30_2
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xF201 0x425A      ADDW     R2,R1,#+1114
   \   00000008   0x2301             MOVS     R3,#+1
    829              g_device_composite->msc_disk.msc_state.isTransferring = false;
    830              g_device_composite->msc_disk.msc_state.sbLoaderStatus = loaderStatus;
   \   0000000A   0x7090             STRB     R0,[R2, #+2]
   \   0000000C   0x7013             STRB     R3,[R2, #+0]
    831              g_device_composite->msc_disk.msc_state.isProcessing = false;
    832              g_device_composite->msc_disk.msc_state.isReceivePending = false;
    833              g_device_composite->msc_disk.msc_state.dataBytesAvailable = 0;
   \   0000000E   0xF44F 0x608D      MOV      R0,#+1128
   \   00000012   0x2300             MOVS     R3,#+0
   \   00000014   0x4408             ADD      R0,R1,R0
   \   00000016   0x7053             STRB     R3,[R2, #+1]
   \   00000018   0x70D3             STRB     R3,[R2, #+3]
   \   0000001A   0x7113             STRB     R3,[R2, #+4]
    834              g_device_composite->msc_disk.msc_state.remainingFileLength = 0;
    835              g_device_composite->msc_disk.msc_state.transferStatus = kTransferringStatus;
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x6043             STR      R3,[R0, #+4]
   \   00000020   0x6003             STR      R3,[R0, #+0]
   \   00000022   0x7201             STRB     R1,[R0, #+8]
    836          }
   \   00000024   0x4770             BX       LR               ;; return
    837          

   \                                 In section .text, align 2, keep-with-next
    838          void format_hex_string(char *s, uint32_t value)
    839          {
   \                     format_hex_string: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    840              s[0] = '0';
   \   00000002   0x2230             MOVS     R2,#+48
   \   00000004   0x7002             STRB     R2,[R0, #+0]
    841              s[1] = 'x';
   \   00000006   0x2278             MOVS     R2,#+120
   \   00000008   0x7042             STRB     R2,[R0, #+1]
    842              s[10] = 0;
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x7282             STRB     R2,[R0, #+10]
    843          
    844              uint32_t i;
    845              for (i = 0; i < 8; ++i)
   \   0000000E   0x.... 0x....      ADR.W    R3,kHexChars
    846              {
    847                  s[i + 2] = kHexChars[(value >> (28 - (i * 4))) & 0xf];
   \                     ??format_hex_string_0: (+1)
   \   00000012   0x0094             LSLS     R4,R2,#+2
   \   00000014   0xF1C4 0x041C      RSB      R4,R4,#+28
   \   00000018   0xFA21 0xF504      LSR      R5,R1,R4
   \   0000001C   0xF005 0x040F      AND      R4,R5,#0xF
   \   00000020   0x1885             ADDS     R5,R0,R2
   \   00000022   0x5D1C             LDRB     R4,[R3, R4]
   \   00000024   0x70AC             STRB     R4,[R5, #+2]
    848              }
   \   00000026   0x1C52             ADDS     R2,R2,#+1
   \   00000028   0x2A08             CMP      R2,#+8
   \   0000002A   0xD3F2             BCC.N    ??format_hex_string_0
    849          }
   \   0000002C   0xBD30             POP      {R4,R5,PC}       ;; return
    850          

   \                                 In section .text, align 2, keep-with-next
    851          void format_digit_string(char *s, uint32_t value)
    852          {
   \                     format_digit_string: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    853              // Get reversed string
    854              uint32_t i = 0;
   \   00000002   0x2200             MOVS     R2,#+0
    855              if (value > 0)
   \   00000004   0xB161             CBZ.N    R1,??format_digit_string_0
    856              {
    857                  while (value)
    858                  {
    859                      s[i] = (value % 10) + '0';
   \                     ??format_digit_string_1: (+1)
   \   00000006   0x230A             MOVS     R3,#+10
   \   00000008   0xFBB1 0xF3F3      UDIV     R3,R1,R3
   \   0000000C   0x240A             MOVS     R4,#+10
   \   0000000E   0xFB04 0x1113      MLS      R1,R4,R3,R1
   \   00000012   0x3130             ADDS     R1,R1,#+48
   \   00000014   0x5481             STRB     R1,[R0, R2]
    860                      value /= 10;
    861                      i++;
   \   00000016   0x1C52             ADDS     R2,R2,#+1
   \   00000018   0x4619             MOV      R1,R3
    862                  }
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD1F3             BNE.N    ??format_digit_string_1
   \   0000001E   0xE002             B.N      ??format_digit_string_2
    863              }
    864              else
    865              {
    866                  s[i++] = '0';
   \                     ??format_digit_string_0: (+1)
   \   00000020   0x2130             MOVS     R1,#+48
   \   00000022   0x7001             STRB     R1,[R0, #+0]
   \   00000024   0x2201             MOVS     R2,#+1
    867              }
    868          
    869              // Reverse above string, then get expected string.
    870              s[i] = '\0';
   \                     ??format_digit_string_2: (+1)
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x5481             STRB     R1,[R0, R2]
    871              char *head = s;
    872              char *tail = (s + i - 1);
   \   0000002A   0x1881             ADDS     R1,R0,R2
   \   0000002C   0x1E49             SUBS     R1,R1,#+1
   \   0000002E   0xE005             B.N      ??format_digit_string_3
    873              char tmp;
    874              while (head < tail)
    875              {
    876                  tmp = *tail;
   \                     ??format_digit_string_4: (+1)
   \   00000030   0x780A             LDRB     R2,[R1, #+0]
    877                  *tail = *head;
   \   00000032   0x7803             LDRB     R3,[R0, #+0]
   \   00000034   0xF801 0x3901      STRB     R3,[R1], #-1
    878                  *head = tmp;
   \   00000038   0xF800 0x2B01      STRB     R2,[R0], #+1
    879                  tail--;
    880                  head++;
    881              }
   \                     ??format_digit_string_3: (+1)
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD3F7             BCC.N    ??format_digit_string_4
    882          }
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    883          

   \                                 In section .text, align 2, keep-with-next
    884          void usb_msd_update_info_file(uint8_t *buffer)
    885          {
   \                     usb_msd_update_info_file: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    886              property_store_t *store = g_bootloaderContext.propertyInterface->store;
   \   00000004   0x....             LDR.N    R0,??DataTable30_5
   \   00000006   0x6880             LDR      R0,[R0, #+8]
   \   00000008   0xB0C0             SUB      SP,SP,#+256
   \   0000000A   0x6905             LDR      R5,[R0, #+16]
    887              standard_version_t version = store->bootloaderVersion;
   \   0000000C   0x6828             LDR      R0,[R5, #+0]
   \   0000000E   0x9014             STR      R0,[SP, #+80]
    888          
    889              char hexBuffers[9][11];
    890              char digitBuffers[6][11];
    891              uint32_t timeoutInMilliSeconds;
    892          
    893              timeoutInMilliSeconds = (store->configurationData.peripheralDetectionTimeoutMs != 0xffff) ?
    894                                          store->configurationData.peripheralDetectionTimeoutMs :
    895                                          BL_DEFAULT_PERIPHERAL_DETECT_TIMEOUT;
   \   00000010   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000014   0xF8B5 0x607A      LDRH     R6,[R5, #+122]
   \   00000018   0x4286             CMP      R6,R0
    896          
    897              format_hex_string(hexBuffers[0], SIM->SDID);
   \   0000001A   0x....             LDR.N    R0,??DataTable30_6  ;; 0x40048024
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0xBF08             IT       EQ 
   \   00000020   0x2600             MOVEQ    R6,#+0
   \   00000022   0xA826             ADD      R0,SP,#+152
   \   00000024   0x.... 0x....      BL       format_hex_string
    898              format_hex_string(hexBuffers[1], store->flashStartAddress);
   \   00000028   0xF855 0x1F10      LDR      R1,[R5, #+16]!
   \   0000002C   0xF10D 0x00A3      ADD      R0,SP,#+163
   \   00000030   0x.... 0x....      BL       format_hex_string
    899              format_hex_string(hexBuffers[2], store->flashStartAddress + store->flashSizeInBytes - 1);
   \   00000034   0x6828             LDR      R0,[R5, #+0]
   \   00000036   0x6869             LDR      R1,[R5, #+4]
   \   00000038   0x1808             ADDS     R0,R1,R0
   \   0000003A   0x1E41             SUBS     R1,R0,#+1
   \   0000003C   0xF10D 0x00AE      ADD      R0,SP,#+174
   \   00000040   0x.... 0x....      BL       format_hex_string
    900              format_hex_string(hexBuffers[3], store->ramStartAddress[0]);
   \   00000044   0x6969             LDR      R1,[R5, #+20]
   \   00000046   0xF10D 0x00B9      ADD      R0,SP,#+185
   \   0000004A   0x.... 0x....      BL       format_hex_string
    901              format_hex_string(hexBuffers[4], store->ramStartAddress[0] + store->ramSizeInBytes[0] - 1);
   \   0000004E   0x6968             LDR      R0,[R5, #+20]
   \   00000050   0x69A9             LDR      R1,[R5, #+24]
   \   00000052   0x1808             ADDS     R0,R1,R0
   \   00000054   0x1E41             SUBS     R1,R0,#+1
   \   00000056   0xA831             ADD      R0,SP,#+196
   \   00000058   0x.... 0x....      BL       format_hex_string
    902              format_hex_string(hexBuffers[5], store->reservedRegions[0].startAddress);
   \   0000005C   0x6CA9             LDR      R1,[R5, #+72]
   \   0000005E   0xF10D 0x00CF      ADD      R0,SP,#+207
   \   00000062   0x.... 0x....      BL       format_hex_string
    903              format_hex_string(hexBuffers[6], store->reservedRegions[0].endAddress);
   \   00000066   0x6CE9             LDR      R1,[R5, #+76]
   \   00000068   0xF10D 0x00DA      ADD      R0,SP,#+218
   \   0000006C   0x.... 0x....      BL       format_hex_string
    904              format_hex_string(hexBuffers[7], store->reservedRegions[1].startAddress);
   \   00000070   0x6D29             LDR      R1,[R5, #+80]
   \   00000072   0xF10D 0x00E5      ADD      R0,SP,#+229
   \   00000076   0x.... 0x....      BL       format_hex_string
    905              format_hex_string(hexBuffers[8], store->reservedRegions[1].endAddress);
   \   0000007A   0x6D69             LDR      R1,[R5, #+84]
   \   0000007C   0xA83C             ADD      R0,SP,#+240
   \   0000007E   0x.... 0x....      BL       format_hex_string
    906          
    907              format_digit_string(digitBuffers[0], store->flashSizeInBytes);
   \   00000082   0x6869             LDR      R1,[R5, #+4]
   \   00000084   0xA815             ADD      R0,SP,#+84
   \   00000086   0x.... 0x....      BL       format_digit_string
    908              format_digit_string(digitBuffers[1], store->flashSectorSize);
   \   0000008A   0x68A9             LDR      R1,[R5, #+8]
   \   0000008C   0xF10D 0x005F      ADD      R0,SP,#+95
   \   00000090   0x.... 0x....      BL       format_digit_string
    909              format_digit_string(digitBuffers[2], store->flashBlockCount);
   \   00000094   0x6929             LDR      R1,[R5, #+16]
   \   00000096   0xF10D 0x006A      ADD      R0,SP,#+106
   \   0000009A   0x.... 0x....      BL       format_digit_string
    910              format_digit_string(digitBuffers[3], store->ramSizeInBytes[0]);
   \   0000009E   0x69A9             LDR      R1,[R5, #+24]
   \   000000A0   0xF10D 0x0075      ADD      R0,SP,#+117
   \   000000A4   0x.... 0x....      BL       format_digit_string
    911              format_digit_string(digitBuffers[4], timeoutInMilliSeconds);
   \   000000A8   0x4631             MOV      R1,R6
   \   000000AA   0xA820             ADD      R0,SP,#+128
   \   000000AC   0x.... 0x....      BL       format_digit_string
    912              format_digit_string(digitBuffers[5], SystemCoreClock);
   \   000000B0   0x....             LDR.N    R0,??DataTable30_7
   \   000000B2   0x6801             LDR      R1,[R0, #+0]
   \   000000B4   0xF10D 0x008B      ADD      R0,SP,#+139
   \   000000B8   0x.... 0x....      BL       format_digit_string
    913          
    914              sprintf((char *)buffer, kInfoFileFormat, version.name, version.major, version.minor, version.bugfix, // Version
    915                      hexBuffers[0],                                                      // System device ID
    916                      digitBuffers[0],                                                    // Flash size
    917                      hexBuffers[1], hexBuffers[2],                                       // Flash range
    918                      digitBuffers[1],                                                    // Flash sector size
    919                      digitBuffers[2],                                                    // Flash block count
    920                      digitBuffers[3],                                                    // RAM size
    921                      hexBuffers[3], hexBuffers[4],                                       // RAM range
    922                      hexBuffers[5], hexBuffers[6],                                       // Reserved range 0
    923                      hexBuffers[7], hexBuffers[8],                                       // Reserved range 1
    924                      store->verifyWrites ? "yes" : "no",                                 // Verify flag
    925                      "yes",                                                              // Always check reserved region
    926                      (store->configurationData.tag == kPropertyStoreTag) ? "yes" : "no", // BCA enabled flag
    927                      digitBuffers[4],                                                    // Peripheral detection timeout
    928                      digitBuffers[5]);                                                   // System Core Clock
   \   000000BC   0x6DAA             LDR      R2,[R5, #+88]
   \   000000BE   0x....             LDR.N    R3,??DataTable30_8  ;; 0x6766636b
   \   000000C0   0x....             ADR.N    R0,??DataTable30  ;; 0x6E, 0x6F, 0x00, 0x00
   \   000000C2   0x....             ADR.N    R1,??DataTable30_1  ;; "yes"
   \   000000C4   0x429A             CMP      R2,R3
   \   000000C6   0x6A2B             LDR      R3,[R5, #+32]
   \   000000C8   0xBF0C             ITE      EQ 
   \   000000CA   0x460A             MOVEQ    R2,R1
   \   000000CC   0x4602             MOVNE    R2,R0
   \   000000CE   0xB103             CBZ.N    R3,??usb_msd_update_info_file_0
   \   000000D0   0x4608             MOV      R0,R1
   \                     ??usb_msd_update_info_file_0: (+1)
   \   000000D2   0x900F             STR      R0,[SP, #+60]
   \   000000D4   0xF10D 0x038B      ADD      R3,SP,#+139
   \   000000D8   0xA83C             ADD      R0,SP,#+240
   \   000000DA   0x900E             STR      R0,[SP, #+56]
   \   000000DC   0x9313             STR      R3,[SP, #+76]
   \   000000DE   0xF10D 0x00E5      ADD      R0,SP,#+229
   \   000000E2   0x900D             STR      R0,[SP, #+52]
   \   000000E4   0xAB20             ADD      R3,SP,#+128
   \   000000E6   0xF10D 0x00DA      ADD      R0,SP,#+218
   \   000000EA   0x900C             STR      R0,[SP, #+48]
   \   000000EC   0x9312             STR      R3,[SP, #+72]
   \   000000EE   0xF10D 0x00CF      ADD      R0,SP,#+207
   \   000000F2   0x900B             STR      R0,[SP, #+44]
   \   000000F4   0x9211             STR      R2,[SP, #+68]
   \   000000F6   0xA831             ADD      R0,SP,#+196
   \   000000F8   0x900A             STR      R0,[SP, #+40]
   \   000000FA   0x9110             STR      R1,[SP, #+64]
   \   000000FC   0xF10D 0x00B9      ADD      R0,SP,#+185
   \   00000100   0x9009             STR      R0,[SP, #+36]
   \   00000102   0xF10D 0x0075      ADD      R0,SP,#+117
   \   00000106   0x9008             STR      R0,[SP, #+32]
   \   00000108   0xF10D 0x006A      ADD      R0,SP,#+106
   \   0000010C   0x9007             STR      R0,[SP, #+28]
   \   0000010E   0xF10D 0x005F      ADD      R0,SP,#+95
   \   00000112   0x9006             STR      R0,[SP, #+24]
   \   00000114   0xF10D 0x00AE      ADD      R0,SP,#+174
   \   00000118   0x9005             STR      R0,[SP, #+20]
   \   0000011A   0xF10D 0x00A3      ADD      R0,SP,#+163
   \   0000011E   0x9004             STR      R0,[SP, #+16]
   \   00000120   0xA815             ADD      R0,SP,#+84
   \   00000122   0x9003             STR      R0,[SP, #+12]
   \   00000124   0xA826             ADD      R0,SP,#+152
   \   00000126   0x9002             STR      R0,[SP, #+8]
   \   00000128   0xF89D 0x0050      LDRB     R0,[SP, #+80]
   \   0000012C   0xF89D 0x3052      LDRB     R3,[SP, #+82]
   \   00000130   0xF89D 0x2053      LDRB     R2,[SP, #+83]
   \   00000134   0x.... 0x....      ADR.W    R1,kInfoFileFormat
   \   00000138   0x9001             STR      R0,[SP, #+4]
   \   0000013A   0xF89D 0x0051      LDRB     R0,[SP, #+81]
   \   0000013E   0x9000             STR      R0,[SP, #+0]
   \   00000140   0x4620             MOV      R0,R4
   \   00000142   0x.... 0x....      BL       sprintf
    929          }
   \   00000146   0xB040             ADD      SP,SP,#+256
   \   00000148   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x6E 0x6F          DC8      0x6E, 0x6F, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_1:
   \   00000000   0x79 0x65          DC8      "yes"
   \              0x73 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_2:
   \   00000000   0x........         DC32     g_device_composite

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_3:
   \   00000000   0x504D5453         DC32     0x504d5453

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_4:
   \   00000000   0x6C746773         DC32     0x6c746773

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_5:
   \   00000000   0x........         DC32     g_bootloaderContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_6:
   \   00000000   0x40048024         DC32     0x40048024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_7:
   \   00000000   0x........         DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_8:
   \   00000000   0x6766636B         DC32     0x6766636b

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x52 0x65          DC8 "Ready\015\012"
   \              0x61 0x64    
   \              0x79 0x0D    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x53 0x42          DC8 "SB processing done: section overrun\015\012"
   \              0x20 0x70    
   \              0x72 0x6F    
   \              0x63 0x65    
   \              0x73 0x73    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x64 0x6F    
   \              0x6E 0x65    
   \              0x3A 0x20    
   \              0x73 0x65    
   \              0x63 0x74    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x6F 0x76    
   \              0x65 0x72    
   \              0x72 0x75    
   \              0x6E 0x0D    
   \              0x0A 0x00    
   \   00000026   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x53 0x42          DC8 "SB processing done: hit jump command\015\012"
   \              0x20 0x70    
   \              0x72 0x6F    
   \              0x63 0x65    
   \              0x73 0x73    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x64 0x6F    
   \              0x6E 0x65    
   \              0x3A 0x20    
   \              0x68 0x69    
   \              0x74 0x20    
   \              0x6A 0x75    
   \              0x6D 0x70    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x0D 0x0A    
   \              0x00         
   \   00000027   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x53 0x42          DC8 "SB processing done: error %d\015\012"
   \              0x20 0x70    
   \              0x72 0x6F    
   \              0x63 0x65    
   \              0x73 0x73    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x64 0x6F    
   \              0x6E 0x65    
   \              0x3A 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x20    
   \              0x25 0x64    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x54 0x72          DC8 "Transferring\015\012"
   \              0x61 0x6E    
   \              0x73 0x66    
   \              0x65 0x72    
   \              0x72 0x69    
   \              0x6E 0x67    
   \              0x0D 0x0A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x53 0x75          DC8 "Success\015\012"
   \              0x63 0x63    
   \              0x65 0x73    
   \              0x73 0x0D    
   \              0x0A 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x46 0x61          DC8 "Failure\015\012"
   \              0x69 0x6C    
   \              0x75 0x72    
   \              0x65 0x0D    
   \              0x0A 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x77 0x72          DC8 77H, 72H, 69H, 74H, 65H, 5FH, 73H, 65H
   \              0x69 0x74    
   \              0x65 0x5F    
   \              0x73 0x65    
   \   00000008   0x63 0x74          DC8 63H, 74H, 6FH, 72H, 3AH, 20H, 69H, 67H
   \              0x6F 0x72    
   \              0x3A 0x20    
   \              0x69 0x67    
   \   00000010   0x6E 0x6F          DC8 6EH, 6FH, 72H, 69H, 6EH, 67H, 20H, 73H
   \              0x72 0x69    
   \              0x6E 0x67    
   \              0x20 0x73    
   \   00000018   0x65 0x63          DC8 65H, 63H, 74H, 6FH, 72H, 20H, 25H, 75H
   \              0x74 0x6F    
   \              0x72 0x20    
   \              0x25 0x75    
   \   00000020   0x20 0x77          DC8 20H, 77H, 72H, 69H, 74H, 65H, 20H, 77H
   \              0x72 0x69    
   \              0x74 0x65    
   \              0x20 0x77    
   \   00000028   0x68 0x69          DC8 68H, 69H, 6CH, 65H, 20H, 53H, 42H, 20H
   \              0x6C 0x65    
   \              0x20 0x53    
   \              0x42 0x20    
   \   00000030   0x70 0x72          DC8 70H, 72H, 6FH, 63H, 65H, 73H, 73H, 69H
   \              0x6F 0x63    
   \              0x65 0x73    
   \              0x73 0x69    
   \   00000038   0x6E 0x67          DC8 6EH, 67H, 20H, 63H, 6FH, 6EH, 74H, 69H
   \              0x20 0x63    
   \              0x6F 0x6E    
   \              0x74 0x69    
   \   00000040   0x6E 0x75          DC8 6EH, 75H, 65H, 73H, 2EH, 2EH, 2EH, 0DH
   \              0x65 0x73    
   \              0x2E 0x2E    
   \              0x2E 0x0D    
   \   00000048   0x0A 0x00          DC8 0AH, 0
   \   0000004A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x79 0x65          DC8 "yes"
   \              0x73 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_9:
   \   00000000   0x6E 0x6F          DC8 "no"
   \              0x00         
   \   00000003   0x00               DC8 0
    930          
    931          #endif //  BL_CONFIG_USB_MSC

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   debug_printf
        16   -> vprintf
       0   feed_sbloader
         0   -> sbloader_pump
       8   format_digit_string
      12   format_hex_string
       0   is_valid_sb_file_header
       0   reset_usb_msd_state
       8   usb_device_msc_callback
         0   -> usb_msd_read_sector
         8   -> usb_msd_read_sector
         8   -> usb_msd_write_sector
       0   usb_device_msc_disk_deinit
      16   usb_device_msc_disk_init
        16   -> __aeabi_memclr4
        16   -> strlen
        16   -> usb_msd_update_info_file
      16   usb_device_msc_disk_pump
         0   -> debug_printf
        16   -> debug_printf
        16   -> feed_sbloader
         0   -> reset_usb_msd_state
        16   -> reset_usb_msd_state
        16   -> sbloader_init
       0   usb_device_msc_disk_set_configure
      16   usb_msd_read_sector
        16   -> __aeabi_memclr
        16   -> __aeabi_memcpy
        16   -> strlen
        16   -> usb_msd_update_info_file
       0   usb_msd_start_transfer
     272   usb_msd_update_info_file
       272   -> format_digit_string
       272   -> format_hex_string
       272   -> sprintf
      24   usb_msd_write_sector
        24   -> __aeabi_memcpy
        24   -> debug_printf
        24   -> is_valid_sb_file_header
        24   -> usb_device_msc_disk_pump
        24   -> usb_msd_start_transfer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_2
       4  ??DataTable30_3
       4  ??DataTable30_4
       4  ??DataTable30_5
       4  ??DataTable30_6
       4  ??DataTable30_7
       4  ??DataTable30_8
      12  ?Subroutine0
       8  ?_0
      16  ?_1
      12  ?_2
      12  ?_3
      40  ?_4
      40  ?_5
      32  ?_6
      76  ?_7
       4  ?_8
       4  ?_9
      14  debug_printf
      44  feed_sbloader
      66  format_digit_string
      46  format_hex_string
       4  g_device_composite
      84  g_msdDiskSectors
      36  is_valid_sb_file_header
      20  kHexChars
     364  kInfoFileFormat
      16  kStatusMessages
      16  k_fat1
      96  k_fseventsdDir
      80  k_indexerVolumeGuidFile
      56  k_pbs
     416  k_rootDir
     160  k_sysVolInfoDir
      38  reset_usb_msd_state
     118  usb_device_msc_callback
      14  usb_device_msc_disk_deinit
      48  usb_device_msc_disk_init
     172  usb_device_msc_disk_pump
       4  usb_device_msc_disk_set_configure
     150  usb_msd_read_sector
      42  usb_msd_start_transfer
     330  usb_msd_update_info_file
     128  usb_msd_write_sector

 
     4 bytes in section .bss
   880 bytes in section .rodata
 1 970 bytes in section .text
 
 1 970 bytes of CODE  memory
   880 bytes of CONST memory
     4 bytes of DATA  memory

Errors: none
Warnings: none
