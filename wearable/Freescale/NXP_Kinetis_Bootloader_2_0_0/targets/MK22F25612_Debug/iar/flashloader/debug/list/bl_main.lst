###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Aug/2016  13:15:51
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\bl_main.c
#    Command line =  
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\bl_main.c"
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN256VDC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D BL_TARGET_RAM -lC
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj"
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices/MK22F25612\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/autobaud\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/osa\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device/class\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/bm_usb\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/CMSIS/Include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers/common\"
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list\bl_main.lst
#    Object file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj\bl_main.o
#
###############################################################################

C:\Users\cwati\Documents\My Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\bl_main.c
      1          /*
      2           * Copyright (c) 2013-2016, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include <stdbool.h>
     32          #include "utilities/fsl_assert.h"
     33          #include "bootloader/bl_context.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void debug_printf(char const *, ...)
   \                     debug_printf: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB500             PUSH     {LR}
   \   00000004   0xA901             ADD      R1,SP,#+4
   \   00000006   0x.... 0x....      BL       vprintf
   \   0000000A   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
     34          #include "bootloader/bl_peripheral.h"
     35          #include "bootloader/bl_shutdown_cleanup.h"
     36          #include "bootloader_common.h"
     37          #include "microseconds/microseconds.h"
     38          #include "bootloader/bootloader.h"
     39          #include "flash/fsl_flash.h"
     40          #include "smc/smc.h"
     41          #include "microseconds/microseconds.h"
     42          #include "property/property.h"
     43          #include "utilities/vector_table_info.h"
     44          #include "utilities/fsl_rtos_abstraction.h"
     45          #if BL_FEATURE_CRC_CHECK
     46          #include "bootloader/bl_app_crc_check.h"
     47          #endif
     48          #if BL_FEATURE_QSPI_MODULE
     49          #include "qspi/qspi.h"
     50          #endif
     51          #include "memory/memory.h"
     52          
     53          #if BL_FEATURE_RELIABLE_UPDATE
     54          #include "bootloader/bl_reliable_update.h"
     55          #endif
     56          
     57          //! @addtogroup bl_core
     58          //! @{
     59          
     60          ////////////////////////////////////////////////////////////////////////////////
     61          // Prototypes
     62          ////////////////////////////////////////////////////////////////////////////////
     63          
     64          #if DEBUG && !DEBUG_PRINT_DISABLE
     65          static const char *get_peripheral_name(uint32_t peripheralTypeMask);
     66          #endif
     67          
     68          #if !BL_FEATURE_TIMEOUT
     69          static void get_user_application_entry(uint32_t *appEntry, uint32_t *appStack);
     70          static void jump_to_application(uint32_t applicationAddress, uint32_t stackPointer);
     71          static bool is_direct_boot(void);
     72          #endif // !BL_FEATURE_TIMEOUT
     73          static peripheral_descriptor_t const *get_active_peripheral(void);
     74          static void bootloader_init(void);
     75          static void bootloader_run(void);
     76          static void bootloader_flash_init(void);
     77          #if BL_FEATURE_QSPI_MODULE
     78          static void configure_quadspi_as_needed(void);
     79          #endif
     80          
     81          int main(void);
     82          
     83          // Not used, but needed to resolve reference in startup.s.
     84          // uint32_t g_bootloaderTree;
     85          
     86          ////////////////////////////////////////////////////////////////////////////////
     87          // Variables
     88          ////////////////////////////////////////////////////////////////////////////////
     89          
     90          #if DEBUG && !DEBUG_PRINT_DISABLE

   \                                 In section .text, align 4, keep-with-next
     91          static const char *const kPeripheralNames[] = {
   \                     kPeripheralNames:
   \   00000000   0x........         DC32 ?_0, ?_1, ?_2, ?_3, ?_4, ?_5, ?_6, ?_7
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
     92              "UART", // kPeripheralType_UART
     93              "I2C",  // kPeripheralType_I2CSlave
     94              "SPI",  // kPeripheralType_SPISlave
     95              "CAN",  // kPeripheralType_CAN
     96              "HID",  // kPeripheralType_USB_HID
     97              "CDC",  // kPeripheralType_USB_CDC
     98              "DFU",  // kPeripheralType_USB_DFU
     99              "MSD"   // kPeripheralType_USB_MSC
    100          };
    101          #endif // DEBUG
    102          
    103          ////////////////////////////////////////////////////////////////////////////////
    104          // Code
    105          ////////////////////////////////////////////////////////////////////////////////
    106          
    107          #if DEBUG && !DEBUG_PRINT_DISABLE
    108          //! @brief Returns the name of a peripheral given its type mask.

   \                                 In section .text, align 2, keep-with-next
    109          const char *get_peripheral_name(uint32_t peripheralTypeMask)
    110          {
    111              uint32_t i;
    112              for (i = 0; i < ARRAY_SIZE(kPeripheralNames); ++i)
   \                     get_peripheral_name: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    113              {
    114                  if (peripheralTypeMask & (1 << i))
   \                     ??get_peripheral_name_0: (+1)
   \   00000002   0xFA20 0xF201      LSR      R2,R0,R1
   \   00000006   0x07D2             LSLS     R2,R2,#+31
   \   00000008   0xD504             BPL.N    ??get_peripheral_name_1
    115                  {
    116                      return kPeripheralNames[i];
   \   0000000A   0x.... 0x....      ADR.W    R0,kPeripheralNames
   \   0000000E   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000012   0x4770             BX       LR
    117                  }
    118              }
   \                     ??get_peripheral_name_1: (+1)
   \   00000014   0x1C49             ADDS     R1,R1,#+1
   \   00000016   0x2908             CMP      R1,#+8
   \   00000018   0xD3F3             BCC.N    ??get_peripheral_name_0
    119          
    120              return "Unknown peripheral";
   \   0000001A   0x.... 0x....      ADR.W    R0,?_8
   \   0000001E   0x4770             BX       LR               ;; return
    121          }
    122          #endif // DEBUG
    123          
    124          #if !BL_FEATURE_TIMEOUT
    125          //! @brief Returns the user application address and stack pointer.
    126          //!
    127          //! For flash-resident and rom-resident target, gets the user application address
    128          //! and stack pointer from the APP_VECTOR_TABLE.
    129          //! Ram-resident version does not support jumping to application address.
    130          static void get_user_application_entry(uint32_t *appEntry, uint32_t *appStack)
    131          {
    132              assert(appEntry);
    133              assert(appStack);
    134          
    135          #if BL_TARGET_RAM
    136              *appEntry = 0;
    137              *appStack = 0;
    138          #else
    139          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    140              // Check if address of SP and PC is in an execute-only region.
    141              if (!is_in_execute_only_region(kDefaultVectorTableAddress, 8))
    142              {
    143                  *appEntry = APP_VECTOR_TABLE[kInitialPC];
    144                  *appStack = APP_VECTOR_TABLE[kInitialSP];
    145              }
    146              else
    147              {
    148                  // Set to invalid value when vector table is in execute-only region,
    149                  // as ROM doesn't support jumping to an application in such region so far.
    150                  // The main purpose of below operation is to prevent ROM from inifinit loop
    151                  // between NVIC_SystemReset() and fetching SP and PC frome execute-only region.
    152                  *appEntry = 0;
    153                  *appStack = 0;
    154              }
    155          #else
    156              *appEntry = APP_VECTOR_TABLE[kInitialPC];
    157              *appStack = APP_VECTOR_TABLE[kInitialSP];
    158          #endif //  FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    159          #endif // BL_TARGET_RAM
    160          }
    161          #endif // BL_FEATURE_TIMEOUT
    162          
    163          #if !BL_FEATURE_TIMEOUT
    164          bool is_direct_boot(void)
    165          {
    166              bootloader_configuration_data_t *configurationData =
    167                  &g_bootloaderContext.propertyInterface->store->configurationData;
    168          
    169              return (~configurationData->bootFlags) & kBootFlag_DirectBoot;
    170          }
    171          #endif // !BL_FEATURE_TIMEOUT
    172          
    173          #if !BL_FEATURE_TIMEOUT
    174          //! @brief Exits bootloader and jumps to the user application.

   \                                 In section .text, align 2, keep-with-next
    175          static void jump_to_application(uint32_t applicationAddress, uint32_t stackPointer)
    176          {
   \                     jump_to_application: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    177          #if BL_FEATURE_OTFAD_MODULE
    178              quadspi_cache_clear();
    179              oftfad_resume_as_needed();
    180          #endif
    181          
    182              shutdown_cleanup(kShutdownType_Shutdown);
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       shutdown_cleanup
    183          
    184              // Create the function call to the user application.
    185              // Static variables are needed since changed the stack pointer out from under the compiler
    186              // we need to ensure the values we are using are not stored on the previous stack
    187              static uint32_t s_stackPointer = 0;
    188              s_stackPointer = stackPointer;
   \   0000000C   0x....             LDR.N    R0,??DataTable19
    189              static void (*farewellBootloader)(void) = 0;
    190              farewellBootloader = (void (*)(void))applicationAddress;
    191          
    192              // Set the VTOR to the application vector table address.
    193              SCB->VTOR = (uint32_t)APP_VECTOR_TABLE;
   \   0000000E   0x....             LDR.N    R2,??DataTable19_1  ;; 0xe000ed08
   \   00000010   0x6005             STR      R5,[R0, #+0]
   \   00000012   0x6044             STR      R4,[R0, #+4]
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6011             STR      R1,[R2, #+0]
    194          
    195              // Set stack pointers to the application stack pointer.
    196              __set_MSP(s_stackPointer);
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0xF381 0x8808      MSR      MSP,R1
    197              __set_PSP(s_stackPointer);
   \   0000001E   0xF381 0x8809      MSR      PSP,R1
    198          
    199              // Jump to the application.
    200              farewellBootloader();
   \   00000022   0x6840             LDR      R0,[R0, #+4]
   \   00000024   0x4780             BLX      R0
    201              // Dummy fcuntion call, should never go to this fcuntion call
    202              shutdown_cleanup(kShutdownType_Shutdown);
   \   00000026   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      B.W      shutdown_cleanup
    203          }

   \                                 In section .bss, align 4
   \                     `jump_to_application::s_stackPointer`:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
    204          #endif // !BL_FEATURE_TIMEOUT
    205          
    206          //! A given jump address is considered valid if:
    207          //! - Not 0x00000000
    208          //! - Not 0xffffffff
    209          //! - Not the reset handler entry point for the bootloader
    210          //! - Is in flash or is in RAM or QuadSPI (if available)
    211          //! @note this interface is also used by the configure_quadspi command

   \                                 In section .text, align 2, keep-with-next
    212          bool is_valid_application_location(uint32_t applicationAddress)
    213          {
   \                     is_valid_application_location: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    214              const memory_map_entry_t *map;
    215              // Verify that the jumpLocation is non zero and then either within flash or RAM, both calculations are:
    216              // (jumpLocation >= startAddress) && (jumpLocation < (startAddress + size))
    217              if ((!applicationAddress) ||              // address is not null AND
    218                  (applicationAddress == 0xffffffff) || // address is not blank Flash (0xff) AND
    219                  (applicationAddress == (uint32_t)&Reset_Handler))
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xBF1E             ITTT     NE 
   \   00000006   0xF110 0x0F01      CMNNE    R0,#+1
   \   0000000A   0x....             LDRNE.N  R1,??DataTable19_2
   \   0000000C   0x4288             CMPNE    R0,R1
   \   0000000E   0xB082             SUB      SP,SP,#+8
   \   00000010   0xD101             BNE.N    ??is_valid_application_location_0
    220              {
    221                  return false;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD16             POP      {R1,R2,R4,PC}
    222              }
    223          
    224              bool isValid = false;
    225              const uint32_t minThumb2InstructionSize = 2; // smallest thumb2 instruction size is 16-bit.
    226              // Check if the application address is in valid executable memory range
    227              status_t status = find_map_entry(applicationAddress, minThumb2InstructionSize, &map);
    228              if ((status == kStatus_Success) && (map->isExecutable))
   \                     ??is_valid_application_location_0: (+1)
   \   00000016   0x466A             MOV      R2,SP
   \   00000018   0x2102             MOVS     R1,#+2
   \   0000001A   0x.... 0x....      BL       find_map_entry
   \   0000001E   0x2400             MOVS     R4,#+0
   \   00000020   0xB918             CBNZ.N   R0,??is_valid_application_location_1
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0x7A00             LDRB     R0,[R0, #+8]
   \   00000026   0xB100             CBZ.N    R0,??is_valid_application_location_1
    229              {
    230                  isValid = true;
   \   00000028   0x2401             MOVS     R4,#+1
    231              }
    232          
    233              return isValid;
   \                     ??is_valid_application_location_1: (+1)
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    234          }
    235          
    236          #if !BL_FEATURE_TIMEOUT
    237          //! @brief Jump application is considered ready for executing if the location is valid and crc check is passed
    238          static bool is_application_ready_for_executing(uint32_t applicationAddress)
    239          {
    240              bool result = is_valid_application_location(applicationAddress);
    241          
    242          #if BL_FEATURE_OTFAD_MODULE
    243              if (result && is_qspi_present())
    244              {
    245                  quadspi_cache_clear();
    246                  status_t status = otfad_init_as_needed();
    247                  if (status != kStatus_Success)
    248                  {
    249                      result = false;
    250                  }
    251                  update_qspi_otfad_init_status(status);
    252              }
    253          #endif
    254          
    255          #if BL_FEATURE_CRC_CHECK
    256              // Validate application crc only if its location is valid
    257              if (result)
    258              {
    259                  result = is_application_crc_check_pass();
    260              }
    261          
    262          #if BL_FEATURE_OTFAD_MODULE
    263              otfad_bypass_as_needed();
    264          #endif // BL_FEATURE_OTFAD_MODULE
    265          
    266          #endif
    267          
    268              return result;
    269          }
    270          #endif // !BL_FEATURE_TIMEOUT
    271          
    272          //! @brief Determines the active peripheral.
    273          //!
    274          //! This function has several stages:
    275          //! - Init enabled peripherals.
    276          //! - Compute timeout.
    277          //! - Wait for peripheral activity with timeout.
    278          //! - Shutdown inactive peripherals.
    279          //!
    280          //! If peripheral detection times out, then this function will call jump_to_application() to
    281          //! directly enter the user application.
    282          //!
    283          //! The timeout value comes from the BCA if set, or the #BL_DEFAULT_PERIPHERAL_DETECT_TIMEOUT
    284          //! configuration macro. If the boot pin is asserted, or if there is not a valid user application
    285          //! in flash, then the timeout is disabled and peripheral detection will continue infinitely.

   \                                 In section .text, align 2, keep-with-next
    286          static peripheral_descriptor_t const *get_active_peripheral(void)
    287          {
   \                     get_active_peripheral: (+1)
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
    288              peripheral_descriptor_t const *peripheral;
    289              peripheral_descriptor_t const *activePeripheral = NULL;
    290              bootloader_configuration_data_t *configurationData =
    291                  &g_bootloaderContext.propertyInterface->store->configurationData;
   \   00000004   0x.... 0x....      LDR.W    R8,??DataTable19_3
    292          
    293              // Bring up all the peripherals
    294              for (peripheral = g_peripherals; peripheral->typeMask != 0; ++peripheral)
   \   00000008   0x....             LDR.N    R5,??DataTable19_4
   \   0000000A   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   0000000E   0x.... 0x....      ADR.W    R4,?_9
   \   00000012   0x6900             LDR      R0,[R0, #+16]
   \   00000014   0xF100 0x0768      ADD      R7,R0,#+104
   \   00000018   0x462E             MOV      R6,R5
   \   0000001A   0xE00F             B.N      ??get_active_peripheral_0
    295              {
    296                  // Check that the peripheral is enabled in the user configuration data
    297                  if (configurationData->enabledPeripherals & peripheral->typeMask)
   \                     ??get_active_peripheral_1: (+1)
   \   0000001C   0x7C39             LDRB     R1,[R7, #+16]
   \   0000001E   0x4201             TST      R1,R0
   \   00000020   0xD00B             BEQ.N    ??get_active_peripheral_2
    298                  {
    299                      assert(peripheral->controlInterface->init);
    300          
    301                      debug_printf("Initing %s\r\n", get_peripheral_name(peripheral->typeMask));
   \   00000022   0x.... 0x....      BL       get_peripheral_name
   \   00000026   0x4601             MOV      R1,R0
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       debug_printf
    302                      peripheral->controlInterface->init(peripheral, peripheral->packetInterface->byteReceivedCallback);
   \   0000002E   0x6970             LDR      R0,[R6, #+20]
   \   00000030   0x68F2             LDR      R2,[R6, #+12]
   \   00000032   0x6981             LDR      R1,[R0, #+24]
   \   00000034   0x6852             LDR      R2,[R2, #+4]
   \   00000036   0x4630             MOV      R0,R6
   \   00000038   0x4790             BLX      R2
    303                  }
    304              }
   \                     ??get_active_peripheral_2: (+1)
   \   0000003A   0x3618             ADDS     R6,R6,#+24
   \                     ??get_active_peripheral_0: (+1)
   \   0000003C   0x6830             LDR      R0,[R6, #+0]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD1EC             BNE.N    ??get_active_peripheral_1
    305          
    306          #if !BL_FEATURE_TIMEOUT
    307              uint64_t lastTicks = 0;    // Value of our last recorded ticks second marker
   \   00000042   0x2400             MOVS     R4,#+0
   \   00000044   0x46A1             MOV      R9,R4
    308              uint64_t timeoutTicks = 0; // The number of ticks we will wait for timeout, 0 means no timeout
   \   00000046   0xE9CD 0x4900      STRD     R4,R9,[SP, #+0]
    309          #if BL_FEATURE_POWERDOWN
    310              bool shortTimeout = false;
    311          #endif
    312              const uint64_t ticksPerMillisecond = microseconds_convert_to_ticks(1000);
   \   0000004A   0xF44F 0x707A      MOV      R0,#+1000
   \   0000004E   0x.... 0x....      BL       microseconds_convert_to_ticks
   \   00000052   0x4606             MOV      R6,R0
   \   00000054   0x468A             MOV      R10,R1
    313          
    314              // Get the user application entry point and stack pointer.
    315              uint32_t applicationAddress, stackPointer;
    316              get_user_application_entry(&applicationAddress, &stackPointer);
    317          
    318              // If the boot to rom option is not set AND there is a valid jump application determine the timeout value
    319              if (!is_boot_pin_asserted() && is_application_ready_for_executing(applicationAddress))
   \   00000056   0x.... 0x....      BL       is_boot_pin_asserted
   \   0000005A   0xBBA0             CBNZ.N   R0,??get_active_peripheral_3
   \   0000005C   0x.... 0x....      BL       is_valid_application_location
   \   00000060   0xB388             CBZ.N    R0,??get_active_peripheral_3
    320              {
    321                  if (is_direct_boot())
   \   00000062   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   00000066   0x6900             LDR      R0,[R0, #+16]
   \   00000068   0xF890 0x0086      LDRB     R0,[R0, #+134]
   \   0000006C   0x07C0             LSLS     R0,R0,#+31
   \   0000006E   0xD403             BMI.N    ??get_active_peripheral_4
    322                  {
    323                      jump_to_application(applicationAddress, stackPointer);
   \   00000070   0x2100             MOVS     R1,#+0
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x.... 0x....      BL       jump_to_application
    324                  }
    325          
    326                  // Calculate how many ticks we need to wait based on the bootloader config. Check to see if
    327                  // there is a valid configuration data value for the timeout. If there's not, use the
    328                  // default timeout value.
    329                  uint32_t milliseconds;
    330                  if (configurationData->peripheralDetectionTimeoutMs != 0xFFFF)
   \                     ??get_active_peripheral_4: (+1)
   \   00000078   0x8A78             LDRH     R0,[R7, #+18]
   \   0000007A   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000007E   0x4288             CMP      R0,R1
   \   00000080   0xBF08             IT       EQ 
   \   00000082   0x2000             MOVEQ    R0,#+0
    331                  {
    332                      milliseconds = configurationData->peripheralDetectionTimeoutMs;
    333                  }
    334                  else
    335                  {
    336                      milliseconds = BL_DEFAULT_PERIPHERAL_DETECT_TIMEOUT;
    337                  }
    338                  timeoutTicks = milliseconds * ticksPerMillisecond;
   \   00000084   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \   00000088   0xFB0A 0x3300      MLA      R3,R10,R0,R3
   \   0000008C   0xE9CD 0x2300      STRD     R2,R3,[SP, #+0]
    339          
    340                  // save how many ticks we're currently at before the detection loop starts
    341                  lastTicks = microseconds_get_ticks();
   \   00000090   0x.... 0x....      BL       microseconds_get_ticks
   \   00000094   0x4604             MOV      R4,R0
   \   00000096   0x4689             MOV      R9,R1
    342          #if BL_FEATURE_POWERDOWN
    343                  shortTimeout = true;
    344          #endif
    345              }
    346          #if BL_FEATURE_POWERDOWN
    347              else
    348              {
    349                  timeoutTicks = BL_DEFAULT_POWERDOWN_TIMEOUT * ticksPerMillisecond;
    350                  lastTicks = microseconds_get_ticks();
    351              }
    352          #endif
    353          #endif // !BL_FEATURE_TIMEOUT
    354          
    355              // Wait for a peripheral to become active
    356              while (activePeripheral == NULL)
    357              {
    358          #if !BL_FEATURE_TIMEOUT
    359                  // If timeout is enabled, check to see if we've exceeded it.
    360                  if (timeoutTicks)
   \                     ??get_active_peripheral_5: (+1)
   \   00000098   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   0000009C   0x2200             MOVS     R2,#+0
   \   0000009E   0x4291             CMP      R1,R2
   \   000000A0   0xBF08             IT       EQ 
   \   000000A2   0x4290             CMPEQ    R0,R2
   \   000000A4   0xD00F             BEQ.N    ??get_active_peripheral_3
    361                  {
    362                      // Note that we assume that the tick counter won't overflow and wrap back to 0.
    363                      // The timeout value is only up to 65536 milliseconds, and the tick count starts
    364                      // at zero when when inited the microseconds driver just a few moments ago.
    365                      uint64_t elapsedTicks = microseconds_get_ticks() - lastTicks;
    366          
    367                      // Check if the elapsed time is longer than the timeout.
    368                      if (elapsedTicks >= timeoutTicks)
   \   000000A6   0x.... 0x....      BL       microseconds_get_ticks
   \   000000AA   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \   000000AE   0x1B00             SUBS     R0,R0,R4
   \   000000B0   0xEB61 0x0109      SBC      R1,R1,R9
   \   000000B4   0x4299             CMP      R1,R3
   \   000000B6   0xD306             BCC.N    ??get_active_peripheral_3
   \   000000B8   0xD801             BHI.N    ??get_active_peripheral_6
   \   000000BA   0x4290             CMP      R0,R2
   \   000000BC   0xD303             BCC.N    ??get_active_peripheral_3
    369                      {
    370          #if BL_FEATURE_POWERDOWN
    371                          if (shortTimeout)
    372                          {
    373          #endif
    374                              // In the case of the typical peripheral timeout, jump to the user application.
    375                              jump_to_application(applicationAddress, stackPointer);
   \                     ??get_active_peripheral_6: (+1)
   \   000000BE   0x2100             MOVS     R1,#+0
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x.... 0x....      BL       jump_to_application
    376          #if BL_FEATURE_POWERDOWN
    377                          }
    378                          else
    379                          {
    380                              // Make sure a timeout value has been defined before shutting down.
    381                              if (BL_DEFAULT_POWERDOWN_TIMEOUT)
    382                              {
    383                                  // Shut down the bootloader and return to reset-type state prior to low
    384                                  // power entry
    385                                  shutdown_cleanup(kShutdownType_Shutdown);
    386          
    387                                  // Enter VLLS1 low power mode
    388                                  enter_vlls1();
    389                              }
    390                          }
    391          #endif
    392                      }
    393                  }
    394          #endif // !BL_FEATURE_TIMEOUT
    395                  // Traverse through all the peripherals
    396                  for (peripheral = g_peripherals; peripheral->typeMask != 0; ++peripheral)
   \                     ??get_active_peripheral_3: (+1)
   \   000000C6   0x462E             MOV      R6,R5
   \   000000C8   0xE000             B.N      ??get_active_peripheral_7
   \                     ??get_active_peripheral_8: (+1)
   \   000000CA   0x3618             ADDS     R6,R6,#+24
   \                     ??get_active_peripheral_7: (+1)
   \   000000CC   0x6830             LDR      R0,[R6, #+0]
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD0E2             BEQ.N    ??get_active_peripheral_5
    397                  {
    398                      // Check that the peripheral is enabled in the user configuration data
    399                      if (configurationData->enabledPeripherals & peripheral->typeMask)
   \   000000D2   0x7C39             LDRB     R1,[R7, #+16]
   \   000000D4   0x4201             TST      R1,R0
   \   000000D6   0xD0F8             BEQ.N    ??get_active_peripheral_8
    400                      {
    401                          assert(peripheral->controlInterface->pollForActivity);
    402          
    403                          if (peripheral->controlInterface->pollForActivity(peripheral))
   \   000000D8   0x68F1             LDR      R1,[R6, #+12]
   \   000000DA   0x6809             LDR      R1,[R1, #+0]
   \   000000DC   0x4630             MOV      R0,R6
   \   000000DE   0x4788             BLX      R1
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xD0F2             BEQ.N    ??get_active_peripheral_8
    404                          {
    405                              debug_printf("%s is active\r\n", get_peripheral_name(peripheral->typeMask));
   \   000000E4   0x6830             LDR      R0,[R6, #+0]
   \   000000E6   0x.... 0x....      BL       get_peripheral_name
   \   000000EA   0x4601             MOV      R1,R0
   \   000000EC   0x.... 0x....      ADR.W    R0,?_10
   \   000000F0   0x.... 0x....      BL       debug_printf
    406          
    407                              activePeripheral = peripheral;
    408                              break;
    409                          }
    410                      }
    411                  }
    412              }
   \   000000F4   0x2E00             CMP      R6,#+0
   \   000000F6   0xD0CF             BEQ.N    ??get_active_peripheral_5
    413          
    414              // Shut down all non active peripherals
    415              for (peripheral = g_peripherals; peripheral->typeMask != 0; ++peripheral)
   \   000000F8   0x.... 0x....      ADR.W    R4,?_11
   \   000000FC   0xE00F             B.N      ??get_active_peripheral_9
    416              {
    417                  // Check that the peripheral is enabled in the user configuration data
    418                  if (configurationData->enabledPeripherals & peripheral->typeMask)
   \                     ??get_active_peripheral_10: (+1)
   \   000000FE   0x7C39             LDRB     R1,[R7, #+16]
   \   00000100   0x4201             TST      R1,R0
   \   00000102   0xBF18             IT       NE 
   \   00000104   0x42AE             CMPNE    R6,R5
    419                  {
    420                      if (activePeripheral != peripheral)
   \   00000106   0xD009             BEQ.N    ??get_active_peripheral_11
    421                      {
    422                          debug_printf("Shutting down %s\r\n", get_peripheral_name(peripheral->typeMask));
   \   00000108   0x.... 0x....      BL       get_peripheral_name
   \   0000010C   0x4601             MOV      R1,R0
   \   0000010E   0x4620             MOV      R0,R4
   \   00000110   0x.... 0x....      BL       debug_printf
    423          
    424                          assert(peripheral->controlInterface->shutdown);
    425                          peripheral->controlInterface->shutdown(peripheral);
   \   00000114   0x68E9             LDR      R1,[R5, #+12]
   \   00000116   0x6889             LDR      R1,[R1, #+8]
   \   00000118   0x4628             MOV      R0,R5
   \   0000011A   0x4788             BLX      R1
    426                      }
    427                  }
    428              }
   \                     ??get_active_peripheral_11: (+1)
   \   0000011C   0x3518             ADDS     R5,R5,#+24
   \                     ??get_active_peripheral_9: (+1)
   \   0000011E   0x6828             LDR      R0,[R5, #+0]
   \   00000120   0x2800             CMP      R0,#+0
   \   00000122   0xD1EC             BNE.N    ??get_active_peripheral_10
    429          
    430              return activePeripheral;
   \   00000124   0x4630             MOV      R0,R6
   \   00000126   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    431          }
    432          
    433          #if BL_FEATURE_QSPI_MODULE
    434          static void configure_quadspi_as_needed(void)
    435          {
    436              // Start the lifetime counter
    437              microseconds_init();
    438              if (qspi_need_configure())
    439              {
    440                  status_t qspiOtfadInitStatus = kStatus_QspiNotConfigured;
    441                  // Try to configure QuadSPI module based on on qspi_config_block_pointer in BCA first,
    442                  // If bootloader cannot get qspi config block from internal flash, try to configure QSPI
    443                  // based on default place (start address of QuadSPI memory).
    444                  uint32_t qspi_config_block_base =
    445                      g_bootloaderContext.propertyInterface->store->configurationData.qspi_config_block_pointer;
    446          
    447                  // Get the start address and flash size
    448                  uint32_t flashStart;
    449                  g_bootloaderContext.flashDriverInterface->flash_get_property(&g_bootloaderContext.flashState,
    450                                                                               kFLASH_PropertyPflashBlockBaseAddr, &flashStart);
    451                  uint32_t flashSize;
    452                  g_bootloaderContext.flashDriverInterface->flash_get_property(&g_bootloaderContext.flashState,
    453                                                                               kFLASH_PropertyPflashTotalSize, &flashSize);
    454          
    455                  // Check if the pointer of qspi config block is valid.
    456                  if ((qspi_config_block_base != 0xFFFFFFFF) && (qspi_config_block_base > flashStart) &&
    457                      (qspi_config_block_base <= (flashStart + flashSize - sizeof(qspi_config_t))))
    458                  {
    459          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    460                      if (!is_in_execute_only_region(qspi_config_block_base, sizeof(qspi_config_t)))
    461                      {
    462                          qspiOtfadInitStatus = quadspi_init((void *)qspi_config_block_base);
    463                      }
    464          #else
    465                      qspiOtfadInitStatus = quadspi_init((void *)qspi_config_block_base);
    466          #endif // FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    467                  }
    468          
    469                  if (qspiOtfadInitStatus == kStatus_QspiNotConfigured)
    470                  {
    471                      qspiOtfadInitStatus = quadspi_init(NULL);
    472                  }
    473                  update_qspi_otfad_init_status(qspiOtfadInitStatus);
    474              }
    475              // Shutdown the lifetime counter before configuring clock.
    476              lock_acquire();
    477              microseconds_shutdown();
    478              lock_release();
    479          }
    480          #endif
    481          
    482          static void bootloader_flash_init(void)
    483          {
    484              g_bootloaderContext.flashDriverInterface->flash_init(&g_bootloaderContext.flashState);
    485          
    486          #if BL_TARGET_FLASH
    487              //! @brief A static buffer used to hold flash_run_command()
    488              static uint32_t s_flashRunCommand[kFLASH_ExecuteInRamFunctionMaxSizeInWords];
    489              //! @brief A static buffer used to hold flash_cache_clear_command()
    490              static uint32_t s_flashCacheClearCommand[kFLASH_ExecuteInRamFunctionMaxSizeInWords];
    491          
    492              static flash_execute_in_ram_function_config_t s_flashExecuteInRamFunctionInfo = {
    493                  .activeFunctionCount = 0,
    494                  .flashRunCommand = s_flashRunCommand,
    495                  .flashCacheClearCommand = s_flashCacheClearCommand,
    496              };
    497          
    498              g_bootloaderContext.flashState.flashExecuteInRamFunctionInfo = &s_flashExecuteInRamFunctionInfo.activeFunctionCount;
    499              g_bootloaderContext.flashDriverInterface->flash_prepare_execute_in_ram_functions(&g_bootloaderContext.flashState);
    500          #endif
    501          }
    502          
    503          //! @brief Initialize the bootloader and peripherals.
    504          //!
    505          //! This function initializes hardware and clocks, loads user configuration data, and initialzes
    506          //! a number of drivers. It then enters the active peripheral detection phase by calling
    507          //! get_active_peripheral(). Once the peripheral is detected, the packet and comand interfaces
    508          //! are initialized.
    509          //!
    510          //! Note that this routine may not return if peripheral detection times out and the bootloader
    511          //! jumps directly to the user application in flash.

   \                                 In section .text, align 2, keep-with-next
    512          static void bootloader_init(void)
    513          {
   \                     bootloader_init: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    514              // Init the global irq lock
    515              lock_init();
   \   00000002   0x.... 0x....      BL       lock_init
    516          
    517              // Init pinmux and other hardware setup.
    518              init_hardware();
   \   00000006   0x.... 0x....      BL       init_hardware
    519          
    520              // Init flash driver.
    521              bootloader_flash_init();
   \   0000000A   0x....             LDR.N    R4,??DataTable19_3
   \   0000000C   0x6921             LDR      R1,[R4, #+16]
   \   0000000E   0x6849             LDR      R1,[R1, #+4]
   \   00000010   0xF104 0x0020      ADD      R0,R4,#+32
   \   00000014   0x4788             BLX      R1
    522          
    523              // Load the user configuration data so that we can configure the clocks
    524              g_bootloaderContext.propertyInterface->load_user_config();
   \   00000016   0x68A0             LDR      R0,[R4, #+8]
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x4780             BLX      R0
    525          
    526          // Init QSPI module if needed
    527          #if BL_FEATURE_QSPI_MODULE
    528              configure_quadspi_as_needed();
    529          #endif // BL_FEATURE_QSPI_MODULE
    530          
    531              // Configure clocks.
    532              configure_clocks(kClockOption_EnterBootloader);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      BL       configure_clocks
    533          
    534              // Start the lifetime counter
    535              microseconds_init();
   \   00000022   0x.... 0x....      BL       microseconds_init
    536          
    537          #if BL_FEATURE_BYPASS_WATCHDOG
    538              g_bootloaderContext.flashDriverInterface->flash_register_callback(&g_bootloaderContext.flashState,
    539                                                                                bootloader_watchdog_service);
    540              bootloader_watchdog_init();
    541          #endif // BL_FEATURE_BYPASS_WATCHDOG
    542          
    543              // Init address range of flash array, SRAM_L and SRAM U.
    544              g_bootloaderContext.memoryInterface->init();
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x4780             BLX      R0
    545          
    546              // Fully init the property store.
    547              g_bootloaderContext.propertyInterface->init();
   \   0000002C   0x68A0             LDR      R0,[R4, #+8]
   \   0000002E   0x6840             LDR      R0,[R0, #+4]
   \   00000030   0x4780             BLX      R0
    548          
    549          #if BL_FEATURE_RELIABLE_UPDATE
    550              bootloader_reliable_update_as_requested(kReliableUpdateOption_Normal, 0);
    551          #endif // BL_FEATURE_RELIABLE_UPDATE
    552          
    553              // Message so python instantiated debugger can tell the
    554              // bootloader application is running on the target.
    555              debug_printf("\r\n\r\nRunning bootloader...\r\n");
   \   00000032   0x.... 0x....      ADR.W    R0,?_12
   \   00000036   0x.... 0x....      BL       debug_printf
    556          
    557          #if DEBUG && !DEBUG_PRINT_DISABLE
    558              standard_version_t version = g_bootloaderContext.propertyInterface->store->bootloaderVersion;
   \   0000003A   0x68A0             LDR      R0,[R4, #+8]
   \   0000003C   0x6900             LDR      R0,[R0, #+16]
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x9001             STR      R0,[SP, #+4]
    559              debug_printf("Bootloader version %c%d.%d.%d\r\n", version.name, version.major, version.minor, version.bugfix);
   \   00000042   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000046   0xF89D 0x3005      LDRB     R3,[SP, #+5]
   \   0000004A   0xF89D 0x2006      LDRB     R2,[SP, #+6]
   \   0000004E   0xF89D 0x1007      LDRB     R1,[SP, #+7]
   \   00000052   0x9000             STR      R0,[SP, #+0]
   \   00000054   0x.... 0x....      ADR.W    R0,?_13
   \   00000058   0x.... 0x....      BL       debug_printf
    560          #endif
    561          
    562              // Wait for a peripheral to become active.
    563              g_bootloaderContext.activePeripheral = get_active_peripheral();
   \   0000005C   0x.... 0x....      BL       get_active_peripheral
   \   00000060   0x61E0             STR      R0,[R4, #+28]
    564              assert(g_bootloaderContext.activePeripheral);
    565          
    566              // Validate required active peripheral interfaces.
    567              assert(g_bootloaderContext.activePeripheral->controlInterface);
    568          
    569              // Init the active peripheral.
    570              if (g_bootloaderContext.activePeripheral->byteInterface &&
    571                  g_bootloaderContext.activePeripheral->byteInterface->init)
   \   00000062   0x6901             LDR      R1,[R0, #+16]
   \   00000064   0xB119             CBZ.N    R1,??bootloader_init_0
   \   00000066   0x6809             LDR      R1,[R1, #+0]
   \   00000068   0x000A             MOVS     R2,R1
   \   0000006A   0xBF18             IT       NE 
    572              {
    573                  g_bootloaderContext.activePeripheral->byteInterface->init(g_bootloaderContext.activePeripheral);
   \   0000006C   0x4788             BLXNE    R1
    574              }
    575              if (g_bootloaderContext.activePeripheral->packetInterface &&
    576                  g_bootloaderContext.activePeripheral->packetInterface->init)
   \                     ??bootloader_init_0: (+1)
   \   0000006E   0x69E0             LDR      R0,[R4, #+28]
   \   00000070   0x6941             LDR      R1,[R0, #+20]
   \   00000072   0xB119             CBZ.N    R1,??bootloader_init_1
   \   00000074   0x6809             LDR      R1,[R1, #+0]
   \   00000076   0x000A             MOVS     R2,R1
   \   00000078   0xBF18             IT       NE 
    577              {
    578                  g_bootloaderContext.activePeripheral->packetInterface->init(g_bootloaderContext.activePeripheral);
   \   0000007A   0x4788             BLXNE    R1
    579              }
    580          
    581              // Initialize the command processor component.
    582              g_bootloaderContext.commandInterface->init();
   \                     ??bootloader_init_1: (+1)
   \   0000007C   0x68E0             LDR      R0,[R4, #+12]
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0xE8BD 0x4016      POP      {R1,R2,R4,LR}
   \   00000084   0x4700             BX       R0
    583          }
    584          
    585          //! @brief Bootloader outer loop.
    586          //!
    587          //! Infinitely calls the command interface and active peripheral control interface pump routines.
    588          static void bootloader_run(void)
    589          {
    590              const peripheral_descriptor_t *activePeripheral = g_bootloaderContext.activePeripheral;
    591          
    592              assert(g_bootloaderContext.commandInterface->pump);
    593          
    594              // Read and execute commands.
    595              while (1)
    596              {
    597                  g_bootloaderContext.commandInterface->pump();
    598          
    599                  // Pump the active peripheral.
    600                  if (activePeripheral->controlInterface->pump)
    601                  {
    602                      activePeripheral->controlInterface->pump(activePeripheral);
    603                  }
    604              }
    605          }
    606          
    607          //! @brief Entry point for the bootloader.

   \                                 In section .text, align 2, keep-with-next
    608          int main(void)
    609          {
   \                     main: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    610              bootloader_init();
   \   00000002   0x.... 0x....      BL       bootloader_init
    611              bootloader_run();
   \   00000006   0x....             LDR.N    R4,??DataTable19_3
   \   00000008   0x69E5             LDR      R5,[R4, #+28]
   \                     ??main_0: (+1)
   \   0000000A   0x68E0             LDR      R0,[R4, #+12]
   \   0000000C   0x6840             LDR      R0,[R0, #+4]
   \   0000000E   0x4780             BLX      R0
   \   00000010   0x68E8             LDR      R0,[R5, #+12]
   \   00000012   0x68C1             LDR      R1,[R0, #+12]
   \   00000014   0x0008             MOVS     R0,R1
   \   00000016   0xD0F8             BEQ.N    ??main_0
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x4788             BLX      R1
   \   0000001C   0xE7F5             B.N      ??main_0
    612          
    613              // Should never end up here.
    614              debug_printf("Warning: reached end of main()\r\n");
    615              return 0;
    616          }
    617          
    618          //! Since we never exit this gets rid of the C standard functions that cause
    619          //! extra ROM size usage.

   \                                 In section .text, align 2, keep-with-next
    620          void exit(int arg)
    621          {
    622          }
   \                     exit: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     `jump_to_application::s_stackPointer`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0xE000ED08         DC32     0xe000ed08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x........         DC32     Reset_Handler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0x........         DC32     g_bootloaderContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \   00000000   0x........         DC32     g_peripherals

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x55 0x41          DC8 "UART"
   \              0x52 0x54    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x49 0x32          DC8 "I2C"
   \              0x43 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x53 0x50          DC8 "SPI"
   \              0x49 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x43 0x41          DC8 "CAN"
   \              0x4E 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x48 0x49          DC8 "HID"
   \              0x44 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x43 0x44          DC8 "CDC"
   \              0x43 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x44 0x46          DC8 "DFU"
   \              0x55 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x4D 0x53          DC8 "MSD"
   \              0x44 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x55 0x6E          DC8 "Unknown peripheral"
   \              0x6B 0x6E    
   \              0x6F 0x77    
   \              0x6E 0x20    
   \              0x70 0x65    
   \              0x72 0x69    
   \              0x70 0x68    
   \              0x65 0x72    
   \              0x61 0x6C    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_9:
   \   00000000   0x49 0x6E          DC8 "Initing %s\015\012"
   \              0x69 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x25 0x73    
   \              0x0D 0x0A    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \   00000000   0x25 0x73          DC8 "%s is active\015\012"
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x61 0x63    
   \              0x74 0x69    
   \              0x76 0x65    
   \              0x0D 0x0A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_11:
   \   00000000   0x53 0x68          DC8 "Shutting down %s\015\012"
   \              0x75 0x74    
   \              0x74 0x69    
   \              0x6E 0x67    
   \              0x20 0x64    
   \              0x6F 0x77    
   \              0x6E 0x20    
   \              0x25 0x73    
   \              0x0D 0x0A    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_12:
   \   00000000   0x0D 0x0A          DC8 "\015\012\015\012Running bootloader...\015\012"
   \              0x0D 0x0A    
   \              0x52 0x75    
   \              0x6E 0x6E    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x62 0x6F    
   \              0x6F 0x74    
   \              0x6C 0x6F    
   \              0x61 0x64    
   \              0x65 0x72    
   \              0x2E 0x2E    
   \              0x2E 0x0D    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_13:
   \   00000000   0x42 0x6F          DC8 "Bootloader version %c%d.%d.%d\015\012"
   \              0x6F 0x74    
   \              0x6C 0x6F    
   \              0x61 0x64    
   \              0x65 0x72    
   \              0x20 0x76    
   \              0x65 0x72    
   \              0x73 0x69    
   \              0x6F 0x6E    
   \              0x20 0x25    
   \              0x63 0x25    
   \              0x64 0x2E    
   \              0x25 0x64    
   \              0x2E 0x25    
   \              0x64 0x0D    
   \              0x0A 0x00    
    623          
    624          #if defined(__CC_ARM)
    625          #define ITM_Port8(n) (*((volatile unsigned char *)(0xE0000000 + 4 * n)))
    626          #define ITM_Port16(n) (*((volatile unsigned short *)(0xE0000000 + 4 * n)))
    627          #define ITM_Port32(n) (*((volatile unsigned long *)(0xE0000000 + 4 * n)))
    628          
    629          #define DEMCR (*((volatile unsigned long *)(0xE000EDFC)))
    630          #define TRCENA 0x01000000
    631          
    632          struct __FILE
    633          {
    634              int handle; /* Add whatever needed */
    635          };
    636          FILE __stdout;
    637          FILE __stdin;
    638          
    639          int fputc(int ch, FILE *f)
    640          {
    641              if (DEMCR & TRCENA)
    642              {
    643                  while (ITM_Port32(0) == 0)
    644                      ;
    645                  ITM_Port8(0) = ch;
    646              }
    647              return (ch);
    648          }
    649          #endif
    650          
    651          //! @}
    652          
    653          ////////////////////////////////////////////////////////////////////////////////
    654          // EOF
    655          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   bootloader_init
         0   -- Indirect call
        16   -- Indirect call
        16   -> configure_clocks
        16   -> debug_printf
        16   -> get_active_peripheral
        16   -> init_hardware
        16   -> lock_init
        16   -> microseconds_init
      16   debug_printf
        16   -> vprintf
       0   exit
      40   get_active_peripheral
        40   -- Indirect call
        40   -> debug_printf
        40   -> get_peripheral_name
        40   -> is_boot_pin_asserted
        40   -> is_valid_application_location
        40   -> jump_to_application
        40   -> microseconds_convert_to_ticks
        40   -> microseconds_get_ticks
       0   get_peripheral_name
      16   is_valid_application_location
        16   -> find_map_entry
      16   jump_to_application
        16   -- Indirect call
         0   -> shutdown_cleanup
        16   -> shutdown_cleanup
      16   main
        16   -- Indirect call
        16   -> bootloader_init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       8  ?_0
       4  ?_1
      16  ?_10
      20  ?_11
      28  ?_12
      32  ?_13
       4  ?_2
       4  ?_3
       4  ?_4
       4  ?_5
       4  ?_6
       4  ?_7
      20  ?_8
      16  ?_9
     134  bootloader_init
      14  debug_printf
       2  exit
     298  get_active_peripheral
      32  get_peripheral_name
      46  is_valid_application_location
      48  jump_to_application
      32  kPeripheralNames
      30  main
       8  s_stackPointer
          farewellBootloader

 
   8 bytes in section .bss
  36 bytes in section .rodata
 788 bytes in section .text
 
 788 bytes of CODE  memory
  36 bytes of CONST memory
   8 bytes of DATA  memory

Errors: none
Warnings: none
