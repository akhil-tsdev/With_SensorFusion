###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Aug/2016  13:15:54
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\crc\fsl_crc.c
#    Command line =  
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\crc\fsl_crc.c"
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN256VDC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D BL_TARGET_RAM -lC
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj"
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices/MK22F25612\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/autobaud\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/osa\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device/class\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/bm_usb\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/CMSIS/Include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers/common\"
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list\fsl_crc.lst
#    Object file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj\fsl_crc.o
#
###############################################################################

C:\Users\cwati\Documents\My Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\crc\fsl_crc.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          #include "fsl_crc.h"
     31          
     32          /*******************************************************************************
     33           * Definitions
     34           ******************************************************************************/
     35          
     36          #if defined(CRC_DRIVER_USE_CRC16_CCIT_FALSE_AS_DEFAULT) && CRC_DRIVER_USE_CRC16_CCIT_FALSE_AS_DEFAULT
     37          /* @brief Default user configuration structure for CRC-16-CCITT */
     38          #define CRC_DRIVER_DEFAULT_POLYNOMIAL 0x1021U
     39          /*< CRC-16-CCIT polynomial x**16 + x**12 + x**5 + x**0 */
     40          #define CRC_DRIVER_DEFAULT_SEED 0xFFFFU
     41          /*< Default initial checksum */
     42          #define CRC_DRIVER_DEFAULT_REFLECT_IN false
     43          /*< Default is no transpose */
     44          #define CRC_DRIVER_DEFAULT_REFLECT_OUT false
     45          /*< Default is transpose bytes */
     46          #define CRC_DRIVER_DEFAULT_COMPLEMENT_CHECKSUM false
     47          /*< Default is without complement of CRC data register read data */
     48          #define CRC_DRIVER_DEFAULT_CRC_BITS kCrcBits16
     49          /*< Default is 16-bit CRC protocol */
     50          #define CRC_DRIVER_DEFAULT_CRC_RESULT kCrcFinalChecksum
     51          /*< Default is resutl type is final checksum */
     52          #endif /* CRC_DRIVER_USE_CRC16_CCIT_FALSE_AS_DEFAULT */
     53          
     54          /*! @brief CRC type of transpose of read write data */
     55          typedef enum _crc_transpose_type
     56          {
     57              kCrcTransposeNone = 0U,         /*! No transpose  */
     58              kCrcTransposeBits = 1U,         /*! Tranpose bits in bytes  */
     59              kCrcTransposeBitsAndBytes = 2U, /*! Transpose bytes and bits in bytes */
     60              kCrcTransposeBytes = 3U,        /*! Transpose bytes */
     61          } crc_transpose_type_t;
     62          
     63          /*!
     64          * @brief CRC module configuration.
     65          *
     66          * This structure holds the configuration for the CRC module.
     67          */
     68          typedef struct _crc_module_config
     69          {
     70              uint32_t polynomial;                 /*!< CRC Polynomial, MSBit first.@n
     71                                                        Example polynomial: 0x1021 = 1_0000_0010_0001 = x^12+x^5+1 */
     72              uint32_t seed;                       /*!< Starting checksum value */
     73              crc_transpose_type_t readTranspose;  /*!< Type of transpose when reading CRC result. */
     74              crc_transpose_type_t writeTranspose; /*!< Type of transpose when writing CRC input data. */
     75              bool complementChecksum;             /*!< True if the result shall be complement of the actual checksum. */
     76              crc_bits_t crcBits;                  /*!< Selects 16- or 32- bit CRC protocol. */
     77          } crc_module_config_t;
     78          
     79          /*******************************************************************************
     80           * Code
     81           ******************************************************************************/
     82          
     83          /*!
     84           * @brief Returns transpose type for CRC protocol reflect in parameter.
     85           *
     86           * This functions helps to set writeTranspose member of crc_config_t structure. Reflect in is CRC protocol parameter.
     87           *
     88           * @param enable True or false for the selected CRC protocol Reflect In (refin) parameter.
     89           */
     90          static inline crc_transpose_type_t crc_GetTransposeTypeFromReflectIn(bool enable)
     91          {
     92              return ((enable) ? kCrcTransposeBitsAndBytes : kCrcTransposeBytes);
     93          }
     94          
     95          /*!
     96           * @brief Returns transpose type for CRC protocol reflect out parameter.
     97           *
     98           * This functions helps to set readTranspose member of crc_config_t structure. Reflect out is CRC protocol parameter.
     99           *
    100           * @param enable True or false for the selected CRC protocol Reflect Out (refout) parameter.
    101           */
    102          static inline crc_transpose_type_t crc_GetTransposeTypeFromReflectOut(bool enable)
    103          {
    104              return ((enable) ? kCrcTransposeBitsAndBytes : kCrcTransposeNone);
    105          }
    106          
    107          /*!
    108           * @brief Starts checksum computation.
    109           *
    110           * Configures the CRC module for the specified CRC protocol. @n
    111           * Starts the checksum computation by writing the seed value
    112           *
    113           * @param base CRC peripheral address.
    114           * @param config Pointer to protocol configuration structure.
    115           */

   \                                 In section .text, align 2, keep-with-next
    116          static void crc_ConfigureAndStart(CRC_Type *base, const crc_module_config_t *config)
    117          {
    118              uint32_t crcControl;
    119          
    120              /* pre-compute value for CRC control registger based on user configuraton without WAS field */
    121              crcControl = 0 | CRC_CTRL_TOT(config->writeTranspose) | CRC_CTRL_TOTR(config->readTranspose) |
    122                           CRC_CTRL_FXOR(config->complementChecksum) | CRC_CTRL_TCRC(config->crcBits);
   \                     crc_ConfigureAndStart: (+1)
   \   00000000   0x7A0B             LDRB     R3,[R1, #+8]
   \   00000002   0x7A4A             LDRB     R2,[R1, #+9]
   \   00000004   0x071B             LSLS     R3,R3,#+28
   \   00000006   0xF003 0x5340      AND      R3,R3,#0x30000000
   \   0000000A   0xEA43 0x7282      ORR      R2,R3,R2, LSL #+30
   \   0000000E   0x7A8B             LDRB     R3,[R1, #+10]
   \   00000010   0xEA42 0x6283      ORR      R2,R2,R3, LSL #+26
   \   00000014   0x7ACB             LDRB     R3,[R1, #+11]
   \   00000016   0x061B             LSLS     R3,R3,#+24
   \   00000018   0xF003 0x7380      AND      R3,R3,#0x1000000
   \   0000001C   0x431A             ORRS     R2,R3,R2
    123          
    124              /* make sure the control register is clear - WAS is deasserted, and protocol is set */
    125              base->CTRL = crcControl;
   \   0000001E   0x6082             STR      R2,[R0, #+8]
    126          
    127              /* write polynomial register */
    128              base->GPOLY = config->polynomial;
   \   00000020   0x680B             LDR      R3,[R1, #+0]
   \   00000022   0x6043             STR      R3,[R0, #+4]
    129          
    130              /* write pre-computed control register value along with WAS to start checksum computation */
    131              base->CTRL = crcControl | CRC_CTRL_WAS(true);
   \   00000024   0xF042 0x7300      ORR      R3,R2,#0x2000000
   \   00000028   0x6083             STR      R3,[R0, #+8]
    132          
    133              /* write seed (initial checksum) */
    134              base->DATA = config->seed;
   \   0000002A   0x6849             LDR      R1,[R1, #+4]
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    135          
    136              /* deassert WAS by writing pre-computed CRC control register value */
    137              base->CTRL = crcControl;
   \   0000002E   0x6082             STR      R2,[R0, #+8]
    138          }
   \   00000030   0x4770             BX       LR               ;; return
    139          
    140          /*!
    141           * @brief Starts final checksum computation.
    142           *
    143           * Configures the CRC module for the specified CRC protocol. @n
    144           * Starts final checksum computation by writing the seed value.
    145           * @note CRC_Get16bitResult() or CRC_Get32bitResult() return final checksum
    146           *       (output reflection and xor functions are applied).
    147           *
    148           * @param base CRC peripheral address.
    149           * @param protocolConfig Pointer to protocol configuration structure.
    150           */
    151          static void crc_SetProtocolConfig(CRC_Type *base, const crc_config_t *protocolConfig)
    152          {
    153              crc_module_config_t moduleConfig;
    154              /* convert protocol to CRC peripheral module configuration, prepare for final checksum */
    155              moduleConfig.polynomial = protocolConfig->polynomial;
    156              moduleConfig.seed = protocolConfig->seed;
    157              moduleConfig.readTranspose = crc_GetTransposeTypeFromReflectOut(protocolConfig->reflectOut);
    158              moduleConfig.writeTranspose = crc_GetTransposeTypeFromReflectIn(protocolConfig->reflectIn);
    159              moduleConfig.complementChecksum = protocolConfig->complementChecksum;
    160              moduleConfig.crcBits = protocolConfig->crcBits;
    161          
    162              crc_ConfigureAndStart(base, &moduleConfig);
    163          }
    164          
    165          /*!
    166           * @brief Starts intermediate checksum computation.
    167           *
    168           * Configures the CRC module for the specified CRC protocol. @n
    169           * Starts intermediate checksum computation by writing the seed value.
    170           * @note CRC_Get16bitResult() or CRC_Get32bitResult() return intermediate checksum (raw data register value).
    171           *
    172           * @param base CRC peripheral address.
    173           * @param protocolConfig Pointer to protocol configuration structure.
    174           */
    175          static void crc_SetRawProtocolConfig(CRC_Type *base, const crc_config_t *protocolConfig)
    176          {
    177              crc_module_config_t moduleConfig;
    178              /* convert protocol to CRC peripheral module configuration, prepare for intermediate checksum */
    179              moduleConfig.polynomial = protocolConfig->polynomial;
    180              moduleConfig.seed = protocolConfig->seed;
    181              moduleConfig.readTranspose =
    182                  kCrcTransposeNone; /* intermediate checksum does no transpose of data register read value */
    183              moduleConfig.writeTranspose = crc_GetTransposeTypeFromReflectIn(protocolConfig->reflectIn);
    184              moduleConfig.complementChecksum = false; /* intermediate checksum does no xor of data register read value */
    185              moduleConfig.crcBits = protocolConfig->crcBits;
    186          
    187              crc_ConfigureAndStart(base, &moduleConfig);
    188          }
    189          

   \                                 In section .text, align 2, keep-with-next
    190          void CRC_Init(CRC_Type *base, const crc_config_t *config)
    191          {
   \                     CRC_Init: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
    192              /* ungate clock */
    193              CLOCK_EnableClock(kCLOCK_Crc0);
   \   00000002   0x....             LDR.N    R2,??DataTable1  ;; 0x4004803c
   \   00000004   0x6813             LDR      R3,[R2, #+0]
   \   00000006   0xF443 0x2380      ORR      R3,R3,#0x40000
   \   0000000A   0x6013             STR      R3,[R2, #+0]
    194              /* configure CRC module and write the seed */
    195              if (config->crcResult == kCrcFinalChecksum)
   \   0000000C   0x7B0A             LDRB     R2,[R1, #+12]
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0x680A             LDR      R2,[R1, #+0]
   \   00000012   0x9200             STR      R2,[SP, #+0]
   \   00000014   0x684A             LDR      R2,[R1, #+4]
   \   00000016   0x9201             STR      R2,[SP, #+4]
   \   00000018   0xD10D             BNE.N    ??CRC_Init_0
    196              {
    197                  crc_SetProtocolConfig(base, config);
   \   0000001A   0x7A4A             LDRB     R2,[R1, #+9]
   \   0000001C   0xB102             CBZ.N    R2,??CRC_Init_1
   \   0000001E   0x2202             MOVS     R2,#+2
   \                     ??CRC_Init_1: (+1)
   \   00000020   0xF88D 0x2008      STRB     R2,[SP, #+8]
   \   00000024   0x7A0A             LDRB     R2,[R1, #+8]
   \   00000026   0x2A00             CMP      R2,#+0
   \   00000028   0xBF14             ITE      NE 
   \   0000002A   0x2202             MOVNE    R2,#+2
   \   0000002C   0x2203             MOVEQ    R2,#+3
   \   0000002E   0xF88D 0x2009      STRB     R2,[SP, #+9]
   \   00000032   0x7A8A             LDRB     R2,[R1, #+10]
   \   00000034   0xE00A             B.N      ??CRC_Init_2
    198              }
    199              else
    200              {
    201                  crc_SetRawProtocolConfig(base, config);
   \                     ??CRC_Init_0: (+1)
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0xF88D 0x2008      STRB     R2,[SP, #+8]
   \   0000003C   0x7A0A             LDRB     R2,[R1, #+8]
   \   0000003E   0x2A00             CMP      R2,#+0
   \   00000040   0xBF14             ITE      NE 
   \   00000042   0x2202             MOVNE    R2,#+2
   \   00000044   0x2203             MOVEQ    R2,#+3
   \   00000046   0xF88D 0x2009      STRB     R2,[SP, #+9]
   \   0000004A   0x2200             MOVS     R2,#+0
   \                     ??CRC_Init_2: (+1)
   \   0000004C   0xF88D 0x200A      STRB     R2,[SP, #+10]
   \   00000050   0x7AC9             LDRB     R1,[R1, #+11]
   \   00000052   0xF88D 0x100B      STRB     R1,[SP, #+11]
   \   00000056   0x4669             MOV      R1,SP
   \   00000058   0x.... 0x....      BL       crc_ConfigureAndStart
    202              }
    203          }
   \   0000005C   0xBD07             POP      {R0-R2,PC}       ;; return
    204          

   \                                 In section .text, align 2, keep-with-next
    205          void CRC_GetDefaultConfig(crc_config_t *config)
    206          {
    207              static const crc_config_t crc16ccit = {
    208                  CRC_DRIVER_DEFAULT_POLYNOMIAL,          CRC_DRIVER_DEFAULT_SEED,
    209                  CRC_DRIVER_DEFAULT_REFLECT_IN,          CRC_DRIVER_DEFAULT_REFLECT_OUT,
    210                  CRC_DRIVER_DEFAULT_COMPLEMENT_CHECKSUM, CRC_DRIVER_DEFAULT_CRC_BITS,
    211                  CRC_DRIVER_DEFAULT_CRC_RESULT,
    212              };
    213          
    214              *config = crc16ccit;
   \                     CRC_GetDefaultConfig: (+1)
   \   00000000   0x.... 0x....      ADR.W    R1,`CRC_GetDefaultConfig::crc16ccit`
   \   00000004   0x2210             MOVS     R2,#+16
   \   00000006   0x.... 0x....      B.W      __aeabi_memcpy4
    215          }

   \                                 In section .text, align 4, keep-with-next
   \                     `CRC_GetDefaultConfig::crc16ccit`:
   \   00000000   0x00001021         DC32 4129, 65535
   \              0x0000FFFF   
   \   00000008   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    216          

   \                                 In section .text, align 2, keep-with-next
    217          void CRC_WriteData(CRC_Type *base, const uint8_t *data, size_t dataSize)
    218          {
   \                     CRC_WriteData: (+1)
   \   00000000   0xE003             B.N      ??CRC_WriteData_0
    219              const uint32_t *data32;
    220          
    221              /* 8-bit reads and writes till source address is aligned 4 bytes */
    222              while ((dataSize) && ((uint32_t)data & 3U))
    223              {
    224                  base->ACCESS8BIT.DATALL = *data;
   \                     ??CRC_WriteData_1: (+1)
   \   00000002   0xF811 0x3B01      LDRB     R3,[R1], #+1
   \   00000006   0x7003             STRB     R3,[R0, #+0]
    225                  data++;
    226                  dataSize--;
   \   00000008   0x1E52             SUBS     R2,R2,#+1
    227              }
   \                     ??CRC_WriteData_0: (+1)
   \   0000000A   0xB13A             CBZ.N    R2,??CRC_WriteData_2
   \   0000000C   0xF011 0x0303      ANDS     R3,R1,#0x3
   \   00000010   0xD1F7             BNE.N    ??CRC_WriteData_1
    228          
    229              /* use 32-bit reads and writes as long as possible */
    230              data32 = (const uint32_t *)data;
   \   00000012   0xE003             B.N      ??CRC_WriteData_2
    231              while (dataSize >= sizeof(uint32_t))
    232              {
    233                  base->DATA = *data32;
   \                     ??CRC_WriteData_3: (+1)
   \   00000014   0xF851 0x3B04      LDR      R3,[R1], #+4
   \   00000018   0x6003             STR      R3,[R0, #+0]
    234                  data32++;
    235                  dataSize -= sizeof(uint32_t);
   \   0000001A   0x1F12             SUBS     R2,R2,#+4
    236              }
   \                     ??CRC_WriteData_2: (+1)
   \   0000001C   0x2A04             CMP      R2,#+4
   \   0000001E   0xD2F9             BCS.N    ??CRC_WriteData_3
    237          
    238              data = (const uint8_t *)data32;
   \   00000020   0x2A00             CMP      R2,#+0
   \   00000022   0xE003             B.N      ??CRC_WriteData_4
    239          
    240              /* 8-bit reads and writes till end of data buffer */
    241              while (dataSize)
    242              {
    243                  base->ACCESS8BIT.DATALL = *data;
   \                     ??CRC_WriteData_5: (+1)
   \   00000024   0xF811 0x3B01      LDRB     R3,[R1], #+1
   \   00000028   0x7003             STRB     R3,[R0, #+0]
    244                  data++;
    245                  dataSize--;
   \   0000002A   0x1E52             SUBS     R2,R2,#+1
    246              }
   \                     ??CRC_WriteData_4: (+1)
   \   0000002C   0xD1FA             BNE.N    ??CRC_WriteData_5
    247          }
   \   0000002E   0x4770             BX       LR               ;; return
    248          

   \                                 In section .text, align 2, keep-with-next
    249          uint16_t CRC_Get16bitResult(CRC_Type *base)
    250          {
    251              uint32_t retval;
    252              uint32_t totr; /* type of transpose read bitfield */
    253          
    254              retval = base->DATA;
   \                     CRC_Get16bitResult: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
    255              totr = (base->CTRL & CRC_CTRL_TOTR_MASK) >> CRC_CTRL_TOTR_SHIFT;
   \   00000002   0x6880             LDR      R0,[R0, #+8]
    256          
    257              /* check transpose type to get 16-bit out of 32-bit register */
    258              if (totr >= 2U)
   \   00000004   0xF3C0 0x7001      UBFX     R0,R0,#+28,#+2
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xBF2C             ITE      CS 
   \   0000000C   0x0C08             LSRCS    R0,R1,#+16
   \   0000000E   0xB288             UXTHCC   R0,R1
    259              {
    260                  /* transpose of bytes for read is set, the result CRC is in CRC_DATA[HU:HL] */
    261                  retval &= 0xFFFF0000U;
    262                  retval = retval >> 16U;
    263              }
    264              else
    265              {
    266                  /* no transpose of bytes for read, the result CRC is in CRC_DATA[LU:LL] */
    267                  retval &= 0x0000FFFFU;
   \   00000010   0x4770             BX       LR
    268              }
    269              return (uint16_t)retval;
    270          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x4004803C         DC32     0x4004803c

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CRC_Get16bitResult
       0   CRC_GetDefaultConfig
         0   -> __aeabi_memcpy4
      16   CRC_Init
        16   -> crc_ConfigureAndStart
       0   CRC_WriteData
       0   crc_ConfigureAndStart


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
      18  CRC_Get16bitResult
      10  CRC_GetDefaultConfig
      94  CRC_Init
      48  CRC_WriteData
      16  crc16ccit
      50  crc_ConfigureAndStart

 
 240 bytes in section .text
 
 240 bytes of CODE memory

Errors: none
Warnings: none
