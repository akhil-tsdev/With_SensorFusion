###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Aug/2016  13:15:53
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\memory\src\flash_memory.c
#    Command line =  
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\memory\src\flash_memory.c"
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN256VDC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D BL_TARGET_RAM -lC
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj"
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices/MK22F25612\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/autobaud\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/osa\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device/class\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/bm_usb\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/CMSIS/Include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers/common\"
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list\flash_memory.lst
#    Object file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj\flash_memory.o
#
###############################################################################

C:\Users\cwati\Documents\My Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\memory\src\flash_memory.c
      1          /*
      2           * Copyright (c) 2013-2016, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "bootloader_common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void debug_printf(char const *, ...)
   \                     debug_printf: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB500             PUSH     {LR}
   \   00000004   0xA901             ADD      R1,SP,#+4
   \   00000006   0x.... 0x....      BL       vprintf
   \   0000000A   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
     32          #include "memory/memory.h"
     33          #include "flash_memory.h"
     34          #include "normal_memory.h"
     35          #include "flash/fsl_flash.h"
     36          #include "bootloader/bl_context.h"
     37          #include "fsl_device_registers.h"
     38          #include "utilities/fsl_rtos_abstraction.h"
     39          #include "utilities/fsl_assert.h"
     40          #include <string.h>
     41          
     42          ////////////////////////////////////////////////////////////////////////////////
     43          // Definitions
     44          ////////////////////////////////////////////////////////////////////////////////
     45          
     46          // If the bootloader is running from flash, then we need to make sure that all
     47          // interrupts are disabled during the execution of a flash operation, so that
     48          // no code is unexpectedly run from flash (which would cause a hard fault).
     49          //
     50          // If we're running from ROM or RAM, then we neither need to nor want to disable
     51          // interrupts during flash operations.
     52          #if !BL_TARGET_FLASH
     53          #define flash_lock_release() (void)sizeof(0)
     54          #define flash_lock_acquire() (void)sizeof(0)
     55          #endif // BL_TARGET_FLASH
     56          
     57          //! @brief Flash Memory constants.
     58          enum _flash_memory_constants
     59          {
     60              kFlashMemory_ErasedValue = ~0
     61          };
     62          
     63          #if BL_IS_FLASH_SECTION_PROGRAMMING_ENABLED
     64          //! @brief FLASH section program memory context
     65          //!
     66          //! An instance is maintained in this file, will is used to keep key information for write and flush
     67          //! operatations.
     68          typedef struct _flash_section_program_info
     69          {
     70              uint32_t startAddress;                      //!< This address is used to record the address which is used
     71                                                          //!< to write the whole section into flash memory
     72              uint32_t storedBytes;                       //!< A variable which is used to indicate if the buffer is full.
     73              uint8_t buffer[kFLASH_AccelerationRamSize]; //!< A buffer which is used to buffer a full section of data
     74          } flash_section_program_info_t;
     75          
     76          flash_section_program_info_t s_flash_section_program_info = { 0 };
     77          #endif
     78          
     79          ////////////////////////////////////////////////////////////////////////////////
     80          // Variables
     81          ////////////////////////////////////////////////////////////////////////////////
     82          
     83          //! @brief Interface to flash memory operations.

   \                                 In section .rodata, align 4, keep-with-next
     84          const memory_region_interface_t g_flashMemoryInterface = {
   \                     g_flashMemoryInterface:
   \   00000000   0x........         DC32 flash_mem_init, flash_mem_read, flash_mem_write, flash_mem_fill
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000010   0x00000000         DC32 0H, flash_mem_erase
   \              0x........   
     85              .init = &flash_mem_init,
     86              .read = &flash_mem_read,
     87              .write = &flash_mem_write,
     88          #if !BL_FEATURE_MIN_PROFILE || BL_FEATURE_FILL_MEMORY
     89              .fill = &flash_mem_fill,
     90          #endif // !BL_FEATURE_MIN_PROFILE
     91          #if BL_IS_FLASH_SECTION_PROGRAMMING_ENABLED
     92              .flush = flash_mem_flush,
     93          #else
     94              .flush = NULL,
     95          #endif
     96              .erase = flash_mem_erase,
     97          };
     98          
     99          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    100          //! @brief It is used for indicating if an XA controlled region is unlocked to program state

   \                                 In section .bss, align 1
    101          bool isFlashRegionUnlocked = false;
   \                     isFlashRegionUnlocked:
   \   00000000                      DS8 1
    102          #endif // FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    103          
    104          #if BL_TARGET_FLASH
    105          static uint32_t s_regPrimask = 0U;
    106          #endif
    107          
    108          ////////////////////////////////////////////////////////////////////////////////
    109          // Prototypes
    110          ////////////////////////////////////////////////////////////////////////////////
    111          //! @brief check if a flash region is in an XA controlled region or contains an XA controlled region.
    112          //         and try to open flash program state by calling verify_erase_all command if needed.
    113          status_t flash_preprocess_execute_only_region(uint32_t address,
    114                                                        uint32_t length,
    115                                                        flash_execute_only_access_state_t *state);
    116          
    117          status_t flash_check_access_before_programming(uint32_t address, uint32_t length, bool *verifyWrites);
    118          
    119          ////////////////////////////////////////////////////////////////////////////////
    120          // Code
    121          ////////////////////////////////////////////////////////////////////////////////
    122          
    123          #if BL_TARGET_FLASH
    124          static void flash_lock_acquire(void)
    125          {
    126              // Ensure that the program operation cannots be interrupted.
    127              s_regPrimask = __get_PRIMASK();
    128              __disable_irq();
    129          }
    130          
    131          static void flash_lock_release(void)
    132          {
    133              // Release lock after the write operation completes.
    134              __set_PRIMASK(s_regPrimask);
    135          }
    136          #endif
    137          
    138          // See flash_memory.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    139          status_t flash_mem_init(void)
    140          {
   \                     flash_mem_init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    141              // Update address range of flash
    142              memory_map_entry_t *map = (memory_map_entry_t *)&g_bootloaderContext.memoryMap[kIndexFlashArray];
   \   00000002   0x....             LDR.N    R5,??DataTable11
    143              g_bootloaderContext.flashDriverInterface->flash_get_property(
    144                  &g_bootloaderContext.flashState, kFLASH_PropertyPflashBlockBaseAddr, &map->startAddress);
   \   00000004   0x692B             LDR      R3,[R5, #+16]
   \   00000006   0x686C             LDR      R4,[R5, #+4]
   \   00000008   0x6ADB             LDR      R3,[R3, #+44]
   \   0000000A   0x4622             MOV      R2,R4
   \   0000000C   0x2104             MOVS     R1,#+4
   \   0000000E   0xF105 0x0020      ADD      R0,R5,#+32
   \   00000012   0x4798             BLX      R3
    145              uint32_t tmp;
    146              g_bootloaderContext.flashDriverInterface->flash_get_property(&g_bootloaderContext.flashState,
    147                                                                           kFLASH_PropertyPflashTotalSize, &tmp);
   \   00000014   0x692B             LDR      R3,[R5, #+16]
   \   00000016   0x6ADB             LDR      R3,[R3, #+44]
   \   00000018   0x466A             MOV      R2,SP
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0xF105 0x0020      ADD      R0,R5,#+32
   \   00000020   0x4798             BLX      R3
    148              map->endAddress = map->startAddress + tmp - 1;
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x9900             LDR      R1,[SP, #+0]
   \   00000026   0x1808             ADDS     R0,R1,R0
   \   00000028   0x1E40             SUBS     R0,R0,#+1
   \   0000002A   0x6060             STR      R0,[R4, #+4]
    149          
    150          #if BL_IS_FLASH_SECTION_PROGRAMMING_ENABLED
    151              s_flash_section_program_info.storedBytes = 0;
    152          #endif
    153          
    154              return kStatus_Success;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    155          }
    156          
    157          // See flash_memory.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    158          status_t flash_mem_read(uint32_t address, uint32_t length, uint8_t *restrict buffer)
    159          {
   \                     flash_mem_read: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    160          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    161              flash_execute_only_access_state_t access_state;
    162              uint32_t alignedAddress = ALIGN_DOWN(address, g_bootloaderContext.flashState.PFlashAccessSegmentSize);
   \   00000002   0x....             LDR.N    R7,??DataTable11
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x6B78             LDR      R0,[R7, #+52]
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4240             RSBS     R0,R0,#+0
   \   0000000C   0x4616             MOV      R6,R2
   \   0000000E   0xEA00 0x0104      AND      R1,R0,R4
    163              uint32_t updatedLength = address - alignedAddress + length;
    164              uint32_t alignedLength = ALIGN_UP(updatedLength, g_bootloaderContext.flashState.PFlashAccessSegmentSize);
    165              status_t status = g_bootloaderContext.flashDriverInterface->flash_is_execute_only(
    166                  &g_bootloaderContext.flashState, alignedAddress, alignedLength, &access_state);
   \   00000012   0x1A62             SUBS     R2,R4,R1
   \   00000014   0x18AA             ADDS     R2,R5,R2
   \   00000016   0x4252             RSBS     R2,R2,#+0
   \   00000018   0x4010             ANDS     R0,R0,R2
   \   0000001A   0x4242             RSBS     R2,R0,#+0
   \   0000001C   0xF107 0x0020      ADD      R0,R7,#+32
   \   00000020   0x693F             LDR      R7,[R7, #+16]
   \   00000022   0x6C7F             LDR      R7,[R7, #+68]
   \   00000024   0x466B             MOV      R3,SP
   \   00000026   0x47B8             BLX      R7
    167              if (status != kStatus_Success)
   \   00000028   0xB948             CBNZ.N   R0,??flash_mem_read_0
    168              {
    169                  return status;
    170              }
    171          
    172              if (access_state != kFLASH_AccessStateUnLimited)
   \   0000002A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002E   0xB108             CBZ.N    R0,??flash_mem_read_1
    173              {
    174                  return kStatus_FLASH_RegionExecuteOnly;
   \   00000030   0x206C             MOVS     R0,#+108
   \   00000032   0xBDF2             POP      {R1,R4-R7,PC}
    175              }
    176          #endif // FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    177          
    178              return normal_mem_read(address, length, buffer);
   \                     ??flash_mem_read_1: (+1)
   \   00000034   0x4632             MOV      R2,R6
   \   00000036   0x4629             MOV      R1,R5
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       normal_mem_read
   \                     ??flash_mem_read_0: (+1)
   \   0000003E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    179          }
    180          
    181          #if !BL_IS_FLASH_SECTION_PROGRAMMING_ENABLED
    182          // See flash_memory.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    183          status_t flash_mem_write(uint32_t address, uint32_t length, const uint8_t *buffer)
    184          {
   \                     flash_mem_write: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   \   00000006   0x4691             MOV      R9,R2
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0x460F             MOV      R7,R1
    185              // Note: the check for "length != 0" and "range not in reserved region" is done in mem_write().
    186              assert(length);
    187              assert(buffer);
    188          
    189              status_t status = kStatus_Success;
    190              uint32_t alignedLength;
    191              uint32_t extraBytes;
    192              uint32_t extraData[2];
    193          
    194              assert(sizeof(extraData) >= sizeof(uint8_t) * FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
    195          
    196              bool verifyWrites;
    197              status = flash_check_access_before_programming(address, length, &verifyWrites);
   \   0000000C   0xAA03             ADD      R2,SP,#+12
   \   0000000E   0x.... 0x....      BL       flash_check_access_before_programming
   \   00000012   0xEA5F 0x0A00      MOVS     R10,R0
    198              if (status != kStatus_Success)
   \   00000016   0xD12D             BNE.N    ??flash_mem_write_0
    199              {
    200                  return status;
    201              }
    202          
    203              // Align length to whole words.
    204              alignedLength = ALIGN_DOWN(length, sizeof(uint8_t) * FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
   \   00000018   0x08BE             LSRS     R6,R7,#+2
   \   0000001A   0x00B6             LSLS     R6,R6,#+2
    205              extraBytes = length - alignedLength;
   \   0000001C   0x1BBF             SUBS     R7,R7,R6
    206              assert(extraBytes < sizeof(uint8_t) * FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
    207          
    208              // Pre-fill word buffer with flash erased value.
    209              extraData[0] = (uint32_t)kFlashMemory_ErasedValue;
   \   0000001E   0xF04F 0x30FF      MOV      R0,#-1
   \   00000022   0x9006             STR      R0,[SP, #+24]
    210              extraData[1] = (uint32_t)kFlashMemory_ErasedValue;
   \   00000024   0x9007             STR      R0,[SP, #+28]
    211              if (extraBytes)
   \   00000026   0xD005             BEQ.N    ??flash_mem_write_1
    212              {
    213                  // Copy extra bytes to word buffer.
    214                  memcpy((uint8_t *)extraData, &buffer[alignedLength], extraBytes);
   \   00000028   0x463A             MOV      R2,R7
   \   0000002A   0xEB09 0x0106      ADD      R1,R9,R6
   \   0000002E   0xA806             ADD      R0,SP,#+24
   \   00000030   0x.... 0x....      BL       __aeabi_memcpy
    215              }
    216          
    217              flash_lock_acquire();
    218              // Program whole words from the user's buffer.
    219              if (alignedLength)
   \                     ??flash_mem_write_1: (+1)
   \   00000034   0xEB06 0x0804      ADD      R8,R6,R4
   \   00000038   0x....             LDR.N    R5,??DataTable11
   \   0000003A   0xB166             CBZ.N    R6,??flash_mem_write_2
    220              {
    221                  status = g_bootloaderContext.flashDriverInterface->flash_program(&g_bootloaderContext.flashState, address,
    222                                                                                   (uint32_t *)buffer, alignedLength);
   \   0000003C   0xF8D5 0xC010      LDR      R12,[R5, #+16]
   \   00000040   0xF8DC 0xC014      LDR      R12,[R12, #+20]
   \   00000044   0x4633             MOV      R3,R6
   \   00000046   0x464A             MOV      R2,R9
   \   00000048   0x4621             MOV      R1,R4
   \   0000004A   0xF105 0x0020      ADD      R0,R5,#+32
   \   0000004E   0x47E0             BLX      R12
   \   00000050   0xEA5F 0x0A00      MOVS     R10,R0
    223              }
    224              if ((status == kStatus_Success) && extraBytes)
   \   00000054   0xD10B             BNE.N    ??flash_mem_write_3
   \                     ??flash_mem_write_2: (+1)
   \   00000056   0xB17F             CBZ.N    R7,??flash_mem_write_4
    225              {
    226                  // Program trailing word.
    227                  status = g_bootloaderContext.flashDriverInterface->flash_program(
    228                      &g_bootloaderContext.flashState, address + alignedLength, extraData,
    229                      (uint32_t)FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
   \   00000058   0xF8D5 0xC010      LDR      R12,[R5, #+16]
   \   0000005C   0xF8DC 0xC014      LDR      R12,[R12, #+20]
   \   00000060   0x2304             MOVS     R3,#+4
   \   00000062   0xAA06             ADD      R2,SP,#+24
   \   00000064   0x4641             MOV      R1,R8
   \   00000066   0xF105 0x0020      ADD      R0,R5,#+32
   \   0000006A   0x47E0             BLX      R12
   \   0000006C   0x4682             MOV      R10,R0
    230              }
    231              flash_lock_release();
    232              if (status != kStatus_Success)
   \                     ??flash_mem_write_3: (+1)
   \   0000006E   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000072   0xD001             BEQ.N    ??flash_mem_write_4
    233              {
    234                  return status;
   \                     ??flash_mem_write_0: (+1)
   \   00000074   0x4650             MOV      R0,R10
   \   00000076   0xE028             B.N      ??flash_mem_write_5
    235              }
    236          
    237          #if !BL_FEATURE_FLASH_VERIFY_DISABLE
    238              if (verifyWrites)
   \                     ??flash_mem_write_4: (+1)
   \   00000078   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   0000007C   0xB320             CBZ.N    R0,??flash_mem_write_6
    239              {
    240                  uint32_t failedAddress;
    241                  uint32_t failedData;
    242          
    243                  flash_lock_acquire();
    244                  if (alignedLength)
   \   0000007E   0xB16E             CBZ.N    R6,??flash_mem_write_7
    245                  {
    246                      status = g_bootloaderContext.flashDriverInterface->flash_verify_program(
    247                          &g_bootloaderContext.flashState, address, alignedLength, (uint32_t *)buffer,
    248                          (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin, &failedAddress,
    249                          &failedData);
   \   00000080   0xA805             ADD      R0,SP,#+20
   \   00000082   0x9002             STR      R0,[SP, #+8]
   \   00000084   0x4621             MOV      R1,R4
   \   00000086   0xA804             ADD      R0,SP,#+16
   \   00000088   0x9001             STR      R0,[SP, #+4]
   \   0000008A   0x464B             MOV      R3,R9
   \   0000008C   0x.... 0x....      BL       ?Subroutine0
    250                  }
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000090   0x4632             MOV      R2,R6
   \   00000092   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000096   0xEA5F 0x0A00      MOVS     R10,R0
    251                  if ((status == kStatus_Success) && extraBytes)
   \   0000009A   0xD10C             BNE.N    ??flash_mem_write_8
   \                     ??flash_mem_write_7: (+1)
   \   0000009C   0xB1A7             CBZ.N    R7,??flash_mem_write_6
    252                  {
    253                      status = g_bootloaderContext.flashDriverInterface->flash_verify_program(
    254                          &g_bootloaderContext.flashState, address + alignedLength, sizeof(extraData), extraData,
    255                          (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin, &failedAddress,
    256                          &failedData);
   \   0000009E   0xA805             ADD      R0,SP,#+20
   \   000000A0   0x9002             STR      R0,[SP, #+8]
   \   000000A2   0xAB06             ADD      R3,SP,#+24
   \   000000A4   0xA804             ADD      R0,SP,#+16
   \   000000A6   0x9001             STR      R0,[SP, #+4]
   \   000000A8   0x2208             MOVS     R2,#+8
   \   000000AA   0x.... 0x....      BL       ?Subroutine0
    257                  }
   \                     ??CrossCallReturnLabel_1: (+1)
   \   000000AE   0x4641             MOV      R1,R8
   \   000000B0   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_4: (+1)
   \   000000B4   0x4682             MOV      R10,R0
    258                  flash_lock_release();
    259                  if (status != kStatus_Success)
   \                     ??flash_mem_write_8: (+1)
   \   000000B6   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000BA   0xD005             BEQ.N    ??flash_mem_write_6
    260                  {
    261                      debug_printf("Error: flash verify failed at address: 0x%x\r\n", failedAddress);
   \   000000BC   0x9904             LDR      R1,[SP, #+16]
   \   000000BE   0x.... 0x....      ADR.W    R0,?_0
   \   000000C2   0x.... 0x....      BL       debug_printf
   \   000000C6   0xE7D5             B.N      ??flash_mem_write_0
    262                      return status;
    263                  }
    264              }
    265          #endif // !BL_FEATURE_FLASH_VERIFY_DISABLE
    266          
    267              return kStatus_Success;
   \                     ??flash_mem_write_6: (+1)
   \   000000C8   0x2000             MOVS     R0,#+0
   \                     ??flash_mem_write_5: (+1)
   \   000000CA   0xB008             ADD      SP,SP,#+32
   \   000000CC   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    268          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x692C             LDR      R4,[R5, #+16]
   \   00000002   0x6AA4             LDR      R4,[R4, #+40]
   \   00000004   0xF105 0x0020      ADD      R0,R5,#+32
   \   00000008   0x4720             BX       R4

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x68A8             LDR      R0,[R5, #+8]
   \   00000002   0x6900             LDR      R0,[R0, #+16]
   \   00000004   0x6D00             LDR      R0,[R0, #+80]
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   \   0000000A   0x4770             BX       LR
    269          
    270          // See flash_memory.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    271          status_t flash_mem_fill(uint32_t address, uint32_t length, uint32_t pattern)
    272          {
   \                     flash_mem_fill: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB088             SUB      SP,SP,#+32
   \   00000006   0x460D             MOV      R5,R1
    273              // Note: the check for "length != 0"
    274              assert(length);
    275          
    276              status_t status = kStatus_Success;
    277              uint32_t patternBuffer[8];
    278          
    279              // Pre-fill pattern buffer with pattern.
    280              for (uint32_t i = 0; i < 8; i++)
   \   00000008   0x2000             MOVS     R0,#+0
    281              {
    282                  patternBuffer[i] = pattern;
   \                     ??flash_mem_fill_0: (+1)
   \   0000000A   0xF84D 0x2020      STR      R2,[SP, R0, LSL #+2]
    283              }
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xD3FA             BCC.N    ??flash_mem_fill_0
    284          
    285              // Program patterns from the pattern buffer.
    286              while (length)
   \                     ??flash_mem_fill_1: (+1)
   \   00000014   0xB175             CBZ.N    R5,??flash_mem_fill_2
    287              {
    288                  uint32_t bytes;
    289                  if (length < sizeof(patternBuffer))
   \   00000016   0x2620             MOVS     R6,#+32
   \   00000018   0x2D20             CMP      R5,#+32
   \   0000001A   0xBF98             IT       LS 
   \   0000001C   0x462E             MOVLS    R6,R5
    290                  {
    291                      bytes = length;
    292                  }
    293                  else
    294                  {
    295                      bytes = sizeof(patternBuffer);
    296                  }
    297          
    298                  status = flash_mem_write(address, bytes, (uint8_t *)patternBuffer);
   \   0000001E   0x466A             MOV      R2,SP
   \   00000020   0x4631             MOV      R1,R6
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       flash_mem_write
    299                  if (status != kStatus_Success)
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xBF04             ITT      EQ 
   \   0000002C   0x1934             ADDEQ    R4,R6,R4
   \   0000002E   0x1BAD             SUBEQ    R5,R5,R6
    300                  {
    301                      return status;
    302                  }
    303          
    304                  address += bytes;
    305                  length -= bytes;
   \   00000030   0xD0F0             BEQ.N    ??flash_mem_fill_1
   \   00000032   0xE000             B.N      ??flash_mem_fill_3
    306              }
    307          
    308              return kStatus_Success;
   \                     ??flash_mem_fill_2: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??flash_mem_fill_3: (+1)
   \   00000036   0xB008             ADD      SP,SP,#+32
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
    309          }
    310          
    311          #else // BL_IS_FLASH_SECTION_PROGRAMMING_ENABLED
    312          
    313          // See flash_memory.h for documentation on this function.
    314          status_t flash_mem_write(uint32_t address, uint32_t length, const uint8_t *buffer)
    315          {
    316              // Note: the check for "length != 0" and "range not in reserved region" is done in mem_write().
    317              assert(length);
    318              assert(buffer);
    319          
    320              status_t status = kStatus_Success;
    321          
    322              while (length)
    323              {
    324                  // Set start address when storing first byte into section program buffer
    325                  if ((!s_flash_section_program_info.storedBytes) && (!s_flash_section_program_info.startAddress))
    326                  {
    327                      // Check address alignment
    328                      if (address & (FSL_FEATURE_FLASH_PFLASH_SECTION_CMD_ADDRESS_ALIGMENT - 1))
    329                      {
    330                          return kStatus_FLASH_AlignmentError;
    331                      }
    332                      s_flash_section_program_info.startAddress = address;
    333                  }
    334                  else
    335                  {
    336                      // Start section programming operation when meet discontinuous address
    337                      if ((s_flash_section_program_info.startAddress + s_flash_section_program_info.storedBytes) != address)
    338                      {
    339                          // flush cached data into target memory,
    340                          status = flash_mem_flush();
    341                          if (status != kStatus_Success)
    342                          {
    343                              return status;
    344                          }
    345                          continue;
    346                      }
    347                  }
    348          
    349                  uint32_t storeBytes;
    350                  // Check to see if section program buffer will be filled with current data packet
    351                  if ((s_flash_section_program_info.storedBytes + length) <= sizeof(s_flash_section_program_info.buffer))
    352                  {
    353                      storeBytes = length;
    354                  }
    355                  else
    356                  {
    357                      storeBytes = sizeof(s_flash_section_program_info.buffer) - s_flash_section_program_info.storedBytes;
    358                  }
    359          
    360                  // Copy data to section program buffer
    361                  if (buffer != &s_flash_section_program_info.buffer[s_flash_section_program_info.storedBytes])
    362                  {
    363                      memcpy(&s_flash_section_program_info.buffer[s_flash_section_program_info.storedBytes], buffer, storeBytes);
    364                  }
    365          
    366                  s_flash_section_program_info.storedBytes += storeBytes;
    367                  buffer += storeBytes;
    368                  address += storeBytes;
    369                  length -= storeBytes;
    370          
    371                  // Start section programming operation when section program buffer is full
    372                  if (s_flash_section_program_info.storedBytes == sizeof(s_flash_section_program_info.buffer))
    373                  {
    374                      // flush cached data into target memory,
    375                      status = flash_mem_flush();
    376                      if (status != kStatus_Success)
    377                      {
    378                          return status;
    379                      }
    380                  }
    381              }
    382          
    383              return kStatus_Success;
    384          }
    385          
    386          // See flash_memory.h for documentation on this function.
    387          status_t flash_mem_fill(uint32_t address, uint32_t length, uint32_t pattern)
    388          {
    389              // Note: the check for "length != 0" and "range not in reserved region" is done in mem_fill().
    390              assert(length);
    391          
    392              status_t status;
    393          
    394              // Pre-fill section program buffer with pattern
    395              uint32_t *buffer = (uint32_t *)s_flash_section_program_info.buffer;
    396              uint32_t maxPatterns = sizeof(s_flash_section_program_info.buffer) >> 2;
    397              for (uint32_t i = 0; i < maxPatterns; i++)
    398              {
    399                  *buffer++ = pattern;
    400              }
    401          
    402              while (length)
    403              {
    404                  uint32_t bytes;
    405          
    406                  s_flash_section_program_info.storedBytes = 0;
    407          
    408                  // Check to see if remaining address range can hold whole section program buffer
    409                  if (length < sizeof(s_flash_section_program_info.buffer))
    410                  {
    411                      bytes = length;
    412                  }
    413                  else
    414                  {
    415                      bytes = sizeof(s_flash_section_program_info.buffer);
    416                  }
    417          
    418                  // flush cached data into target memory,
    419                  status = flash_mem_write(address, bytes, s_flash_section_program_info.buffer);
    420                  if (status != kStatus_Success)
    421                  {
    422                      return status;
    423                  }
    424          
    425                  address += bytes;
    426                  length -= bytes;
    427              }
    428          
    429              // flush cached data into target memory,
    430              status = flash_mem_flush();
    431              if (status != kStatus_Success)
    432              {
    433                  return status;
    434              }
    435          
    436              return kStatus_Success;
    437          }
    438          
    439          // See memory.h for documentation on this function.
    440          status_t flash_mem_flush(void)
    441          {
    442              status_t status = kStatus_Success;
    443          
    444              if (s_flash_section_program_info.storedBytes)
    445              {
    446                  uint32_t address = s_flash_section_program_info.startAddress;
    447                  uint32_t length = s_flash_section_program_info.storedBytes;
    448          
    449                  // Clear related states no matter following operations are executed successfully or not.
    450                  s_flash_section_program_info.startAddress = 0;
    451                  s_flash_section_program_info.storedBytes = 0;
    452          
    453                  // Align length to section program unit
    454                  uint32_t alignedLength = ALIGN_UP(length, (uint32_t)FSL_FEATURE_FLASH_PFLASH_SECTION_CMD_ADDRESS_ALIGMENT);
    455          
    456                  bool verifyWrites;
    457                  status = flash_check_access_before_programming(address, length, &verifyWrites);
    458                  if (status != kStatus_Success)
    459                  {
    460                      return status;
    461                  }
    462          
    463                  // Fill unused region with oxFFs.
    464                  assert(length <= sizeof(s_flash_section_program_info.buffer));
    465                  if (length < alignedLength)
    466                  {
    467                      memset(&s_flash_section_program_info.buffer[length], 0xFF, alignedLength - length);
    468                  }
    469          
    470                  flash_lock_acquire();
    471                  // Write data of aligned length to flash
    472                  status = FLASH_ProgramSection(&g_bootloaderContext.flashState, address,
    473                                                (uint32_t *)s_flash_section_program_info.buffer, alignedLength);
    474                  flash_lock_release();
    475          
    476                  if (status != kStatus_Success)
    477                  {
    478                      return status;
    479                  }
    480          
    481          // Verify wether the data has been programmed to flash successfully.
    482          #if !BL_FEATURE_FLASH_VERIFY_DISABLE
    483                  // Verify flash program
    484                  if (verifyWrites)
    485                  {
    486                      uint32_t failedAddress;
    487                      uint32_t failedData;
    488          
    489                      flash_lock_acquire();
    490                      status = g_bootloaderContext.flashDriverInterface->flash_verify_program(
    491                          &g_bootloaderContext.flashState, address, alignedLength,
    492                          (uint32_t *)&s_flash_section_program_info.buffer,
    493                          (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin, &failedAddress,
    494                          &failedData);
    495                      flash_lock_release();
    496                      if (status != kStatus_Success)
    497                      {
    498                          debug_printf("Error: flash verify failed at address: 0x%x\r\n", failedAddress);
    499                          return status;
    500                      }
    501                  }
    502          #endif // !BL_FEATURE_FLASH_VERIFY_DISABLE
    503              }
    504          
    505              return status;
    506          }
    507          #endif // !BL_IS_FLASH_SECTION_PROGRAMMING_ENABLED
    508          
    509          // See memory.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    510          status_t flash_mem_erase(uint32_t address, uint32_t length)
    511          {
   \                     flash_mem_erase: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    512              status_t status;
    513          
    514              flash_lock_acquire();
    515              status = g_bootloaderContext.flashDriverInterface->flash_erase(&g_bootloaderContext.flashState, address, length,
    516                                                                             kFLASH_ApiEraseKey);
   \   00000006   0x....             LDR.N    R6,??DataTable11
   \   00000008   0x....             LDR.N    R3,??DataTable11_1  ;; 0x6b65666b
   \   0000000A   0x6937             LDR      R7,[R6, #+16]
   \   0000000C   0x693F             LDR      R7,[R7, #+16]
   \   0000000E   0x462A             MOV      R2,R5
   \   00000010   0x4621             MOV      R1,R4
   \   00000012   0xF106 0x0020      ADD      R0,R6,#+32
   \   00000016   0x47B8             BLX      R7
   \   00000018   0x0007             MOVS     R7,R0
    517              flash_lock_release();
    518          
    519          #if !BL_FEATURE_FLASH_VERIFY_DISABLE
    520              if ((status == kStatus_Success) && (g_bootloaderContext.propertyInterface->store->verifyWrites))
   \   0000001A   0xD112             BNE.N    ??flash_mem_erase_0
   \   0000001C   0x68B0             LDR      R0,[R6, #+8]
   \   0000001E   0x6900             LDR      R0,[R0, #+16]
   \   00000020   0x6B01             LDR      R1,[R0, #+48]
   \   00000022   0xB171             CBZ.N    R1,??flash_mem_erase_0
    521              {
    522                  flash_lock_acquire();
    523                  status = g_bootloaderContext.flashDriverInterface->flash_verify_erase(
    524                      &g_bootloaderContext.flashState, address, length,
    525                      (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin);
   \   00000024   0x4621             MOV      R1,R4
   \   00000026   0x6934             LDR      R4,[R6, #+16]
   \   00000028   0x6D03             LDR      R3,[R0, #+80]
   \   0000002A   0x6A64             LDR      R4,[R4, #+36]
   \   0000002C   0xB2DB             UXTB     R3,R3
   \   0000002E   0x462A             MOV      R2,R5
   \   00000030   0xF106 0x0020      ADD      R0,R6,#+32
   \   00000034   0x47A0             BLX      R4
   \   00000036   0x0007             MOVS     R7,R0
    526                  flash_lock_release();
    527                  if (status != kStatus_Success)
   \   00000038   0xBF1C             ITT      NE 
    528                  {
    529                      debug_printf("Error: flash_verify_erase failed\r\n");
   \   0000003A   0x.... 0x....      ADRNE.W  R0,?_1
   \   0000003E   0x.... 0x....      BLNE     debug_printf
    530                      return status;
    531                  }
    532              }
    533          #endif // !BL_FEATURE_FLASH_VERIFY_DISABLE
    534          
    535              return status;
   \                     ??flash_mem_erase_0: (+1)
   \   00000042   0x4638             MOV      R0,R7
   \   00000044   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    536          }
    537          
    538          // See memory.h for documentation on this function.
    539          #if BL_FEATURE_FAC_ERASE
    540          status_t flash_mem_erase_all(flash_erase_all_option_t eraseOption)
    541          #else

   \                                 In section .text, align 2, keep-with-next
    542          status_t flash_mem_erase_all(void)
    543          #endif
    544          {
   \                     flash_mem_erase_all: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    545              status_t status = kStatus_Success;
    546          
    547          // Decompose the the flash erase all into two region erases.
    548          #if BL_TARGET_FLASH
    549              reserved_region_t *reservedRegion =
    550                  &g_bootloaderContext.propertyInterface->store->reservedRegions[kProperty_FlashReservedRegionIndex];
    551              const uint32_t eraseSize = g_bootloaderContext.propertyInterface->store->flashSectorSize;
    552          
    553          #if BL_FEATURE_FAC_ERASE
    554              if (eraseOption == kFlashEraseAllOption_ExecuteOnlySegments)
    555              {
    556                  uint32_t address = ALIGN_DOWN(reservedRegion->startAddress, eraseSize);
    557                  uint32_t length = ALIGN_UP(reservedRegion->endAddress, eraseSize) - address;
    558                  flash_execute_only_access_state_t access_state;
    559          
    560                  // If the reserved flash region is in an execute-only protected segment, then FAC erase command is not
    561                  // allowed
    562                  flash_lock_acquire();
    563                  status = flash_preprocess_execute_only_region(address, length, &access_state);
    564                  if (status != kStatus_Success)
    565                  {
    566                      flash_lock_release();
    567                      return status;
    568                  }
    569                  flash_lock_release();
    570          
    571                  if (access_state != kFLASH_AccessStateUnLimited)
    572                  {
    573                      return kStatusMemoryAppOverlapWithExecuteOnlyRegion;
    574                  }
    575              }
    576              else if (eraseOption == kFlashEraseAllOption_Blocks)
    577          #endif
    578              {
    579                  memory_map_entry_t *map = (memory_map_entry_t *)&g_bootloaderContext.memoryMap[kIndexFlashArray];
    580                  bool isReservedRegionEmpty =
    581                      (reservedRegion->startAddress == map->startAddress) && (reservedRegion->endAddress == map->startAddress);
    582                  if (!isReservedRegionEmpty)
    583                  {
    584                      // Erase the initial unreserved region, if any.
    585                      if (reservedRegion->startAddress > map->startAddress)
    586                      {
    587                          uint32_t length = ALIGN_DOWN(reservedRegion->startAddress, eraseSize);
    588                          if (length > 0)
    589                          {
    590                              status = flash_mem_erase(map->startAddress, length);
    591                          }
    592                      }
    593          
    594                      // Erase the final unreserved region, if any.
    595                      if (status == kStatus_Success)
    596                      {
    597                          uint32_t start = ALIGN_UP(reservedRegion->endAddress, eraseSize);
    598                          if (start < map->endAddress)
    599                          {
    600                              status = flash_mem_erase(start, (map->endAddress + 1) - start);
    601                          }
    602                      }
    603          
    604                      return status;
    605                  }
    606              }
    607          
    608          #endif // BL_TARGET_FLASH
    609          
    610              // Do full erase and verify.
    611          
    612              flash_lock_acquire();
    613          #if BL_FEATURE_FAC_ERASE
    614              if (eraseOption == kFlashEraseAllOption_ExecuteOnlySegments)
    615              {
    616                  status = g_bootloaderContext.flashDriverInterface->flash_erase_all_execute_only_segments(
    617                      &g_bootloaderContext.flashState, kFLASH_ApiEraseKey);
    618              }
    619              else if (eraseOption == kFlashEraseAllOption_Blocks)
    620          #endif
    621              {
    622                  status = g_bootloaderContext.flashDriverInterface->flash_erase_all(&g_bootloaderContext.flashState,
    623                                                                                     kFLASH_ApiEraseKey);
   \   00000002   0x....             LDR.N    R4,??DataTable11
   \   00000004   0x....             LDR.N    R1,??DataTable11_1  ;; 0x6b65666b
   \   00000006   0x6922             LDR      R2,[R4, #+16]
   \   00000008   0x6892             LDR      R2,[R2, #+8]
   \   0000000A   0xF104 0x0020      ADD      R0,R4,#+32
   \   0000000E   0x4790             BLX      R2
   \   00000010   0x0005             MOVS     R5,R0
    624              }
    625              flash_lock_release();
    626          
    627          #if !BL_FEATURE_FLASH_VERIFY_DISABLE
    628              if ((status == kStatus_Success) && (g_bootloaderContext.propertyInterface->store->verifyWrites))
   \   00000012   0xD10F             BNE.N    ??flash_mem_erase_all_0
   \   00000014   0x68A0             LDR      R0,[R4, #+8]
   \   00000016   0x6900             LDR      R0,[R0, #+16]
   \   00000018   0x6B01             LDR      R1,[R0, #+48]
   \   0000001A   0xB141             CBZ.N    R1,??flash_mem_erase_all_1
    629              {
    630                  flash_lock_acquire();
    631          #if BL_FEATURE_FAC_ERASE
    632                  if (eraseOption == kFlashEraseAllOption_ExecuteOnlySegments)
    633                  {
    634                      status = g_bootloaderContext.flashDriverInterface->flash_verify_erase_all_execute_only_segments(
    635                          &g_bootloaderContext.flashState,
    636                          (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin);
    637                  }
    638                  else if (eraseOption == kFlashEraseAllOption_Blocks)
    639          #endif
    640                  {
    641                      status = g_bootloaderContext.flashDriverInterface->flash_verify_erase_all(
    642                          &g_bootloaderContext.flashState,
    643                          (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin);
   \   0000001C   0x.... 0x....      BL       ?Subroutine1
    644                  }
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000020   0x0005             MOVS     R5,R0
    645                  flash_lock_release();
    646                  if (status != kStatus_Success)
   \   00000022   0xD004             BEQ.N    ??flash_mem_erase_all_1
    647                  {
    648                      debug_printf("Error: flash_verify_erase_all/all_execute_only_segments failed\r\n");
   \   00000024   0x.... 0x....      ADR.W    R0,?_2
   \   00000028   0x.... 0x....      BL       debug_printf
    649                      return status;
   \   0000002C   0xE002             B.N      ??flash_mem_erase_all_0
    650                  }
    651              }
    652          #endif // !BL_FEATURE_FLASH_VERIFY_DISABLE
    653          
    654          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    655              if (status == kStatus_Success)
    656              {
    657                  isFlashRegionUnlocked = true;
   \                     ??flash_mem_erase_all_1: (+1)
   \   0000002E   0x....             LDR.N    R1,??DataTable11_2
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x7008             STRB     R0,[R1, #+0]
    658              }
    659          #endif // FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    660          
    661              return status;
   \                     ??flash_mem_erase_all_0: (+1)
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    662          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x6922             LDR      R2,[R4, #+16]
   \   00000002   0x6D01             LDR      R1,[R0, #+80]
   \   00000004   0x6A12             LDR      R2,[R2, #+32]
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0xF104 0x0020      ADD      R0,R4,#+32
   \   0000000C   0x4710             BX       R2
    663          
    664          // See memory.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    665          status_t flash_mem_erase_all_unsecure(void)
    666          {
    667              status_t status;
    668          
    669              flash_lock_acquire();
    670              status = g_bootloaderContext.flashDriverInterface->flash_erase_all_unsecure(&g_bootloaderContext.flashState,
    671                                                                                          kFLASH_ApiEraseKey);
    672              flash_lock_release();
    673          
    674              return status;
   \                     flash_mem_erase_all_unsecure: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable11
   \   00000002   0x....             LDR.N    R1,??DataTable11_1  ;; 0x6b65666b
   \   00000004   0xF102 0x0020      ADD      R0,R2,#+32
   \   00000008   0x6912             LDR      R2,[R2, #+16]
   \   0000000A   0x68D2             LDR      R2,[R2, #+12]
   \   0000000C   0x4710             BX       R2
    675          }
    676          
    677          //! @brief check if a flash region is in an XA controlled region or contains an XA controlled region.
    678          //         and try to open flash program state by calling verify_erase_all command if needed.

   \                                 In section .text, align 2, keep-with-next
    679          status_t flash_preprocess_execute_only_region(uint32_t address,
    680                                                        uint32_t length,
    681                                                        flash_execute_only_access_state_t *state)
    682          {
   \                     flash_preprocess_execute_only_region: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4615             MOV      R5,R2
   \   00000004   0xB082             SUB      SP,SP,#+8
    683              status_t status = kStatus_Success;
    684              *state = kFLASH_AccessStateUnLimited;
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x702A             STRB     R2,[R5, #+0]
    685          
    686          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    687              // If a target flash location is in an execute-only protected segment, these program commands are not
    688              // allowed unless a Read 1s All Blocks command is executed and returns with a pass code
    689              flash_execute_only_access_state_t access_state;
    690          
    691              status = g_bootloaderContext.flashDriverInterface->flash_is_execute_only(&g_bootloaderContext.flashState, address,
    692                                                                                       length, &access_state);
   \   0000000A   0x460A             MOV      R2,R1
   \   0000000C   0x....             LDR.N    R4,??DataTable11
   \   0000000E   0x6926             LDR      R6,[R4, #+16]
   \   00000010   0x6C76             LDR      R6,[R6, #+68]
   \   00000012   0x4601             MOV      R1,R0
   \   00000014   0x466B             MOV      R3,SP
   \   00000016   0xF104 0x0020      ADD      R0,R4,#+32
   \   0000001A   0x47B0             BLX      R6
    693              if (status != kStatus_Success)
   \   0000001C   0xB988             CBNZ.N   R0,??flash_preprocess_execute_only_region_0
    694              {
    695                  return status;
    696              }
    697          
    698              *state = access_state;
   \   0000001E   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000022   0x7029             STRB     R1,[R5, #+0]
    699          
    700              if ((access_state != kFLASH_AccessStateUnLimited) && (!isFlashRegionUnlocked))
   \   00000024   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000028   0xB159             CBZ.N    R1,??flash_preprocess_execute_only_region_0
   \   0000002A   0x....             LDR.N    R5,??DataTable11_2
   \   0000002C   0x7829             LDRB     R1,[R5, #+0]
   \   0000002E   0xB941             CBNZ.N   R1,??flash_preprocess_execute_only_region_0
    701              {
    702          #if BL_FEATURE_FAC_ERASE
    703                  status = g_bootloaderContext.flashDriverInterface->flash_verify_erase_all_execute_only_segments(
    704                      &g_bootloaderContext.flashState,
    705                      (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin);
    706          #else
    707                  status = g_bootloaderContext.flashDriverInterface->flash_verify_erase_all(
    708                      &g_bootloaderContext.flashState,
    709                      (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin);
   \   00000030   0x68A0             LDR      R0,[R4, #+8]
   \   00000032   0x6900             LDR      R0,[R0, #+16]
   \   00000034   0x.... 0x....      BL       ?Subroutine1
    710          #endif
    711                  if (status != kStatus_Success)
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000038   0xB108             CBZ.N    R0,??flash_preprocess_execute_only_region_1
    712                  {
    713                      return kStatus_FLASH_RegionExecuteOnly;
   \   0000003A   0x206C             MOVS     R0,#+108
   \   0000003C   0xBD76             POP      {R1,R2,R4-R6,PC}
    714                  }
    715          
    716                  isFlashRegionUnlocked = true;
   \                     ??flash_preprocess_execute_only_region_1: (+1)
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0x7029             STRB     R1,[R5, #+0]
    717              }
    718          #endif // FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    719              return status;
   \                     ??flash_preprocess_execute_only_region_0: (+1)
   \   00000042   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    720          }
    721          

   \                                 In section .text, align 2, keep-with-next
    722          status_t flash_check_access_before_programming(uint32_t address, uint32_t length, bool *verifyWrites)
    723          {
   \                     flash_check_access_before_programming: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4614             MOV      R4,R2
    724              status_t status = kStatus_Success;
    725          
    726          #if !BL_FEATURE_FLASH_VERIFY_DISABLE
    727              *verifyWrites = g_bootloaderContext.propertyInterface->store->verifyWrites;
   \   00000004   0x....             LDR.N    R2,??DataTable11
   \   00000006   0x6892             LDR      R2,[R2, #+8]
   \   00000008   0xB082             SUB      SP,SP,#+8
   \   0000000A   0x6912             LDR      R2,[R2, #+16]
   \   0000000C   0x6B12             LDR      R2,[R2, #+48]
   \   0000000E   0xB102             CBZ.N    R2,??flash_check_access_before_programming_0
   \   00000010   0x2201             MOVS     R2,#+1
    728          #endif // BL_FEATURE_FLASH_VERIFY_DISABLE
    729          
    730          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    731              // If a target flash location is in an execute-only protected segment, these program commands are not
    732              // allowed unless a Read 1s All Blocks command is executed and returns with a pass code
    733              flash_execute_only_access_state_t access_state;
    734          
    735              uint32_t actualLength = ALIGN_UP(length, (uint32_t)FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
    736              flash_lock_acquire();
    737              status = flash_preprocess_execute_only_region(address, actualLength, &access_state);
   \                     ??flash_check_access_before_programming_0: (+1)
   \   00000012   0x4249             RSBS     R1,R1,#+0
   \   00000014   0x7022             STRB     R2,[R4, #+0]
   \   00000016   0x0889             LSRS     R1,R1,#+2
   \   00000018   0x0089             LSLS     R1,R1,#+2
   \   0000001A   0x466A             MOV      R2,SP
   \   0000001C   0x4249             RSBS     R1,R1,#+0
   \   0000001E   0x.... 0x....      BL       flash_preprocess_execute_only_region
    738              if (status != kStatus_Success)
   \   00000022   0xB920             CBNZ.N   R0,??flash_check_access_before_programming_1
    739              {
    740                  flash_lock_release();
    741                  return status;
    742              }
    743              flash_lock_release();
    744          
    745          #if !BL_FEATURE_FLASH_VERIFY_DISABLE
    746              if (access_state != kFLASH_AccessStateUnLimited)
   \   00000024   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000028   0xB109             CBZ.N    R1,??flash_check_access_before_programming_1
    747              {
    748                  *verifyWrites = false;
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x7021             STRB     R1,[R4, #+0]
    749              }
    750          #endif // BL_FEATURE_FLASH_VERIFY_DISABLE
    751          
    752          #endif // FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    753          
    754          // Do cumulative write check
    755          #if BL_FEATURE_FLASH_CHECK_CUMULATIVE_WRITE || FSL_FEATURE_SOC_FTFE_COUNT
    756              bool isCumulativeCheckNeeded = true;
    757          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    758              if (access_state != kFLASH_AccessStateUnLimited)
    759              {
    760                  isCumulativeCheckNeeded = false;
    761              }
    762          #endif // FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    763              if (isCumulativeCheckNeeded)
    764              {
    765                  uint32_t actualLength = ALIGN_UP(length, (uint32_t)FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
    766                  if (!mem_is_erased(address, actualLength))
    767                  {
    768                      return kStatusMemoryCumulativeWrite;
    769                  }
    770              }
    771          #endif // BL_FEATURE_FLASH_CHECK_CUMULATIVE_WRITE || FSL_FEATURE_SOC_FTFE_COUNT
    772          
    773              return status;
   \                     ??flash_check_access_before_programming_1: (+1)
   \   0000002E   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    774          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     g_bootloaderContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x6B65666B         DC32     0x6b65666b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     isFlashRegionUnlocked

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x45 0x72          DC8 "Error: flash verify failed at address: 0x%x\015\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x66    
   \              0x6C 0x61    
   \              0x73 0x68    
   \              0x20 0x76    
   \              0x65 0x72    
   \              0x69 0x66    
   \              0x79 0x20    
   \              0x66 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x20 0x61    
   \              0x74 0x20    
   \              0x61 0x64    
   \              0x64 0x72    
   \              0x65 0x73    
   \              0x73 0x3A    
   \              0x20 0x30    
   \              0x78 0x25    
   \              0x78 0x0D    
   \              0x0A 0x00    
   \   0000002E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x45 0x72          DC8 "Error: flash_verify_erase failed\015\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x66    
   \              0x6C 0x61    
   \              0x73 0x68    
   \              0x5F 0x76    
   \              0x65 0x72    
   \              0x69 0x66    
   \              0x79 0x5F    
   \              0x65 0x72    
   \              0x61 0x73    
   \              0x65 0x20    
   \              0x66 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x0D 0x0A    
   \              0x00         
   \   00000023   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x45 0x72          DC8 45H, 72H, 72H, 6FH, 72H, 3AH, 20H, 66H
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x66    
   \   00000008   0x6C 0x61          DC8 6CH, 61H, 73H, 68H, 5FH, 76H, 65H, 72H
   \              0x73 0x68    
   \              0x5F 0x76    
   \              0x65 0x72    
   \   00000010   0x69 0x66          DC8 69H, 66H, 79H, 5FH, 65H, 72H, 61H, 73H
   \              0x79 0x5F    
   \              0x65 0x72    
   \              0x61 0x73    
   \   00000018   0x65 0x5F          DC8 65H, 5FH, 61H, 6CH, 6CH, 2FH, 61H, 6CH
   \              0x61 0x6C    
   \              0x6C 0x2F    
   \              0x61 0x6C    
   \   00000020   0x6C 0x5F          DC8 6CH, 5FH, 65H, 78H, 65H, 63H, 75H, 74H
   \              0x65 0x78    
   \              0x65 0x63    
   \              0x75 0x74    
   \   00000028   0x65 0x5F          DC8 65H, 5FH, 6FH, 6EH, 6CH, 79H, 5FH, 73H
   \              0x6F 0x6E    
   \              0x6C 0x79    
   \              0x5F 0x73    
   \   00000030   0x65 0x67          DC8 65H, 67H, 6DH, 65H, 6EH, 74H, 73H, 20H
   \              0x6D 0x65    
   \              0x6E 0x74    
   \              0x73 0x20    
   \   00000038   0x66 0x61          DC8 66H, 61H, 69H, 6CH, 65H, 64H, 0DH, 0AH
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x0D 0x0A    
   \   00000040   0x00               DC8 0
   \   00000041   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    775          
    776          ////////////////////////////////////////////////////////////////////////////////
    777          // EOF
    778          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   debug_printf
        16   -> vprintf
      16   flash_check_access_before_programming
        16   -> flash_preprocess_execute_only_region
      24   flash_mem_erase
        24   -- Indirect call
        24   -> debug_printf
      16   flash_mem_erase_all
        16   -- Indirect call
        16   -> debug_printf
       0   flash_mem_erase_all_unsecure
         0   -- Indirect call
      48   flash_mem_fill
        48   -> flash_mem_write
      16   flash_mem_init
        16   -- Indirect call
      24   flash_mem_read
        24   -- Indirect call
        24   -> normal_mem_read
      64   flash_mem_write
        64   -- Indirect call
        64   -> __aeabi_memcpy
        64   -> debug_printf
        64   -> flash_check_access_before_programming
      24   flash_preprocess_execute_only_region
        24   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
      12  ?Subroutine0
      14  ?Subroutine1
      10  ?Subroutine2
      48  ?_0
      36  ?_1
      68  ?_2
      14  debug_printf
      48  flash_check_access_before_programming
      70  flash_mem_erase
      56  flash_mem_erase_all
      14  flash_mem_erase_all_unsecure
      58  flash_mem_fill
      48  flash_mem_init
      64  flash_mem_read
     208  flash_mem_write
      68  flash_preprocess_execute_only_region
      24  g_flashMemoryInterface
       1  isFlashRegionUnlocked

 
   1 byte  in section .bss
  24 bytes in section .rodata
 848 bytes in section .text
 
 848 bytes of CODE  memory
  24 bytes of CONST memory
   1 byte  of DATA  memory

Errors: none
Warnings: none
