###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Aug/2016  13:16:02
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_msc.c
#    Command line =  
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_msc.c"
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN256VDC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D BL_TARGET_RAM -lC
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj"
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices/MK22F25612\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/autobaud\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/osa\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device/class\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/bm_usb\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/CMSIS/Include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers/common\"
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list\usb_device_msc.lst
#    Object file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj\usb_device_msc.o
#
###############################################################################

C:\Users\cwati\Documents\My Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_msc.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "usb_device_config.h"
     32          #include "usb.h"
     33          #include "usb_device.h"
     34          
     35          #include "usb_device_class.h"
     36          
     37          #if ((defined(USB_DEVICE_CONFIG_MSC)) && (USB_DEVICE_CONFIG_MSC > 0U))
     38          #include "usb_device_msc.h"
     39          /*******************************************************************************
     40           * Definitions
     41           ******************************************************************************/
     42          
     43          /*******************************************************************************
     44           * Prototypes
     45           ******************************************************************************/
     46          usb_status_t USB_DeviceMscRecv(usb_device_msc_struct_t *mscHandle);
     47          usb_status_t USB_DeviceMscSend(usb_device_msc_struct_t *mscHandle);
     48          /*******************************************************************************
     49           * Variables
     50           ******************************************************************************/
     51          

   \                                 In section m_usb_global, align 4
     52          USB_GLOBAL usb_device_msc_struct_t g_msc_handle[USB_DEVICE_CONFIG_MSC_MAX_INSTANCE];
   \                     g_msc_handle:
   \   00000000                      DS8 256
     53          /*******************************************************************************
     54           * Code
     55           ******************************************************************************/
     56          
     57          /*!
     58           * @brief Allocate a device msc class handle.
     59           *
     60           * This function allocates a device msc class handle.
     61           *
     62           * @param handle          It is out parameter, is used to return pointer of the device msc class handle to the caller.
     63           *
     64           * @retval kStatus_USB_Success              Get a device msc class handle successfully.
     65           * @retval kStatus_USB_Busy                 Cannot allocate a device msc class handle.
     66           */
     67          
     68          static usb_status_t USB_DeviceMscAllocateHandle(usb_device_msc_struct_t **handle)
     69          {
     70              uint32_t count;
     71              for (count = 0; count < USB_DEVICE_CONFIG_MSC_MAX_INSTANCE; count++)
     72              {
     73                  if (NULL == g_msc_handle[count].handle)
     74                  {
     75                      *handle = &g_msc_handle[count];
     76                      return kStatus_USB_Success;
     77                  }
     78              }
     79          
     80              return kStatus_USB_Busy;
     81          }
     82          
     83          /*!
     84           * @brief Free a device msc class hanlde.
     85           *
     86           * This function frees a device msc class hanlde.
     87           *
     88           * @param handle          The device msc class hanlde.
     89           *
     90           * @retval kStatus_USB_Success              Free device msc class hanlde successfully.
     91           */

   \                                 In section .text, align 2, keep-with-next
     92          static usb_status_t USB_DeviceMscFreeHandle(usb_device_msc_struct_t *handle)
     93          {
     94              handle->handle = NULL;
   \                     USB_DeviceMscFreeHandle: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
     95              handle->configurationStruct = (usb_device_class_config_struct_t *)NULL;
   \   00000004   0x6041             STR      R1,[R0, #+4]
     96              handle->configuration = 0;
   \   00000006   0x30FB             ADDS     R0,R0,#+251
   \   00000008   0x7041             STRB     R1,[R0, #+1]
     97              handle->alternate = 0;
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
     98              return kStatus_USB_Success;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
     99          }
    100          
    101          /*!
    102           * @brief Process usb msc ufi command.
    103           *
    104           * This function analyse the cbw , get the command code.
    105           *
    106           * @param handle          The device msc class hanlde.
    107           *
    108           * @retval kStatus_USB_Success              Free device msc class hanlde successfully.
    109           */

   \                                 In section .text, align 2, keep-with-next
    110          usb_status_t USB_DeviceMscProcessUfiCommand(usb_device_msc_struct_t *mscHandle)
    111          {
   \                     USB_DeviceMscProcessUfiCommand: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    112              usb_status_t error = kStatus_USB_Error;
    113              usb_device_msc_ufi_struct_t *ufi = NULL;
    114          
    115              ufi = &mscHandle->mscUfi;
    116          
    117              ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_NO_SENSE;
   \   00000004   0xF104 0x005A      ADD      R0,R4,#+90
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
    118              ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_NO_SENSE;
   \   0000000C   0x7281             STRB     R1,[R0, #+10]
    119              ufi->requestSense.additionalSenseQualifer = USB_DEVICE_MSC_UFI_NO_SENSE;
   \   0000000E   0x72C1             STRB     R1,[R0, #+11]
    120              ufi->thirteenCase.hostExpectedDataLength = mscHandle->mscCbw.dataTransferLength;
   \   00000010   0xF104 0x006C      ADD      R0,R4,#+108
   \   00000014   0xF104 0x0130      ADD      R1,R4,#+48
   \   00000018   0x680A             LDR      R2,[R1, #+0]
   \   0000001A   0x6002             STR      R2,[R0, #+0]
    121              ufi->thirteenCase.hostExpectedDirection = (uint8_t)(mscHandle->mscCbw.flags >> USB_DEVICE_MSC_CBW_DIRECTION_SHIFT);
   \   0000001C   0x790A             LDRB     R2,[R1, #+4]
   \   0000001E   0x09D2             LSRS     R2,R2,#+7
   \   00000020   0x7542             STRB     R2,[R0, #+21]
    122              /*The first byte of all ufi command blocks shall contain an Operation Code, refer to ufi spec*/
    123              switch (mscHandle->mscCbw.cbwcb[0])
   \   00000022   0x79C8             LDRB     R0,[R1, #+7]
   \   00000024   0xB398             CBZ.N    R0,??USB_DeviceMscProcessUfiCommand_0
   \   00000026   0x2803             CMP      R0,#+3
   \   00000028   0xD02C             BEQ.N    ??USB_DeviceMscProcessUfiCommand_1
   \   0000002A   0x2804             CMP      R0,#+4
   \   0000002C   0xD03E             BEQ.N    ??USB_DeviceMscProcessUfiCommand_2
   \   0000002E   0x2812             CMP      R0,#+18
   \   00000030   0xD01E             BEQ.N    ??USB_DeviceMscProcessUfiCommand_3
   \   00000032   0x2815             CMP      R0,#+21
   \   00000034   0xD049             BEQ.N    ??USB_DeviceMscProcessUfiCommand_4
   \   00000036   0x281A             CMP      R0,#+26
   \   00000038   0xD042             BEQ.N    ??USB_DeviceMscProcessUfiCommand_5
   \   0000003A   0x281B             CMP      R0,#+27
   \   0000003C   0xD059             BEQ.N    ??USB_DeviceMscProcessUfiCommand_6
   \   0000003E   0x281D             CMP      R0,#+29
   \   00000040   0xD04D             BEQ.N    ??USB_DeviceMscProcessUfiCommand_7
   \   00000042   0x281E             CMP      R0,#+30
   \   00000044   0xD02D             BEQ.N    ??USB_DeviceMscProcessUfiCommand_8
   \   00000046   0x2823             CMP      R0,#+35
   \   00000048   0xD044             BEQ.N    ??USB_DeviceMscProcessUfiCommand_9
   \   0000004A   0x2825             CMP      R0,#+37
   \   0000004C   0xD033             BEQ.N    ??USB_DeviceMscProcessUfiCommand_10
   \   0000004E   0x2828             CMP      R0,#+40
   \   00000050   0xD013             BEQ.N    ??USB_DeviceMscProcessUfiCommand_11
   \   00000052   0x282A             CMP      R0,#+42
   \   00000054   0xD020             BEQ.N    ??USB_DeviceMscProcessUfiCommand_12
   \   00000056   0x282F             CMP      R0,#+47
   \   00000058   0xD046             BEQ.N    ??USB_DeviceMscProcessUfiCommand_13
   \   0000005A   0x2855             CMP      R0,#+85
   \   0000005C   0xD035             BEQ.N    ??USB_DeviceMscProcessUfiCommand_4
   \   0000005E   0x285A             CMP      R0,#+90
   \   00000060   0xD02E             BEQ.N    ??USB_DeviceMscProcessUfiCommand_5
   \   00000062   0x289E             CMP      R0,#+158
   \   00000064   0xD027             BEQ.N    ??USB_DeviceMscProcessUfiCommand_10
   \   00000066   0x28A8             CMP      R0,#+168
   \   00000068   0xD007             BEQ.N    ??USB_DeviceMscProcessUfiCommand_11
   \   0000006A   0x28AA             CMP      R0,#+170
   \   0000006C   0xD014             BEQ.N    ??USB_DeviceMscProcessUfiCommand_12
   \   0000006E   0xE045             B.N      ??USB_DeviceMscProcessUfiCommand_14
    124              {
    125                  /* ufi commmand operation code*/
    126                  case USB_DEVICE_MSC_INQUIRY_COMMAND: /*operation code : 0x12*/
    127                      error = USB_DeviceMscUfiInquiryCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_3: (+1)
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0xE8BD 0x4010      POP      {R4,LR}
   \   00000076   0x.... 0x....      B.W      USB_DeviceMscUfiInquiryCommand
    128                      break;
    129                  case USB_DEVICE_MSC_READ_10_COMMAND: /*operation code : 0x28 */
    130                  case USB_DEVICE_MSC_READ_12_COMMAND: /*operation code : 0xA8 */
    131                      error = USB_DeviceMscUfiReadCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_11: (+1)
   \   0000007A   0x4620             MOV      R0,R4
   \   0000007C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000080   0x.... 0x....      B.W      USB_DeviceMscUfiReadCommand
    132                      break;
    133                  case USB_DEVICE_MSC_REQUEST_SENSE_COMMAND: /*operation code : 0x03*/
    134                      error = USB_DeviceMscUfiRequestSenseCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_1: (+1)
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0xE8BD 0x4010      POP      {R4,LR}
   \   0000008A   0x.... 0x....      B.W      USB_DeviceMscUfiRequestSenseCommand
    135                      break;
    136                  case USB_DEVICE_MSC_TEST_UNIT_READY_COMMAND: /*operation code : 0x00 */
    137                      error = USB_DeviceMscUfiTestUnitReadyCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_0: (+1)
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0xE8BD 0x4010      POP      {R4,LR}
   \   00000094   0x.... 0x....      B.W      USB_DeviceMscUfiTestUnitReadyCommand
    138                      break;
    139                  case USB_DEVICE_MSC_WRITE_10_COMMAND: /*operation code : 0x2A */
    140                  case USB_DEVICE_MSC_WRITE_12_COMMAND: /*operation code : 0xAA */
    141                      error = USB_DeviceMscUfiWriteCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_12: (+1)
   \   00000098   0x4620             MOV      R0,R4
   \   0000009A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000009E   0x.... 0x....      B.W      USB_DeviceMscUfiWriteCommand
    142                      break;
    143                  case USB_DEVICE_MSC_PREVENT_ALLOW_MEDIUM_REM_COMMAND: /*operation code :0x1E */
    144                      error = USB_DeviceMscUfiPreventAllowMediumCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_8: (+1)
   \   000000A2   0x4620             MOV      R0,R4
   \   000000A4   0xE8BD 0x4010      POP      {R4,LR}
   \   000000A8   0x.... 0x....      B.W      USB_DeviceMscUfiPreventAllowMediumCommand
    145                      break;
    146                  case USB_DEVICE_MSC_FORMAT_UNIT_COMMAND: /*operation code : 0x04*/
    147                      error = USB_DeviceMscUfiFormatUnitCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_2: (+1)
   \   000000AC   0x4620             MOV      R0,R4
   \   000000AE   0xE8BD 0x4010      POP      {R4,LR}
   \   000000B2   0x.... 0x....      B.W      USB_DeviceMscUfiFormatUnitCommand
    148                      break;
    149                  case USB_DEVICE_MSC_READ_CAPACITY_10_COMMAND: /*operation code : 0x25*/
    150                  case USB_DEVICE_MSC_READ_CAPACITY_16_COMMAND: /*operation code : 0x9E*/
    151                      error = USB_DeviceMscUfiReadCapacityCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_10: (+1)
   \   000000B6   0x4620             MOV      R0,R4
   \   000000B8   0xE8BD 0x4010      POP      {R4,LR}
   \   000000BC   0x.... 0x....      B.W      USB_DeviceMscUfiReadCapacityCommand
    152                      break;
    153                  case USB_DEVICE_MSC_MODE_SENSE_10_COMMAND: /* operation code :0x5A*/
    154                  case USB_DEVICE_MSC_MODE_SENSE_6_COMMAND:  /* operation code : 0x1A */
    155                      error = USB_DeviceMscUfiModeSenseCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_5: (+1)
   \   000000C0   0x4620             MOV      R0,R4
   \   000000C2   0xE8BD 0x4010      POP      {R4,LR}
   \   000000C6   0x.... 0x....      B.W      USB_DeviceMscUfiModeSenseCommand
    156                      break;
    157                  case USB_DEVICE_MSC_MODE_SELECT_10_COMMAND: /*operation code : 0x55 */
    158                  case USB_DEVICE_MSC_MODE_SELECT_6_COMMAND:  /*operation code : 0x15 */
    159                      error = USB_DeviceMscUfiModeSelectCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_4: (+1)
   \   000000CA   0x4620             MOV      R0,R4
   \   000000CC   0xE8BD 0x4010      POP      {R4,LR}
   \   000000D0   0x.... 0x....      B.W      USB_DeviceMscUfiModeSelectCommand
    160                      break;
    161                  case USB_DEVICE_MSC_READ_FORMAT_CAPACITIES_COMMAND: /*operation code : 0x23 */
    162                      error = USB_DeviceMscUfiReadFormatCapacityCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_9: (+1)
   \   000000D4   0x4620             MOV      R0,R4
   \   000000D6   0xE8BD 0x4010      POP      {R4,LR}
   \   000000DA   0x.... 0x....      B.W      USB_DeviceMscUfiReadFormatCapacityCommand
    163                      break;
    164                  case USB_DEVICE_MSC_SEND_DIAGNOSTIC_COMMAND: /*operation code : 0x1D*/
    165                      error = USB_DeviceMscUfiSendDiagnosticCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_7: (+1)
   \   000000DE   0x4620             MOV      R0,R4
   \   000000E0   0xE8BD 0x4010      POP      {R4,LR}
   \   000000E4   0x.... 0x....      B.W      USB_DeviceMscUfiSendDiagnosticCommand
    166                      break;
    167                  case USB_DEVICE_MSC_VERIFY_COMMAND: /*operation code : 0x2F*/
    168                      error = USB_DeviceMscUfiVerifyCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_13: (+1)
   \   000000E8   0x4620             MOV      R0,R4
   \   000000EA   0xE8BD 0x4010      POP      {R4,LR}
   \   000000EE   0x.... 0x....      B.W      USB_DeviceMscUfiVerifyCommand
    169                      break;
    170                  case USB_DEVICE_MSC_START_STOP_UNIT_COMMAND: /*operation code : 0x1B*/
    171                      error = USB_DeviceMscUfiStartStopUnitCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_6: (+1)
   \   000000F2   0x4620             MOV      R0,R4
   \   000000F4   0xE8BD 0x4010      POP      {R4,LR}
   \   000000F8   0x.... 0x....      B.W      USB_DeviceMscUfiStartStopUnitCommand
    172                      break;
    173                  default:
    174                      error = USB_DeviceMscUfiUnsupportCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_14: (+1)
   \   000000FC   0x4620             MOV      R0,R4
   \   000000FE   0x.... 0x....      BL       USB_DeviceMscUfiUnsupportCommand
    175                      mscHandle->dataOutFlag = 0;
   \   00000102   0xF104 0x01EC      ADD      R1,R4,#+236
   \   00000106   0x2200             MOVS     R2,#+0
   \   00000108   0x700A             STRB     R2,[R1, #+0]
    176                      mscHandle->dataInFlag = 0;
   \   0000010A   0x704A             STRB     R2,[R1, #+1]
    177                      mscHandle->outEndpointStallFlag = 0;
   \   0000010C   0x70CA             STRB     R2,[R1, #+3]
    178                      mscHandle->inEndpointStallFlag = 0;
   \   0000010E   0x708A             STRB     R2,[R1, #+2]
    179                      mscHandle->needOutStallFlag = 0;
   \   00000110   0x720A             STRB     R2,[R1, #+8]
    180                      mscHandle->needInStallFlag = 0;
   \   00000112   0x71CA             STRB     R2,[R1, #+7]
    181                      break;
    182              }
    183              return error;
   \   00000114   0xBD10             POP      {R4,PC}          ;; return
    184          }
    185          
    186          /*!
    187           * @brief Bulk IN endpoint callback function.
    188           *
    189           * This callback function is used to notify uplayer the tranfser result of a transfer.
    190           * This callback pointer is passed when the Bulk IN pipe initialized.
    191           *
    192           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    193           * @param message         The result of the Bulk IN pipe transfer.
    194           * @param callbackParam  The paramter for this callback. It is same with
    195           * usb_device_endpoint_callback_struct_t::callbackParam. In the class, the value is the MSC class handle.
    196           *
    197           * @return A USB error code or kStatus_USB_Success.
    198           */

   \                                 In section .text, align 2, keep-with-next
    199          static usb_status_t USB_DeviceMscBulkIn(usb_device_handle handle,
    200                                                  usb_device_endpoint_callback_message_struct_t *message,
    201                                                  void *callbackParam)
    202          {
   \                     USB_DeviceMscBulkIn: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0xB084             SUB      SP,SP,#+16
   \   00000008   0x4615             MOV      R5,R2
    203              usb_device_msc_struct_t *mscHandle = (usb_device_msc_struct_t *)callbackParam;
    204              usb_device_msc_csw_t *csw;
    205              usb_status_t error = kStatus_USB_Error;
    206          
    207              if (message->length == USB_UNINITIALIZED_VAL_32)
   \   0000000A   0x6862             LDR      R2,[R4, #+4]
   \   0000000C   0x1D2F             ADDS     R7,R5,#+4
   \   0000000E   0xF112 0x0F01      CMN      R2,#+1
   \   00000012   0xF04F 0x0801      MOV      R8,#+1
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0xF105 0x06ED      ADD      R6,R5,#+237
   \   0000001C   0xD118             BNE.N    ??USB_DeviceMscBulkIn_0
    208              {
    209                  if ((mscHandle->dataInFlag) && (mscHandle->configurationStruct->classCallback != NULL) &&
    210                      ((USB_DEVICE_MSC_READ_10_COMMAND == mscHandle->mscCbw.cbwcb[0]) ||
    211                       (USB_DEVICE_MSC_READ_12_COMMAND == mscHandle->mscCbw.cbwcb[0])))
   \   0000001E   0x7831             LDRB     R1,[R6, #+0]
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xBF1E             ITTT     NE 
   \   00000024   0x6839             LDRNE    R1,[R7, #+0]
   \   00000026   0x6809             LDRNE    R1,[R1, #+0]
   \   00000028   0x2900             CMPNE    R1,#+0
   \   0000002A   0xD065             BEQ.N    ??USB_DeviceMscBulkIn_1
   \   0000002C   0xF895 0x1037      LDRB     R1,[R5, #+55]
   \   00000030   0x2928             CMP      R1,#+40
   \   00000032   0xBF18             IT       NE 
   \   00000034   0x29A8             CMPNE    R1,#+168
   \   00000036   0xD15F             BNE.N    ??USB_DeviceMscBulkIn_1
    212                  {
    213                      usb_device_lba_app_struct_t lbaData;
    214          
    215                      lbaData.size = 0;
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x9101             STR      R1,[SP, #+4]
    216                      lbaData.buffer = message->buffer;
    217                      lbaData.offset = 0;
    218                      mscHandle->configurationStruct->classCallback((class_handle_t)mscHandle, kUSB_DeviceMscEventReadResponse,
    219                                                                    (void *)&lbaData);
   \   0000003C   0x466A             MOV      R2,SP
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x9102             STR      R1,[SP, #+8]
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x9100             STR      R1,[SP, #+0]
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0x683B             LDR      R3,[R7, #+0]
   \   0000004A   0x681B             LDR      R3,[R3, #+0]
   \   0000004C   0x4798             BLX      R3
    220                  }
    221                  return error;
   \   0000004E   0xE053             B.N      ??USB_DeviceMscBulkIn_1
    222              }
    223              if (mscHandle->transferRemaining >= message->length)
   \                     ??USB_DeviceMscBulkIn_0: (+1)
   \   00000050   0x68BB             LDR      R3,[R7, #+8]
   \   00000052   0x4293             CMP      R3,R2
   \   00000054   0xBF24             ITT      CS 
   \   00000056   0x1A9A             SUBCS    R2,R3,R2
   \   00000058   0x60BA             STRCS    R2,[R7, #+8]
    224              {
    225                  mscHandle->transferRemaining -= message->length;
    226              }
    227          
    228              if (mscHandle->needInStallFlag == 1)
   \   0000005A   0x79B2             LDRB     R2,[R6, #+6]
   \   0000005C   0x2A01             CMP      R2,#+1
   \   0000005E   0xD109             BNE.N    ??USB_DeviceMscBulkIn_2
    229              {
    230                  mscHandle->needInStallFlag = 0;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x71B0             STRB     R0,[R6, #+6]
    231                  mscHandle->inEndpointStallFlag = 1;
   \   00000064   0xF886 0x8001      STRB     R8,[R6, #+1]
    232                  mscHandle->dataInFlag = 0;
   \   00000068   0x7030             STRB     R0,[R6, #+0]
    233                  USB_DeviceStallEndpoint(mscHandle->handle, mscHandle->bulkInEndpoint);
   \   0000006A   0x7B31             LDRB     R1,[R6, #+12]
   \   0000006C   0x6828             LDR      R0,[R5, #+0]
   \   0000006E   0x.... 0x....      BL       USB_DeviceStallEndpoint
    234                  return error;
   \   00000072   0xE041             B.N      ??USB_DeviceMscBulkIn_1
    235              }
    236              if ((!mscHandle->dataInFlag) && (message->length == USB_DEVICE_MSC_CSW_LENGTH))
   \                     ??USB_DeviceMscBulkIn_2: (+1)
   \   00000074   0x7832             LDRB     R2,[R6, #+0]
   \   00000076   0x2A00             CMP      R2,#+0
   \   00000078   0xBF02             ITTT     EQ 
   \   0000007A   0x6862             LDREQ    R2,[R4, #+4]
   \   0000007C   0x2A0D             CMPEQ    R2,#+13
   \   0000007E   0x6821             LDREQ    R1,[R4, #+0]
    237              {
    238                  csw = (usb_device_msc_csw_t *)(message->buffer);
    239              }
    240          
    241              if (mscHandle->dataInFlag)
   \   00000080   0x7832             LDRB     R2,[R6, #+0]
   \   00000082   0xB352             CBZ.N    R2,??USB_DeviceMscBulkIn_3
    242              {
    243                  if ((mscHandle->configurationStruct->classCallback != NULL))
   \   00000084   0x6839             LDR      R1,[R7, #+0]
   \   00000086   0x6809             LDR      R1,[R1, #+0]
   \   00000088   0x2900             CMP      R1,#+0
   \   0000008A   0xD035             BEQ.N    ??USB_DeviceMscBulkIn_1
    244                  {
    245                      usb_device_lba_app_struct_t lbaData;
    246          
    247                      lbaData.size = message->length;
   \   0000008C   0x6861             LDR      R1,[R4, #+4]
   \   0000008E   0x9101             STR      R1,[SP, #+4]
    248                      lbaData.buffer = message->buffer;
   \   00000090   0x6821             LDR      R1,[R4, #+0]
   \   00000092   0x9102             STR      R1,[SP, #+8]
    249                      lbaData.offset = mscHandle->currentOffset;
   \   00000094   0x68F9             LDR      R1,[R7, #+12]
   \   00000096   0x9100             STR      R1,[SP, #+0]
    250          
    251                      if ((USB_DEVICE_MSC_READ_10_COMMAND == mscHandle->mscCbw.cbwcb[0]) ||
    252                          (USB_DEVICE_MSC_READ_12_COMMAND == mscHandle->mscCbw.cbwcb[0]))
   \   00000098   0xF895 0x1037      LDRB     R1,[R5, #+55]
   \   0000009C   0x2928             CMP      R1,#+40
   \   0000009E   0xBF18             IT       NE 
   \   000000A0   0x29A8             CMPNE    R1,#+168
   \   000000A2   0xD104             BNE.N    ??USB_DeviceMscBulkIn_4
    253                      {
    254                          mscHandle->configurationStruct->classCallback((class_handle_t)mscHandle,
    255                                                                        kUSB_DeviceMscEventReadResponse, (void *)&lbaData);
   \   000000A4   0x683B             LDR      R3,[R7, #+0]
   \   000000A6   0x681B             LDR      R3,[R3, #+0]
   \   000000A8   0x466A             MOV      R2,SP
   \   000000AA   0x2101             MOVS     R1,#+1
   \   000000AC   0x4798             BLX      R3
    256                      }
    257          
    258                      if (mscHandle->transferRemaining)
   \                     ??USB_DeviceMscBulkIn_4: (+1)
   \   000000AE   0x68B8             LDR      R0,[R7, #+8]
   \   000000B0   0xB148             CBZ.N    R0,??USB_DeviceMscBulkIn_5
    259                      {
    260                          mscHandle->currentOffset += message->length;
   \   000000B2   0x68F8             LDR      R0,[R7, #+12]
   \   000000B4   0x6861             LDR      R1,[R4, #+4]
   \   000000B6   0x1808             ADDS     R0,R1,R0
   \   000000B8   0x60F8             STR      R0,[R7, #+12]
    261                          error = USB_DeviceMscSend(mscHandle);
   \   000000BA   0x4628             MOV      R0,R5
   \   000000BC   0x.... 0x....      BL       USB_DeviceMscSend
   \   000000C0   0x4680             MOV      R8,R0
    262                      }
    263                      if (!mscHandle->transferRemaining)
   \   000000C2   0x68B8             LDR      R0,[R7, #+8]
   \   000000C4   0xB9C0             CBNZ.N   R0,??USB_DeviceMscBulkIn_1
    264                      {
    265                          mscHandle->dataInFlag = 0;
   \                     ??USB_DeviceMscBulkIn_5: (+1)
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0x7030             STRB     R0,[R6, #+0]
    266                          /*data transfer has been done, send the csw to host */
    267                          USB_DeviceSendRequest(mscHandle->handle, mscHandle->bulkInEndpoint, (uint8_t *)&mscHandle->mscCsw,
    268                                                USB_DEVICE_MSC_CSW_LENGTH);
   \   000000CA   0x230D             MOVS     R3,#+13
   \   000000CC   0x7B31             LDRB     R1,[R6, #+12]
   \   000000CE   0x6828             LDR      R0,[R5, #+0]
   \   000000D0   0xF105 0x0248      ADD      R2,R5,#+72
   \   000000D4   0x.... 0x....      BL       USB_DeviceSendRequest
   \   000000D8   0xE00E             B.N      ??USB_DeviceMscBulkIn_1
    269                      }
    270                  }
    271              }
    272              else if ((message->length == USB_DEVICE_MSC_CSW_LENGTH) && (csw->signature == USB_DEVICE_MSC_DCSWSIGNATURE))
   \                     ??USB_DeviceMscBulkIn_3: (+1)
   \   000000DA   0x6860             LDR      R0,[R4, #+4]
   \   000000DC   0x280D             CMP      R0,#+13
   \   000000DE   0xBF02             ITTT     EQ 
   \   000000E0   0x6808             LDREQ    R0,[R1, #+0]
   \   000000E2   0x.... 0x....      LDREQ.W  R1,??DataTable2  ;; 0x53425355
   \   000000E6   0x4288             CMPEQ    R0,R1
   \   000000E8   0xD106             BNE.N    ??USB_DeviceMscBulkIn_1
    273              {
    274                  mscHandle->cbwValidFlag = 1;
   \   000000EA   0xF886 0x8003      STRB     R8,[R6, #+3]
    275          
    276                  (void)USB_DeviceRecvRequest(mscHandle->handle, mscHandle->bulkOutEndpoint, (uint8_t *)&mscHandle->mscCbw,
    277                                              USB_DEVICE_MSC_CBW_LENGTH);
   \   000000EE   0x7B71             LDRB     R1,[R6, #+13]
   \   000000F0   0x.... 0x....      BL       ?Subroutine2
    278                  mscHandle->cbwPrimeFlag = 1;
   \                     ??CrossCallReturnLabel_3: (+1)
   \   000000F4   0xF886 0x8008      STRB     R8,[R6, #+8]
    279              }
    280              else
    281              {
    282              }
    283              return error;
   \                     ??USB_DeviceMscBulkIn_1: (+1)
   \   000000F8   0x4640             MOV      R0,R8
   \   000000FA   0x....             B.N      ?Subroutine0
    284          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xB004             ADD      SP,SP,#+16
   \   00000002   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x6828             LDR      R0,[R5, #+0]
   \   00000002   0x231F             MOVS     R3,#+31
   \   00000004   0xF105 0x0228      ADD      R2,R5,#+40
   \   00000008   0x.... 0x....      B.W      USB_DeviceRecvRequest
    285          
    286          /*!
    287           * @brief Bulk OUT endpoint callback function.
    288           *
    289           * This callback function is used to notify uplayer the tranfser result of a transfer.
    290           * This callback pointer is passed when the Bulk OUT pipe initialized.
    291           *
    292           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    293           * @param message         The result of the Bulk OUT pipe transfer.
    294           * @param callbackParam  The paramter for this callback. It is same with
    295           * usb_device_endpoint_callback_struct_t::callbackParam. In the class, the value is the MSC class handle.
    296           *
    297           * @return A USB error code or kStatus_USB_Success.
    298           */

   \                                 In section .text, align 2, keep-with-next
    299          usb_status_t USB_DeviceMscBulkOut(usb_device_handle handle,
    300                                            usb_device_endpoint_callback_message_struct_t *message,
    301                                            void *callbackParam)
    302          {
   \                     USB_DeviceMscBulkOut: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0xB084             SUB      SP,SP,#+16
   \   00000008   0x4690             MOV      R8,R2
    303              usb_device_msc_struct_t *mscHandle = (usb_device_msc_struct_t *)callbackParam;
    304              usb_status_t error = kStatus_USB_Success;
    305              if (message->length == USB_UNINITIALIZED_VAL_32)
   \   0000000A   0x6862             LDR      R2,[R4, #+4]
   \   0000000C   0x2600             MOVS     R6,#+0
   \   0000000E   0xF112 0x0F01      CMN      R2,#+1
   \   00000012   0xF108 0x0134      ADD      R1,R8,#+52
   \   00000016   0xF108 0x07EC      ADD      R7,R8,#+236
   \   0000001A   0x4640             MOV      R0,R8
   \   0000001C   0xF108 0x0504      ADD      R5,R8,#+4
   \   00000020   0xD115             BNE.N    ??USB_DeviceMscBulkOut_0
    306              {
    307                  if ((mscHandle->dataInFlag) && (mscHandle->configurationStruct->classCallback != NULL) &&
    308                      ((USB_DEVICE_MSC_WRITE_10_COMMAND == mscHandle->mscCbw.cbwcb[0]) ||
    309                       (USB_DEVICE_MSC_WRITE_12_COMMAND == mscHandle->mscCbw.cbwcb[0])))
   \   00000022   0x787A             LDRB     R2,[R7, #+1]
   \   00000024   0x2A00             CMP      R2,#+0
   \   00000026   0xBF1E             ITTT     NE 
   \   00000028   0x682A             LDRNE    R2,[R5, #+0]
   \   0000002A   0x6812             LDRNE    R2,[R2, #+0]
   \   0000002C   0x2A00             CMPNE    R2,#+0
   \   0000002E   0xD00D             BEQ.N    ??USB_DeviceMscBulkOut_1
   \   00000030   0x78C9             LDRB     R1,[R1, #+3]
   \   00000032   0x292A             CMP      R1,#+42
   \   00000034   0xBF18             IT       NE 
   \   00000036   0x29AA             CMPNE    R1,#+170
   \   00000038   0xD108             BNE.N    ??USB_DeviceMscBulkOut_1
    310                  {
    311                      usb_device_lba_app_struct_t lbaData;
    312          
    313                      lbaData.size = 0;
   \   0000003A   0x9601             STR      R6,[SP, #+4]
    314                      lbaData.buffer = message->buffer;
    315                      lbaData.offset = 0;
    316                      mscHandle->configurationStruct->classCallback((class_handle_t)mscHandle, kUSB_DeviceMscEventWriteResponse,
    317                                                                    (void *)&lbaData);
   \   0000003C   0x466A             MOV      R2,SP
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x9600             STR      R6,[SP, #+0]
   \   00000042   0x9102             STR      R1,[SP, #+8]
   \   00000044   0x2102             MOVS     R1,#+2
   \   00000046   0x682B             LDR      R3,[R5, #+0]
   \   00000048   0x681B             LDR      R3,[R3, #+0]
   \   0000004A   0x4798             BLX      R3
    318                  }
    319                  return error;
   \                     ??USB_DeviceMscBulkOut_1: (+1)
   \   0000004C   0xE0A8             B.N      ??USB_DeviceMscBulkOut_2
    320              }
    321          
    322              if (mscHandle->transferRemaining >= message->length)
   \                     ??USB_DeviceMscBulkOut_0: (+1)
   \   0000004E   0x68AB             LDR      R3,[R5, #+8]
   \   00000050   0x4293             CMP      R3,R2
   \   00000052   0xBF24             ITT      CS 
   \   00000054   0x1A9A             SUBCS    R2,R3,R2
   \   00000056   0x60AA             STRCS    R2,[R5, #+8]
    323              {
    324                  mscHandle->transferRemaining -= message->length;
    325              }
    326          
    327              if (mscHandle->needOutStallFlag == 1)
   \   00000058   0x7A3A             LDRB     R2,[R7, #+8]
   \   0000005A   0x2A01             CMP      R2,#+1
   \   0000005C   0xD107             BNE.N    ??USB_DeviceMscBulkOut_3
    328              {
    329                  mscHandle->needOutStallFlag = 0;
    330                  mscHandle->outEndpointStallFlag = 1;
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0x70F8             STRB     R0,[R7, #+3]
   \   00000062   0x723E             STRB     R6,[R7, #+8]
    331                  mscHandle->dataOutFlag = 0;
   \   00000064   0x703E             STRB     R6,[R7, #+0]
    332                  mscHandle->cbwPrimeFlag = 0;
   \   00000066   0x727E             STRB     R6,[R7, #+9]
    333                  USB_DeviceStallEndpoint(mscHandle->handle, mscHandle->bulkOutEndpoint);
   \   00000068   0x.... 0x....      BL       ?Subroutine3
    334                  return error;
   \                     ??CrossCallReturnLabel_6: (+1)
   \   0000006C   0xE098             B.N      ??USB_DeviceMscBulkOut_2
    335              }
    336          
    337              if (mscHandle->dataOutFlag)
   \                     ??USB_DeviceMscBulkOut_3: (+1)
   \   0000006E   0x783A             LDRB     R2,[R7, #+0]
   \   00000070   0xB30A             CBZ.N    R2,??USB_DeviceMscBulkOut_4
    338              {
    339                  usb_device_lba_app_struct_t lbaData;
    340          
    341                  lbaData.size = message->length;
   \   00000072   0x6862             LDR      R2,[R4, #+4]
   \   00000074   0x9201             STR      R2,[SP, #+4]
    342                  lbaData.buffer = message->buffer;
   \   00000076   0x6822             LDR      R2,[R4, #+0]
   \   00000078   0x9202             STR      R2,[SP, #+8]
    343                  lbaData.offset = mscHandle->currentOffset;
   \   0000007A   0x68EA             LDR      R2,[R5, #+12]
   \   0000007C   0x9200             STR      R2,[SP, #+0]
    344          
    345                  if ((mscHandle->configurationStruct->classCallback != NULL))
   \   0000007E   0x682A             LDR      R2,[R5, #+0]
   \   00000080   0x6813             LDR      R3,[R2, #+0]
   \   00000082   0x001A             MOVS     R2,R3
   \   00000084   0xD011             BEQ.N    ??USB_DeviceMscBulkOut_5
   \   00000086   0x78C9             LDRB     R1,[R1, #+3]
   \   00000088   0x292A             CMP      R1,#+42
   \   0000008A   0xBF18             IT       NE 
   \   0000008C   0x29AA             CMPNE    R1,#+170
   \   0000008E   0xD102             BNE.N    ??USB_DeviceMscBulkOut_6
    346                  {
    347                      if ((USB_DEVICE_MSC_WRITE_10_COMMAND == mscHandle->mscCbw.cbwcb[0]) ||
    348                          (USB_DEVICE_MSC_WRITE_12_COMMAND == mscHandle->mscCbw.cbwcb[0]))
    349                      {
    350                          mscHandle->configurationStruct->classCallback((class_handle_t)mscHandle,
    351                                                                        kUSB_DeviceMscEventWriteResponse, (void *)&lbaData);
   \   00000090   0x466A             MOV      R2,SP
   \   00000092   0x2102             MOVS     R1,#+2
   \   00000094   0x4798             BLX      R3
    352                      }
    353          
    354                      if (mscHandle->transferRemaining)
   \                     ??USB_DeviceMscBulkOut_6: (+1)
   \   00000096   0x68A8             LDR      R0,[R5, #+8]
   \   00000098   0xB150             CBZ.N    R0,??USB_DeviceMscBulkOut_7
    355                      {
    356                          mscHandle->currentOffset += message->length;
   \   0000009A   0x68E8             LDR      R0,[R5, #+12]
   \   0000009C   0x6861             LDR      R1,[R4, #+4]
   \   0000009E   0x1808             ADDS     R0,R1,R0
   \   000000A0   0x60E8             STR      R0,[R5, #+12]
    357                          error = USB_DeviceMscRecv(mscHandle);
   \   000000A2   0x4640             MOV      R0,R8
   \   000000A4   0x.... 0x....      BL       USB_DeviceMscRecv
   \   000000A8   0x4606             MOV      R6,R0
    358                      }
    359                  }
    360          
    361                  if (!mscHandle->transferRemaining)
   \                     ??USB_DeviceMscBulkOut_5: (+1)
   \   000000AA   0x68A8             LDR      R0,[R5, #+8]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD177             BNE.N    ??USB_DeviceMscBulkOut_2
    362                  {
    363                      mscHandle->dataOutFlag = 0;
   \                     ??USB_DeviceMscBulkOut_7: (+1)
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x7038             STRB     R0,[R7, #+0]
    364                      {
    365                          USB_DeviceSendRequest(mscHandle->handle, mscHandle->bulkInEndpoint, (uint8_t *)&mscHandle->mscCsw,
    366                                                USB_DEVICE_MSC_CSW_LENGTH);
   \   000000B4   0xE05E             B.N      ??USB_DeviceMscBulkOut_8
    367                          mscHandle->cswPrimeFlag = 1;
    368                      }
    369                  }
    370              }
    371              else if ((mscHandle->cbwValidFlag) && (message->length == USB_DEVICE_MSC_CBW_LENGTH) &&
    372                       (mscHandle->mscCbw.signature == USB_DEVICE_MSC_DCBWSIGNATURE) &&
    373                       (!((mscHandle->mscCbw.logicalUnitNumber & 0xF0) || (mscHandle->mscCbw.cbLength & 0xE0))) &&
    374                       (mscHandle->mscCbw.logicalUnitNumber < (mscHandle->logicalUnitNumber + 1)) &&
    375                       ((mscHandle->mscCbw.cbLength >= 0x01) && (mscHandle->mscCbw.cbLength <= 0x10)))
   \                     ??USB_DeviceMscBulkOut_4: (+1)
   \   000000B6   0x7938             LDRB     R0,[R7, #+4]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD066             BEQ.N    ??USB_DeviceMscBulkOut_9
   \   000000BC   0x6860             LDR      R0,[R4, #+4]
   \   000000BE   0x281F             CMP      R0,#+31
   \   000000C0   0xBF02             ITTT     EQ 
   \   000000C2   0x6A68             LDREQ    R0,[R5, #+36]
   \   000000C4   0x....             LDREQ.N  R2,??DataTable2_1  ;; 0x43425355
   \   000000C6   0x4290             CMPEQ    R0,R2
   \   000000C8   0xD15F             BNE.N    ??USB_DeviceMscBulkOut_9
   \   000000CA   0x784A             LDRB     R2,[R1, #+1]
   \   000000CC   0x20F0             MOVS     R0,#+240
   \   000000CE   0x4202             TST      R2,R0
   \   000000D0   0xBF02             ITTT     EQ 
   \   000000D2   0x788B             LDRBEQ   R3,[R1, #+2]
   \   000000D4   0x24E0             MOVEQ    R4,#+224
   \   000000D6   0x4223             TSTEQ    R3,R4
   \   000000D8   0xD157             BNE.N    ??USB_DeviceMscBulkOut_9
   \   000000DA   0x7B38             LDRB     R0,[R7, #+12]
   \   000000DC   0x1C40             ADDS     R0,R0,#+1
   \   000000DE   0x4282             CMP      R2,R0
   \   000000E0   0xDA53             BGE.N    ??USB_DeviceMscBulkOut_9
   \   000000E2   0x0018             MOVS     R0,R3
   \   000000E4   0xD051             BEQ.N    ??USB_DeviceMscBulkOut_9
   \   000000E6   0x2B11             CMP      R3,#+17
   \   000000E8   0xDA4F             BGE.N    ??USB_DeviceMscBulkOut_9
    376              {
    377                  mscHandle->cbwPrimeFlag = 0;
   \   000000EA   0x727E             STRB     R6,[R7, #+9]
    378                  mscHandle->transferRemaining = 0;
   \   000000EC   0x60AE             STR      R6,[R5, #+8]
    379          
    380                  mscHandle->mscCsw.signature = USB_DEVICE_MSC_DCSWSIGNATURE;
    381                  mscHandle->mscCsw.dataResidue = 0;
   \   000000EE   0x61CE             STR      R6,[R1, #+28]
   \   000000F0   0x....             LDR.N    R0,??DataTable2  ;; 0x53425355
   \   000000F2   0x6148             STR      R0,[R1, #+20]
    382                  mscHandle->mscCsw.tag = mscHandle->mscCbw.tag;
   \   000000F4   0x6AA8             LDR      R0,[R5, #+40]
   \   000000F6   0x6188             STR      R0,[R1, #+24]
    383          
    384                  mscHandle->cbwValidFlag = 0;
   \   000000F8   0x713E             STRB     R6,[R7, #+4]
    385          
    386                  mscHandle->mscCbw.dataTransferLength = USB_LONG_TO_LITTLE_ENDIAN(mscHandle->mscCbw.dataTransferLength);
   \   000000FA   0x6AE8             LDR      R0,[R5, #+44]
   \   000000FC   0x62E8             STR      R0,[R5, #+44]
    387          
    388                  mscHandle->dataOutFlag = (uint8_t)(((!(mscHandle->mscCbw.flags & USB_DEVICE_MSC_CBW_DIRECTION_BIT)) &&
    389                                                      (mscHandle->mscCbw.dataTransferLength)) ?
    390                                                         1 :
    391                                                         0);
   \   000000FE   0x780A             LDRB     R2,[R1, #+0]
   \   00000100   0x0612             LSLS     R2,R2,#+24
   \   00000102   0xD402             BMI.N    ??USB_DeviceMscBulkOut_10
   \   00000104   0xB110             CBZ.N    R0,??USB_DeviceMscBulkOut_11
   \   00000106   0x2001             MOVS     R0,#+1
   \   00000108   0xE000             B.N      ??USB_DeviceMscBulkOut_11
   \                     ??USB_DeviceMscBulkOut_10: (+1)
   \   0000010A   0x2000             MOVS     R0,#+0
   \                     ??USB_DeviceMscBulkOut_11: (+1)
   \   0000010C   0x7038             STRB     R0,[R7, #+0]
    392          
    393                  mscHandle->dataInFlag = (uint8_t)(
    394                      ((mscHandle->mscCbw.flags & USB_DEVICE_MSC_CBW_DIRECTION_BIT) && (mscHandle->mscCbw.dataTransferLength)) ?
    395                          1 :
    396                          0);
   \   0000010E   0x7808             LDRB     R0,[R1, #+0]
   \   00000110   0x0600             LSLS     R0,R0,#+24
   \   00000112   0xD503             BPL.N    ??USB_DeviceMscBulkOut_12
   \   00000114   0x6AE8             LDR      R0,[R5, #+44]
   \   00000116   0xB110             CBZ.N    R0,??USB_DeviceMscBulkOut_13
   \   00000118   0x2001             MOVS     R0,#+1
   \   0000011A   0xE000             B.N      ??USB_DeviceMscBulkOut_13
   \                     ??USB_DeviceMscBulkOut_12: (+1)
   \   0000011C   0x2000             MOVS     R0,#+0
   \                     ??USB_DeviceMscBulkOut_13: (+1)
   \   0000011E   0x7078             STRB     R0,[R7, #+1]
    397          
    398                  if ((0 != mscHandle->dataInFlag) && (0 != mscHandle->inEndpointStallFlag))
   \   00000120   0x7878             LDRB     R0,[R7, #+1]
   \   00000122   0x2800             CMP      R0,#+0
   \   00000124   0xBF1E             ITTT     NE 
   \   00000126   0x78B8             LDRBNE   R0,[R7, #+2]
   \   00000128   0x2800             CMPNE    R0,#+0
   \   0000012A   0x2001             MOVNE    R0,#+1
    399                  {
    400                      error = kStatus_USB_Error;
    401                      return error;
   \   0000012C   0xD139             BNE.N    ??USB_DeviceMscBulkOut_14
    402                  }
    403                  error = USB_DeviceMscProcessUfiCommand(mscHandle);
   \   0000012E   0x4640             MOV      R0,R8
   \   00000130   0x.... 0x....      BL       USB_DeviceMscProcessUfiCommand
   \   00000134   0x4606             MOV      R6,R0
    404                  if (error == kStatus_USB_InvalidRequest)
   \   00000136   0x2E05             CMP      R6,#+5
   \   00000138   0xD114             BNE.N    ??USB_DeviceMscBulkOut_15
    405                  {
    406                      if (mscHandle->dataOutFlag == 1)
   \   0000013A   0x7838             LDRB     R0,[R7, #+0]
   \   0000013C   0x2801             CMP      R0,#+1
   \   0000013E   0xD106             BNE.N    ??USB_DeviceMscBulkOut_16
    407                      {
    408                          if (mscHandle->outEndpointStallFlag == 0)
   \   00000140   0x78F8             LDRB     R0,[R7, #+3]
   \   00000142   0xB908             CBNZ.N   R0,??USB_DeviceMscBulkOut_17
    409                          {
    410                              mscHandle->needOutStallFlag = 1;
   \   00000144   0x2001             MOVS     R0,#+1
   \   00000146   0x7238             STRB     R0,[R7, #+8]
    411                          }
    412                          mscHandle->dataOutFlag = 0;
   \                     ??USB_DeviceMscBulkOut_17: (+1)
   \   00000148   0x2000             MOVS     R0,#+0
   \   0000014A   0x7038             STRB     R0,[R7, #+0]
   \   0000014C   0xE008             B.N      ??USB_DeviceMscBulkOut_18
    413                      }
    414                      else if (mscHandle->dataInFlag == 1)
   \                     ??USB_DeviceMscBulkOut_16: (+1)
   \   0000014E   0x7878             LDRB     R0,[R7, #+1]
   \   00000150   0x2801             CMP      R0,#+1
   \   00000152   0xD105             BNE.N    ??USB_DeviceMscBulkOut_18
    415                      {
    416                          if (mscHandle->inEndpointStallFlag == 0)
   \   00000154   0x78B8             LDRB     R0,[R7, #+2]
   \   00000156   0xB908             CBNZ.N   R0,??USB_DeviceMscBulkOut_19
    417                          {
    418                              mscHandle->needInStallFlag = 1;
   \   00000158   0x2001             MOVS     R0,#+1
   \   0000015A   0x71F8             STRB     R0,[R7, #+7]
    419                          }
    420                          mscHandle->dataInFlag = 0;
   \                     ??USB_DeviceMscBulkOut_19: (+1)
   \   0000015C   0x2000             MOVS     R0,#+0
   \   0000015E   0x7078             STRB     R0,[R7, #+1]
    421                      }
    422                      else
    423                      {
    424                      }
    425                      mscHandle->stallStatus = (uint8_t)USB_DEVICE_MSC_STALL_IN_DATA;
   \                     ??USB_DeviceMscBulkOut_18: (+1)
   \   00000160   0x2002             MOVS     R0,#+2
   \   00000162   0x72F8             STRB     R0,[R7, #+11]
    426                  }
    427          
    428                  if (!((mscHandle->dataOutFlag) || ((mscHandle->dataInFlag) || (mscHandle->needInStallFlag))))
   \                     ??USB_DeviceMscBulkOut_15: (+1)
   \   00000164   0x7838             LDRB     R0,[R7, #+0]
   \   00000166   0x2800             CMP      R0,#+0
   \   00000168   0xBF04             ITT      EQ 
   \   0000016A   0x7878             LDRBEQ   R0,[R7, #+1]
   \   0000016C   0x2800             CMPEQ    R0,#+0
   \   0000016E   0xD117             BNE.N    ??USB_DeviceMscBulkOut_2
   \   00000170   0x79F8             LDRB     R0,[R7, #+7]
   \   00000172   0xB9A8             CBNZ.N   R0,??USB_DeviceMscBulkOut_2
    429                  {
    430                      USB_DeviceSendRequest(mscHandle->handle, mscHandle->bulkInEndpoint, (uint8_t *)&mscHandle->mscCsw,
    431                                            USB_DEVICE_MSC_CSW_LENGTH);
   \                     ??USB_DeviceMscBulkOut_8: (+1)
   \   00000174   0x7B79             LDRB     R1,[R7, #+13]
   \   00000176   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000017A   0x230D             MOVS     R3,#+13
   \   0000017C   0xF108 0x0248      ADD      R2,R8,#+72
   \   00000180   0x.... 0x....      BL       USB_DeviceSendRequest
    432                      mscHandle->cswPrimeFlag = 1;
   \   00000184   0x2001             MOVS     R0,#+1
   \   00000186   0x72B8             STRB     R0,[R7, #+10]
   \   00000188   0xE00A             B.N      ??USB_DeviceMscBulkOut_2
    433                  }
    434              }
    435              else
    436              {
    437                  USB_DeviceStallEndpoint(mscHandle->handle, mscHandle->bulkOutEndpoint);
   \                     ??USB_DeviceMscBulkOut_9: (+1)
   \   0000018A   0x.... 0x....      BL       ?Subroutine3
    438                  USB_DeviceStallEndpoint(mscHandle->handle, mscHandle->bulkInEndpoint);
   \                     ??CrossCallReturnLabel_5: (+1)
   \   0000018E   0x7B79             LDRB     R1,[R7, #+13]
   \   00000190   0x.... 0x....      BL       ??Subroutine3_0
    439                  mscHandle->cbwValidFlag = 0;
    440                  mscHandle->outEndpointStallFlag = 1;
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000194   0x2001             MOVS     R0,#+1
   \   00000196   0x713E             STRB     R6,[R7, #+4]
   \   00000198   0x70F8             STRB     R0,[R7, #+3]
    441                  mscHandle->inEndpointStallFlag = 1;
   \   0000019A   0x70B8             STRB     R0,[R7, #+2]
    442                  mscHandle->stallStatus = (uint8_t)USB_DEVICE_MSC_STALL_IN_CBW;
   \   0000019C   0x72F8             STRB     R0,[R7, #+11]
    443                  mscHandle->performResetRecover = 1;
   \   0000019E   0x7178             STRB     R0,[R7, #+5]
    444              }
    445              return error;
   \                     ??USB_DeviceMscBulkOut_2: (+1)
   \   000001A0   0x4630             MOV      R0,R6
   \                     ??USB_DeviceMscBulkOut_14: (+1)
   \   000001A2                      REQUIRE ?Subroutine0
   \   000001A2                      ;; // Fall through to label ?Subroutine0
    446          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x7BB9             LDRB     R1,[R7, #+14]
   \                     ??Subroutine3_0: (+1)
   \   00000002   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000006   0x.... 0x....      B.W      USB_DeviceStallEndpoint
    447          
    448          /*!
    449           * @brief Initialize the endpoints of the msc class.
    450           *
    451           * This callback function is used to initialize the endpoints of the msc class.
    452           *
    453           * @param mscHandle          The device msc class handle. It equals the value returned from
    454           * usb_device_class_config_struct_t::classHandle.
    455           *
    456           * @return A USB error code or kStatus_USB_Success.
    457           */

   \                                 In section .text, align 2, keep-with-next
    458          usb_status_t USB_DeviceMscEndpointsInit(usb_device_msc_struct_t *mscHandle)
    459          {
   \                     USB_DeviceMscEndpointsInit: (+1)
   \   00000000   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
    460              usb_device_interface_list_t *interfaceList;
    461              usb_device_interface_struct_t *interface = (usb_device_interface_struct_t *)NULL;
    462              usb_status_t error = kStatus_USB_Error;
   \   00000006   0xF104 0x06EC      ADD      R6,R4,#+236
   \   0000000A   0x6860             LDR      R0,[R4, #+4]
   \   0000000C   0x6880             LDR      R0,[R0, #+8]
   \   0000000E   0x7C31             LDRB     R1,[R6, #+16]
   \   00000010   0x7942             LDRB     R2,[R0, #+5]
   \   00000012   0x2500             MOVS     R5,#+0
   \   00000014   0x428A             CMP      R2,R1
   \   00000016   0xF04F 0x0A01      MOV      R10,#+1
   \   0000001A   0xD322             BCC.N    ??USB_DeviceMscEndpointsInit_0
    463          
    464              /* Check the configuration is valid or not. */
    465              if (mscHandle->configuration > mscHandle->configurationStruct->classInfomation->configurations)
    466              {
    467                  return error;
    468              }
    469          
    470              /* Get the interface list of the new configuration. */
    471              /* Check the interface list is valid or not. */
    472              if (NULL == mscHandle->configurationStruct->classInfomation->interfaceList)
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xB300             CBZ.N    R0,??USB_DeviceMscEndpointsInit_0
    473              {
    474                  return error;
    475              }
    476              interfaceList = &mscHandle->configurationStruct->classInfomation->interfaceList[mscHandle->configuration - 1];
   \   00000020   0xEB00 0x00C1      ADD      R0,R0,R1, LSL #+3
   \   00000024   0x3808             SUBS     R0,R0,#+8
    477          
    478              /* Find interface by using the alternate setting of the interface. */
    479              for (int count = 0; count < interfaceList->count; count++)
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0xE000             B.N      ??USB_DeviceMscEndpointsInit_1
   \                     ??USB_DeviceMscEndpointsInit_2: (+1)
   \   0000002A   0x1C49             ADDS     R1,R1,#+1
   \                     ??USB_DeviceMscEndpointsInit_1: (+1)
   \   0000002C   0x7802             LDRB     R2,[R0, #+0]
   \   0000002E   0x4291             CMP      R1,R2
   \   00000030   0xDA17             BGE.N    ??USB_DeviceMscEndpointsInit_0
    480              {
    481                  if (USB_DEVICE_CONFIG_MSC_CLASS_CODE == interfaceList->interfaces[count].classCode)
   \   00000032   0x6842             LDR      R2,[R0, #+4]
   \   00000034   0x230C             MOVS     R3,#+12
   \   00000036   0x434B             MULS     R3,R3,R1
   \   00000038   0x441A             ADD      R2,R2,R3
   \   0000003A   0x7813             LDRB     R3,[R2, #+0]
   \   0000003C   0x2B08             CMP      R3,#+8
   \   0000003E   0xD1F4             BNE.N    ??USB_DeviceMscEndpointsInit_2
    482                  {
    483                      for (int index = 0; index < interfaceList->interfaces[count].count; index++)
   \   00000040   0xF896 0xC00F      LDRB     R12,[R6, #+15]
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE000             B.N      ??USB_DeviceMscEndpointsInit_3
   \                     ??USB_DeviceMscEndpointsInit_4: (+1)
   \   00000048   0x1C40             ADDS     R0,R0,#+1
   \                     ??USB_DeviceMscEndpointsInit_3: (+1)
   \   0000004A   0x7A11             LDRB     R1,[R2, #+8]
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xDA05             BGE.N    ??USB_DeviceMscEndpointsInit_5
    484                      {
    485                          if (interfaceList->interfaces[count].interface[index].alternateSetting == mscHandle->alternate)
   \   00000050   0x6851             LDR      R1,[R2, #+4]
   \   00000052   0x0103             LSLS     R3,R0,#+4
   \   00000054   0x5CCF             LDRB     R7,[R1, R3]
   \   00000056   0x4567             CMP      R7,R12
   \   00000058   0xD1F6             BNE.N    ??USB_DeviceMscEndpointsInit_4
    486                          {
    487                              interface = &interfaceList->interfaces[count].interface[index];
   \   0000005A   0x18CD             ADDS     R5,R1,R3
    488                              break;
    489                          }
    490                      }
    491                      mscHandle->interfaceNumber = interfaceList->interfaces[count].interfaceNumber;
   \                     ??USB_DeviceMscEndpointsInit_5: (+1)
   \   0000005C   0x78D0             LDRB     R0,[R2, #+3]
   \   0000005E   0x7470             STRB     R0,[R6, #+17]
    492                      break;
    493                  }
    494              }
    495              if (!interface)
   \   00000060   0xB90D             CBNZ.N   R5,??USB_DeviceMscEndpointsInit_6
    496              {
    497                  /* Return error if the interface is not found. */
    498                  return error;
   \                     ??USB_DeviceMscEndpointsInit_0: (+1)
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xE04B             B.N      ??USB_DeviceMscEndpointsInit_7
    499              }
    500          
    501              /* Keep new interface handle. */
    502              mscHandle->interfaceHandle = interface;
   \                     ??USB_DeviceMscEndpointsInit_6: (+1)
   \   00000066   0x60A5             STR      R5,[R4, #+8]
    503              /* Initialize the endpoints of the new interface. */
    504              for (int count = 0; count < interface->endpointList.count; count++)
   \   00000068   0xF04F 0x0900      MOV      R9,#+0
   \   0000006C   0x....             LDR.N    R7,??DataTable2_2
   \   0000006E   0x.... 0x....      LDR.W    R8,??DataTable2_3
   \   00000072   0xE008             B.N      ??USB_DeviceMscEndpointsInit_8
    505              {
    506                  usb_device_endpoint_init_struct_t epInitStruct;
    507                  usb_device_endpoint_callback_struct_t ep_callback;
    508                  epInitStruct.zlt = 0;
    509                  epInitStruct.endpointAddress = interface->endpointList.endpoint[count].endpointAddress;
    510                  epInitStruct.maxPacketSize = interface->endpointList.endpoint[count].maxPacketSize;
    511                  epInitStruct.transferType = interface->endpointList.endpoint[count].transferType;
    512          
    513                  if (USB_IN == ((epInitStruct.endpointAddress & USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_MASK) >>
    514                                 USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT))
    515                  {
    516                      mscHandle->bulkInEndpoint = epInitStruct.endpointAddress;
    517                      ep_callback.callbackFn = USB_DeviceMscBulkIn;
    518                  }
    519                  else
    520                  {
    521                      mscHandle->bulkOutEndpoint = epInitStruct.endpointAddress;
    522                      ep_callback.callbackFn = USB_DeviceMscBulkOut;
    523                  }
    524                  ep_callback.callbackParam = mscHandle;
   \                     ??USB_DeviceMscEndpointsInit_9: (+1)
   \   00000074   0x9403             STR      R4,[SP, #+12]
    525          
    526                  error = USB_DeviceInitEndpoint(mscHandle->handle, &epInitStruct, &ep_callback);
   \   00000076   0xAA02             ADD      R2,SP,#+8
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x4669             MOV      R1,SP
   \   0000007C   0x.... 0x....      BL       USB_DeviceInitEndpoint
   \   00000080   0x4682             MOV      R10,R0
   \   00000082   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??USB_DeviceMscEndpointsInit_8: (+1)
   \   00000086   0x7928             LDRB     R0,[R5, #+4]
   \   00000088   0x4581             CMP      R9,R0
   \   0000008A   0xDA19             BGE.N    ??USB_DeviceMscEndpointsInit_10
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   00000092   0x68A8             LDR      R0,[R5, #+8]
   \   00000094   0xF810 0x0029      LDRB     R0,[R0, R9, LSL #+2]
   \   00000098   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   0000009C   0x68A9             LDR      R1,[R5, #+8]
   \   0000009E   0xEB01 0x0189      ADD      R1,R1,R9, LSL #+2
   \   000000A2   0x884A             LDRH     R2,[R1, #+2]
   \   000000A4   0xF8AD 0x2000      STRH     R2,[SP, #+0]
   \   000000A8   0x7849             LDRB     R1,[R1, #+1]
   \   000000AA   0xF88D 0x1003      STRB     R1,[SP, #+3]
   \   000000AE   0x09C1             LSRS     R1,R0,#+7
   \   000000B0   0x2901             CMP      R1,#+1
   \   000000B2   0xBF07             ITTEE    EQ 
   \   000000B4   0x7370             STRBEQ   R0,[R6, #+13]
   \   000000B6   0xF8CD 0x8008      STREQ    R8,[SP, #+8]
   \   000000BA   0x73B0             STRBNE   R0,[R6, #+14]
   \   000000BC   0x9702             STRNE    R7,[SP, #+8]
   \   000000BE   0xE7D9             B.N      ??USB_DeviceMscEndpointsInit_9
    527              }
    528          
    529              mscHandle->dataOutFlag = 0;
   \                     ??USB_DeviceMscEndpointsInit_10: (+1)
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x7030             STRB     R0,[R6, #+0]
    530              mscHandle->dataInFlag = 0;
   \   000000C4   0x7070             STRB     R0,[R6, #+1]
    531              mscHandle->outEndpointStallFlag = 0;
   \   000000C6   0x70F0             STRB     R0,[R6, #+3]
    532              mscHandle->inEndpointStallFlag = 0;
   \   000000C8   0x70B0             STRB     R0,[R6, #+2]
    533              mscHandle->needOutStallFlag = 0;
   \   000000CA   0x7230             STRB     R0,[R6, #+8]
    534              mscHandle->needInStallFlag = 0;
   \   000000CC   0x71F0             STRB     R0,[R6, #+7]
    535              mscHandle->cbwValidFlag = 1;
   \   000000CE   0x2001             MOVS     R0,#+1
   \   000000D0   0x7130             STRB     R0,[R6, #+4]
    536              mscHandle->transferRemaining = 0;
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0x60E0             STR      R0,[R4, #+12]
    537              mscHandle->performResetRecover = 0;
   \   000000D6   0x7170             STRB     R0,[R6, #+5]
    538              mscHandle->performResetDoneFlag = 0;
   \   000000D8   0x71B0             STRB     R0,[R6, #+6]
    539              mscHandle->stallStatus = 0;
   \   000000DA   0x72F0             STRB     R0,[R6, #+11]
    540          
    541              if (mscHandle->cbwPrimeFlag == 1)
   \   000000DC   0x7A70             LDRB     R0,[R6, #+9]
   \   000000DE   0x2801             CMP      R0,#+1
   \   000000E0   0xD103             BNE.N    ??USB_DeviceMscEndpointsInit_11
    542              {
    543                  USB_DeviceCancel(mscHandle->handle, mscHandle->bulkOutEndpoint);
   \   000000E2   0x7BB1             LDRB     R1,[R6, #+14]
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0x.... 0x....      BL       USB_DeviceCancel
    544              }
    545              USB_DeviceRecvRequest(mscHandle->handle, mscHandle->bulkOutEndpoint, (uint8_t *)&mscHandle->mscCbw,
    546                                    USB_DEVICE_MSC_CBW_LENGTH);
   \                     ??USB_DeviceMscEndpointsInit_11: (+1)
   \   000000EA   0x7BB1             LDRB     R1,[R6, #+14]
   \   000000EC   0x6820             LDR      R0,[R4, #+0]
   \   000000EE   0x231F             MOVS     R3,#+31
   \   000000F0   0xF104 0x0228      ADD      R2,R4,#+40
   \   000000F4   0x.... 0x....      BL       USB_DeviceRecvRequest
    547              mscHandle->cbwPrimeFlag = 1;
   \   000000F8   0x2001             MOVS     R0,#+1
   \   000000FA   0x7270             STRB     R0,[R6, #+9]
    548          
    549              return error;
   \   000000FC   0x4650             MOV      R0,R10
   \                     ??USB_DeviceMscEndpointsInit_7: (+1)
   \   000000FE   0xB004             ADD      SP,SP,#+16
   \   00000100   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    550          }
    551          
    552          /*!
    553           * @brief De-initialize the endpoints of the msc class.
    554           *
    555           * This callback function is used to de-initialize the endpoints of the msc class.
    556           *
    557           * @param mscHandle          The device msc class handle. It equals the value returned from
    558           * usb_device_class_config_struct_t::classHandle.
    559           *
    560           * @return A USB error code or kStatus_USB_Success.
    561           */

   \                                 In section .text, align 2, keep-with-next
    562          usb_status_t USB_DeviceMscEndpointsDeinit(usb_device_msc_struct_t *mscHandle)
    563          {
   \                     USB_DeviceMscEndpointsDeinit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    564              usb_status_t error = kStatus_USB_Error;
   \   00000004   0x2001             MOVS     R0,#+1
    565          
    566              if (!mscHandle->interfaceHandle)
   \   00000006   0x68A1             LDR      R1,[R4, #+8]
   \   00000008   0xB161             CBZ.N    R1,??USB_DeviceMscEndpointsDeinit_0
    567              {
    568                  return error;
    569              }
    570              /* De-initialize all endpoints of the interface */
    571              for (int count = 0; count < mscHandle->interfaceHandle->endpointList.count; count++)
   \   0000000A   0x2500             MOVS     R5,#+0
   \   0000000C   0xE006             B.N      ??USB_DeviceMscEndpointsDeinit_1
    572              {
    573                  error = USB_DeviceDeinitEndpoint(mscHandle->handle,
    574                                                   mscHandle->interfaceHandle->endpointList.endpoint[count].endpointAddress);
   \                     ??USB_DeviceMscEndpointsDeinit_2: (+1)
   \   0000000E   0x6888             LDR      R0,[R1, #+8]
   \   00000010   0xF810 0x1025      LDRB     R1,[R0, R5, LSL #+2]
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x.... 0x....      BL       USB_DeviceDeinitEndpoint
    575              }
   \   0000001A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??USB_DeviceMscEndpointsDeinit_1: (+1)
   \   0000001C   0x68A1             LDR      R1,[R4, #+8]
   \   0000001E   0x790A             LDRB     R2,[R1, #+4]
   \   00000020   0x4295             CMP      R5,R2
   \   00000022   0xDBF4             BLT.N    ??USB_DeviceMscEndpointsDeinit_2
   \                     ??USB_DeviceMscEndpointsDeinit_0: (+1)
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    576              return error;
    577          }
    578          
    579          /*!
    580           * @brief Initialize the msc class.
    581           *
    582           * This function is used to initialize the msc class.
    583           *
    584           * @param controllerId   The controller id of the USB IP. Please refer to the enumeration usb_controller_index_t.
    585           * @param config          The class configuration information.
    586           * @param handle          It is out parameter, is used to return pointer of the msc class handle to the caller.
    587           *
    588           * @return A USB error code or kStatus_USB_Success.
    589           */

   \                                 In section .text, align 2, keep-with-next
    590          usb_status_t USB_DeviceMscInit(uint8_t controllerId, usb_device_class_config_struct_t *config, class_handle_t *handle)
    591          {
   \                     USB_DeviceMscInit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    592              usb_device_msc_struct_t *mscHandle;
    593              usb_status_t error = kStatus_USB_Error;
    594              uint32_t implementingDiskDrive = USB_DEVICE_CONFIG_MSC_IMPLEMENTING_DISK_DRIVE;
    595              usb_device_lba_information_struct_t diskInformation;
    596              usb_device_msc_ufi_struct_t *ufi = NULL;
    597          
    598              /* Allocate a msc class handle. */
    599              error = USB_DeviceMscAllocateHandle(&mscHandle);
   \   00000004   0x....             LDR.N    R5,??DataTable2_4
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x6829             LDR      R1,[R5, #+0]
   \   0000000A   0xB086             SUB      SP,SP,#+24
   \   0000000C   0x4614             MOV      R4,R2
   \   0000000E   0xB109             CBZ.N    R1,??USB_DeviceMscInit_0
    600          
    601              if (kStatus_USB_Success != error)
    602              {
    603                  return error;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE062             B.N      ??USB_DeviceMscInit_1
    604              }
    605          
    606              /* Get the device handle according to the controller id. */
    607              error = USB_DeviceClassGetDeviceHandle(controllerId, &mscHandle->handle);
   \                     ??USB_DeviceMscInit_0: (+1)
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0x.... 0x....      BL       USB_DeviceClassGetDeviceHandle
   \   0000001A   0x0006             MOVS     R6,R0
    608          
    609              if (kStatus_USB_Success != error)
   \   0000001C   0xD004             BEQ.N    ??USB_DeviceMscInit_2
    610              {
    611                  USB_DeviceMscFreeHandle(mscHandle);
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0x.... 0x....      BL       USB_DeviceMscFreeHandle
    612                  return error;
   \   00000024   0x4630             MOV      R0,R6
   \   00000026   0xE058             B.N      ??USB_DeviceMscInit_1
    613              }
    614              if (!mscHandle->handle)
   \                     ??USB_DeviceMscInit_2: (+1)
   \   00000028   0x6828             LDR      R0,[R5, #+0]
   \   0000002A   0xB920             CBNZ.N   R0,??USB_DeviceMscInit_3
    615              {
    616                  USB_DeviceMscFreeHandle(mscHandle);
   \   0000002C   0x4628             MOV      R0,R5
   \   0000002E   0x.... 0x....      BL       USB_DeviceMscFreeHandle
    617                  return kStatus_USB_InvalidHandle;
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0xE051             B.N      ??USB_DeviceMscInit_1
    618              }
    619              /* Save the configuration of the class. */
    620              mscHandle->configurationStruct = config;
   \                     ??USB_DeviceMscInit_3: (+1)
   \   00000036   0x606F             STR      R7,[R5, #+4]
    621              /* Clear the configuration value. */
    622              mscHandle->configuration = 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xF105 0x07F5      ADD      R7,R5,#+245
   \   0000003E   0x71F8             STRB     R0,[R7, #+7]
    623              mscHandle->alternate = 0xff;
   \   00000040   0x20FF             MOVS     R0,#+255
    624          
    625              /* Get device information. */
    626              error = mscHandle->configurationStruct->classCallback(
    627                  (class_handle_t)mscHandle, kUSB_DeviceMscEventGetLbaInformation, (void *)&diskInformation);
   \   00000042   0x686B             LDR      R3,[R5, #+4]
   \   00000044   0x71B8             STRB     R0,[R7, #+6]
   \   00000046   0x462E             MOV      R6,R5
   \   00000048   0x681B             LDR      R3,[R3, #+0]
   \   0000004A   0x466A             MOV      R2,SP
   \   0000004C   0x2105             MOVS     R1,#+5
   \   0000004E   0x4630             MOV      R0,R6
   \   00000050   0x4798             BLX      R3
   \   00000052   0x4680             MOV      R8,R0
    628          
    629              if (((diskInformation.lengthOfEachLba) && (diskInformation.totalLbaNumberSupports)) == 0)
   \   00000054   0x9801             LDR      R0,[SP, #+4]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xBF1C             ITT      NE 
   \   0000005A   0x9900             LDRNE    R1,[SP, #+0]
   \   0000005C   0x2900             CMPNE    R1,#+0
   \   0000005E   0xD038             BEQ.N    ??USB_DeviceMscInit_4
    630              {
    631                  error = kStatus_USB_Error;
    632                  USB_DeviceMscFreeHandle(mscHandle);
    633                  return error;
    634              }
    635              mscHandle->logicalUnitNumber = diskInformation.logicalUnitNumberSupported;
   \   00000060   0xF89D 0x1010      LDRB     R1,[SP, #+16]
    636              /*initialize the basic device information*/
    637              ufi = &mscHandle->mscUfi;
    638              mscHandle->totalLogicalBlockNumber = diskInformation.totalLbaNumberSupports;
   \   00000064   0x9A00             LDR      R2,[SP, #+0]
   \   00000066   0x70F9             STRB     R1,[R7, #+3]
   \   00000068   0x616A             STR      R2,[R5, #+20]
    639              mscHandle->lengthOfEachLba = diskInformation.lengthOfEachLba;
    640              mscHandle->logicalUnitNumber = diskInformation.logicalUnitNumberSupported - 1;
   \   0000006A   0x1E49             SUBS     R1,R1,#+1
   \   0000006C   0x70F9             STRB     R1,[R7, #+3]
    641              mscHandle->bulkInBufferSize = diskInformation.bulkInBufferSize;
    642              mscHandle->bulkOutBufferSize = diskInformation.bulkOutBufferSize;
    643              mscHandle->implementingDiskDrive = implementingDiskDrive;
    644          
    645              ufi->requestSense.validErrorCode = USB_DEVICE_MSC_UFI_REQ_SENSE_VALID_ERROR_CODE;
   \   0000006E   0x2270             MOVS     R2,#+112
   \   00000070   0x9902             LDR      R1,[SP, #+8]
   \   00000072   0x6229             STR      R1,[R5, #+32]
   \   00000074   0x61A8             STR      R0,[R5, #+24]
   \   00000076   0x9903             LDR      R1,[SP, #+12]
   \   00000078   0x6269             STR      R1,[R5, #+36]
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x61E9             STR      R1,[R5, #+28]
   \   0000007E   0xF105 0x0158      ADD      R1,R5,#+88
   \   00000082   0x700A             STRB     R2,[R1, #+0]
    646              ufi->requestSense.additionalSenseLength = USB_DEVICE_MSC_UFI_REQ_SENSE_ADDITIONAL_SENSE_LEN;
   \   00000084   0x220A             MOVS     R2,#+10
   \   00000086   0x71CA             STRB     R2,[R1, #+7]
    647              ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_NO_SENSE;
   \   00000088   0x2200             MOVS     R2,#+0
   \   0000008A   0x708A             STRB     R2,[R1, #+2]
    648              ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_NO_SENSE;
   \   0000008C   0x818A             STRH     R2,[R1, #+12]
    649              ufi->requestSense.additionalSenseQualifer = USB_DEVICE_MSC_UFI_NO_SENSE;
    650          
    651              ufi->readCapacity.lastLogicalBlockAddress = USB_LONG_TO_BIG_ENDIAN(mscHandle->totalLogicalBlockNumber - 1);
   \   0000008E   0x696A             LDR      R2,[R5, #+20]
   \   00000090   0x1E52             SUBS     R2,R2,#+1
   \   00000092   0x0213             LSLS     R3,R2,#+8
   \   00000094   0xF403 0x037F      AND      R3,R3,#0xFF0000
   \   00000098   0x0A15             LSRS     R5,R2,#+8
   \   0000009A   0xEA43 0x6302      ORR      R3,R3,R2, LSL #+24
   \   0000009E   0xF405 0x457F      AND      R5,R5,#0xFF00
   \   000000A2   0x432B             ORRS     R3,R5,R3
    652              ufi->readCapacity.blockSize = USB_LONG_TO_BIG_ENDIAN((uint32_t)mscHandle->lengthOfEachLba);
   \   000000A4   0x0A05             LSRS     R5,R0,#+8
   \   000000A6   0xF405 0x457F      AND      R5,R5,#0xFF00
   \   000000AA   0xEA43 0x6212      ORR      R2,R3,R2, LSR #+24
   \   000000AE   0x0203             LSLS     R3,R0,#+8
   \   000000B0   0xF403 0x037F      AND      R3,R3,#0xFF0000
   \   000000B4   0xEA43 0x6300      ORR      R3,R3,R0, LSL #+24
   \   000000B8   0x432B             ORRS     R3,R5,R3
   \   000000BA   0xEA43 0x6010      ORR      R0,R3,R0, LSR #+24
   \   000000BE   0x6308             STR      R0,[R1, #+48]
    653              ufi->readCapacity16.lastLogicalBlockAddress1 = USB_LONG_TO_BIG_ENDIAN(mscHandle->totalLogicalBlockNumber - 1);
    654              ufi->readCapacity16.blockSize = USB_LONG_TO_BIG_ENDIAN((uint32_t)mscHandle->lengthOfEachLba);
   \   000000C0   0x63C8             STR      R0,[R1, #+60]
   \   000000C2   0x62CA             STR      R2,[R1, #+44]
    655          
    656              mscHandle->cbwPrimeFlag = 0;
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x638A             STR      R2,[R1, #+56]
   \   000000C8   0x7038             STRB     R0,[R7, #+0]
    657              mscHandle->cswPrimeFlag = 0;
   \   000000CA   0x7078             STRB     R0,[R7, #+1]
    658          
    659              *handle = (class_handle_t)mscHandle;
   \   000000CC   0x6026             STR      R6,[R4, #+0]
    660              return error;
   \   000000CE   0x4640             MOV      R0,R8
   \   000000D0   0xE003             B.N      ??USB_DeviceMscInit_1
   \                     ??USB_DeviceMscInit_4: (+1)
   \   000000D2   0x4628             MOV      R0,R5
   \   000000D4   0x.... 0x....      BL       USB_DeviceMscFreeHandle
   \   000000D8   0x2001             MOVS     R0,#+1
   \                     ??USB_DeviceMscInit_1: (+1)
   \   000000DA   0xB006             ADD      SP,SP,#+24
   \   000000DC   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    661          }
    662          
    663          /*!
    664           * @brief De-initialize the device msc class.
    665           *
    666           * The function de-initializes the device msc class.
    667           *
    668           * @param handle The msc class handle got from usb_device_class_config_struct_t::classHandle.
    669           *
    670           * @return A USB error code or kStatus_USB_Success.
    671           */

   \                                 In section .text, align 2, keep-with-next
    672          usb_status_t USB_DeviceMscDeinit(class_handle_t handle)
    673          {
   \                     USB_DeviceMscDeinit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    674              usb_device_msc_struct_t *mscHandle;
    675              usb_status_t error = kStatus_USB_Error;
    676          
    677              mscHandle = (usb_device_msc_struct_t *)handle;
    678          
    679              if (!mscHandle)
   \   00000004   0xD101             BNE.N    ??USB_DeviceMscDeinit_0
    680              {
    681                  return kStatus_USB_InvalidHandle;
   \   00000006   0x2003             MOVS     R0,#+3
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}
    682              }
    683              error = USB_DeviceMscEndpointsDeinit(mscHandle);
   \                     ??USB_DeviceMscDeinit_0: (+1)
   \   0000000A   0x.... 0x....      BL       USB_DeviceMscEndpointsDeinit
   \   0000000E   0x4605             MOV      R5,R0
    684              USB_DeviceMscFreeHandle(mscHandle);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       USB_DeviceMscFreeHandle
    685              return error;
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    686          }
    687          
    688          /*!
    689           * @brief Handle the event passed to the msc class.
    690           *
    691           * This function handles the event passed to the msc class.
    692           *
    693           * @param handle          The msc class handle, got from the usb_device_class_config_struct_t::classHandle.
    694           * @param event           The event codes. Please refer to the enumeration usb_device_class_event_t.
    695           * @param param           The param type is determined by the event code.
    696           *
    697           * @return A USB error code or kStatus_USB_Success.
    698           * @retval kStatus_USB_Success              Free device handle successfully.
    699           * @retval kStatus_USB_InvalidParameter     The device handle not be found.
    700           * @retval kStatus_USB_InvalidRequest       The request is invalid, and the control pipe will be stalled by the caller.
    701           */

   \                                 In section .text, align 4, keep-with-next
    702          usb_status_t USB_DeviceMscEvent(void *handle, uint32_t event, void *param)
    703          {
   \                     USB_DeviceMscEvent: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x0017             MOVS     R7,R2
    704              usb_status_t error = kStatus_USB_Error;
    705              usb_device_msc_struct_t *mscHandle;
    706          
    707              uint16_t interfaceAlternate;
    708              uint8_t *temp8;
    709              uint8_t alternate;
    710          
    711              if ((!param) || (!handle))
   \   00000008   0xBF14             ITE      NE 
   \   0000000A   0x2D00             CMPNE    R5,#+0
   \   0000000C   0x2003             MOVEQ    R0,#+3
   \   0000000E   0xF04F 0x0801      MOV      R8,#+1
    712              {
    713                  return kStatus_USB_InvalidHandle;
   \   00000012   0xF000 0x80EB      BEQ.W    ??USB_DeviceMscEvent_1
    714              }
    715          
    716              /* Get the msc class handle. */
    717              mscHandle = (usb_device_msc_struct_t *)handle;
    718              switch (event)
   \   00000016   0x1D2C             ADDS     R4,R5,#+4
   \   00000018   0x1E49             SUBS     R1,R1,#+1
   \   0000001A   0x2905             CMP      R1,#+5
   \   0000001C   0xF105 0x06EE      ADD      R6,R5,#+238
   \   00000020   0xD806             BHI.N    ??USB_DeviceMscEvent_2
   \   00000022   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??USB_DeviceMscEvent_0:
   \   00000026   0xA8 0x03          DC8      0xA8,0x3,0x6,0x16
   \              0x06 0x16    
   \   0000002A   0x2D 0x50          DC8      0x2D,0x50
    719              {
    720                  case kUSB_DeviceClassEventDeviceReset:
    721                      /* Bus reset, clear the configuration. */
    722                      mscHandle->configuration = 0;
   \                     ??USB_DeviceMscEvent_3: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x73B0             STRB     R0,[R6, #+14]
    723                      break;
   \                     ??USB_DeviceMscEvent_2: (+1)
   \   00000030   0xE0DB             B.N      ??USB_DeviceMscEvent_4
    724                  case kUSB_DeviceClassEventSetConfiguration:
    725                      /* Get the new configuration. */
    726                      temp8 = ((uint8_t *)param);
    727                      if (!mscHandle->configurationStruct)
   \                     ??USB_DeviceMscEvent_5: (+1)
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xBF1E             ITTT     NE 
   \   00000038   0x7BB0             LDRBNE   R0,[R6, #+14]
   \   0000003A   0x7839             LDRBNE   R1,[R7, #+0]
   \   0000003C   0x4281             CMPNE    R1,R0
    728                      {
    729                          break;
    730                      }
    731                      if (*temp8 == mscHandle->configuration)
   \   0000003E   0xD0F7             BEQ.N    ??USB_DeviceMscEvent_2
    732                      {
    733                          break;
    734                      }
    735          
    736                      if (mscHandle->configuration)
   \   00000040   0xB110             CBZ.N    R0,??USB_DeviceMscEvent_6
    737                      {
    738                          /* De-initialize the endpoints when current configuration is none zero. */
    739                          error = USB_DeviceMscEndpointsDeinit(mscHandle);
   \   00000042   0x4628             MOV      R0,R5
   \   00000044   0x.... 0x....      BL       USB_DeviceMscEndpointsDeinit
    740                      }
    741                      /* Save new configuration. */
    742                      mscHandle->configuration = *temp8;
   \                     ??USB_DeviceMscEvent_6: (+1)
   \   00000048   0x7838             LDRB     R0,[R7, #+0]
   \   0000004A   0x73B0             STRB     R0,[R6, #+14]
    743                      /* Clear the alternate setting value. */
    744                      mscHandle->alternate = 0;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x7370             STRB     R0,[R6, #+13]
    745                      /* Initialize the endpoints of the new current configuration by using the alternate setting 0. */
    746                      error = USB_DeviceMscEndpointsInit(mscHandle);
   \   00000050   0xE011             B.N      ??USB_DeviceMscEvent_7
    747                      break;
    748                  case kUSB_DeviceClassEventSetInterface:
    749          
    750                      if (!mscHandle->configurationStruct)
   \                     ??USB_DeviceMscEvent_8: (+1)
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD0EB             BEQ.N    ??USB_DeviceMscEvent_2
    751                      {
    752                          break;
    753                      }
    754                      /* Get the new alternate setting of the interface */
    755                      interfaceAlternate = *((uint16_t *)param);
   \   00000058   0x8838             LDRH     R0,[R7, #+0]
    756                      /* Get the alternate setting value */
    757                      alternate = (uint8_t)(interfaceAlternate & 0xFF);
    758          
    759                      /* Whether the interface belongs to the class. */
    760                      if (mscHandle->interfaceNumber != ((uint8_t)(interfaceAlternate >> 8)))
   \   0000005A   0x7BF1             LDRB     R1,[R6, #+15]
   \   0000005C   0x4607             MOV      R7,R0
   \   0000005E   0x0400             LSLS     R0,R0,#+16
   \   00000060   0xEBB1 0x6F10      CMP      R1,R0, LSR #+24
   \   00000064   0xD10B             BNE.N    ??USB_DeviceMscEvent_9
    761                      {
    762                          break;
    763                      }
    764                      /* Only handle new alternate setting. */
    765                      if (alternate == mscHandle->alternate)
   \   00000066   0x7B71             LDRB     R1,[R6, #+13]
   \   00000068   0xB2F8             UXTB     R0,R7
   \   0000006A   0x4288             CMP      R0,R1
   \   0000006C   0xD007             BEQ.N    ??USB_DeviceMscEvent_9
    766                      {
    767                          break;
    768                      }
    769                      /* De-initialize old endpoints */
    770                      error = USB_DeviceMscEndpointsDeinit(mscHandle);
   \   0000006E   0x4628             MOV      R0,R5
   \   00000070   0x.... 0x....      BL       USB_DeviceMscEndpointsDeinit
    771                      mscHandle->alternate = alternate;
   \   00000074   0x7377             STRB     R7,[R6, #+13]
    772                      /* Initialize new endpoints */
    773                      error = USB_DeviceMscEndpointsInit(mscHandle);
   \                     ??USB_DeviceMscEvent_7: (+1)
   \   00000076   0x4628             MOV      R0,R5
   \   00000078   0x.... 0x....      BL       USB_DeviceMscEndpointsInit
   \   0000007C   0x4680             MOV      R8,R0
    774                      break;
   \                     ??USB_DeviceMscEvent_9: (+1)
   \   0000007E   0xE0B4             B.N      ??USB_DeviceMscEvent_4
    775                  case kUSB_DeviceClassEventSetEndpointHalt:
    776                      if ((!mscHandle->configurationStruct) || (!mscHandle->interfaceHandle))
   \                     ??USB_DeviceMscEvent_10: (+1)
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xBF1C             ITT      NE 
   \   00000086   0x6860             LDRNE    R0,[R4, #+4]
   \   00000088   0x2800             CMPNE    R0,#+0
   \   0000008A   0xD0F8             BEQ.N    ??USB_DeviceMscEvent_9
    777                      {
    778                          break;
    779                      }
    780                      /* Get the endpoint address */
    781                      temp8 = ((uint8_t *)param);
    782                      for (int count = 0; count < mscHandle->interfaceHandle->endpointList.count; count++)
   \   0000008C   0xF04F 0x0900      MOV      R9,#+0
   \                     ??USB_DeviceMscEvent_11: (+1)
   \   00000090   0x6860             LDR      R0,[R4, #+4]
   \   00000092   0x7901             LDRB     R1,[R0, #+4]
   \   00000094   0x4589             CMP      R9,R1
   \   00000096   0xDAF2             BGE.N    ??USB_DeviceMscEvent_9
    783                      {
    784                          if (*temp8 == mscHandle->interfaceHandle->endpointList.endpoint[count].endpointAddress)
   \   00000098   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_7: (+1)
   \   0000009C   0xD110             BNE.N    ??USB_DeviceMscEvent_12
    785                          {
    786                              if (mscHandle->inEndpointStallFlag == 0)
   \   0000009E   0x7830             LDRB     R0,[R6, #+0]
   \   000000A0   0xB928             CBNZ.N   R0,??USB_DeviceMscEvent_13
    787                              {
    788                                  /* Only stall the endpoint belongs to the class */
    789                                  error = USB_DeviceStallEndpoint(mscHandle->handle, *temp8);
   \   000000A2   0x6828             LDR      R0,[R5, #+0]
   \   000000A4   0x.... 0x....      BL       USB_DeviceStallEndpoint
   \   000000A8   0x4680             MOV      R8,R0
    790                                  mscHandle->inEndpointStallFlag = 1;
   \   000000AA   0x2001             MOVS     R0,#+1
   \   000000AC   0x7030             STRB     R0,[R6, #+0]
    791                              }
    792                              if (mscHandle->outEndpointStallFlag == 0)
   \                     ??USB_DeviceMscEvent_13: (+1)
   \   000000AE   0x7870             LDRB     R0,[R6, #+1]
   \   000000B0   0xB930             CBNZ.N   R0,??USB_DeviceMscEvent_12
    793                              {
    794                                  error = USB_DeviceStallEndpoint(mscHandle->handle, *temp8);
   \   000000B2   0x7839             LDRB     R1,[R7, #+0]
   \   000000B4   0x6828             LDR      R0,[R5, #+0]
   \   000000B6   0x.... 0x....      BL       USB_DeviceStallEndpoint
   \   000000BA   0x4680             MOV      R8,R0
    795                                  mscHandle->inEndpointStallFlag = 0;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x7030             STRB     R0,[R6, #+0]
    796                              }
    797                          }
    798                      }
   \                     ??USB_DeviceMscEvent_12: (+1)
   \   000000C0   0xF109 0x0901      ADD      R9,R9,#+1
   \   000000C4   0xE7E4             B.N      ??USB_DeviceMscEvent_11
    799          
    800                      break;
    801                  case kUSB_DeviceClassEventClearEndpointHalt:
    802                      if ((!mscHandle->configurationStruct) || (!mscHandle->interfaceHandle) ||
    803                          (mscHandle->performResetRecover == 1))
   \                     ??USB_DeviceMscEvent_14: (+1)
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xBF1F             ITTTT    NE 
   \   000000CC   0x6860             LDRNE    R0,[R4, #+4]
   \   000000CE   0x2800             CMPNE    R0,#+0
   \   000000D0   0x78F0             LDRBNE   R0,[R6, #+3]
   \   000000D2   0x2801             CMPNE    R0,#+1
   \   000000D4   0xD0D3             BEQ.N    ??USB_DeviceMscEvent_9
    804                      {
    805                          break;
    806                      }
    807                      /* Get the endpoint address */
    808                      temp8 = ((uint8_t *)param);
    809                      for (int count = 0; count < mscHandle->interfaceHandle->endpointList.count; count++)
   \   000000D6   0xF04F 0x0900      MOV      R9,#+0
   \   000000DA   0xE017             B.N      ??USB_DeviceMscEvent_15
    810                      {
    811                          if (*temp8 == mscHandle->interfaceHandle->endpointList.endpoint[count].endpointAddress)
   \                     ??USB_DeviceMscEvent_16: (+1)
   \   000000DC   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_8: (+1)
   \   000000E0   0xD112             BNE.N    ??USB_DeviceMscEvent_17
    812                          {
    813                              /* Only un-stall the endpoint belongs to the class , If the dedpoint is in stall status ,then
    814                               * un-stall it*/
    815                              if (mscHandle->inEndpointStallFlag == 1)
   \   000000E2   0x7830             LDRB     R0,[R6, #+0]
   \   000000E4   0x2801             CMP      R0,#+1
   \   000000E6   0xD105             BNE.N    ??USB_DeviceMscEvent_18
    816                              {
    817                                  error = USB_DeviceUnstallEndpoint(mscHandle->handle, *temp8);
   \   000000E8   0x6828             LDR      R0,[R5, #+0]
   \   000000EA   0x.... 0x....      BL       USB_DeviceUnstallEndpoint
   \   000000EE   0x4680             MOV      R8,R0
    818                                  mscHandle->inEndpointStallFlag = 0;
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0x7030             STRB     R0,[R6, #+0]
    819                              }
    820                              if (mscHandle->outEndpointStallFlag == 1)
   \                     ??USB_DeviceMscEvent_18: (+1)
   \   000000F4   0x7870             LDRB     R0,[R6, #+1]
   \   000000F6   0x2801             CMP      R0,#+1
   \   000000F8   0xD106             BNE.N    ??USB_DeviceMscEvent_17
    821                              {
    822                                  error = USB_DeviceUnstallEndpoint(mscHandle->handle, *temp8);
   \   000000FA   0x7839             LDRB     R1,[R7, #+0]
   \   000000FC   0x6828             LDR      R0,[R5, #+0]
   \   000000FE   0x.... 0x....      BL       USB_DeviceUnstallEndpoint
   \   00000102   0x4680             MOV      R8,R0
    823                                  mscHandle->inEndpointStallFlag = 0;
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0x7030             STRB     R0,[R6, #+0]
    824                              }
    825                          }
    826                      }
   \                     ??USB_DeviceMscEvent_17: (+1)
   \   00000108   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??USB_DeviceMscEvent_15: (+1)
   \   0000010C   0x6860             LDR      R0,[R4, #+4]
   \   0000010E   0x7901             LDRB     R1,[R0, #+4]
   \   00000110   0x4589             CMP      R9,R1
   \   00000112   0xDBE3             BLT.N    ??USB_DeviceMscEvent_16
   \   00000114   0x7A70             LDRB     R0,[R6, #+9]
   \   00000116   0x2803             CMP      R0,#+3
   \   00000118   0xBF18             IT       NE 
   \   0000011A   0x2802             CMPNE    R0,#+2
   \   0000011C   0xD113             BNE.N    ??USB_DeviceMscEvent_19
   \   0000011E   0x7930             LDRB     R0,[R6, #+4]
   \   00000120   0x2801             CMP      R0,#+1
   \   00000122   0xD013             BEQ.N    ??USB_DeviceMscEvent_20
    827                      if (((mscHandle->stallStatus == USB_DEVICE_MSC_STALL_IN_CSW) ||
    828                           (mscHandle->stallStatus == USB_DEVICE_MSC_STALL_IN_DATA)) &&
    829                          (mscHandle->performResetDoneFlag != 1))
    830                      {
    831                          if (mscHandle->cswPrimeFlag == 1)
   \   00000124   0x7A30             LDRB     R0,[R6, #+8]
   \   00000126   0x2801             CMP      R0,#+1
   \   00000128   0xD103             BNE.N    ??USB_DeviceMscEvent_21
    832                          {
    833                              USB_DeviceCancel(mscHandle->handle, mscHandle->bulkInEndpoint);
   \   0000012A   0x7AF1             LDRB     R1,[R6, #+11]
   \   0000012C   0x6828             LDR      R0,[R5, #+0]
   \   0000012E   0x.... 0x....      BL       USB_DeviceCancel
    834                          }
    835                          /*send csw*/
    836                          USB_DeviceSendRequest(mscHandle->handle, mscHandle->bulkInEndpoint, (uint8_t *)&mscHandle->mscCsw,
    837                                                USB_DEVICE_MSC_CSW_LENGTH);
   \                     ??USB_DeviceMscEvent_21: (+1)
   \   00000132   0x7AF1             LDRB     R1,[R6, #+11]
   \   00000134   0x6828             LDR      R0,[R5, #+0]
   \   00000136   0x230D             MOVS     R3,#+13
   \   00000138   0xF105 0x0248      ADD      R2,R5,#+72
   \   0000013C   0x.... 0x....      BL       USB_DeviceSendRequest
    838                          mscHandle->cswPrimeFlag = 0;
   \   00000140   0x2000             MOVS     R0,#+0
   \   00000142   0x7230             STRB     R0,[R6, #+8]
    839                          mscHandle->stallStatus = 0;
   \   00000144   0x7270             STRB     R0,[R6, #+9]
    840                      }
    841                      if ((mscHandle->performResetDoneFlag == 1) && (mscHandle->inEndpointStallFlag == 0) &&
    842                          (mscHandle->outEndpointStallFlag == 0))
   \                     ??USB_DeviceMscEvent_19: (+1)
   \   00000146   0x7930             LDRB     R0,[R6, #+4]
   \   00000148   0x2801             CMP      R0,#+1
   \   0000014A   0xD14E             BNE.N    ??USB_DeviceMscEvent_4
   \                     ??USB_DeviceMscEvent_20: (+1)
   \   0000014C   0x7830             LDRB     R0,[R6, #+0]
   \   0000014E   0x2800             CMP      R0,#+0
   \   00000150   0xBF04             ITT      EQ 
   \   00000152   0x7870             LDRBEQ   R0,[R6, #+1]
   \   00000154   0x2800             CMPEQ    R0,#+0
   \   00000156   0xD148             BNE.N    ??USB_DeviceMscEvent_4
    843                      {
    844                          mscHandle->performResetDoneFlag = 0;
   \   00000158   0x7130             STRB     R0,[R6, #+4]
    845                          if (mscHandle->cswPrimeFlag == 1)
   \   0000015A   0x7A30             LDRB     R0,[R6, #+8]
   \   0000015C   0x2801             CMP      R0,#+1
   \   0000015E   0xD103             BNE.N    ??USB_DeviceMscEvent_22
    846                          {
    847                              USB_DeviceCancel(mscHandle->handle, mscHandle->bulkInEndpoint);
   \   00000160   0x7AF1             LDRB     R1,[R6, #+11]
   \   00000162   0x6828             LDR      R0,[R5, #+0]
   \   00000164   0x.... 0x....      BL       USB_DeviceCancel
    848                          }
    849                          /*prime cbw for new transfer*/
    850                          USB_DeviceRecvRequest(mscHandle->handle, mscHandle->bulkOutEndpoint, (uint8_t *)&mscHandle->mscCbw,
    851                                                USB_DEVICE_MSC_CBW_LENGTH);
   \                     ??USB_DeviceMscEvent_22: (+1)
   \   00000168   0x7B31             LDRB     R1,[R6, #+12]
   \   0000016A   0x.... 0x....      BL       ?Subroutine2
    852                          mscHandle->cswPrimeFlag = 0;
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0x7230             STRB     R0,[R6, #+8]
    853                          mscHandle->stallStatus = 0;
   \   00000172   0x7270             STRB     R0,[R6, #+9]
   \   00000174   0xE039             B.N      ??USB_DeviceMscEvent_4
    854                      }
    855                      break;
    856                  case kUSB_DeviceClassEventClassRequest:
    857                      if (param)
    858                      {
    859                          /* Handle the msc class specific request. */
    860                          usb_device_control_request_struct_t *control_request = (usb_device_control_request_struct_t *)param;
    861          
    862                          if ((control_request->setup->bmRequestType & USB_REQUEST_TYPE_RECIPIENT_MASK) !=
    863                              USB_REQUEST_TYPE_RECIPIENT_INTERFACE)
   \                     ??USB_DeviceMscEvent_23: (+1)
   \   00000176   0x6839             LDR      R1,[R7, #+0]
   \   00000178   0x7808             LDRB     R0,[R1, #+0]
   \   0000017A   0xF000 0x021F      AND      R2,R0,#0x1F
   \   0000017E   0x2A01             CMP      R2,#+1
   \   00000180   0xBF01             ITTTT    EQ 
   \   00000182   0x7BF2             LDRBEQ   R2,[R6, #+15]
   \   00000184   0x888B             LDRHEQ   R3,[R1, #+4]
   \   00000186   0xF003 0x04FF      ANDEQ    R4,R3,#0xFF
   \   0000018A   0x4294             CMPEQ    R4,R2
    864                          {
    865                              break;
    866                          }
    867          
    868                          if ((control_request->setup->wIndex & 0xFF) != mscHandle->interfaceNumber)
   \   0000018C   0xD12D             BNE.N    ??USB_DeviceMscEvent_4
    869                          {
    870                              break;
    871                          }
    872          
    873                          switch (control_request->setup->bRequest)
   \   0000018E   0x784C             LDRB     R4,[R1, #+1]
   \   00000190   0x2CFE             CMP      R4,#+254
   \   00000192   0xD002             BEQ.N    ??USB_DeviceMscEvent_24
   \   00000194   0x2CFF             CMP      R4,#+255
   \   00000196   0xD011             BEQ.N    ??USB_DeviceMscEvent_25
   \   00000198   0xE027             B.N      ??USB_DeviceMscEvent_4
    874                          {
    875                              case USB_DEVICE_MSC_GET_MAX_LUN:
    876                                  /*Get Max LUN */
    877                                  if ((control_request->setup->wIndex == mscHandle->interfaceNumber) &&
    878                                      (!control_request->setup->wValue) && (control_request->setup->wLength <= 0x0001) &&
    879                                      ((control_request->setup->bmRequestType & USB_REQUSET_TYPE_DIR_MASK) ==
    880                                       USB_REQUEST_TYPE_DIR_IN))
   \                     ??USB_DeviceMscEvent_24: (+1)
   \   0000019A   0x4293             CMP      R3,R2
   \   0000019C   0xBF04             ITT      EQ 
   \   0000019E   0x884A             LDRHEQ   R2,[R1, #+2]
   \   000001A0   0x2A00             CMPEQ    R2,#+0
   \   000001A2   0xD120             BNE.N    ??USB_DeviceMscEvent_26
   \   000001A4   0x88C9             LDRH     R1,[R1, #+6]
   \   000001A6   0x2902             CMP      R1,#+2
   \   000001A8   0xDA1D             BGE.N    ??USB_DeviceMscEvent_26
   \   000001AA   0x0600             LSLS     R0,R0,#+24
   \   000001AC   0xD51B             BPL.N    ??USB_DeviceMscEvent_26
    881                                  {
    882                                      control_request->buffer = &mscHandle->logicalUnitNumber;
   \   000001AE   0xF105 0x00F8      ADD      R0,R5,#+248
   \   000001B2   0x6078             STR      R0,[R7, #+4]
    883                                      control_request->length = (uint32_t)control_request->setup->wLength;
   \   000001B4   0x6838             LDR      R0,[R7, #+0]
   \   000001B6   0x88C0             LDRH     R0,[R0, #+6]
   \   000001B8   0x60B8             STR      R0,[R7, #+8]
   \   000001BA   0xE016             B.N      ??USB_DeviceMscEvent_4
    884                                  }
    885                                  else
    886                                  {
    887                                      error = kStatus_USB_InvalidRequest;
    888                                  }
    889          
    890                                  break;
    891                              case USB_DEVICE_MSC_BULK_ONLY_MASS_STORAGE_RESET:
    892                                  /*Bulk-Only Mass Storage Reset (class-specific request)*/
    893                                  if ((control_request->setup->wIndex == mscHandle->interfaceNumber) &&
    894                                      (!control_request->setup->wValue) && (!control_request->setup->wLength) &&
    895                                      ((control_request->setup->bmRequestType & USB_REQUSET_TYPE_DIR_MASK) ==
    896                                       USB_REQUEST_TYPE_DIR_OUT))
   \                     ??USB_DeviceMscEvent_25: (+1)
   \   000001BC   0x4293             CMP      R3,R2
   \   000001BE   0xBF04             ITT      EQ 
   \   000001C0   0x884A             LDRHEQ   R2,[R1, #+2]
   \   000001C2   0x2A00             CMPEQ    R2,#+0
   \   000001C4   0xD10F             BNE.N    ??USB_DeviceMscEvent_26
   \   000001C6   0x88C9             LDRH     R1,[R1, #+6]
   \   000001C8   0xB969             CBNZ.N   R1,??USB_DeviceMscEvent_26
   \   000001CA   0x0600             LSLS     R0,R0,#+24
   \   000001CC   0xD40B             BMI.N    ??USB_DeviceMscEvent_26
    897                                  {
    898                                      error = USB_DeviceMscEndpointsDeinit(mscHandle);
   \   000001CE   0x4628             MOV      R0,R5
   \   000001D0   0x.... 0x....      BL       USB_DeviceMscEndpointsDeinit
    899                                      error = USB_DeviceMscEndpointsInit(mscHandle);
   \   000001D4   0x4628             MOV      R0,R5
   \   000001D6   0x.... 0x....      BL       USB_DeviceMscEndpointsInit
   \   000001DA   0x4680             MOV      R8,R0
    900                                      mscHandle->performResetRecover = 0;
   \   000001DC   0x2000             MOVS     R0,#+0
   \   000001DE   0x70F0             STRB     R0,[R6, #+3]
    901                                      mscHandle->performResetDoneFlag = 1;
   \   000001E0   0x2001             MOVS     R0,#+1
   \   000001E2   0x7130             STRB     R0,[R6, #+4]
   \   000001E4   0xE001             B.N      ??USB_DeviceMscEvent_4
    902                                  }
    903                                  else
    904                                  {
    905                                      error = kStatus_USB_InvalidRequest;
   \                     ??USB_DeviceMscEvent_26: (+1)
   \   000001E6   0xF04F 0x0805      MOV      R8,#+5
    906                                  }
    907          
    908                                  break;
    909                              default:
    910                                  break;
    911                          }
    912                      }
    913                      break;
    914                  default:
    915                      break;
    916              }
    917          
    918              return error;
   \                     ??USB_DeviceMscEvent_4: (+1)
   \   000001EA   0x4640             MOV      R0,R8
   \                     ??USB_DeviceMscEvent_1: (+1)
   \   000001EC   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    919          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x6880             LDR      R0,[R0, #+8]
   \   00000002   0x7839             LDRB     R1,[R7, #+0]
   \   00000004   0xF810 0x0029      LDRB     R0,[R0, R9, LSL #+2]
   \   00000008   0x4281             CMP      R1,R0
   \   0000000A   0x4770             BX       LR
    920          
    921          /*!
    922           * @brief Send data through a specified endpoint.
    923           *
    924           * The function is used to send data through a specified endpoint.
    925           * The function calls USB_DeviceSendRequest internally.
    926           *
    927           * @param handle The msc class handle got from usb_device_class_config_struct_t::classHandle.
    928           *
    929           * @return A USB error code or kStatus_USB_Success.
    930           *
    931           * @note The return value just means if the sending request is successful or not; the transfer done is notified by
    932           * USB_DeviceMscBulkIn.
    933           * Currently, only one transfer request can be supported for one specific endpoint.
    934           * If there is a specific requirement to support multiple transfer requests for one specific endpoint, the application
    935           * should implement a queue in the application level.
    936           * The subsequent transfer could begin only when the previous transfer is done (get notification through the endpoint
    937           * callback).
    938           */

   \                                 In section .text, align 2, keep-with-next
    939          usb_status_t USB_DeviceMscSend(usb_device_msc_struct_t *mscHandle)
    940          {
   \                     USB_DeviceMscSend: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine1
    941              usb_status_t error = kStatus_USB_Success;
    942              usb_device_lba_app_struct_t lba;
    943          
    944              lba.offset = mscHandle->currentOffset;
    945              /*bulkInBufferSize is the application buffer size, USB_DEVICE_MSC_MAX_SEND_TRANSFER_LENGTH is the max transfer
    946                 length by the hardware,
    947                  lba.size is the data pending  for transfer ,select the minimum size to transfer ,the remaining will be transfer
    948                 next time*/
    949              lba.size = (mscHandle->bulkInBufferSize > USB_DEVICE_MSC_MAX_SEND_TRANSFER_LENGTH) ?
    950                             USB_DEVICE_MSC_MAX_SEND_TRANSFER_LENGTH :
    951                             mscHandle->bulkInBufferSize;
    952              lba.size =
    953                  (mscHandle->transferRemaining > lba.size) ? lba.size : mscHandle->transferRemaining; /* which one is smaller */
    954          
    955              lba.buffer = NULL;
    956              mscHandle->configurationStruct->classCallback((class_handle_t)mscHandle, kUSB_DeviceMscEventReadRequest, &lba);
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000006   0x6A20             LDR      R0,[R4, #+32]
   \   00000008   0xF1B0 0x1F01      CMP      R0,#+65537
   \   0000000C   0xBF28             IT       CS 
   \   0000000E   0xF44F 0x3080      MOVCS    R0,#+65536
   \   00000012   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000016   0xBF38             IT       CC 
   \   00000018   0x4608             MOVCC    R0,R1
   \   0000001A   0x9001             STR      R0,[SP, #+4]
   \   0000001C   0x2104             MOVS     R1,#+4
   \   0000001E   0x6863             LDR      R3,[R4, #+4]
   \   00000020   0x681B             LDR      R3,[R3, #+0]
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x4798             BLX      R3
    957          
    958              if (mscHandle->currentOffset < (mscHandle->totalLogicalBlockNumber * mscHandle->lengthOfEachLba))
   \   00000026   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_11: (+1)
   \   0000002A   0xF104 0x00ED      ADD      R0,R4,#+237
   \   0000002E   0xD207             BCS.N    ??USB_DeviceMscSend_0
    959              {
    960                  error = USB_DeviceSendRequest(mscHandle->handle, mscHandle->bulkInEndpoint, lba.buffer, lba.size);
   \   00000030   0x7B01             LDRB     R1,[R0, #+12]
   \   00000032   0x9B01             LDR      R3,[SP, #+4]
   \   00000034   0x9A02             LDR      R2,[SP, #+8]
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x.... 0x....      BL       USB_DeviceSendRequest
   \   0000003C   0x4605             MOV      R5,R0
   \   0000003E   0xE009             B.N      ??USB_DeviceMscSend_1
    961              }
    962              else
    963              {
    964                  mscHandle->needInStallFlag = 0;
    965                  mscHandle->inEndpointStallFlag = 1;
   \                     ??USB_DeviceMscSend_0: (+1)
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0x7041             STRB     R1,[R0, #+1]
   \   00000044   0x7185             STRB     R5,[R0, #+6]
    966                  mscHandle->dataInFlag = 0;
    967                  mscHandle->stallStatus = (uint8_t)USB_DEVICE_MSC_STALL_IN_DATA;
   \   00000046   0x2102             MOVS     R1,#+2
   \   00000048   0x7281             STRB     R1,[R0, #+10]
   \   0000004A   0x7005             STRB     R5,[R0, #+0]
    968                  USB_DeviceStallEndpoint(mscHandle->handle, mscHandle->bulkInEndpoint);
   \   0000004C   0x7B01             LDRB     R1,[R0, #+12]
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x.... 0x....      BL       USB_DeviceStallEndpoint
    969              }
    970              return error;
   \                     ??USB_DeviceMscSend_1: (+1)
   \   00000054   0x4628             MOV      R0,R5
   \   00000056   0xBD3E             POP      {R1-R5,PC}       ;; return
    971          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x6962             LDR      R2,[R4, #+20]
   \   00000002   0x69A3             LDR      R3,[R4, #+24]
   \   00000004   0x6921             LDR      R1,[R4, #+16]
   \   00000006   0x435A             MULS     R2,R3,R2
   \   00000008   0x4291             CMP      R1,R2
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x9001             STR      R0,[SP, #+4]
   \   00000002   0x9901             LDR      R1,[SP, #+4]
   \   00000004   0x68E0             LDR      R0,[R4, #+12]
   \   00000006   0x9502             STR      R5,[SP, #+8]
   \   00000008   0x4281             CMP      R1,R0
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x2500             MOVS     R5,#+0
   \   00000004   0x6920             LDR      R0,[R4, #+16]
   \   00000006   0x9000             STR      R0,[SP, #+0]
   \   00000008   0x466A             MOV      R2,SP
   \   0000000A   0x4770             BX       LR
    972          
    973          /*!
    974           * @brief Receive data through a specified endpoint.
    975           *
    976           * The function is used to receive data through a specified endpoint.
    977           * The function calls USB_DeviceRecvRequest internally.
    978           *
    979           * @param handle The msc class handle got from usb_device_class_config_struct_t::classHandle.
    980           *
    981           * @return A USB error code or kStatus_USB_Success.
    982           *
    983           * @note The return value just means if the receiving request is successful or not; the transfer done is notified by
    984           * USB_DeviceMscBulkOut.
    985           * Currently, only one transfer request can be supported for one specific endpoint.
    986           * If there is a specific requirement to support multiple transfer requests for one specific endpoint, the application
    987           * should implement a queue in the application level.
    988           * The subsequent transfer could begin only when the previous transfer is done (get notification through the endpoint
    989           * callback).
    990           */

   \                                 In section .text, align 2, keep-with-next
    991          usb_status_t USB_DeviceMscRecv(usb_device_msc_struct_t *mscHandle)
    992          {
   \                     USB_DeviceMscRecv: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine1
    993              usb_status_t error = kStatus_USB_Success;
    994              usb_device_lba_app_struct_t lba;
    995          
    996              lba.offset = mscHandle->currentOffset;
    997              /*bulkOutBufferSize is the application buffer size, USB_DEVICE_MSC_MAX_RECV_TRANSFER_LENGTH is the max transfer
    998                 length by the hardware,
    999                 lba.size is the data pending  for transfer ,select the minimum size to transfer ,the remaining will be transfer
   1000                 next time*/
   1001              lba.size = (mscHandle->bulkOutBufferSize > USB_DEVICE_MSC_MAX_RECV_TRANSFER_LENGTH) ?
   1002                             USB_DEVICE_MSC_MAX_RECV_TRANSFER_LENGTH :
   1003                             mscHandle->bulkOutBufferSize;
   1004              lba.size =
   1005                  (mscHandle->transferRemaining > lba.size) ? lba.size : mscHandle->transferRemaining; /* whichever is smaller */
   1006          
   1007              lba.buffer = NULL;
   1008              mscHandle->configurationStruct->classCallback((class_handle_t)mscHandle, kUSB_DeviceMscEventWriteRequest, &lba);
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000006   0x6A60             LDR      R0,[R4, #+36]
   \   00000008   0xF1B0 0x1F01      CMP      R0,#+65537
   \   0000000C   0xBF28             IT       CS 
   \   0000000E   0xF44F 0x3080      MOVCS    R0,#+65536
   \   00000012   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_10: (+1)
   \   00000016   0xBF38             IT       CC 
   \   00000018   0x4608             MOVCC    R0,R1
   \   0000001A   0x9001             STR      R0,[SP, #+4]
   \   0000001C   0x2103             MOVS     R1,#+3
   \   0000001E   0x6863             LDR      R3,[R4, #+4]
   \   00000020   0x681B             LDR      R3,[R3, #+0]
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x4798             BLX      R3
   1009          
   1010              if (mscHandle->currentOffset < (mscHandle->totalLogicalBlockNumber * mscHandle->lengthOfEachLba))
   \   00000026   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_12: (+1)
   \   0000002A   0xF104 0x00EC      ADD      R0,R4,#+236
   \   0000002E   0xD207             BCS.N    ??USB_DeviceMscRecv_0
   1011              {
   1012                  error = USB_DeviceRecvRequest(mscHandle->handle, mscHandle->bulkOutEndpoint, lba.buffer, lba.size);
   \   00000030   0x7B81             LDRB     R1,[R0, #+14]
   \   00000032   0x9B01             LDR      R3,[SP, #+4]
   \   00000034   0x9A02             LDR      R2,[SP, #+8]
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x.... 0x....      BL       USB_DeviceRecvRequest
   \   0000003C   0x4605             MOV      R5,R0
   \   0000003E   0xE009             B.N      ??USB_DeviceMscRecv_1
   1013              }
   1014              else
   1015              {
   1016                  mscHandle->needOutStallFlag = 0;
   1017                  mscHandle->outEndpointStallFlag = 1;
   \                     ??USB_DeviceMscRecv_0: (+1)
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0x70C1             STRB     R1,[R0, #+3]
   \   00000044   0x7205             STRB     R5,[R0, #+8]
   1018                  mscHandle->dataOutFlag = 0;
   1019                  mscHandle->stallStatus = (uint8_t)USB_DEVICE_MSC_STALL_IN_DATA;
   \   00000046   0x2102             MOVS     R1,#+2
   \   00000048   0x72C1             STRB     R1,[R0, #+11]
   \   0000004A   0x7005             STRB     R5,[R0, #+0]
   1020                  USB_DeviceStallEndpoint(mscHandle->handle, mscHandle->bulkOutEndpoint);
   \   0000004C   0x7B81             LDRB     R1,[R0, #+14]
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x.... 0x....      BL       USB_DeviceStallEndpoint
   1021              }
   1022              return error;
   \                     ??USB_DeviceMscRecv_1: (+1)
   \   00000054   0x4628             MOV      R0,R5
   \   00000056   0xBD3E             POP      {R1-R5,PC}       ;; return
   1023          }
   1024          
   1025          /*!
   1026           * @brief Recv Send data through a specified endpoint.
   1027           *
   1028           * The function is used when ufi process read/write command .
   1029           * The function calls USB_DeviceMscRecv or  usb_device_send_recv as the direction internally.
   1030           *
   1031           * @param handle The msc class handle got from usb_device_class_config_struct_t::classHandle.
   1032           * @param direction     Data direction: 0 = Data-Out from host to the device, 1 = Data-In from the device to the host.
   1033           * @param buffer The memory address to hold the data need to be sent.
   1034           * @return A USB error code or kStatus_USB_Success.
   1035           *
   1036           * @note The return value just means if the sending or reciving request is successful or not.
   1037           */

   \                                 In section .text, align 2, keep-with-next
   1038          usb_status_t USB_DeviceMscLbaTransfer(usb_device_msc_struct_t *mscHandle,
   1039                                                uint8_t direction,
   1040                                                usb_lba_transfer_information_struct_t *lba_info_ptr)
   1041          {
   \                     USB_DeviceMscLbaTransfer: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1042              usb_status_t error = kStatus_USB_Success;
   1043          
   1044              mscHandle->transferRemaining = lba_info_ptr->transferNumber * mscHandle->lengthOfEachLba;
   \   00000002   0x6853             LDR      R3,[R2, #+4]
   \   00000004   0x6984             LDR      R4,[R0, #+24]
   \   00000006   0x4363             MULS     R3,R4,R3
   \   00000008   0x60C3             STR      R3,[R0, #+12]
   1045              mscHandle->currentOffset = lba_info_ptr->startingLogicalBlockAddress * mscHandle->lengthOfEachLba;
   \   0000000A   0x6812             LDR      R2,[R2, #+0]
   \   0000000C   0x6983             LDR      R3,[R0, #+24]
   \   0000000E   0x435A             MULS     R2,R3,R2
   \   00000010   0x6102             STR      R2,[R0, #+16]
   1046          
   1047              if (direction == USB_IN)
   \   00000012   0x2901             CMP      R1,#+1
   \   00000014   0xBF04             ITT      EQ 
   1048              {
   1049                  error = USB_DeviceMscSend(mscHandle);
   \   00000016   0xE8BD 0x4010      POPEQ    {R4,LR}
   \   0000001A   0x.... 0x....      BEQ.W    USB_DeviceMscSend
   1050              }
   1051              else
   1052              {
   1053                  error = USB_DeviceMscRecv(mscHandle);
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x....             B.N      USB_DeviceMscRecv
   1054              }
   1055              return error;
   1056          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x53425355         DC32     0x53425355

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x43425355         DC32     0x43425355

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     USB_DeviceMscBulkOut

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     USB_DeviceMscBulkIn

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x........         DC32     g_msc_handle
   1057          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   USB_DeviceMscBulkIn
        40   -- Indirect call
        40   -> USB_DeviceMscSend
        40   -> USB_DeviceRecvRequest
        40   -> USB_DeviceSendRequest
        40   -> USB_DeviceStallEndpoint
      40   USB_DeviceMscBulkOut
        40   -- Indirect call
        40   -> USB_DeviceMscProcessUfiCommand
        40   -> USB_DeviceMscRecv
        40   -> USB_DeviceSendRequest
        40   -> USB_DeviceStallEndpoint
      16   USB_DeviceMscDeinit
        16   -> USB_DeviceMscEndpointsDeinit
        16   -> USB_DeviceMscFreeHandle
      16   USB_DeviceMscEndpointsDeinit
        16   -> USB_DeviceDeinitEndpoint
      48   USB_DeviceMscEndpointsInit
        48   -> USB_DeviceCancel
        48   -> USB_DeviceInitEndpoint
        48   -> USB_DeviceRecvRequest
      32   USB_DeviceMscEvent
        32   -> USB_DeviceCancel
        32   -> USB_DeviceMscEndpointsDeinit
        32   -> USB_DeviceMscEndpointsInit
        32   -> USB_DeviceRecvRequest
        32   -> USB_DeviceSendRequest
        32   -> USB_DeviceStallEndpoint
        32   -> USB_DeviceUnstallEndpoint
       0   USB_DeviceMscFreeHandle
      48   USB_DeviceMscInit
        48   -- Indirect call
        48   -> USB_DeviceClassGetDeviceHandle
        48   -> USB_DeviceMscFreeHandle
       8   USB_DeviceMscLbaTransfer
         0   -> USB_DeviceMscRecv
         8   -> USB_DeviceMscSend
       8   USB_DeviceMscProcessUfiCommand
         0   -> USB_DeviceMscUfiFormatUnitCommand
         0   -> USB_DeviceMscUfiInquiryCommand
         0   -> USB_DeviceMscUfiModeSelectCommand
         0   -> USB_DeviceMscUfiModeSenseCommand
         0   -> USB_DeviceMscUfiPreventAllowMediumCommand
         0   -> USB_DeviceMscUfiReadCapacityCommand
         0   -> USB_DeviceMscUfiReadCommand
         0   -> USB_DeviceMscUfiReadFormatCapacityCommand
         0   -> USB_DeviceMscUfiRequestSenseCommand
         0   -> USB_DeviceMscUfiSendDiagnosticCommand
         0   -> USB_DeviceMscUfiStartStopUnitCommand
         0   -> USB_DeviceMscUfiTestUnitReadyCommand
         8   -> USB_DeviceMscUfiUnsupportCommand
         0   -> USB_DeviceMscUfiVerifyCommand
         0   -> USB_DeviceMscUfiWriteCommand
      24   USB_DeviceMscRecv
        24   -- Indirect call
        24   -> USB_DeviceRecvRequest
        24   -> USB_DeviceStallEndpoint
      24   USB_DeviceMscSend
        24   -- Indirect call
        24   -> USB_DeviceSendRequest
        24   -> USB_DeviceStallEndpoint


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       6  ?Subroutine0
      12  ?Subroutine1
      12  ?Subroutine2
      10  ?Subroutine3
      12  ?Subroutine4
      12  ?Subroutine5
      12  ?Subroutine6
     252  USB_DeviceMscBulkIn
     418  USB_DeviceMscBulkOut
      26  USB_DeviceMscDeinit
      38  USB_DeviceMscEndpointsDeinit
     260  USB_DeviceMscEndpointsInit
     496  USB_DeviceMscEvent
      16  USB_DeviceMscFreeHandle
     224  USB_DeviceMscInit
      36  USB_DeviceMscLbaTransfer
     278  USB_DeviceMscProcessUfiCommand
      88  USB_DeviceMscRecv
      88  USB_DeviceMscSend
     256  g_msc_handle

 
 2 316 bytes in section .text
   256 bytes in section m_usb_global
 
 2 316 bytes of CODE memory
   256 bytes of DATA memory

Errors: none
Warnings: none
