###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Aug/2016  13:15:50
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\bl_command.c
#    Command line =  
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\bl_command.c"
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN256VDC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D BL_TARGET_RAM -lC
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj"
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices/MK22F25612\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/autobaud\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/osa\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device/class\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/bm_usb\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/CMSIS/Include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers/common\"
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list\bl_command.lst
#    Object file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj\bl_command.o
#
###############################################################################

C:\Users\cwati\Documents\My Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\bl_command.c
      1          /*
      2           * Copyright (c) 2013-2016, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "bootloader_common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void debug_printf(char const *, ...)
   \                     debug_printf: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB500             PUSH     {LR}
   \   00000004   0xA901             ADD      R1,SP,#+4
   \   00000006   0x.... 0x....      BL       vprintf
   \   0000000A   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
     32          #include "bootloader/bootloader.h"
     33          #include "memory/memory.h"
     34          #include "sbloader/sbloader.h"
     35          #include "property/property.h"
     36          #include "utilities/fsl_assert.h"
     37          #include "utilities/fsl_rtos_abstraction.h"
     38          #include <string.h>
     39          #include <stdint.h>
     40          
     41          #if !defined(BOOTLOADER_HOST)
     42          #include "flash/fsl_flash.h"
     43          #include "fsl_device_registers.h"
     44          #if BL_FEATURE_QSPI_MODULE
     45          #include "qspi/qspi.h"
     46          #endif // #if BL_FEATURE_QSPI_MODULE
     47          #if BL_FEATURE_OTFAD_MODULE
     48          #include "otfad/fsl_otfad_driver.h"
     49          #endif // #if BL_FEATURE_OTFAD_MODULE
     50          #endif
     51          
     52          #if BL_FEATURE_RELIABLE_UPDATE
     53          #include "bootloader/bl_reliable_update.h"
     54          #endif
     55          
     56          //! @addtogroup command
     57          //! @{
     58          
     59          //! @name State machine
     60          //@{
     61          static status_t handle_command(uint8_t *packet, uint32_t packetLength);
     62          static status_t handle_data(bool *hasMoreData);
     63          //@}
     64          
     65          //! @name Command handlers
     66          //@{
     67          void handle_reset(uint8_t *packet, uint32_t packetLength);
     68          void handle_flash_erase_all(uint8_t *packet, uint32_t packetLength);
     69          void handle_flash_erase_all_unsecure(uint8_t *packet, uint32_t packetLength);
     70          void handle_flash_erase_region(uint8_t *packet, uint32_t packetLength);
     71          void handle_receive_sb_file(uint8_t *packet, uint32_t packetLength);
     72          void handle_read_memory(uint8_t *packet, uint32_t packetLength);
     73          void handle_fill_memory(uint8_t *packet, uint32_t packetLength);
     74          void handle_set_property(uint8_t *packet, uint32_t packetLength);
     75          void handle_get_property(uint8_t *packet, uint32_t packetLength);
     76          void handle_write_memory(uint8_t *packet, uint32_t packetLength);
     77          void handle_execute(uint8_t *packet, uint32_t packetLength);
     78          void handle_call(uint8_t *packet, uint32_t packetLength);
     79          void handle_flash_security_disable(uint8_t *packet, uint32_t packetLength);
     80          void handle_flash_program_once(uint8_t *packet, uint32_t length);
     81          void handle_flash_read_once(uint8_t *packet, uint32_t length);
     82          void handle_flash_read_resource(uint8_t *packet, uint32_t length);
     83          void handle_configure_quadspi(uint8_t *packet, uint32_t packetLength);
     84          void handle_reliable_update(uint8_t *packet, uint32_t packetLength);
     85          //@}
     86          
     87          //! @name Command responses
     88          //@{
     89          void send_read_memory_response(uint32_t commandStatus, uint32_t length);
     90          void send_generic_response(uint32_t commandStatus, uint32_t commandTag);
     91          void send_get_property_response(uint32_t commandStatus, uint32_t *value, uint32_t numValues);
     92          void send_flash_read_once_response(uint32_t commandStatus, uint32_t *value, uint32_t byteCount);
     93          void send_flash_read_resource_response(uint32_t commandStatus, uint32_t length);
     94          //@}
     95          
     96          //! @name Data phase
     97          //@{
     98          static void reset_data_phase(void);
     99          void finalize_data_phase(status_t status);
    100          status_t handle_data_producer(bool *hasMoreData);
    101          status_t handle_data_consumer(bool *hasMoreData);
    102          //@}
    103          
    104          ////////////////////////////////////////////////////////////////////////////////
    105          // Definitions
    106          ////////////////////////////////////////////////////////////////////////////////
    107          
    108          //#define TEST_SENDER_ABORT
    109          //#define TEST_RECEIVER_ABORT
    110          
    111          enum _secure_commands
    112          {
    113              //! @brief Bitmask of commands allowed when flash security is enabled.
    114              //!
    115              //! This bitmask uses the same format as the AvailableCommands property. This is,
    116              //! the bit number for a given command is the command's tag value minus one.
    117              kCommandsAllowedWhenSecure = (HAS_CMD(kCommandTag_FlashSecurityDisable) | HAS_CMD(kCommandTag_GetProperty) |
    118                                            HAS_CMD(kCommandTag_Reset) | HAS_CMD(kCommandTag_SetProperty) |
    119                                            HAS_CMD(kCommandTag_FlashEraseAllUnsecure) | HAS_CMD(kCommandTag_ReceiveSbFile))
    120          };
    121          
    122          ////////////////////////////////////////////////////////////////////////////////
    123          // Variables
    124          ////////////////////////////////////////////////////////////////////////////////
    125          
    126          //! @brief Command handler table.

   \                                 In section .rodata, align 4, keep-with-next
    127          const command_handler_entry_t g_commandHandlerTable[] = {
   \                     g_commandHandlerTable:
   \   00000000   0x........         DC32 handle_flash_erase_all, 0H, handle_flash_erase_region, 0H
   \              0x00000000   
   \              0x........   
   \              0x00000000   
   \   00000010   0x........         DC32 handle_read_memory, handle_data_producer, handle_write_memory
   \              0x........   
   \              0x........   
   \   0000001C   0x........         DC32 handle_data_consumer, handle_fill_memory, 0H, 0H
   \              0x........   
   \              0x00000000   
   \              0x00000000   
   \   0000002C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000030   0x........         DC32 handle_get_property, 0H, handle_receive_sb_file
   \              0x00000000   
   \              0x........   
   \   0000003C   0x........         DC32 handle_data_consumer, handle_execute, 0H, handle_call, 0H
   \              0x........   
   \              0x00000000   
   \              0x........   
   \              0x00000000   
   \   00000050   0x........         DC32 handle_reset, 0H, handle_set_property, 0H, 0H
   \              0x00000000   
   \              0x........   
   \              0x00000000   
   \              0x00000000   
   \   00000064   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000068   0x........         DC32 handle_flash_program_once, 0H, handle_flash_read_once, 0H
   \              0x00000000   
   \              0x........   
   \              0x00000000   
   \   00000078   0x........         DC32 handle_flash_read_resource, handle_data_producer, 0H
   \              0x........   
   \              0x00000000   
   \   00000084   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000088   0x00000000         DC32 0H
   \   0000008C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    128          // cmd handler              // data handler or NULL
    129          #if !BL_FEATURE_MIN_PROFILE
    130              { handle_flash_erase_all, NULL },              // kCommandTag_FlashEraseAll = 0x01
    131              { handle_flash_erase_region, NULL },           // kCommandTag_FlashEraseRegion = 0x02
    132              { handle_read_memory, handle_data_producer },  // kCommandTag_ReadMemory = 0x03
    133              { handle_write_memory, handle_data_consumer }, // kCommandTag_WriteMemory = 0x04
    134              { handle_fill_memory, NULL },                  // kCommandTag_FillMemory = 0x05
    135          #if BL_FEATURE_FLASH_SECURITY
    136              { handle_flash_security_disable, NULL }, // kCommandTag_FlashSecurityDisable = 0x06
    137          #else
    138              { 0 },
    139          #endif                                                // BL_FEATURE_FLASH_SECURITY
    140              { handle_get_property, NULL },                    // kCommandTag_GetProperty = 0x07
    141              { handle_receive_sb_file, handle_data_consumer }, // kCommandTag_ReceiveSbFile = 0x08
    142              { handle_execute, NULL },                         // kCommandTag_Execute = 0x09
    143              { handle_call, NULL },                            // kCommandTag_Call = 0x0a
    144              { handle_reset, NULL },                           // kCommandTag_Reset = 0x0b
    145              { handle_set_property, NULL },                    // kCommandTag_SetProperty = 0x0c
    146          #if BL_FEATURE_ERASEALL_UNSECURE
    147              { handle_flash_erase_all_unsecure, NULL }, // kCommandTag_FlashEraseAllUnsecure = 0x0d
    148          #else  // BL_FEATURE_ERASEALL_UNSECURE
    149              { 0 }, // kCommandTag_FlashEraseAllUnsecure = 0x0d
    150          #endif // BL_FEATURE_ERASEALL_UNSECURE
    151              { handle_flash_program_once, NULL },                  // kCommandTag_ProgramOnce = 0x0e
    152              { handle_flash_read_once, NULL },                     // kCommandTag_ReadOnce = 0x0f
    153              { handle_flash_read_resource, handle_data_producer }, // kCommandTag_ReadResource = 0x10
    154          #if BL_FEATURE_QSPI_MODULE
    155              { handle_configure_quadspi, NULL }, // kCommandTag_ConfigureQuadSpi = 0x11
    156          #else                                   // BL_FEATURE_QSPI_MODULE
    157              { 0 }, // kCommandTag_ConfigureQuadSpi = 0x11
    158          #endif                                  // BL_FEATURE_QSPI_MODULE
    159          #if BL_FEATURE_RELIABLE_UPDATE
    160              { handle_reliable_update, NULL }, // kCommandTag_ReliableUpdate = 0x12
    161          #else
    162              { 0 }, // kCommandTag_ReliableUpdate = 0x12
    163          #endif // BL_FEATURE_RELIABLE_UPDATE
    164          
    165          #else // BL_FEATURE_MIN_PROFILE
    166              { handle_flash_erase_all, NULL },    // kCommandTag_FlashEraseAll = 0x01
    167              { handle_flash_erase_region, NULL }, // kCommandTag_FlashEraseRegion = 0x02
    168          #if BL_FEATURE_READ_MEMORY
    169              { handle_read_memory, handle_data_producer }, // kCommandTag_ReadMemory = 0x03
    170          #else // BL_FEATURE_READ_MEMORY
    171              { 0 }, // kCommandTag_ReadMemory = 0x03
    172          #endif
    173              { handle_write_memory, handle_data_consumer }, // kCommandTag_WriteMemory = 0x04
    174          #if BL_FEATURE_FILL_MEMORY
    175              { handle_fill_memory, NULL }, // kCommandTag_FillMemory = 0x05
    176          #else
    177              { 0 },
    178          #endif // BL_FEATURE_FILL_MEMORY
    179          #if BL_FEATURE_FLASH_SECURITY
    180              { handle_flash_security_disable, NULL }, // kCommandTag_FlashSecurityDisable = 0x06
    181          #else
    182              { 0 },
    183          #endif // BL_FEATURE_FLASH_SECURITY
    184              { handle_get_property, NULL },             // kCommandTag_GetProperty = 0x07
    185              { 0 },                                     // kCommandTag_ReceiveSbFile = 0x08
    186              { handle_execute, NULL },                  // kCommandTag_Execute = 0x09
    187              { 0 },                                     // kCommandTag_Call = 0x0a
    188              { handle_reset, NULL },                    // kCommandTag_Reset = 0x0b
    189              { handle_set_property, NULL },             // kCommandTag_SetProperty = 0x0c
    190          #if BL_FEATURE_ERASEALL_UNSECURE
    191              { handle_flash_erase_all_unsecure, NULL }, // kCommandTag_FlashEraseAllUnsecure = 0x0d
    192          #else  // BL_FEATURE_ERASEALL_UNSECURE
    193              { 0 }, // kCommandTag_FlashEraseAllUnsecure = 0x0d
    194          #endif // BL_FEATURE_ERASEALL_UNSECURE
    195              { 0 },                                     // kCommandTag_ProgramOnce = 0x0e
    196              { 0 },                                     // kCommandTag_ReadOnce = 0x0f
    197              { 0 },                                     // kCommandTag_ReadResource = 0x10
    198              { 0 },                                     // kCommandTag_ConfigureQuadSpi = 0x11
    199              { 0 },                                     // kCommandTag_ReliableUpdate = 0x12
    200          #endif // BL_FEATURE_MIN_PROFILE
    201          };
    202          
    203          //! @brief Command processor state data.

   \                                 In section .bss, align 4
    204          command_processor_data_t g_commandData;
   \                     g_commandData:
   \   00000000                      DS8 36
    205          
    206          // See bl_command.h for documentation on this interface.

   \                                 In section .data, align 4
    207          command_interface_t g_commandInterface = { bootloader_command_init, bootloader_command_pump,
   \                     g_commandInterface:
   \   00000000   0x........         DC32 bootloader_command_init, bootloader_command_pump
   \              0x........   
   \   00000008   0x........         DC32 g_commandHandlerTable, g_commandData
   \              0x........   
    208                                                     (command_handler_entry_t *)&g_commandHandlerTable, &g_commandData };
    209          
    210          ////////////////////////////////////////////////////////////////////////////////
    211          // Code
    212          ////////////////////////////////////////////////////////////////////////////////
    213          
    214          // See bl_command.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    215          status_t bootloader_command_init()
    216          {
    217              command_processor_data_t *data = g_bootloaderContext.commandInterface->stateData;
    218          
    219              data->state = kCommandState_CommandPhase;
   \                     bootloader_command_init: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable34
   \   00000004   0x68C9             LDR      R1,[R1, #+12]
   \   00000006   0x68C9             LDR      R1,[R1, #+12]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    220              return kStatus_Success;
   \   0000000C   0x4770             BX       LR               ;; return
    221          }
    222          
    223          // See bl_command.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    224          status_t bootloader_command_pump()
    225          {
   \                     bootloader_command_pump: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    226              status_t status = kStatus_Success;
    227              bool hasMoreData = false;
    228          
    229              if (g_bootloaderContext.activePeripheral->packetInterface)
   \   00000002   0x.... 0x....      LDR.W    R5,??DataTable34
   \   00000006   0x69E8             LDR      R0,[R5, #+28]
   \   00000008   0xB082             SUB      SP,SP,#+8
   \   0000000A   0x2400             MOVS     R4,#+0
   \   0000000C   0xF88D 0x4000      STRB     R4,[SP, #+0]
   \   00000010   0x6946             LDR      R6,[R0, #+20]
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD036             BEQ.N    ??bootloader_command_pump_0
   \   00000016   0x68E9             LDR      R1,[R5, #+12]
   \   00000018   0x68C9             LDR      R1,[R1, #+12]
   \   0000001A   0x680A             LDR      R2,[R1, #+0]
   \   0000001C   0x2A01             CMP      R2,#+1
   \   0000001E   0xD023             BEQ.N    ??bootloader_command_pump_1
    230              {
    231                  switch (g_bootloaderContext.commandInterface->stateData->state)
    232                  {
    233                      default:
    234                      case kCommandState_CommandPhase:
    235                          status = g_bootloaderContext.activePeripheral->packetInterface->readPacket(
    236                              g_bootloaderContext.activePeripheral, &g_bootloaderContext.commandInterface->stateData->packet,
    237                              &g_bootloaderContext.commandInterface->stateData->packetLength, kPacketType_Command);
   \   00000020   0xF101 0x0208      ADD      R2,R1,#+8
   \   00000024   0x6874             LDR      R4,[R6, #+4]
   \   00000026   0x2300             MOVS     R3,#+0
   \   00000028   0x1D09             ADDS     R1,R1,#+4
   \   0000002A   0x47A0             BLX      R4
   \   0000002C   0x0004             MOVS     R4,R0
    238                          if ((status != kStatus_Success) && (status != kStatus_AbortDataPhase) && (status != kStatus_Ping))
   \   0000002E   0xBF1F             ITTTT    NE 
   \   00000030   0xF242 0x7012      MOVWNE   R0,#+10002
   \   00000034   0x4284             CMPNE    R4,R0
   \   00000036   0xF242 0x7013      MOVWNE   R0,#+10003
   \   0000003A   0x4284             CMPNE    R4,R0
   \   0000003C   0xD003             BEQ.N    ??bootloader_command_pump_2
    239                          {
    240                              debug_printf("Error: readPacket returned status 0x%x\r\n", status);
   \   0000003E   0x4621             MOV      R1,R4
   \   00000040   0x.... 0x....      ADR.W    R0,?_0
   \   00000044   0xE00B             B.N      ??bootloader_command_pump_3
    241                              break;
    242                          }
   \                     ??bootloader_command_pump_2: (+1)
   \   00000046   0x68E8             LDR      R0,[R5, #+12]
   \   00000048   0x68C0             LDR      R0,[R0, #+12]
   \   0000004A   0x6881             LDR      R1,[R0, #+8]
   \   0000004C   0xB1D1             CBZ.N    R1,??bootloader_command_pump_0
    243                          if (g_bootloaderContext.commandInterface->stateData->packetLength == 0)
    244                          {
    245                              // No command packet is available. Return success.
    246                              break;
    247                          }
    248                          status = handle_command(g_bootloaderContext.commandInterface->stateData->packet,
    249                                                  g_bootloaderContext.commandInterface->stateData->packetLength);
   \   0000004E   0x6840             LDR      R0,[R0, #+4]
   \   00000050   0x.... 0x....      BL       handle_command
   \   00000054   0x0004             MOVS     R4,R0
    250                          if (status != kStatus_Success)
   \   00000056   0xD005             BEQ.N    ??bootloader_command_pump_4
    251                          {
    252                              debug_printf("Error: handle_command returned status 0x%x\r\n", status);
   \   00000058   0x4621             MOV      R1,R4
   \   0000005A   0x.... 0x....      ADR.W    R0,?_1
   \                     ??bootloader_command_pump_3: (+1)
   \   0000005E   0x.... 0x....      BL       debug_printf
    253                              break;
   \   00000062   0xE00F             B.N      ??bootloader_command_pump_0
    254                          }
    255                          g_bootloaderContext.commandInterface->stateData->state = kCommandState_DataPhase;
   \                     ??bootloader_command_pump_4: (+1)
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0xE00A             B.N      ??bootloader_command_pump_5
    256                          break;
    257          
    258                      case kCommandState_DataPhase:
    259                          status = handle_data(&hasMoreData);
   \                     ??bootloader_command_pump_1: (+1)
   \   00000068   0x6A08             LDR      R0,[R1, #+32]
   \   0000006A   0xB168             CBZ.N    R0,??bootloader_command_pump_6
   \   0000006C   0x6841             LDR      R1,[R0, #+4]
   \   0000006E   0x0008             MOVS     R0,R1
   \   00000070   0xD002             BEQ.N    ??bootloader_command_pump_7
   \   00000072   0x4668             MOV      R0,SP
   \   00000074   0x4788             BLX      R1
   \   00000076   0x4604             MOV      R4,R0
    260                          if (status != kStatus_Success)
   \                     ??bootloader_command_pump_7: (+1)
   \   00000078   0xB95C             CBNZ.N   R4,??bootloader_command_pump_8
    261                          {
    262                              debug_printf("Error: handle_data returned status 0x%x\r\n", status);
    263                              g_bootloaderContext.commandInterface->stateData->state = kCommandState_CommandPhase;
    264                              break;
    265                          }
    266                          g_bootloaderContext.commandInterface->stateData->state =
    267                              hasMoreData ? kCommandState_DataPhase : kCommandState_CommandPhase;
   \                     ??bootloader_command_pump_9: (+1)
   \   0000007A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \                     ??bootloader_command_pump_5: (+1)
   \   0000007E   0x68E9             LDR      R1,[R5, #+12]
   \   00000080   0x68C9             LDR      R1,[R1, #+12]
   \   00000082   0x6008             STR      R0,[R1, #+0]
    268                          break;
    269                  }
    270              }
    271          
    272              return status;
   \                     ??bootloader_command_pump_0: (+1)
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   \                     ??bootloader_command_pump_6: (+1)
   \   00000088   0x.... 0x....      ADR.W    R0,?_5
   \   0000008C   0x.... 0x....      BL       debug_printf
   \   00000090   0xE7F3             B.N      ??bootloader_command_pump_9
   \                     ??bootloader_command_pump_8: (+1)
   \   00000092   0x4621             MOV      R1,R4
   \   00000094   0x.... 0x....      ADR.W    R0,?_2
   \   00000098   0x.... 0x....      BL       debug_printf
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xE7EE             B.N      ??bootloader_command_pump_5
    273          }
    274          
    275          //! @brief Find command handler entry.
    276          //!
    277          //! @retval NULL if no entry found.
    278          static const command_handler_entry_t *find_entry(uint8_t tag)
    279          {
    280              if (tag < kFirstCommandTag || tag > kLastCommandTag)
    281              {
    282                  return 0; // invalid command
    283              }
    284              const command_handler_entry_t *entry =
    285                  &g_bootloaderContext.commandInterface->handlerTable[(tag - kFirstCommandTag)];
    286          
    287              return entry;
    288          }
    289          
    290          //! @brief Handle a command transaction.

   \                                 In section .text, align 2, keep-with-next
    291          static status_t handle_command(uint8_t *packet, uint32_t packetLength)
    292          {
   \                     handle_command: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB082             SUB      SP,SP,#+8
    293              command_packet_t *commandPacket = (command_packet_t *)packet;
    294              uint8_t commandTag = commandPacket->commandTag;
   \   00000008   0x7826             LDRB     R6,[R4, #+0]
    295              status_t status = kStatus_Success;
    296          
    297              // Look up the handler entry and save it for the data phaase.
    298              g_bootloaderContext.commandInterface->stateData->handlerEntry = find_entry(commandTag);
   \   0000000A   0x.... 0x....      LDR.W    R7,??DataTable34
   \   0000000E   0x0030             MOVS     R0,R6
   \   00000010   0x460D             MOV      R5,R1
   \   00000012   0xD007             BEQ.N    ??handle_command_0
   \   00000014   0x2E13             CMP      R6,#+19
   \   00000016   0xDA05             BGE.N    ??handle_command_0
   \   00000018   0x68F9             LDR      R1,[R7, #+12]
   \   0000001A   0x6889             LDR      R1,[R1, #+8]
   \   0000001C   0xEB01 0x00C6      ADD      R0,R1,R6, LSL #+3
   \   00000020   0x3808             SUBS     R0,R0,#+8
   \   00000022   0xE000             B.N      ??handle_command_1
   \                     ??handle_command_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??handle_command_1: (+1)
   \   00000026   0x68F9             LDR      R1,[R7, #+12]
   \   00000028   0x68C9             LDR      R1,[R1, #+12]
   \   0000002A   0x6208             STR      R0,[R1, #+32]
    299          
    300              if (g_bootloaderContext.commandInterface->stateData->handlerEntry &&
    301                  g_bootloaderContext.commandInterface->stateData->handlerEntry->handleCommand)
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xBF1C             ITT      NE 
   \   00000030   0x6800             LDRNE    R0,[R0, #+0]
   \   00000032   0x2800             CMPNE    R0,#+0
   \   00000034   0xD022             BEQ.N    ??handle_command_2
    302              {
    303          #if !BOOTLOADER_HOST
    304                  // Get flash security state.
    305                  flash_security_state_t securityState;
    306                  status = g_bootloaderContext.flashDriverInterface->flash_get_security_state(&g_bootloaderContext.flashState,
    307                                                                                              &securityState);
   \   00000036   0x693A             LDR      R2,[R7, #+16]
   \   00000038   0x6992             LDR      R2,[R2, #+24]
   \   0000003A   0x4669             MOV      R1,SP
   \   0000003C   0xF107 0x0020      ADD      R0,R7,#+32
   \   00000040   0x4790             BLX      R2
   \   00000042   0xEA5F 0x0800      MOVS     R8,R0
    308          
    309                  if (status == kStatus_Success)
   \   00000046   0xD120             BNE.N    ??handle_command_3
    310                  {
    311                      // If flash security is enabled, make sure the command is one that is allowed. If
    312                      // it's not, then we return an error response.
    313                      if ((securityState != kFLASH_SecurityStateNotSecure) &&
    314                          !IS_CMD_AVAILABLE(kCommandsAllowedWhenSecure, commandTag))
   \   00000048   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004C   0xB168             CBZ.N    R0,??handle_command_4
   \   0000004E   0xF44F 0x50E7      MOV      R0,#+7392
   \   00000052   0x1E71             SUBS     R1,R6,#+1
   \   00000054   0x40C8             LSRS     R0,R0,R1
   \   00000056   0x07C0             LSLS     R0,R0,#+31
   \   00000058   0xD407             BMI.N    ??handle_command_4
    315                      {
    316                          // Security is enabled and the command is not one of the few that can be
    317                          // run, so return a security violation error.
    318                          debug_printf("Error: command 0x%x not available due to flash security\r\n", commandPacket->commandTag);
   \   0000005A   0x7821             LDRB     R1,[R4, #+0]
   \   0000005C   0x.... 0x....      ADR.W    R0,?_3
   \   00000060   0x.... 0x....      BL       debug_printf
    319                          status = kStatus_SecurityViolation;
   \   00000064   0xF242 0x7811      MOVW     R8,#+10001
   \   00000068   0xE00F             B.N      ??handle_command_3
    320                      }
    321                      else
    322                      {
    323          #endif // BOOTLOADER_HOST
    324                          // Process the command normally.
    325                          g_bootloaderContext.commandInterface->stateData->handlerEntry->handleCommand(packet, packetLength);
   \                     ??handle_command_4: (+1)
   \   0000006A   0x68FA             LDR      R2,[R7, #+12]
   \   0000006C   0x68D2             LDR      R2,[R2, #+12]
   \   0000006E   0x6A12             LDR      R2,[R2, #+32]
   \   00000070   0x6812             LDR      R2,[R2, #+0]
   \   00000072   0x4629             MOV      R1,R5
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x4790             BLX      R2
    326                          return kStatus_Success;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xE00B             B.N      ??handle_command_5
    327          #if !BOOTLOADER_HOST
    328                      }
    329                  }
    330          #endif // BOOTLOADER_HOST
    331              }
    332              else
    333              {
    334                  // We don't recognize this command, so return an error response.
    335                  debug_printf("unknown command 0x%x\r\n", commandPacket->commandTag);
   \                     ??handle_command_2: (+1)
   \   0000007C   0x7821             LDRB     R1,[R4, #+0]
   \   0000007E   0x.... 0x....      ADR.W    R0,?_4
   \   00000082   0x.... 0x....      BL       debug_printf
    336                  status = kStatus_UnknownCommand;
   \   00000086   0xF242 0x7810      MOVW     R8,#+10000
    337              }
    338          
    339              // Should only get to this point if an error occurred before running the command handler.
    340              send_generic_response(status, commandTag);
   \                     ??handle_command_3: (+1)
   \   0000008A   0x4631             MOV      R1,R6
   \   0000008C   0x4640             MOV      R0,R8
   \   0000008E   0x.... 0x....      BL       send_generic_response
    341              return status;
   \   00000092   0x4640             MOV      R0,R8
   \                     ??handle_command_5: (+1)
   \   00000094   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    342          }
    343          
    344          //! @brief Handle a data transaction.
    345          static status_t handle_data(bool *hasMoreData)
    346          {
    347              if (g_bootloaderContext.commandInterface->stateData->handlerEntry)
    348              {
    349                  // Run data phase if present, otherwise just return success.
    350                  *hasMoreData = 0;
    351                  return g_bootloaderContext.commandInterface->stateData->handlerEntry->handleData ?
    352                             g_bootloaderContext.commandInterface->stateData->handlerEntry->handleData(hasMoreData) :
    353                             kStatus_Success;
    354              }
    355          
    356              debug_printf("Error: no handler entry for data phase\r\n");
    357              return kStatus_Success;
    358          }
    359          
    360          ////////////////////////////////////////////////////////////////////////////////
    361          // Command Handlers
    362          ////////////////////////////////////////////////////////////////////////////////
    363          
    364          //! @brief Reset command handler.

   \                                 In section .text, align 2, keep-with-next
    365          void handle_reset(uint8_t *packet, uint32_t packetLength)
    366          {
   \                     handle_reset: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    367              command_packet_t *commandPacket = (command_packet_t *)packet;
    368              send_generic_response(kStatus_Success, commandPacket->commandTag);
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       send_generic_response
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable34
   \   0000000E   0x69C0             LDR      R0,[R0, #+28]
   \   00000010   0x6941             LDR      R1,[R0, #+20]
   \   00000012   0x6909             LDR      R1,[R1, #+16]
    369          
    370          #if !defined(BOOTLOADER_HOST)
    371              // Wait for the ack from the host to the generic response
    372              g_bootloaderContext.activePeripheral->packetInterface->finalize(g_bootloaderContext.activePeripheral);
   \   00000014   0x4788             BLX      R1
    373          
    374              // Prepare for shutdown.
    375              shutdown_cleanup(kShutdownType_Reset);
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x.... 0x....      BL       shutdown_cleanup
    376          
    377              NVIC_SystemReset();
   \   0000001C   0xF3BF 0x8F4F      DSB      
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable34_1  ;; 0xe000ed0c
   \   00000024   0x.... 0x....      LDR.W    R2,??DataTable34_2  ;; 0x5fa0004
   \   00000028   0x6801             LDR      R1,[R0, #+0]
   \   0000002A   0xF401 0x61E0      AND      R1,R1,#0x700
   \   0000002E   0x4311             ORRS     R1,R2,R1
   \   00000030   0x6001             STR      R1,[R0, #+0]
   \   00000032   0xF3BF 0x8F4F      DSB      
   \                     ??handle_reset_0: (+1)
   \   00000036   0xBF00             Nop      
   \   00000038   0xE7FD             B.N      ??handle_reset_0
    378              // Does not get here.
    379              assert(0);
    380          #endif // BOOTLOADER_HOST
    381          }
    382          
    383          #if BL_FEATURE_RELIABLE_UPDATE
    384          //! @brief Reliable Update command handler.
    385          void handle_reliable_update(uint8_t *packet, uint32_t packetLength)
    386          {
    387              command_packet_t *commandPacket = (command_packet_t *)packet;
    388              status_t status = kStatus_Success;
    389          
    390          #if !defined(BOOTLOADER_HOST)
    391              reliable_update_packet_t *command = (reliable_update_packet_t *)packet;
    392              uint32_t address = command->address;
    393          
    394              // Call reliable update implementation..
    395              bootloader_reliable_update_as_requested(kReliableUpdateOption_Swap, address);
    396          
    397              status = g_bootloaderContext.propertyInterface->store->reliableUpdateStatus;
    398              send_generic_response(status, commandPacket->commandTag);
    399          
    400              if (status == kStatus_ReliableUpdateSuccess)
    401              {
    402                  // Wait for the ack from the host to the generic response
    403                  g_bootloaderContext.activePeripheral->packetInterface->finalize(g_bootloaderContext.activePeripheral);
    404          
    405                  // Prepare for shutdown.
    406                  shutdown_cleanup(kShutdownType_Reset);
    407          
    408                  NVIC_SystemReset();
    409                  // Does not get here.
    410                  assert(0);
    411              }
    412          #else
    413              send_generic_response(status, commandPacket->commandTag);
    414          #endif // BOOTLOADER_HOST
    415          }
    416          #endif // BL_FEATURE_RELIABLE_UPDATE
    417          
    418          //! @brief Reset data phase variables.

   \                                 In section .text, align 2, keep-with-next
    419          static void reset_data_phase()
    420          {
    421              memset(&g_bootloaderContext.commandInterface->stateData->dataPhase, 0,
    422                     sizeof(g_bootloaderContext.commandInterface->stateData->dataPhase));
   \                     reset_data_phase: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable34
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0x68C0             LDR      R0,[R0, #+12]
   \   00000008   0x2114             MOVS     R1,#+20
   \   0000000A   0x300C             ADDS     R0,R0,#+12
   \   0000000C   0x.... 0x....      B.W      __aeabi_memclr4
    423          }
    424          
    425          //! @brief Flash Erase All command handler.

   \                                 In section .text, align 2, keep-with-next
    426          void handle_flash_erase_all(uint8_t *packet, uint32_t packetLength)
    427          {
   \                     handle_flash_erase_all: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    428              flash_erase_all_packet_t *commandPacket = (flash_erase_all_packet_t *)packet;
    429              status_t status = kStatus_Success;
    430          
    431          // Call flash erase all implementation.
    432          #ifdef BOOTLOADER_HOST
    433              host_flash_erase_all();
    434          #else
    435                                                         // For target without QSPI module, ignore the memory identifier
    436          #if ((!BL_FEATURE_QSPI_MODULE) && (!BL_FEATURE_FAC_ERASE))
    437              status = flash_mem_erase_all();
   \   00000004   0x.... 0x....      BL       flash_mem_erase_all
    438          #else
    439              switch (commandPacket->memoryId)
    440              {
    441          #if BL_FEATURE_FAC_ERASE
    442                  case kFlashMemInternal:
    443                      status = flash_mem_erase_all(kFlashEraseAllOption_Blocks);
    444                      break;
    445                  case kFlashMemExecuteOnly:
    446                      status = flash_mem_erase_all(kFlashEraseAllOption_ExecuteOnlySegments);
    447                      break;
    448          #else
    449                  case kFlashMemInternal:
    450                      status = flash_mem_erase_all();
    451                      break;
    452          #endif
    453          #if BL_FEATURE_QSPI_MODULE
    454                  case kFlashMemQuadSpi0:
    455                      status = qspi_mem_erase_all();
    456                      break;
    457          #endif
    458                  default:
    459                      status = kStatus_InvalidArgument;
    460                      break;
    461              }
    462          #endif // #if (!BL_FEATURE_QSPI_MODULE)
    463          #endif // #ifdef BOOTLOADER_HOST
    464          
    465              send_generic_response(status, commandPacket->commandPacket.commandTag);
   \   00000008   0x....             B.N      ?Subroutine0
    466          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x7821             LDRB     R1,[R4, #+0]
   \   00000002   0xE8BD 0x4010      POP      {R4,LR}
   \   00000006   0x....             B.N      send_generic_response
    467          
    468          //! @brief Flash Erase All Unsecure command handler.

   \                                 In section .text, align 2, keep-with-next
    469          void handle_flash_erase_all_unsecure(uint8_t *packet, uint32_t packetLength)
    470          {
   \                     handle_flash_erase_all_unsecure: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    471              command_packet_t *commandPacket = (command_packet_t *)packet;
    472              status_t status = kStatus_Success;
    473          
    474          // Call flash erase all unsecure implementation.
    475          #ifdef BOOTLOADER_HOST
    476              host_flash_erase_all_unsecure();
    477          #else
    478              status = flash_mem_erase_all_unsecure();
   \   00000004   0x.... 0x....      BL       flash_mem_erase_all_unsecure
    479          #endif
    480          
    481              send_generic_response(status, commandPacket->commandTag);
   \   00000008                      REQUIRE ?Subroutine0
   \   00000008                      ;; // Fall through to label ?Subroutine0
    482          }
    483          
    484          //! @brief Flash Erase Region command handler.

   \                                 In section .text, align 2, keep-with-next
    485          void handle_flash_erase_region(uint8_t *packet, uint32_t packetLength)
    486          {
   \                     handle_flash_erase_region: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    487              flash_erase_region_packet_t *command = (flash_erase_region_packet_t *)packet;
    488              status_t status = kStatus_Success;
    489          
    490          // Call flash erase region implementation.
    491          #ifdef BOOTLOADER_HOST
    492              host_flash_erase_region(command->startAddress, command->byteCount);
    493          #else
    494              status = g_bootloaderContext.memoryInterface->erase(command->startAddress, command->byteCount);
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable34
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0x6952             LDR      R2,[R2, #+20]
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0x68A1             LDR      R1,[R4, #+8]
   \   0000000E   0x6860             LDR      R0,[R4, #+4]
   \   00000010   0x4790             BLX      R2
    495          #endif
    496          
    497              send_generic_response(status, command->commandPacket.commandTag);
   \   00000012   0x....             B.N      ?Subroutine0
    498          }
    499          
    500          //! @brief Receive SB File command handler.

   \                                 In section .text, align 2, keep-with-next
    501          void handle_receive_sb_file(uint8_t *packet, uint32_t packetLength)
    502          {
   \                     handle_receive_sb_file: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine8
    503              receive_sb_file_packet_t *command = (receive_sb_file_packet_t *)packet;
    504          
    505              // Start the data phase.
    506              reset_data_phase();
   \                     ??CrossCallReturnLabel_11: (+1)
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable34
   \   0000000A   0x68C0             LDR      R0,[R0, #+12]
   \   0000000C   0x68C0             LDR      R0,[R0, #+12]
   \   0000000E   0x6861             LDR      R1,[R4, #+4]
   \   00000010   0x6101             STR      R1,[R0, #+16]
    507              g_bootloaderContext.commandInterface->stateData->dataPhase.count = command->byteCount;
    508              g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag = kCommandTag_ReceiveSbFile;
   \   00000012   0x2108             MOVS     R1,#+8
   \   00000014   0x7701             STRB     R1,[R0, #+28]
    509              send_generic_response(kStatus_Success, command->commandPacket.commandTag);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x7821             LDRB     R1,[R4, #+0]
   \   0000001A   0x.... 0x....      BL       send_generic_response
    510          
    511              // Initialize the SB file loader state machine
    512              sbloader_init();
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x.... 0x....      B.W      sbloader_init
    513          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x....             B.N      reset_data_phase
    514          
    515          //! @brief Get Property command handler.

   \                                 In section .text, align 2, keep-with-next
    516          void handle_get_property(uint8_t *packet, uint32_t packetLength)
    517          {
   \                     handle_get_property: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    518              get_property_packet_t *command = (get_property_packet_t *)packet;
    519          
    520              uint32_t *value = NULL;
    521              uint32_t valueSize = 0;
    522              status_t status = g_bootloaderContext.propertyInterface->get(command->propertyTag, command->memoryId,
    523                                                                           (const void **)&value, &valueSize);
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable34
   \   00000008   0x68A5             LDR      R5,[R4, #+8]
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x9101             STR      R1,[SP, #+4]
   \   0000000E   0x9100             STR      R1,[SP, #+0]
   \   00000010   0x466B             MOV      R3,SP
   \   00000012   0x6881             LDR      R1,[R0, #+8]
   \   00000014   0x6840             LDR      R0,[R0, #+4]
   \   00000016   0x68AD             LDR      R5,[R5, #+8]
   \   00000018   0xAA01             ADD      R2,SP,#+4
   \   0000001A   0xB2C9             UXTB     R1,R1
   \   0000001C   0xB2C0             UXTB     R0,R0
   \   0000001E   0x47A8             BLX      R5
    524          
    525              // Make sure the property's size is no more than the size of the max number of return parameters.
    526              assert(valueSize <= (kMaxPropertyReturnValues * sizeof(uint32_t)));
    527          
    528              // Currently there are no property responses that contain a data phase.
    529              g_bootloaderContext.commandInterface->stateData->dataPhase.count = 0;
   \   00000020   0x68E2             LDR      R2,[R4, #+12]
   \   00000022   0x68D2             LDR      R2,[R2, #+12]
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x6111             STR      R1,[R2, #+16]
    530              send_get_property_response(status, value, (valueSize / sizeof(uint32_t)));
   \   00000028   0x9900             LDR      R1,[SP, #+0]
   \   0000002A   0x088A             LSRS     R2,R1,#+2
   \   0000002C   0x9901             LDR      R1,[SP, #+4]
   \   0000002E   0x.... 0x....      BL       send_get_property_response
    531          }
   \   00000032   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    532          
    533          //! @brief Set Property command handler.

   \                                 In section .text, align 2, keep-with-next
    534          void handle_set_property(uint8_t *packet, uint32_t packetLength)
    535          {
   \                     handle_set_property: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    536              set_property_packet_t *command = (set_property_packet_t *)packet;
    537          
    538              status_t status = g_bootloaderContext.propertyInterface->set_uint32(command->propertyTag, command->propertyValue);
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable34
   \   00000006   0x6892             LDR      R2,[R2, #+8]
   \   00000008   0x68D2             LDR      R2,[R2, #+12]
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0x6860             LDR      R0,[R4, #+4]
   \   0000000E   0x68A1             LDR      R1,[R4, #+8]
   \   00000010   0xB2C0             UXTB     R0,R0
   \   00000012   0x4790             BLX      R2
    539          
    540              send_generic_response(status, command->commandPacket.commandTag);
   \   00000014   0x....             B.N      ?Subroutine0
    541          }
    542          
    543          #if BL_FEATURE_QSPI_MODULE
    544          //! @brief Configure QuadSpi command handler.
    545          void handle_configure_quadspi(uint8_t *packet, uint32_t packetLength)
    546          {
    547              configure_quadspi_packet_t *command = (configure_quadspi_packet_t *)packet;
    548              status_t status = kStatus_Success;
    549          
    550              uint32_t startAddr = command->configBlockAddress;
    551              uint32_t endAddr = startAddr + sizeof(qspi_config_t) - 1;
    552          
    553              // Validate parameters.
    554              if ((command->flashMemId != kFlashMemQuadSpi0) || (!is_valid_application_location(startAddr)) ||
    555                  (!is_valid_application_location(endAddr)))
    556              {
    557                  status = kStatus_InvalidArgument;
    558              }
    559          
    560              // Call configure quadspi implementation.
    561              if (status == kStatus_Success)
    562              {
    563          #ifdef BOOTLOADER_HOST
    564          #else
    565                  status = quadspi_init((void *)startAddr);
    566                  if (status == kStatus_Success)
    567                  {
    568                      // Re-init memory interface to intialize qspi memory interface
    569                      g_bootloaderContext.memoryInterface->init();
    570                  }
    571                  g_bootloaderContext.propertyInterface->store->qspiInitStatus = status;
    572          #endif
    573              }
    574          
    575              send_generic_response(status, command->commandPacket.commandTag);
    576          }
    577          #endif // BL_FEATURE_QSPI_MODULE
    578          
    579          //! @brief Write Memory command handler.

   \                                 In section .text, align 2, keep-with-next
    580          void handle_write_memory(uint8_t *packet, uint32_t packetLength)
    581          {
   \                     handle_write_memory: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine8
    582              write_memory_packet_t *command = (write_memory_packet_t *)packet;
    583          
    584              // Start the data phase.
    585              reset_data_phase();
   \                     ??CrossCallReturnLabel_10: (+1)
   \   00000006   0x.... 0x....      BL       ?Subroutine4
    586              g_bootloaderContext.commandInterface->stateData->dataPhase.count = command->byteCount;
    587              g_bootloaderContext.commandInterface->stateData->dataPhase.address = command->startAddress;
    588              g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag = kCommandTag_WriteMemory;
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000000A   0x2104             MOVS     R1,#+4
   \   0000000C   0x7701             STRB     R1,[R0, #+28]
    589              send_generic_response(kStatus_Success, command->commandPacket.commandTag);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x....             B.N      ?Subroutine0
    590          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable34
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0x68C0             LDR      R0,[R0, #+12]
   \   00000008   0x68A1             LDR      R1,[R4, #+8]
   \   0000000A   0x6101             STR      R1,[R0, #+16]
   \   0000000C   0x6861             LDR      R1,[R4, #+4]
   \   0000000E   0x6141             STR      R1,[R0, #+20]
   \   00000010   0x4770             BX       LR
    591          
    592          //! @brief Read Memory command handler.

   \                                 In section .text, align 2, keep-with-next
    593          void handle_read_memory(uint8_t *packet, uint32_t packetLength)
    594          {
   \                     handle_read_memory: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine8
    595              read_memory_packet_t *command = (read_memory_packet_t *)packet;
    596          
    597              // Start the data phase.
    598              reset_data_phase();
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000006   0x.... 0x....      BL       ?Subroutine4
    599              g_bootloaderContext.commandInterface->stateData->dataPhase.count = command->byteCount;
    600              g_bootloaderContext.commandInterface->stateData->dataPhase.address = command->startAddress;
    601              g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag = kCommandTag_ReadMemory;
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000000A   0x2103             MOVS     R1,#+3
   \   0000000C   0x7701             STRB     R1,[R0, #+28]
    602              send_read_memory_response(kStatus_Success, command->byteCount);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x68A1             LDR      R1,[R4, #+8]
   \   00000012   0xE8BD 0x4010      POP      {R4,LR}
   \   00000016   0x....             B.N      send_read_memory_response
    603          }
    604          
    605          //! @brief Complete the data phase, optionally send a response.

   \                                 In section .text, align 2, keep-with-next
    606          void finalize_data_phase(status_t status)
    607          {
   \                     finalize_data_phase: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    608              g_bootloaderContext.commandInterface->stateData->dataPhase.address = 0;
   \   00000002   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6141             STR      R1,[R0, #+20]
    609              g_bootloaderContext.commandInterface->stateData->dataPhase.count = 0;
   \   0000000A   0x6101             STR      R1,[R0, #+16]
    610          
    611              // Force to write cached data to target memory
    612              if (g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag == kCommandTag_WriteMemory)
   \   0000000C   0x7F00             LDRB     R0,[R0, #+28]
   \   0000000E   0x2804             CMP      R0,#+4
   \   00000010   0xD104             BNE.N    ??finalize_data_phase_0
    613              {
    614                  assert(g_bootloaderContext.memoryInterface->flush);
    615                  status_t flushStatus = g_bootloaderContext.memoryInterface->flush();
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x6900             LDR      R0,[R0, #+16]
   \   00000016   0x4780             BLX      R0
    616          
    617                  // Update status only if the last operation result is successfull in order to reflect
    618                  // real result of the write operation.
    619                  if (status == kStatus_Success)
   \   00000018   0xB904             CBNZ.N   R4,??finalize_data_phase_0
    620                  {
    621                      status = flushStatus;
   \   0000001A   0x4604             MOV      R4,R0
    622                  }
    623              }
    624          
    625              // Send final response packet.
    626              send_generic_response(status, g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag);
   \                     ??finalize_data_phase_0: (+1)
   \   0000001C   0x68E8             LDR      R0,[R5, #+12]
   \   0000001E   0x68C0             LDR      R0,[R0, #+12]
   \   00000020   0x7F01             LDRB     R1,[R0, #+28]
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       send_generic_response
    627          
    628          #if !BL_FEATURE_MIN_PROFILE
    629              if ((status == kStatus_AbortDataPhase) &&
    630                  g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag == kCommandTag_ReceiveSbFile)
   \   00000028   0xF242 0x7012      MOVW     R0,#+10002
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD108             BNE.N    ??finalize_data_phase_1
   \   00000030   0x68E8             LDR      R0,[R5, #+12]
   \   00000032   0x68C0             LDR      R0,[R0, #+12]
   \   00000034   0x7F00             LDRB     R0,[R0, #+28]
   \   00000036   0x2808             CMP      R0,#+8
   \   00000038   0xBF04             ITT      EQ 
    631              {
    632                  // Aborting due to sb loader jump or reset command.
    633                  // If jump or reset successful, this will not return.
    634                  // In the current architecture there is no way to handle an error return from sbloader_finalize()
    635                  // because we already sent the "abort" status above to indicate that a jump command was encountered.
    636                  sbloader_finalize();
   \   0000003A   0xE8BD 0x4031      POPEQ    {R0,R4,R5,LR}
   \   0000003E   0x.... 0x....      BEQ.W    sbloader_finalize
    637              }
    638          #endif // !BL_FEATURE_MIN_PROFILE
    639          }
   \                     ??finalize_data_phase_1: (+1)
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x....             LDR.N    R5,??DataTable34
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x68E8             LDR      R0,[R5, #+12]
   \   00000006   0x68C0             LDR      R0,[R0, #+12]
   \   00000008   0x4770             BX       LR
    640          
    641          //! @brief Handle data phase with data consumer (read from host).

   \                                 In section .text, align 2, keep-with-next
    642          status_t handle_data_consumer(bool *hasMoreData)
    643          {
   \                     handle_data_consumer: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
    644              if (g_bootloaderContext.commandInterface->stateData->dataPhase.count == 0)
   \   00000004   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000008   0x6901             LDR      R1,[R0, #+16]
   \   0000000A   0xB921             CBNZ.N   R1,??handle_data_consumer_0
    645              {
    646                  // No data phase.
    647                  *hasMoreData = false;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x7020             STRB     R0,[R4, #+0]
    648                  finalize_data_phase(kStatus_Success);
   \   00000010   0x.... 0x....      BL       finalize_data_phase
    649                  return kStatus_Success;
   \   00000014   0xE068             B.N      ??handle_data_consumer_1
    650              }
    651          
    652              *hasMoreData = true;
   \                     ??handle_data_consumer_0: (+1)
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x7021             STRB     R1,[R4, #+0]
    653              uint32_t remaining = g_bootloaderContext.commandInterface->stateData->dataPhase.count;
   \   0000001A   0x6906             LDR      R6,[R0, #+16]
    654              uint32_t dataAddress = g_bootloaderContext.commandInterface->stateData->dataPhase.address;
   \   0000001C   0x6947             LDR      R7,[R0, #+20]
    655              uint8_t *packet;
    656              uint32_t packetLength = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x9000             STR      R0,[SP, #+0]
    657              status_t status;
    658          
    659              // Read the data packet.
    660              status = g_bootloaderContext.activePeripheral->packetInterface->readPacket(
    661                  g_bootloaderContext.activePeripheral, &packet, &packetLength, kPacketType_Data);
   \   00000022   0x2301             MOVS     R3,#+1
   \   00000024   0x69E8             LDR      R0,[R5, #+28]
   \   00000026   0xF8D0 0xC014      LDR      R12,[R0, #+20]
   \   0000002A   0xF8DC 0xC004      LDR      R12,[R12, #+4]
   \   0000002E   0x466A             MOV      R2,SP
   \   00000030   0xA901             ADD      R1,SP,#+4
   \   00000032   0x47E0             BLX      R12
   \   00000034   0xEA5F 0x0800      MOVS     R8,R0
    662              if (status != kStatus_Success)
   \   00000038   0xD00A             BEQ.N    ??handle_data_consumer_2
    663              {
    664                  // Abort data phase due to error.
    665                  debug_printf("consumer abort data phase due to status 0x%x\r\n", status);
   \   0000003A   0x4641             MOV      R1,R8
   \   0000003C   0x.... 0x....      ADR.W    R0,?_6
   \   00000040   0x.... 0x....      BL       debug_printf
    666                  g_bootloaderContext.activePeripheral->packetInterface->abortDataPhase(g_bootloaderContext.activePeripheral);
   \   00000044   0x69E8             LDR      R0,[R5, #+28]
   \   00000046   0x6941             LDR      R1,[R0, #+20]
   \   00000048   0x68C9             LDR      R1,[R1, #+12]
   \   0000004A   0x4788             BLX      R1
    667                  finalize_data_phase(status);
   \   0000004C   0x4640             MOV      R0,R8
   \   0000004E   0xE007             B.N      ??handle_data_consumer_3
    668                  *hasMoreData = false;
    669                  return kStatus_Success;
    670              }
    671              if (packetLength == 0)
   \                     ??handle_data_consumer_2: (+1)
   \   00000050   0x9800             LDR      R0,[SP, #+0]
   \   00000052   0xB950             CBNZ.N   R0,??handle_data_consumer_4
    672              {
    673                  // Sender requested data phase abort.
    674                  debug_printf("Data phase aborted by sender\r\n");
   \   00000054   0x.... 0x....      ADR.W    R0,?_7
   \   00000058   0x.... 0x....      BL       debug_printf
    675                  finalize_data_phase(kStatus_AbortDataPhase);
   \   0000005C   0xF242 0x7012      MOVW     R0,#+10002
   \                     ??handle_data_consumer_3: (+1)
   \   00000060   0x.... 0x....      BL       finalize_data_phase
    676                  *hasMoreData = false;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x7020             STRB     R0,[R4, #+0]
    677                  return kStatus_Success;
   \   00000068   0xE03F             B.N      ??handle_data_consumer_5
    678              }
    679          
    680              //
    681              // Write the data to the destination address.
    682              //
    683          
    684              packetLength = MIN(packetLength, remaining);
   \                     ??handle_data_consumer_4: (+1)
   \   0000006A   0x42B0             CMP      R0,R6
   \   0000006C   0xBF88             IT       HI 
   \   0000006E   0x4630             MOVHI    R0,R6
   \   00000070   0x9000             STR      R0,[SP, #+0]
   \   00000072   0x68E8             LDR      R0,[R5, #+12]
   \   00000074   0x68C0             LDR      R0,[R0, #+12]
   \   00000076   0x7F01             LDRB     R1,[R0, #+28]
   \   00000078   0x2908             CMP      R1,#+8
   \   0000007A   0xD113             BNE.N    ??handle_data_consumer_6
    685          
    686          #if !BL_FEATURE_MIN_PROFILE
    687              if (g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag == kCommandTag_ReceiveSbFile)
    688              {
    689                  // Consumer is sb loader state machine
    690                  g_bootloaderContext.commandInterface->stateData->dataPhase.data = packet;
   \   0000007C   0x9901             LDR      R1,[SP, #+4]
   \   0000007E   0x60C1             STR      R1,[R0, #+12]
    691                  g_bootloaderContext.commandInterface->stateData->dataPhase.dataBytesAvailable = packetLength;
   \   00000080   0x9900             LDR      R1,[SP, #+0]
   \   00000082   0x6181             STR      R1,[R0, #+24]
    692          
    693                  status = sbloader_pump(packet, packetLength);
   \   00000084   0x9801             LDR      R0,[SP, #+4]
   \   00000086   0x9900             LDR      R1,[SP, #+0]
   \   00000088   0x.... 0x....      BL       sbloader_pump
   \   0000008C   0x4680             MOV      R8,R0
    694          
    695                  // kStatusRomLdrDataUnderrun means need more data
    696                  // kStatusRomLdrSectionOverrun means we reached the end of the sb file processing
    697                  // either of these are OK
    698                  if ((status == kStatusRomLdrDataUnderrun) || (status == kStatusRomLdrSectionOverrun))
   \   0000008E   0xF242 0x707D      MOVW     R0,#+10109
   \   00000092   0x4580             CMP      R8,R0
   \   00000094   0xBF1C             ITT      NE 
   \   00000096   0xF242 0x7074      MOVWNE   R0,#+10100
   \   0000009A   0x4580             CMPNE    R8,R0
   \   0000009C   0xD10B             BNE.N    ??handle_data_consumer_7
    699                  {
    700                      status = kStatus_Success;
   \   0000009E   0xF04F 0x0800      MOV      R8,#+0
   \   000000A2   0xE008             B.N      ??handle_data_consumer_7
    701                  }
    702              }
    703              else
    704          #endif // !BL_FEATURE_MIN_PROFILE
    705              {
    706                  // Consumer is memory interface.
    707                  status = g_bootloaderContext.memoryInterface->write(dataAddress, packetLength, packet);
   \                     ??handle_data_consumer_6: (+1)
   \   000000A4   0x682B             LDR      R3,[R5, #+0]
   \   000000A6   0x9A01             LDR      R2,[SP, #+4]
   \   000000A8   0x9900             LDR      R1,[SP, #+0]
   \   000000AA   0x689B             LDR      R3,[R3, #+8]
   \   000000AC   0x4638             MOV      R0,R7
   \   000000AE   0x4798             BLX      R3
   \   000000B0   0x4680             MOV      R8,R0
    708                  dataAddress += packetLength;
   \   000000B2   0x9800             LDR      R0,[SP, #+0]
   \   000000B4   0x19C7             ADDS     R7,R0,R7
    709              }
    710          
    711              remaining -= packetLength;
   \                     ??handle_data_consumer_7: (+1)
   \   000000B6   0x9800             LDR      R0,[SP, #+0]
   \   000000B8   0x1A36             SUBS     R6,R6,R0
    712          
    713          #ifdef TEST_RECEIVER_ABORT
    714              status = kStatus_Fail;
    715          #endif
    716          
    717              if (remaining == 0)
   \   000000BA   0xD00B             BEQ.N    ??handle_data_consumer_8
    718              {
    719                  finalize_data_phase(status);
    720                  *hasMoreData = false;
    721              }
    722              else if (status != kStatus_Success)
   \   000000BC   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000C0   0xD00E             BEQ.N    ??handle_data_consumer_9
    723              {
    724                  // Abort data phase due to error.
    725                  debug_printf("Data phase error 0x%x, aborting\r\n", status);
   \   000000C2   0x4641             MOV      R1,R8
   \   000000C4   0x.... 0x....      ADR.W    R0,?_8
   \   000000C8   0x.... 0x....      BL       debug_printf
    726                  g_bootloaderContext.activePeripheral->packetInterface->abortDataPhase(g_bootloaderContext.activePeripheral);
   \   000000CC   0x69E8             LDR      R0,[R5, #+28]
   \   000000CE   0x6941             LDR      R1,[R0, #+20]
   \   000000D0   0x68C9             LDR      R1,[R1, #+12]
   \   000000D2   0x4788             BLX      R1
    727                  finalize_data_phase(status);
   \                     ??handle_data_consumer_8: (+1)
   \   000000D4   0x4640             MOV      R0,R8
   \   000000D6   0x.... 0x....      BL       finalize_data_phase
    728                  *hasMoreData = false;
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0x7020             STRB     R0,[R4, #+0]
   \   000000DE   0xE003             B.N      ??handle_data_consumer_1
    729              }
   \                     ??handle_data_consumer_9: (+1)
   \   000000E0   0x68E8             LDR      R0,[R5, #+12]
   \   000000E2   0x68C0             LDR      R0,[R0, #+12]
   \   000000E4   0x6106             STR      R6,[R0, #+16]
    730              else
    731              {
    732                  g_bootloaderContext.commandInterface->stateData->dataPhase.count = remaining;
    733                  g_bootloaderContext.commandInterface->stateData->dataPhase.address = dataAddress;
   \   000000E6   0x6147             STR      R7,[R0, #+20]
    734              }
    735          
    736              return kStatus_Success;
   \                     ??handle_data_consumer_1: (+1)
   \   000000E8   0x2000             MOVS     R0,#+0
   \                     ??handle_data_consumer_5: (+1)
   \   000000EA   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    737          }
    738          
    739          //! @brief Handle data phase with data producer (send to host).

   \                                 In section .text, align 2, keep-with-next
    740          status_t handle_data_producer(bool *hasMoreData)
    741          {
   \                     handle_data_producer: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
    742              if (g_bootloaderContext.commandInterface->stateData->dataPhase.count == 0)
   \   00000004   0x....             LDR.N    R6,??DataTable34
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x68F0             LDR      R0,[R6, #+12]
   \   0000000A   0xB089             SUB      SP,SP,#+36
   \   0000000C   0x68C0             LDR      R0,[R0, #+12]
   \   0000000E   0x6901             LDR      R1,[R0, #+16]
   \   00000010   0xB921             CBNZ.N   R1,??handle_data_producer_0
    743              {
    744                  // No data phase.
    745                  *hasMoreData = false;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x7020             STRB     R0,[R4, #+0]
    746                  finalize_data_phase(kStatus_Success);
   \   00000016   0x.... 0x....      BL       finalize_data_phase
    747                  return kStatus_Success;
   \   0000001A   0xE06C             B.N      ??handle_data_producer_1
    748              }
    749          
    750              *hasMoreData = true;
   \                     ??handle_data_producer_0: (+1)
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x7021             STRB     R1,[R4, #+0]
    751              uint32_t remaining = g_bootloaderContext.commandInterface->stateData->dataPhase.count;
   \   00000020   0x6907             LDR      R7,[R0, #+16]
    752              uint32_t dataAddress = g_bootloaderContext.commandInterface->stateData->dataPhase.address;
   \   00000022   0xF8D0 0x8014      LDR      R8,[R0, #+20]
    753              uint8_t *data = g_bootloaderContext.commandInterface->stateData->dataPhase.data;
   \   00000026   0x68C1             LDR      R1,[R0, #+12]
    754              uint8_t commandTag = g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag;
   \   00000028   0xF890 0x901C      LDRB     R9,[R0, #+28]
    755              status_t status = kStatus_Success;
    756          
    757              // Initialize the data packet to send.
    758              uint32_t packetSize;
    759              uint8_t packet[kMinPacketBufferSize];
    760          
    761              // Copy the data into the data packet.
    762              packetSize = MIN(kMinPacketBufferSize, remaining);
   \   0000002C   0x2F21             CMP      R7,#+33
   \   0000002E   0xBF2C             ITE      CS 
   \   00000030   0xF04F 0x0A20      MOVCS    R10,#+32
   \   00000034   0x46BA             MOVCC    R10,R7
    763              if (data)
   \   00000036   0xB181             CBZ.N    R1,??handle_data_producer_2
    764              {
    765                  // Copy data using compiler-generated memcpy.
    766                  memcpy(packet, data, packetSize);
   \   00000038   0x4652             MOV      R2,R10
   \   0000003A   0xA801             ADD      R0,SP,#+4
   \   0000003C   0x.... 0x....      BL       __aeabi_memcpy
    767                  data += packetSize;
    768                  status = kStatus_Success;
    769              }
    770              else
    771              {
    772                  if (commandTag == kCommandTag_ReadMemory)
    773                  {
    774                      // Copy data using memory interface.
    775                      status = g_bootloaderContext.memoryInterface->read(dataAddress, packetSize, packet);
    776                  }
    777                  else if (commandTag == kCommandTag_FlashReadResource)
    778                  {
    779          // Read data from special-purpose flash memory
    780          #if !defined(BOOTLOADER_HOST)
    781                      flash_read_resource_option_t option =
    782                          (flash_read_resource_option_t)g_bootloaderContext.commandInterface->stateData->dataPhase.option;
    783                      lock_acquire();
    784                      status = g_bootloaderContext.flashDriverInterface->flash_read_resource(
    785                          &g_bootloaderContext.flashState, dataAddress, (uint32_t *)packet, packetSize, option);
    786                      lock_release();
    787          #endif // BOOTLOADER_HOST
    788                  }
    789                  dataAddress += packetSize;
    790              }
    791              if (status != kStatus_Success)
    792              {
    793                  debug_printf("Error: %s returned status 0x%x, abort data phase\r\n",
    794                               (commandTag == kCommandTag_ReadMemory) ? "read memory" : "flash read resource", status);
    795                  // Send zero length packet to tell host we are aborting data phase
    796                  g_bootloaderContext.activePeripheral->packetInterface->writePacket(
    797                      g_bootloaderContext.activePeripheral, (const uint8_t *)packet, 0, kPacketType_Data);
    798                  finalize_data_phase(status);
    799                  *hasMoreData = false;
    800                  return kStatus_Success;
    801              }
    802              remaining -= packetSize;
    803          
    804          #ifdef TEST_SENDER_ABORT
    805          #ifndef WIN32
    806          // Disble IAR "statement is unreachable" error
    807          #pragma diag_suppress = Pe111
    808          #endif // WIN32
    809              // Send zero length packet to abort data phase.
    810              g_bootloaderContext.activePeripheral->packetInterface->writePacket(g_bootloaderContext.activePeripheral,
    811                                                                                 (const uint8_t *)packet, 0, kPacketType_Data);
    812              finalize_data_phase(kStatus_AbortDataPhase);
    813              *hasMoreData = false;
    814              return kStatus_Success;
    815          #endif // TEST_SENDER_ABORT;
    816          
    817              status = g_bootloaderContext.activePeripheral->packetInterface->writePacket(
    818                  g_bootloaderContext.activePeripheral, (const uint8_t *)packet, packetSize, kPacketType_Data);
   \                     ??handle_data_producer_3: (+1)
   \   00000040   0x69F0             LDR      R0,[R6, #+28]
   \   00000042   0x6945             LDR      R5,[R0, #+20]
   \   00000044   0x68AD             LDR      R5,[R5, #+8]
   \   00000046   0x2301             MOVS     R3,#+1
   \   00000048   0x4652             MOV      R2,R10
   \   0000004A   0xA901             ADD      R1,SP,#+4
   \   0000004C   0xEBA7 0x070A      SUB      R7,R7,R10
   \   00000050   0x47A8             BLX      R5
    819          
    820              if (remaining == 0)
   \   00000052   0x2F00             CMP      R7,#+0
   \   00000054   0x4605             MOV      R5,R0
   \   00000056   0xD13D             BNE.N    ??handle_data_producer_4
    821              {
    822                  finalize_data_phase(status);
   \   00000058   0xE043             B.N      ??handle_data_producer_5
    823                  *hasMoreData = false;
    824              }
   \                     ??handle_data_producer_2: (+1)
   \   0000005A   0xF1B9 0x0F03      CMP      R9,#+3
   \   0000005E   0xEB0A 0x0B08      ADD      R11,R10,R8
   \   00000062   0xD107             BNE.N    ??handle_data_producer_6
   \   00000064   0x6833             LDR      R3,[R6, #+0]
   \   00000066   0x685B             LDR      R3,[R3, #+4]
   \   00000068   0xAA01             ADD      R2,SP,#+4
   \   0000006A   0x4651             MOV      R1,R10
   \   0000006C   0x4640             MOV      R0,R8
   \   0000006E   0x4798             BLX      R3
   \   00000070   0x4605             MOV      R5,R0
   \   00000072   0xE013             B.N      ??handle_data_producer_7
   \                     ??handle_data_producer_6: (+1)
   \   00000074   0xF1B9 0x0F10      CMP      R9,#+16
   \   00000078   0xBF18             IT       NE 
   \   0000007A   0x46D8             MOVNE    R8,R11
   \   0000007C   0xD1E0             BNE.N    ??handle_data_producer_3
   \   0000007E   0x7F45             LDRB     R5,[R0, #+29]
   \   00000080   0x.... 0x....      BL       lock_acquire
   \   00000084   0x9500             STR      R5,[SP, #+0]
   \   00000086   0x4653             MOV      R3,R10
   \   00000088   0x6935             LDR      R5,[R6, #+16]
   \   0000008A   0x6BED             LDR      R5,[R5, #+60]
   \   0000008C   0xAA01             ADD      R2,SP,#+4
   \   0000008E   0x4641             MOV      R1,R8
   \   00000090   0xF106 0x0020      ADD      R0,R6,#+32
   \   00000094   0x47A8             BLX      R5
   \   00000096   0x4605             MOV      R5,R0
   \   00000098   0x.... 0x....      BL       lock_release
   \                     ??handle_data_producer_7: (+1)
   \   0000009C   0x2D00             CMP      R5,#+0
   \   0000009E   0x46D8             MOV      R8,R11
   \   000000A0   0xD0CE             BEQ.N    ??handle_data_producer_3
   \   000000A2   0xF1B9 0x0F03      CMP      R9,#+3
   \   000000A6   0xBF0C             ITE      EQ 
   \   000000A8   0x.... 0x....      ADREQ.W  R1,?_10
   \   000000AC   0x.... 0x....      ADRNE.W  R1,?_11
   \   000000B0   0x462A             MOV      R2,R5
   \   000000B2   0x.... 0x....      ADR.W    R0,?_9
   \   000000B6   0x.... 0x....      BL       debug_printf
   \   000000BA   0x69F0             LDR      R0,[R6, #+28]
   \   000000BC   0x6946             LDR      R6,[R0, #+20]
   \   000000BE   0x68B6             LDR      R6,[R6, #+8]
   \   000000C0   0x2301             MOVS     R3,#+1
   \   000000C2   0x2200             MOVS     R2,#+0
   \   000000C4   0xA901             ADD      R1,SP,#+4
   \   000000C6   0x47B0             BLX      R6
   \   000000C8   0x4628             MOV      R0,R5
   \   000000CA   0x.... 0x....      BL       finalize_data_phase
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x7020             STRB     R0,[R4, #+0]
   \   000000D2   0xE011             B.N      ??handle_data_producer_8
    825              else if (status != kStatus_Success)
   \                     ??handle_data_producer_4: (+1)
   \   000000D4   0xB155             CBZ.N    R5,??handle_data_producer_9
    826              {
    827                  debug_printf("writePacket aborted due to status 0x%x\r\n", status);
   \   000000D6   0x4629             MOV      R1,R5
   \   000000D8   0x.... 0x....      ADR.W    R0,?_12
   \   000000DC   0x.... 0x....      BL       debug_printf
    828                  finalize_data_phase(status);
   \   000000E0   0x4628             MOV      R0,R5
   \                     ??handle_data_producer_5: (+1)
   \   000000E2   0x.... 0x....      BL       finalize_data_phase
    829                  *hasMoreData = false;
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x7020             STRB     R0,[R4, #+0]
   \   000000EA   0xE004             B.N      ??handle_data_producer_1
    830              }
   \                     ??handle_data_producer_9: (+1)
   \   000000EC   0x68F0             LDR      R0,[R6, #+12]
   \   000000EE   0x68C0             LDR      R0,[R0, #+12]
   \   000000F0   0x6107             STR      R7,[R0, #+16]
    831              else
    832              {
    833                  g_bootloaderContext.commandInterface->stateData->dataPhase.count = remaining;
    834                  g_bootloaderContext.commandInterface->stateData->dataPhase.address = dataAddress;
   \   000000F2   0xF8C0 0x8014      STR      R8,[R0, #+20]
    835              }
    836          
    837              return kStatus_Success;
   \                     ??handle_data_producer_1: (+1)
   \   000000F6   0x2000             MOVS     R0,#+0
   \                     ??handle_data_producer_8: (+1)
   \   000000F8   0xB009             ADD      SP,SP,#+36
   \   000000FA   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    838          }
    839          
    840          //! @brief Fill Memory command handler.

   \                                 In section .text, align 2, keep-with-next
    841          void handle_fill_memory(uint8_t *packet, uint32_t packetLength)
    842          {
   \                     handle_fill_memory: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    843              fill_memory_packet_t *command = (fill_memory_packet_t *)packet;
    844          
    845              status_t status =
    846                  g_bootloaderContext.memoryInterface->fill(command->startAddress, command->byteCount, command->patternWord);
   \   00000002   0x....             LDR.N    R3,??DataTable34
   \   00000004   0x681B             LDR      R3,[R3, #+0]
   \   00000006   0x68DB             LDR      R3,[R3, #+12]
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0x68E2             LDR      R2,[R4, #+12]
   \   0000000C   0x68A1             LDR      R1,[R4, #+8]
   \   0000000E   0x6860             LDR      R0,[R4, #+4]
   \   00000010   0x4798             BLX      R3
    847          
    848              send_generic_response(status, command->commandPacket.commandTag);
   \   00000012   0x....             B.N      ?Subroutine0
    849          }
    850          
    851          //! @brief Execute command handler.

   \                                 In section .text, align 2, keep-with-next
    852          void handle_execute(uint8_t *packet, uint32_t packetLength)
    853          {
   \                     handle_execute: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
    854              execute_call_packet_t *command = (execute_call_packet_t *)packet;
    855          
    856          #if !defined(BOOTLOADER_HOST)
    857              static uint32_t s_addr = 0;
    858              uint32_t call_address = command->callAddress;
    859              uint32_t argument_word = command->argumentWord;
    860              s_addr = command->stackpointer;
   \   00000006   0x....             LDR.N    R4,??DataTable34_3
   \   00000008   0x686E             LDR      R6,[R5, #+4]
   \   0000000A   0xF8D5 0x8008      LDR      R8,[R5, #+8]
   \   0000000E   0x68E8             LDR      R0,[R5, #+12]
    861              status_t responseStatus = kStatus_Success;
    862          
    863              // Get RAM address ranges
    864              const memory_map_entry_t *map = &g_bootloaderContext.memoryMap[kIndexSRAM];
   \   00000010   0x....             LDR.N    R1,??DataTable34
   \   00000012   0x6020             STR      R0,[R4, #+0]
   \   00000014   0x2700             MOVS     R7,#+0
   \   00000016   0x6849             LDR      R1,[R1, #+4]
   \   00000018   0x3110             ADDS     R1,R1,#+16
    865          
    866              // Validate stack pointer address. It must either be 0 or within the RAM range.
    867              if (!((s_addr == 0) || ((s_addr >= map->startAddress) && (s_addr <= map->endAddress + 1))))
   \   0000001A   0xB130             CBZ.N    R0,??handle_execute_0
   \   0000001C   0x680A             LDR      R2,[R1, #+0]
   \   0000001E   0x4290             CMP      R0,R2
   \   00000020   0xBF23             ITTTE    CS 
   \   00000022   0x6849             LDRCS    R1,[R1, #+4]
   \   00000024   0x1C49             ADDCS    R1,R1,#+1
   \   00000026   0x4281             CMPCS    R1,R0
   \   00000028   0x2704             MOVCC    R7,#+4
    868              {
    869                  // Invalid stack pointer value, respond with kStatus_InvalidArgument.
    870                  responseStatus = kStatus_InvalidArgument;
    871              }
    872          
    873              // Validate call address.
    874              if (!is_valid_application_location(call_address))
   \                     ??handle_execute_0: (+1)
   \   0000002A   0x4630             MOV      R0,R6
   \   0000002C   0x.... 0x....      BL       is_valid_application_location
   \   00000030   0xB900             CBNZ.N   R0,??handle_execute_1
    875              {
    876                  // Invalid address, respond with kStatus_InvalidArgument.
    877                  responseStatus = kStatus_InvalidArgument;
   \   00000032   0x2704             MOVS     R7,#+4
    878              }
    879          
    880          #if BL_FEATURE_OTFAD_MODULE
    881              if (is_qspi_present())
    882              {
    883                  quadspi_cache_clear();
    884                  status_t status = otfad_init_as_needed();
    885                  if (status != kStatus_Success)
    886                  {
    887                      responseStatus = kStatus_OtfadInvalidKeyBlob;
    888                  }
    889                  update_qspi_otfad_init_status(status);
    890              }
    891          #endif
    892          
    893              // Send response immediately since call may not return
    894              send_generic_response(responseStatus, command->commandPacket.commandTag);
   \                     ??handle_execute_1: (+1)
   \   00000034   0x7829             LDRB     R1,[R5, #+0]
   \   00000036   0x4638             MOV      R0,R7
   \   00000038   0x.... 0x....      BL       send_generic_response
    895          
    896              if (responseStatus == kStatus_Success)
   \   0000003C   0xB99F             CBNZ.N   R7,??handle_execute_2
    897              {
    898                  static call_function_t s_callFunction = 0;
    899                  s_callFunction = (call_function_t)call_address;
   \   0000003E   0x6066             STR      R6,[R4, #+4]
    900          
    901                  // Prepare for shutdown.
    902                  shutdown_cleanup(kShutdownType_Shutdown);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x.... 0x....      BL       shutdown_cleanup
    903          
    904                  // Static variables are needed since we are changing the stack pointer out from under the compiler
    905                  // we need to ensure the values we are using are not stored on the previous stack
    906                  static uint32_t s_argument = 0;
    907                  s_argument = argument_word;
    908          
    909                  if (s_addr)
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0xF8C4 0x8008      STR      R8,[R4, #+8]
   \   0000004C   0xB118             CBZ.N    R0,??handle_execute_3
    910                  {
    911                      // Set main stack pointer and process stack pointer
    912                      __set_MSP(s_addr);
   \   0000004E   0xF380 0x8808      MSR      MSP,R0
    913                      __set_PSP(s_addr);
   \   00000052   0xF380 0x8809      MSR      PSP,R0
    914                  }
    915          
    916                  s_callFunction(s_argument);
   \                     ??handle_execute_3: (+1)
   \   00000056   0x6861             LDR      R1,[R4, #+4]
   \   00000058   0x4640             MOV      R0,R8
   \   0000005A   0x4788             BLX      R1
    917                  // Dummy fcuntion call, should never go to this fcuntion call
    918                  shutdown_cleanup(kShutdownType_Shutdown);
   \   0000005C   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x.... 0x....      B.W      shutdown_cleanup
    919              }
    920          #else
    921              // Just send a successful response.
    922              send_generic_response(kStatus_Success, command->commandPacket.commandTag);
    923          #endif // BOOTLOADER_HOST
    924          }
   \                     ??handle_execute_2: (+1)
   \   00000066   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .bss, align 4
   \                     `handle_execute::s_addr`:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
   \   00000008                      DS8 4
    925          
    926          //! @brief Call command handler.

   \                                 In section .text, align 2, keep-with-next
    927          void handle_call(uint8_t *packet, uint32_t packetLength)
    928          {
   \                     handle_call: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    929              execute_call_packet_t *command = (execute_call_packet_t *)packet;
    930              status_t responseStatus = kStatus_Success;
    931          
    932          #if !defined(BOOTLOADER_HOST)
    933              // Validate call address.
    934              if (!is_valid_application_location(command->callAddress))
   \   00000004   0x6860             LDR      R0,[R4, #+4]
   \   00000006   0x.... 0x....      BL       is_valid_application_location
   \   0000000A   0xB908             CBNZ.N   R0,??handle_call_0
    935              {
    936                  // Invalid address, respond with kStatus_InvalidArgument.
    937                  responseStatus = kStatus_InvalidArgument;
   \   0000000C   0x2004             MOVS     R0,#+4
   \   0000000E   0xE005             B.N      ??handle_call_1
    938              }
    939              else
    940              {
    941                  call_function_t callFunction = (call_function_t)command->callAddress;
   \                     ??handle_call_0: (+1)
   \   00000010   0x6865             LDR      R5,[R4, #+4]
    942                  shutdown_cleanup(kShutdownType_Cleanup);
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x.... 0x....      BL       shutdown_cleanup
    943                  responseStatus = callFunction(command->argumentWord);
   \   00000018   0x68A0             LDR      R0,[R4, #+8]
   \   0000001A   0x47A8             BLX      R5
    944              }
    945          #endif // BOOTLOADER_HOST
    946          
    947              send_generic_response(responseStatus, command->commandPacket.commandTag);
   \                     ??handle_call_1: (+1)
   \   0000001C   0x7821             LDRB     R1,[R4, #+0]
   \   0000001E   0x....             B.N      ?Subroutine1
    948          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000004   0x....             B.N      send_generic_response
    949          
    950          //! @brief Flash Security Disable command handler.

   \                                 In section .text, align 2, keep-with-next
    951          void handle_flash_security_disable(uint8_t *packet, uint32_t packetLength)
    952          {
    953              flash_security_disable_packet_t *command = (flash_security_disable_packet_t *)packet;
    954          
    955              status_t status = kStatus_Success;
    956          #if !defined(BOOTLOADER_HOST)
    957              // Flash interface wants little endian, so just send two uint32s.
    958              status = g_bootloaderContext.flashDriverInterface->flash_security_bypass(&g_bootloaderContext.flashState,
    959                                                                                       (uint8_t *)&command->keyLow);
   \                     handle_flash_security_disable: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable34
   \   00000002   0xB510             PUSH     {R4,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xF102 0x0020      ADD      R0,R2,#+32
   \   0000000A   0x6912             LDR      R2,[R2, #+16]
   \   0000000C   0x69D2             LDR      R2,[R2, #+28]
   \   0000000E   0x1D21             ADDS     R1,R4,#+4
   \   00000010   0x4790             BLX      R2
    960          #endif // BOOTLOADER_HOST
    961          
    962              send_generic_response(status, command->commandPacket.commandTag);
   \   00000012   0x....             B.N      ?Subroutine0
    963          }
    964          
    965          //! @brief  Flash Program Once command handler

   \                                 In section .text, align 2, keep-with-next
    966          void handle_flash_program_once(uint8_t *packet, uint32_t length)
    967          {
   \                     handle_flash_program_once: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine5
    968              flash_program_once_packet_t *command = (flash_program_once_packet_t *)packet;
    969          
    970              status_t status = kStatus_Success;
    971          
    972          #if !defined(BOOTLOADER_HOST)
    973              lock_acquire();
    974              status = g_bootloaderContext.flashDriverInterface->flash_program_once(
    975                  &g_bootloaderContext.flashState, command->index, &command->data[0], command->byteCount);
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000006   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_16: (+1)
   \   0000000A   0x6B6D             LDR      R5,[R5, #+52]
   \   0000000C   0xF104 0x020C      ADD      R2,R4,#+12
   \   00000010   0x47A8             BLX      R5
   \   00000012   0x4605             MOV      R5,R0
    976              lock_release();
   \   00000014   0x.... 0x....      BL       lock_release
    977          #endif // BOOTLOADER_HOST
    978          
    979              send_generic_response(status, command->commandPacket.commandTag);
   \   00000018   0x7821             LDRB     R1,[R4, #+0]
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C                      REQUIRE ?Subroutine1
   \   0000001C                      ;; // Fall through to label ?Subroutine1
    980          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \   00000000   0xF105 0x0020      ADD      R0,R5,#+32
   \   00000004   0x692D             LDR      R5,[R5, #+16]
   \   00000006   0x68A3             LDR      R3,[R4, #+8]
   \   00000008   0x6861             LDR      R1,[R4, #+4]
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x....             LDR.N    R5,??DataTable34
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x.... 0x....      B.W      lock_acquire
    981          
    982          //! @brief  Flash Read Once command handler

   \                                 In section .text, align 2, keep-with-next
    983          void handle_flash_read_once(uint8_t *packet, uint32_t length)
    984          {
   \                     handle_flash_read_once: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    985              flash_read_once_packet_t *command = (flash_read_once_packet_t *)packet;
    986          
    987              uint32_t readOnceItemData[2] = { 0 };
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0xE9CD 0x1100      STRD     R1,R1,[SP, #+0]
   \   0000000A   0x.... 0x....      BL       ?Subroutine5
    988          
    989              status_t status = kStatus_Success;
    990          
    991          #if !defined(BOOTLOADER_HOST)
    992              lock_acquire();
    993              status = g_bootloaderContext.flashDriverInterface->flash_read_once(&g_bootloaderContext.flashState, command->index,
    994                                                                                 &readOnceItemData[0], command->byteCount);
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000000E   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_17: (+1)
   \   00000012   0x6BAD             LDR      R5,[R5, #+56]
   \   00000014   0x466A             MOV      R2,SP
   \   00000016   0x47A8             BLX      R5
   \   00000018   0x4605             MOV      R5,R0
    995              lock_release();
   \   0000001A   0x.... 0x....      BL       lock_release
    996          #endif // BOOTLOADER_HOST
    997          
    998              send_flash_read_once_response(status, readOnceItemData, command->byteCount);
   \   0000001E   0x68A2             LDR      R2,[R4, #+8]
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0x.... 0x....      BL       send_flash_read_once_response
    999          }
   \   00000028   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
   1000          
   1001          //! @brief  Flash Read Resource command handler

   \                                 In section .text, align 2, keep-with-next
   1002          void handle_flash_read_resource(uint8_t *packet, uint32_t length)
   1003          {
   \                     handle_flash_read_resource: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine8
   1004              flash_read_resource_packet_t *command = (flash_read_resource_packet_t *)packet;
   1005          
   1006              // Start the data phase.
   1007              reset_data_phase();
   1008              g_bootloaderContext.commandInterface->stateData->dataPhase.count = command->byteCount;
   \                     ??CrossCallReturnLabel_8: (+1)
   \   00000006   0x....             LDR.N    R0,??DataTable34
   \   00000008   0x68C1             LDR      R1,[R0, #+12]
   \   0000000A   0x68C9             LDR      R1,[R1, #+12]
   \   0000000C   0x68A2             LDR      R2,[R4, #+8]
   \   0000000E   0x610A             STR      R2,[R1, #+16]
   1009              g_bootloaderContext.commandInterface->stateData->dataPhase.address = command->startAddress;
   \   00000010   0x6862             LDR      R2,[R4, #+4]
   \   00000012   0x614A             STR      R2,[R1, #+20]
   1010              g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag = kCommandTag_FlashReadResource;
   \   00000014   0x2210             MOVS     R2,#+16
   \   00000016   0x770A             STRB     R2,[R1, #+28]
   1011              g_bootloaderContext.commandInterface->stateData->dataPhase.option = (uint8_t)command->option;
   \   00000018   0x68C0             LDR      R0,[R0, #+12]
   \   0000001A   0x68C0             LDR      R0,[R0, #+12]
   \   0000001C   0x68E1             LDR      R1,[R4, #+12]
   \   0000001E   0x7741             STRB     R1,[R0, #+29]
   1012              send_flash_read_resource_response(kStatus_Success, command->byteCount);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x68A1             LDR      R1,[R4, #+8]
   \   00000024   0xE8BD 0x4010      POP      {R4,LR}
   \   00000028   0x....             B.N      send_flash_read_resource_response
   1013          }
   1014          
   1015          //! @brief Send a generic response packet.

   \                                 In section .text, align 2, keep-with-next
   1016          void send_generic_response(uint32_t commandStatus, uint32_t commandTag)
   1017          {
   \                     send_generic_response: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   1018              generic_response_packet_t responsePacket;
   1019              responsePacket.commandPacket.commandTag = kCommandTag_GenericResponse;
   \   00000004   0x22A0             MOVS     R2,#+160
   1020              responsePacket.commandPacket.flags = 0;
   1021              responsePacket.commandPacket.reserved = 0;
   1022              responsePacket.commandPacket.parameterCount = 2;
   1023              responsePacket.status = commandStatus;
   \   00000006   0x9001             STR      R0,[SP, #+4]
   \   00000008   0xF88D 0x2000      STRB     R2,[SP, #+0]
   \   0000000C   0x2200             MOVS     R2,#+0
   1024              responsePacket.commandTag = commandTag;
   \   0000000E   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_14: (+1)
   \   00000012   0xF88D 0x2002      STRB     R2,[SP, #+2]
   \   00000016   0x9102             STR      R1,[SP, #+8]
   \   00000018   0x2202             MOVS     R2,#+2
   \   0000001A   0xF88D 0x2003      STRB     R2,[SP, #+3]
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x6944             LDR      R4,[R0, #+20]
   \   00000022   0x68A4             LDR      R4,[R4, #+8]
   \   00000024   0x220C             MOVS     R2,#+12
   \   00000026   0x....             B.N      ??Subroutine2_0
   1025          
   1026              status_t status = g_bootloaderContext.activePeripheral->packetInterface->writePacket(
   1027                  g_bootloaderContext.activePeripheral, (const uint8_t *)&responsePacket, sizeof(responsePacket),
   1028                  kPacketType_Command);
   1029              if (status != kStatus_Success)
   1030              {
   1031                  debug_printf("Error: writePacket returned status 0x%x\r\n", status);
   1032              }
   1033          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xF88D 0x2000      STRB     R2,[SP, #+0]
   \   00000004   0x9001             STR      R0,[SP, #+4]
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_15: (+1)
   \   0000000C   0x9102             STR      R1,[SP, #+8]
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0xF88D 0x2002      STRB     R2,[SP, #+2]
   \   00000014   0x2300             MOVS     R3,#+0
   \   00000016   0x2202             MOVS     R2,#+2
   \   00000018   0xF88D 0x2003      STRB     R2,[SP, #+3]
   \   0000001C   0x220C             MOVS     R2,#+12
   \   0000001E   0x6944             LDR      R4,[R0, #+20]
   \   00000020   0x68A4             LDR      R4,[R4, #+8]
   \                     ??Subroutine2_0: (+1)
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x47A0             BLX      R4
   \   00000026   0xB120             CBZ.N    R0,??Subroutine2_1
   \   00000028   0x4601             MOV      R1,R0
   \   0000002A   0x.... 0x....      ADR.W    R0,?_14
   \   0000002E   0x.... 0x....      BL       debug_printf
   \                     ??Subroutine2_1: (+1)
   \   00000032   0xBD1F             POP      {R0-R4,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable34
   \   00000002   0x69C0             LDR      R0,[R0, #+28]
   \   00000004   0xF88D 0x2001      STRB     R2,[SP, #+1]
   \   00000008   0x4770             BX       LR
   1034          
   1035          //! @brief Send a get property response packet.

   \                                 In section .text, align 2, keep-with-next
   1036          void send_get_property_response(uint32_t commandStatus, uint32_t *value, uint32_t numValues)
   1037          {
   \                     send_get_property_response: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   1038              get_property_response_packet_t responsePacket;
   1039              responsePacket.commandPacket.commandTag = kCommandTag_GetPropertyResponse;
   \   00000004   0x23A7             MOVS     R3,#+167
   \   00000006   0x.... 0x....      BL       ?Subroutine7
   1040              responsePacket.commandPacket.flags = 0;
   1041              responsePacket.commandPacket.reserved = 0;
   1042              responsePacket.commandPacket.parameterCount = 1 + numValues; // status + value words
   1043              responsePacket.status = commandStatus;
   1044          
   1045              for (uint32_t i = 0; i < numValues; ++i)
   \                     ??CrossCallReturnLabel_6: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x1C53             ADDS     R3,R2,#+1
   \   0000000E   0xF88D 0x3003      STRB     R3,[SP, #+3]
   \   00000012   0xE006             B.N      ??send_get_property_response_0
   1046              {
   1047                  responsePacket.propertyValue[i] = value[i];
   \                     ??send_get_property_response_1: (+1)
   \   00000014   0x466C             MOV      R4,SP
   \   00000016   0xF851 0x3020      LDR      R3,[R1, R0, LSL #+2]
   \   0000001A   0xEB04 0x0480      ADD      R4,R4,R0, LSL #+2
   1048              }
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0x60A3             STR      R3,[R4, #+8]
   \                     ??send_get_property_response_0: (+1)
   \   00000022   0x4290             CMP      R0,R2
   \   00000024   0xD3F6             BCC.N    ??send_get_property_response_1
   \   00000026   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_12: (+1)
   \   0000002A   0x2300             MOVS     R3,#+0
   \   0000002C   0x....             B.N      ?Subroutine3
   1049          
   1050              uint32_t packetSize =
   1051                  sizeof(responsePacket.commandPacket) + (responsePacket.commandPacket.parameterCount * sizeof(uint32_t));
   1052          
   1053              status_t status = g_bootloaderContext.activePeripheral->packetInterface->writePacket(
   1054                  g_bootloaderContext.activePeripheral, (const uint8_t *)&responsePacket, packetSize, kPacketType_Command);
   1055              if (status != kStatus_Success)
   1056              {
   1057                  debug_printf("Error: writePacket returned status 0x%x\r\n", status);
   1058              }
   1059          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x4669             MOV      R1,SP
   \   00000002   0x47A0             BLX      R4
   \   00000004   0xB120             CBZ.N    R0,??Subroutine3_0
   \   00000006   0x4601             MOV      R1,R0
   \   00000008   0x.... 0x....      ADR.W    R0,?_14
   \   0000000C   0x.... 0x....      BL       debug_printf
   \                     ??Subroutine3_0: (+1)
   \   00000010   0xB008             ADD      SP,SP,#+32
   \   00000012   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable34
   \   00000002   0x69C0             LDR      R0,[R0, #+28]
   \   00000004   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   00000008   0x6944             LDR      R4,[R0, #+20]
   \   0000000A   0x68A4             LDR      R4,[R4, #+8]
   \   0000000C   0x0089             LSLS     R1,R1,#+2
   \   0000000E   0x1D0A             ADDS     R2,R1,#+4
   \   00000010   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0xF88D 0x3000      STRB     R3,[SP, #+0]
   \   00000004   0x9001             STR      R0,[SP, #+4]
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0xF88D 0x3001      STRB     R3,[SP, #+1]
   \   0000000C   0xF88D 0x3002      STRB     R3,[SP, #+2]
   \   00000010   0x4770             BX       LR
   1060          
   1061          //! @brief Send a read memory response packet.

   \                                 In section .text, align 2, keep-with-next
   1062          void send_read_memory_response(uint32_t commandStatus, uint32_t length)
   1063          {
   \                     send_read_memory_response: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   1064              read_memory_response_packet_t responsePacket;
   1065              responsePacket.commandPacket.commandTag = kCommandTag_ReadMemoryResponse;
   \   00000004   0x22A3             MOVS     R2,#+163
   \   00000006   0x....             B.N      ?Subroutine2
   1066              responsePacket.commandPacket.flags = kCommandFlag_HasDataPhase;
   1067              responsePacket.commandPacket.reserved = 0;
   1068              responsePacket.commandPacket.parameterCount = 2;
   1069              responsePacket.status = commandStatus;
   1070              responsePacket.dataByteCount = length;
   1071          
   1072              status_t status = g_bootloaderContext.activePeripheral->packetInterface->writePacket(
   1073                  g_bootloaderContext.activePeripheral, (const uint8_t *)&responsePacket, sizeof(responsePacket),
   1074                  kPacketType_Command);
   1075              if (status != kStatus_Success)
   1076              {
   1077                  debug_printf("Error: writePacket returned status 0x%x\r\n", status);
   1078              }
   1079          }
   1080          
   1081          //! @brief Send a flash read once resposne packet.

   \                                 In section .text, align 2, keep-with-next
   1082          void send_flash_read_once_response(uint32_t commandStatus, uint32_t *value, uint32_t byteCount)
   1083          {
   \                     send_flash_read_once_response: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   1084              flash_read_once_response_packet_t responsePacket;
   1085              responsePacket.commandPacket.commandTag = kCommandTag_FlashReadOnceResponse;
   \   00000004   0x23AF             MOVS     R3,#+175
   \   00000006   0x.... 0x....      BL       ?Subroutine7
   1086              responsePacket.commandPacket.flags = 0;
   1087              responsePacket.commandPacket.reserved = 0;
   1088              responsePacket.commandPacket.parameterCount = 2; // always includes two parameters: status and byte count
   1089              responsePacket.status = commandStatus;
   \                     ??CrossCallReturnLabel_7: (+1)
   \   0000000A   0x2302             MOVS     R3,#+2
   \   0000000C   0xF88D 0x3003      STRB     R3,[SP, #+3]
   1090          
   1091              if (commandStatus == kStatus_Success)
   \   00000010   0xB950             CBNZ.N   R0,??send_flash_read_once_response_0
   1092              {
   1093                  responsePacket.commandPacket.parameterCount += byteCount / sizeof(uint32_t); // add parameter: data
   \   00000012   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   1094                  responsePacket.byteCount = byteCount;
   \   00000016   0x9202             STR      R2,[SP, #+8]
   \   00000018   0xEB00 0x0092      ADD      R0,R0,R2, LSR #+2
   \   0000001C   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1095                  memcpy(responsePacket.data, value, byteCount);
   \   00000020   0xA803             ADD      R0,SP,#+12
   \   00000022   0x.... 0x....      BL       __aeabi_memcpy4
   1096              }
   \   00000026   0xE001             B.N      ??send_flash_read_once_response_1
   1097              else
   1098              {
   1099                  responsePacket.byteCount = 0;
   \                     ??send_flash_read_once_response_0: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x9002             STR      R0,[SP, #+8]
   \                     ??send_flash_read_once_response_1: (+1)
   \   0000002C   0x2300             MOVS     R3,#+0
   1100              }
   \   0000002E   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_13: (+1)
   \   00000032                      REQUIRE ?Subroutine3
   \   00000032                      ;; // Fall through to label ?Subroutine3
   1101          
   1102              uint32_t packetSize =
   1103                  sizeof(responsePacket.commandPacket) + (responsePacket.commandPacket.parameterCount * sizeof(uint32_t));
   1104          
   1105              status_t status = g_bootloaderContext.activePeripheral->packetInterface->writePacket(
   1106                  g_bootloaderContext.activePeripheral, (const uint8_t *)&responsePacket, packetSize, kPacketType_Command);
   1107              if (status != kStatus_Success)
   1108              {
   1109                  debug_printf("Error: writePacket returned status 0x%x\r\n", status);
   1110              }
   1111          }
   1112          
   1113          //! @brief Send a flash read resource memory response packet.

   \                                 In section .text, align 2, keep-with-next
   1114          void send_flash_read_resource_response(uint32_t commandStatus, uint32_t length)
   1115          {
   \                     send_flash_read_resource_response: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   1116              flash_read_resource_response_packet_t responsePacket;
   1117              responsePacket.commandPacket.commandTag = kCommandTag_FlashReadResourceResponse;
   \   00000004   0x22B0             MOVS     R2,#+176
   \   00000006                      REQUIRE ?Subroutine2
   \   00000006                      ;; // Fall through to label ?Subroutine2
   1118              responsePacket.commandPacket.flags = kCommandFlag_HasDataPhase;
   1119              responsePacket.commandPacket.reserved = 0;
   1120              responsePacket.commandPacket.parameterCount = 2;
   1121              responsePacket.status = commandStatus;
   1122              responsePacket.dataByteCount = length;
   1123          
   1124              status_t status = g_bootloaderContext.activePeripheral->packetInterface->writePacket(
   1125                  g_bootloaderContext.activePeripheral, (const uint8_t *)&responsePacket, sizeof(responsePacket),
   1126                  kPacketType_Command);
   1127              if (status != kStatus_Success)
   1128              {
   1129                  debug_printf("Error: writePacket returned status 0x%x\r\n", status);
   1130              }
   1131          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   0x........         DC32     g_bootloaderContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_1:
   \   00000000   0xE000ED0C         DC32     0xe000ed0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_2:
   \   00000000   0x05FA0004         DC32     0x5fa0004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_3:
   \   00000000   0x........         DC32     `handle_execute::s_addr`

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x45 0x72          DC8 "Error: readPacket returned status 0x%x\015\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x72    
   \              0x65 0x61    
   \              0x64 0x50    
   \              0x61 0x63    
   \              0x6B 0x65    
   \              0x74 0x20    
   \              0x72 0x65    
   \              0x74 0x75    
   \              0x72 0x6E    
   \              0x65 0x64    
   \              0x20 0x73    
   \              0x74 0x61    
   \              0x74 0x75    
   \              0x73 0x20    
   \              0x30 0x78    
   \              0x25 0x78    
   \              0x0D 0x0A    
   \              0x00         
   \   00000029   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x45 0x72          DC8 "Error: handle_command returned status 0x%x\015\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x68    
   \              0x61 0x6E    
   \              0x64 0x6C    
   \              0x65 0x5F    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x20    
   \              0x72 0x65    
   \              0x74 0x75    
   \              0x72 0x6E    
   \              0x65 0x64    
   \              0x20 0x73    
   \              0x74 0x61    
   \              0x74 0x75    
   \              0x73 0x20    
   \              0x30 0x78    
   \              0x25 0x78    
   \              0x0D 0x0A    
   \              0x00         
   \   0000002D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x45 0x72          DC8 "Error: handle_data returned status 0x%x\015\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x68    
   \              0x61 0x6E    
   \              0x64 0x6C    
   \              0x65 0x5F    
   \              0x64 0x61    
   \              0x74 0x61    
   \              0x20 0x72    
   \              0x65 0x74    
   \              0x75 0x72    
   \              0x6E 0x65    
   \              0x64 0x20    
   \              0x73 0x74    
   \              0x61 0x74    
   \              0x75 0x73    
   \              0x20 0x30    
   \              0x78 0x25    
   \              0x78 0x0D    
   \              0x0A 0x00    
   \   0000002A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x45 0x72          DC8 45H, 72H, 72H, 6FH, 72H, 3AH, 20H, 63H
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x63    
   \   00000008   0x6F 0x6D          DC8 6FH, 6DH, 6DH, 61H, 6EH, 64H, 20H, 30H
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x20 0x30    
   \   00000010   0x78 0x25          DC8 78H, 25H, 78H, 20H, 6EH, 6FH, 74H, 20H
   \              0x78 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \   00000018   0x61 0x76          DC8 61H, 76H, 61H, 69H, 6CH, 61H, 62H, 6CH
   \              0x61 0x69    
   \              0x6C 0x61    
   \              0x62 0x6C    
   \   00000020   0x65 0x20          DC8 65H, 20H, 64H, 75H, 65H, 20H, 74H, 6FH
   \              0x64 0x75    
   \              0x65 0x20    
   \              0x74 0x6F    
   \   00000028   0x20 0x66          DC8 20H, 66H, 6CH, 61H, 73H, 68H, 20H, 73H
   \              0x6C 0x61    
   \              0x73 0x68    
   \              0x20 0x73    
   \   00000030   0x65 0x63          DC8 65H, 63H, 75H, 72H, 69H, 74H, 79H, 0DH
   \              0x75 0x72    
   \              0x69 0x74    
   \              0x79 0x0D    
   \   00000038   0x0A 0x00          DC8 0AH, 0
   \   0000003A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x75 0x6E          DC8 "unknown command 0x%x\015\012"
   \              0x6B 0x6E    
   \              0x6F 0x77    
   \              0x6E 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x20    
   \              0x30 0x78    
   \              0x25 0x78    
   \              0x0D 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x45 0x72          DC8 "Error: no handler entry for data phase\015\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x6E    
   \              0x6F 0x20    
   \              0x68 0x61    
   \              0x6E 0x64    
   \              0x6C 0x65    
   \              0x72 0x20    
   \              0x65 0x6E    
   \              0x74 0x72    
   \              0x79 0x20    
   \              0x66 0x6F    
   \              0x72 0x20    
   \              0x64 0x61    
   \              0x74 0x61    
   \              0x20 0x70    
   \              0x68 0x61    
   \              0x73 0x65    
   \              0x0D 0x0A    
   \              0x00         
   \   00000029   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x63 0x6F          DC8 "consumer abort data phase due to status 0x%x\015\012"
   \              0x6E 0x73    
   \              0x75 0x6D    
   \              0x65 0x72    
   \              0x20 0x61    
   \              0x62 0x6F    
   \              0x72 0x74    
   \              0x20 0x64    
   \              0x61 0x74    
   \              0x61 0x20    
   \              0x70 0x68    
   \              0x61 0x73    
   \              0x65 0x20    
   \              0x64 0x75    
   \              0x65 0x20    
   \              0x74 0x6F    
   \              0x20 0x73    
   \              0x74 0x61    
   \              0x74 0x75    
   \              0x73 0x20    
   \              0x30 0x78    
   \              0x25 0x78    
   \              0x0D 0x0A    
   \              0x00         
   \   0000002F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x44 0x61          DC8 "Data phase aborted by sender\015\012"
   \              0x74 0x61    
   \              0x20 0x70    
   \              0x68 0x61    
   \              0x73 0x65    
   \              0x20 0x61    
   \              0x62 0x6F    
   \              0x72 0x74    
   \              0x65 0x64    
   \              0x20 0x62    
   \              0x79 0x20    
   \              0x73 0x65    
   \              0x6E 0x64    
   \              0x65 0x72    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x44 0x61          DC8 "Data phase error 0x%x, aborting\015\012"
   \              0x74 0x61    
   \              0x20 0x70    
   \              0x68 0x61    
   \              0x73 0x65    
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x20 0x30    
   \              0x78 0x25    
   \              0x78 0x2C    
   \              0x20 0x61    
   \              0x62 0x6F    
   \              0x72 0x74    
   \              0x69 0x6E    
   \              0x67 0x0D    
   \              0x0A 0x00    
   \   00000022   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_9:
   \   00000000   0x45 0x72          DC8 45H, 72H, 72H, 6FH, 72H, 3AH, 20H, 25H
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x25    
   \   00000008   0x73 0x20          DC8 73H, 20H, 72H, 65H, 74H, 75H, 72H, 6EH
   \              0x72 0x65    
   \              0x74 0x75    
   \              0x72 0x6E    
   \   00000010   0x65 0x64          DC8 65H, 64H, 20H, 73H, 74H, 61H, 74H, 75H
   \              0x20 0x73    
   \              0x74 0x61    
   \              0x74 0x75    
   \   00000018   0x73 0x20          DC8 73H, 20H, 30H, 78H, 25H, 78H, 2CH, 20H
   \              0x30 0x78    
   \              0x25 0x78    
   \              0x2C 0x20    
   \   00000020   0x61 0x62          DC8 61H, 62H, 6FH, 72H, 74H, 20H, 64H, 61H
   \              0x6F 0x72    
   \              0x74 0x20    
   \              0x64 0x61    
   \   00000028   0x74 0x61          DC8 74H, 61H, 20H, 70H, 68H, 61H, 73H, 65H
   \              0x20 0x70    
   \              0x68 0x61    
   \              0x73 0x65    
   \   00000030   0x0D 0x0A          DC8 0DH, 0AH, 0
   \              0x00         
   \   00000033   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \   00000000   0x72 0x65          DC8 "read memory"
   \              0x61 0x64    
   \              0x20 0x6D    
   \              0x65 0x6D    
   \              0x6F 0x72    
   \              0x79 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_11:
   \   00000000   0x66 0x6C          DC8 "flash read resource"
   \              0x61 0x73    
   \              0x68 0x20    
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x20 0x72    
   \              0x65 0x73    
   \              0x6F 0x75    
   \              0x72 0x63    
   \              0x65 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_12:
   \   00000000   0x77 0x72          DC8 "writePacket aborted due to status 0x%x\015\012"
   \              0x69 0x74    
   \              0x65 0x50    
   \              0x61 0x63    
   \              0x6B 0x65    
   \              0x74 0x20    
   \              0x61 0x62    
   \              0x6F 0x72    
   \              0x74 0x65    
   \              0x64 0x20    
   \              0x64 0x75    
   \              0x65 0x20    
   \              0x74 0x6F    
   \              0x20 0x73    
   \              0x74 0x61    
   \              0x74 0x75    
   \              0x73 0x20    
   \              0x30 0x78    
   \              0x25 0x78    
   \              0x0D 0x0A    
   \              0x00         
   \   00000029   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_14:
   \   00000000   0x45 0x72          DC8 "Error: writePacket returned status 0x%x\015\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x77    
   \              0x72 0x69    
   \              0x74 0x65    
   \              0x50 0x61    
   \              0x63 0x6B    
   \              0x65 0x74    
   \              0x20 0x72    
   \              0x65 0x74    
   \              0x75 0x72    
   \              0x6E 0x65    
   \              0x64 0x20    
   \              0x73 0x74    
   \              0x61 0x74    
   \              0x75 0x73    
   \              0x20 0x30    
   \              0x78 0x25    
   \              0x78 0x0D    
   \              0x0A 0x00    
   \   0000002A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_13:
   \   00000000   0x00000000         DC32 0, 0
   \              0x00000000   
   1132          
   1133          //! @}
   1134          
   1135          ////////////////////////////////////////////////////////////////////////////////
   1136          // EOF
   1137          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   bootloader_command_init
      24   bootloader_command_pump
        24   -- Indirect call
        24   -> debug_printf
        24   -> handle_command
      16   debug_printf
        16   -> vprintf
      16   finalize_data_phase
        16   -- Indirect call
        16   -> sbloader_finalize
        16   -> send_generic_response
      16   handle_call
        16   -- Indirect call
        16   -> is_valid_application_location
         0   -> send_generic_response
        16   -> shutdown_cleanup
      32   handle_command
        32   -- Indirect call
        32   -> debug_printf
        32   -> send_generic_response
      32   handle_data_consumer
        32   -- Indirect call
        32   -> debug_printf
        32   -> finalize_data_phase
        32   -> sbloader_pump
      72   handle_data_producer
        72   -- Indirect call
        72   -> __aeabi_memcpy
        72   -> debug_printf
        72   -> finalize_data_phase
        72   -> lock_acquire
        72   -> lock_release
      24   handle_execute
        24   -- Indirect call
        24   -> is_valid_application_location
        24   -> send_generic_response
         0   -> shutdown_cleanup
        24   -> shutdown_cleanup
       8   handle_fill_memory
         8   -- Indirect call
         0   -> send_generic_response
       8   handle_flash_erase_all
         8   -> flash_mem_erase_all
         0   -> send_generic_response
       8   handle_flash_erase_all_unsecure
         8   -> flash_mem_erase_all_unsecure
         0   -> send_generic_response
       8   handle_flash_erase_region
         8   -- Indirect call
         0   -> send_generic_response
      16   handle_flash_program_once
        16   -- Indirect call
        16   -> lock_acquire
        16   -> lock_release
         0   -> send_generic_response
      24   handle_flash_read_once
        24   -- Indirect call
        24   -> lock_acquire
        24   -> lock_release
        24   -> send_flash_read_once_response
       8   handle_flash_read_resource
         8   -> reset_data_phase
         0   -> send_flash_read_resource_response
       8   handle_flash_security_disable
         8   -- Indirect call
         0   -> send_generic_response
      24   handle_get_property
        24   -- Indirect call
        24   -> send_get_property_response
       8   handle_read_memory
         8   -> reset_data_phase
         0   -> send_read_memory_response
       8   handle_receive_sb_file
         8   -> reset_data_phase
         0   -> sbloader_init
         8   -> send_generic_response
       8   handle_reset
         8   -- Indirect call
         8   -> send_generic_response
         8   -> shutdown_cleanup
       8   handle_set_property
         8   -- Indirect call
         0   -> send_generic_response
       8   handle_write_memory
         8   -> reset_data_phase
         0   -> send_generic_response
       0   reset_data_phase
         0   -> __aeabi_memclr4
      40   send_flash_read_once_response
        40   -- Indirect call
        40   -> __aeabi_memcpy4
        40   -> debug_printf
      24   send_flash_read_resource_response
        24   -- Indirect call
        24   -> debug_printf
      24   send_generic_response
        24   -- Indirect call
        24   -> debug_printf
      40   send_get_property_response
        40   -- Indirect call
        40   -> debug_printf
      24   send_read_memory_response
        24   -- Indirect call
        24   -> debug_printf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable34_2
       4  ??DataTable34_3
       8  ?Subroutine0
       6  ?Subroutine1
      10  ?Subroutine10
      12  ?Subroutine11
      52  ?Subroutine2
      20  ?Subroutine3
      18  ?Subroutine4
       8  ?Subroutine5
      10  ?Subroutine6
      18  ?Subroutine7
       4  ?Subroutine8
      18  ?Subroutine9
      44  ?_0
      48  ?_1
      12  ?_10
      20  ?_11
      44  ?_12
       8  ?_13
      44  ?_14
      44  ?_2
      60  ?_3
      24  ?_4
      44  ?_5
      48  ?_6
      32  ?_7
      36  ?_8
      52  ?_9
      14  bootloader_command_init
     160  bootloader_command_pump
      14  debug_printf
      68  finalize_data_phase
      36  g_commandData
     144  g_commandHandlerTable
      16  g_commandInterface
      32  handle_call
     152  handle_command
     238  handle_data_consumer
     254  handle_data_producer
     106  handle_execute
      20  handle_fill_memory
      10  handle_flash_erase_all
       8  handle_flash_erase_all_unsecure
      20  handle_flash_erase_region
      28  handle_flash_program_once
      42  handle_flash_read_once
      42  handle_flash_read_resource
      20  handle_flash_security_disable
      52  handle_get_property
      24  handle_read_memory
      38  handle_receive_sb_file
      58  handle_reset
      22  handle_set_property
      18  handle_write_memory
      16  reset_data_phase
      12  s_addr
          s_callFunction
          s_argument
      50  send_flash_read_once_response
       6  send_flash_read_resource_response
      40  send_generic_response
      46  send_get_property_response
       8  send_read_memory_response

 
    48 bytes in section .bss
    16 bytes in section .data
   152 bytes in section .rodata
 2 358 bytes in section .text
 
 2 358 bytes of CODE  memory
   152 bytes of CONST memory
    64 bytes of DATA  memory

Errors: none
Warnings: none
