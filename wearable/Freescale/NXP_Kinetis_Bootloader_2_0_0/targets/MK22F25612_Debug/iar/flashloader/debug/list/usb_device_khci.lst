###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Aug/2016  13:16:02
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\usb_device_khci.c
#    Command line =  
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\usb_device_khci.c"
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN256VDC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D BL_TARGET_RAM -lC
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj"
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices/MK22F25612\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/autobaud\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/osa\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device/class\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/bm_usb\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/CMSIS/Include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers/common\"
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list\usb_device_khci.lst
#    Object file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj\usb_device_khci.o
#
###############################################################################

C:\Users\cwati\Documents\My Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\usb_device_khci.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "usb_device_config.h"
     32          #include "usb.h"
     33          
     34          #include "usb_device.h"
     35          
     36          #include "fsl_device_registers.h"
     37          
     38          #if ((defined(USB_DEVICE_CONFIG_KHCI)) && (USB_DEVICE_CONFIG_KHCI > 0U))
     39          
     40          #include "usb_khci.h"
     41          #include "usb_device_dci.h"
     42          
     43          #include "usb_device_khci.h"
     44          
     45          /*******************************************************************************
     46           * Definitions
     47           ******************************************************************************/
     48          
     49          /*******************************************************************************
     50           * Prototypes
     51           ******************************************************************************/
     52          static usb_status_t USB_DeviceKhciEndpointTransfer(
     53              usb_device_khci_state_struct_t *khciState, uint8_t endpoint, uint8_t direction, uint8_t *buffer, uint32_t length);
     54          static void USB_DeviceKhciPrimeNextSetup(usb_device_khci_state_struct_t *khciState);
     55          static void USB_DeviceKhciSetDefaultState(usb_device_khci_state_struct_t *khciState);
     56          static usb_status_t USB_DeviceKhciEndpointInit(usb_device_khci_state_struct_t *khciState,
     57                                                         usb_device_endpoint_init_struct_t *epInit);
     58          static usb_status_t USB_DeviceKhciEndpointDeinit(usb_device_khci_state_struct_t *khciState, uint8_t ep);
     59          static usb_status_t USB_DeviceKhciEndpointStall(usb_device_khci_state_struct_t *khciState, uint8_t ep);
     60          static usb_status_t USB_DeviceKhciEndpointUnstall(usb_device_khci_state_struct_t *khciState, uint8_t ep);
     61          static void USB_DeviceKhciInterruptTokenDone(usb_device_khci_state_struct_t *khciState);
     62          static void USB_DeviceKhciInterruptReset(usb_device_khci_state_struct_t *khciState);
     63          #if ((defined(USB_DEVICE_CONFIG_LOW_POWER_MODE) && (USB_DEVICE_CONFIG_LOW_POWER_MODE > 0U)) || \
     64               (defined(USB_DEVICE_CONFIG_REMOTE_WAKEUP) && (USB_DEVICE_CONFIG_REMOTE_WAKEUP > 0U)))
     65          static void USB_DeviceKhciInterruptSleep(usb_device_khci_state_struct_t *khciState);
     66          static void USB_DeviceKhciInterruptResume(usb_device_khci_state_struct_t *khciState);
     67          #endif /* USB_DEVICE_CONFIG_LOW_POWER_MODE || USB_DEVICE_CONFIG_REMOTE_WAKEUP */
     68          static void USB_DeviceKhciInterruptStall(usb_device_khci_state_struct_t *khciState);
     69          #if defined(USB_DEVICE_CONFIG_KHCI_ERROR_HANDLING) && (USB_DEVICE_CONFIG_KHCI_ERROR_HANDLING > 0U)
     70          static void USB_DeviceKhciInterruptError(usb_device_khci_state_struct_t *khciState);
     71          #endif /* USB_DEVICE_CONFIG_KHCI_ERROR_HANDLING */
     72          
     73          extern usb_status_t USB_DeviceNotificationTrigger(void *handle, void *msg);
     74          
     75          /*******************************************************************************
     76           * Variables
     77           ******************************************************************************/
     78          
     79          /* Apply for BDT buffer, 512-byte alignment */

   \                                 In section m_usb_bdt, align 512
     80          USB_RAM_ADDRESS_ALGINMENT_512 USB_BDT static uint8_t s_UsbDeviceKhciBdtBuffer[USB_DEVICE_CONFIG_KHCI][512U];
   \                     s_UsbDeviceKhciBdtBuffer:
   \   00000000                      DS8 512
     81          
     82          /* Apply for khci device state structure */

   \                                 In section m_usb_global, align 4
     83          USB_GLOBAL static usb_device_khci_state_struct_t s_UsbDeviceKhciState[USB_DEVICE_CONFIG_KHCI];
   \                     s_UsbDeviceKhciState:
   \   00000000                      DS8 292
   \   00000124                      DS8 64
     84          /* Apply for KHCI DMA aligned buffer when marco USB_DEVICE_CONFIG_KHCI_DMA_ALIGN enabled */
     85          USB_GLOBAL static uint32_t s_UsbDeviceKhciDmaAlignBuffer
     86              [USB_DEVICE_CONFIG_KHCI][((USB_DEVICE_CONFIG_KHCI_DMA_ALIGN_BUFFER_LENGTH - 1U) >> 2U) + 1U];
     87          
     88          /*******************************************************************************
     89           * Code
     90           ******************************************************************************/
     91          
     92          /*!
     93           * @brief Write the BDT to start a transfer.
     94           *
     95           * The function is used to start a transfer by writing the BDT.
     96           *
     97           * @param khciState       Pointer of the device KHCI state structure.
     98           * @param endpoint         Endpoint number.
     99           * @param direction        The direction of the endpoint, 0U - USB_OUT, 1U - USB_IN.
    100           * @param buffer           The memory address to save the received data, or the memory address to hold the data need to
    101           * be sent.
    102           * @param length           The length of the data.
    103           *
    104           * @return A USB error code or kStatus_USB_Success.
    105           */

   \                                 In section .text, align 2, keep-with-next
    106          static usb_status_t USB_DeviceKhciEndpointTransfer(
    107              usb_device_khci_state_struct_t *khciState, uint8_t endpoint, uint8_t direction, uint8_t *buffer, uint32_t length)
    108          {
   \                     USB_DeviceKhciEndpointTransfer: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x461D             MOV      R5,R3
   \   00000008   0x460E             MOV      R6,R1
   \   0000000A   0x4617             MOV      R7,R2
    109              uint32_t index = ((uint32_t)endpoint << 1U) | (uint32_t)direction;
    110              USB_OSA_SR_ALLOC();
    111          
    112              /* Enter critical */
    113              USB_OSA_ENTER_CRITICAL();
   \   0000000C   0x.... 0x....      BL       USB_BmEnterCritical
   \   00000010   0xEA47 0x0846      ORR      R8,R7,R6, LSL #+1
    114          
    115              /* Flag the endpoint is busy. */
    116              khciState->endpointState[index].stateUnion.stateBitField.transferring = 1U;
   \   00000014   0xEB04 0x1008      ADD      R0,R4,R8, LSL #+4
    117          
    118              /* Add the data buffer address to the BDT. */
    119              USB_KHCI_BDT_SET_ADDRESS((uint32_t)khciState->bdt, endpoint, direction,
    120                                       khciState->endpointState[index].stateUnion.stateBitField.bdtOdd, (uint32_t)buffer);
   \   00000018   0x0172             LSLS     R2,R6,#+5
   \   0000001A   0x6AC1             LDR      R1,[R0, #+44]
   \   0000001C   0xF441 0x4380      ORR      R3,R1,#0x4000
   \   00000020   0x62C3             STR      R3,[R0, #+44]
   \   00000022   0x0139             LSLS     R1,R7,#+4
   \   00000024   0x6866             LDR      R6,[R4, #+4]
   \   00000026   0xF402 0x72F0      AND      R2,R2,#0x1E0
   \   0000002A   0x0A76             LSRS     R6,R6,#+9
   \   0000002C   0xF001 0x0110      AND      R1,R1,#0x10
   \   00000030   0xEA42 0x2646      ORR      R6,R2,R6, LSL #+9
   \   00000034   0x0A5B             LSRS     R3,R3,#+9
   \   00000036   0x430E             ORRS     R6,R1,R6
   \   00000038   0xF003 0x0308      AND      R3,R3,#0x8
   \   0000003C   0x4333             ORRS     R3,R3,R6
   \   0000003E   0x605D             STR      R5,[R3, #+4]
    121          
    122              /* Change the BDT control field to start the transfer. */
    123              USB_KHCI_BDT_SET_CONTROL(
    124                  (uint32_t)khciState->bdt, endpoint, direction, khciState->endpointState[index].stateUnion.stateBitField.bdtOdd,
    125                  USB_LONG_TO_LITTLE_ENDIAN(USB_KHCI_BDT_BC(length) | USB_KHCI_BDT_OWN | USB_KHCI_BDT_DTS |
    126                                            USB_KHCI_BDT_DATA01(khciState->endpointState[index].stateUnion.stateBitField.data0)));
   \   00000040   0x6863             LDR      R3,[R4, #+4]
   \   00000042   0x6AC0             LDR      R0,[R0, #+44]
   \   00000044   0x0A5B             LSRS     R3,R3,#+9
   \   00000046   0xEA42 0x2243      ORR      R2,R2,R3, LSL #+9
   \   0000004A   0x4311             ORRS     R1,R1,R2
   \   0000004C   0x0A42             LSRS     R2,R0,#+9
   \   0000004E   0xF002 0x0208      AND      R2,R2,#0x8
   \   00000052   0x4311             ORRS     R1,R2,R1
   \   00000054   0x9A06             LDR      R2,[SP, #+24]
   \   00000056   0x.... 0x....      LDR.W    R3,??DataTable4  ;; 0x3ff0000
   \   0000005A   0x0940             LSRS     R0,R0,#+5
   \   0000005C   0xEA03 0x4202      AND      R2,R3,R2, LSL #+16
   \   00000060   0xF000 0x0040      AND      R0,R0,#0x40
   \   00000064   0x4310             ORRS     R0,R0,R2
   \   00000066   0xF040 0x0088      ORR      R0,R0,#0x88
   \   0000006A   0x6008             STR      R0,[R1, #+0]
    127          
    128              /* Exit critical */
    129              USB_OSA_EXIT_CRITICAL();
   \   0000006C   0x.... 0x....      BL       USB_BmExitCritical
    130          
    131              /* Clear the token busy state */
    132              khciState->registerBase->CTL &= ~USB_CTL_TXSUSPENDTOKENBUSY_MASK;
   \   00000070   0x.... 0x....      BL       ?Subroutine0
    133              return kStatus_USB_Success;
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000074   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    134          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x68A0             LDR      R0,[R4, #+8]
   \   00000002   0xF890 0x1094      LDRB     R1,[R0, #+148]
   \   00000006   0xF001 0x01DF      AND      R1,R1,#0xDF
   \   0000000A   0xF880 0x1094      STRB     R1,[R0, #+148]
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4770             BX       LR
    135          
    136          /*!
    137           * @brief Prime a next setup transfer.
    138           *
    139           * The function is used to prime a buffer in control out pipe to wait for receiving the host's setup packet.
    140           *
    141           * @param khciState       Pointer of the device KHCI state structure.
    142           *
    143           */

   \                                 In section .text, align 2, keep-with-next
    144          static void USB_DeviceKhciPrimeNextSetup(usb_device_khci_state_struct_t *khciState)
    145          {
   \                     USB_DeviceKhciPrimeNextSetup: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    146          /* Update the endpoint state */
    147          /* Save the buffer address used to receive the setup packet. */
    148          #if defined(FSL_FEATURE_USB_KHCI_KEEP_ALIVE_ENABLED) && (FSL_FEATURE_USB_KHCI_KEEP_ALIVE_ENABLED > 0U) \
    149          && defined(USB_DEVICE_CONFIG_KEEP_ALIVE_MODE) &&                                         \
    150              (USB_DEVICE_CONFIG_KEEP_ALIVE_MODE > 0U) && defined(FSL_FEATURE_USB_KHCI_USB_RAM) && \
    151              (FSL_FEATURE_USB_KHCI_USB_RAM > 0U)
    152              /* In case of lowpower mode enabled, it requires to put the setup packet buffer(16 bytes) into the USB RAM so
    153               * that the setup packet would wake up the USB.
    154               */
    155              khciState->endpointState[(USB_CONTROL_ENDPOINT << 1U) | USB_OUT].transferBuffer =
    156                  (uint8_t *)(khciState->bdt + 0x200U - 0x10U) +
    157                  khciState->endpointState[(USB_CONTROL_ENDPOINT << 1U) | USB_OUT].stateUnion.stateBitField.bdtOdd *
    158                      USB_SETUP_PACKET_SIZE;
    159          #else
    160              khciState->endpointState[(USB_CONTROL_ENDPOINT << 1U) | USB_OUT].transferBuffer =
    161                  (uint8_t *)&khciState->setupPacketBuffer[0] +
    162                  khciState->endpointState[(USB_CONTROL_ENDPOINT << 1U) | USB_OUT].stateUnion.stateBitField.bdtOdd *
    163                      USB_SETUP_PACKET_SIZE;
   \   00000002   0x6AC1             LDR      R1,[R0, #+44]
   \   00000004   0x0A4A             LSRS     R2,R1,#+9
   \   00000006   0xF002 0x0208      AND      R2,R2,#0x8
   \   0000000A   0x4402             ADD      R2,R0,R2
   \   0000000C   0x320C             ADDS     R2,R2,#+12
   \   0000000E   0x6202             STR      R2,[R0, #+32]
    164          #endif
    165              /* Clear the transferred length. */
    166              khciState->endpointState[(USB_CONTROL_ENDPOINT << 1U) | USB_OUT].transferDone = 0U;
    167              /* Save the data length expected to get from a host. */
    168              khciState->endpointState[(USB_CONTROL_ENDPOINT << 1U) | USB_OUT].transferLength = USB_SETUP_PACKET_SIZE;
    169              /* Save the data buffer DMA align flag. */
    170              khciState->endpointState[(USB_CONTROL_ENDPOINT << 1U) | USB_OUT].stateUnion.stateBitField.dmaAlign = 1U;
    171              /* Set the DATA0/1 to DATA0. */
    172              khciState->endpointState[(USB_CONTROL_ENDPOINT << 1U) | USB_OUT].stateUnion.stateBitField.data0 = 0U;
   \   00000010   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x6282             STR      R2,[R0, #+40]
   \   00000018   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000001C   0x2208             MOVS     R2,#+8
   \   0000001E   0x6242             STR      R2,[R0, #+36]
   \   00000020   0x62C1             STR      R1,[R0, #+44]
    173          
    174              USB_DeviceKhciEndpointTransfer(khciState, USB_CONTROL_ENDPOINT, USB_OUT,
    175                                             khciState->endpointState[(USB_CONTROL_ENDPOINT << 1U) | USB_OUT].transferBuffer,
    176                                             USB_SETUP_PACKET_SIZE);
   \   00000022   0x9200             STR      R2,[SP, #+0]
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0x6A03             LDR      R3,[R0, #+32]
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x.... 0x....      BL       USB_DeviceKhciEndpointTransfer
    177          }
   \   0000002E   0xBD01             POP      {R0,PC}          ;; return
    178          
    179          /*!
    180           * @brief Set device controller state to default state.
    181           *
    182           * The function is used to set device controller state to default state.
    183           * The function will be called when USB_DeviceKhciInit called or the control type kUSB_DeviceControlGetEndpointStatus
    184           * received in USB_DeviceKhciControl.
    185           *
    186           * @param khciState       Pointer of the device KHCI state structure.
    187           *
    188           */

   \                                 In section .text, align 2, keep-with-next
    189          static void USB_DeviceKhciSetDefaultState(usb_device_khci_state_struct_t *khciState)
    190          {
   \                     USB_DeviceKhciSetDefaultState: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    191              uint8_t interruptFlag;
    192          
    193              /* Clear the error state register */
    194              khciState->registerBase->ERRSTAT = 0xFFU;
   \   00000002   0x1D01             ADDS     R1,R0,#+4
   \   00000004   0x22FF             MOVS     R2,#+255
   \   00000006   0x684B             LDR      R3,[R1, #+4]
   \   00000008   0xF883 0x2088      STRB     R2,[R3, #+136]
    195          
    196              /* Setting this bit to 1U resets all the BDT ODD ping/pong fields to 0U, which then specifies the EVEN BDT bank. */
    197              khciState->registerBase->CTL |= USB_CTL_ODDRST_MASK;
   \   0000000C   0x684B             LDR      R3,[R1, #+4]
   \   0000000E   0xF893 0x4094      LDRB     R4,[R3, #+148]
   \   00000012   0xF044 0x0402      ORR      R4,R4,#0x2
   \   00000016   0xF883 0x4094      STRB     R4,[R3, #+148]
    198          
    199              /* Clear the device address */
    200              khciState->registerBase->ADDR = 0U;
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x684C             LDR      R4,[R1, #+4]
   \   0000001E   0xF884 0x3098      STRB     R3,[R4, #+152]
    201          
    202              /* Clear the endpoint state and disable the endpoint */
    203              for (uint8_t count = 0U; count < USB_DEVICE_CONFIG_ENDPOINTS; count++)
    204              {
    205                  USB_KHCI_BDT_SET_CONTROL((uint32_t)khciState->bdt, count, USB_OUT, 0U, 0U);
   \                     ??USB_DeviceKhciSetDefaultState_0: (+1)
   \   00000022   0x680E             LDR      R6,[R1, #+0]
   \   00000024   0x015C             LSLS     R4,R3,#+5
   \   00000026   0xF404 0x74F0      AND      R4,R4,#0x1E0
   \   0000002A   0x0A76             LSRS     R6,R6,#+9
   \   0000002C   0xEA44 0x2646      ORR      R6,R4,R6, LSL #+9
   \   00000030   0x2500             MOVS     R5,#+0
   \   00000032   0x.... 0x....      BL       ?Subroutine2
    206                  USB_KHCI_BDT_SET_CONTROL((uint32_t)khciState->bdt, count, USB_OUT, 1U, 0U);
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000036   0xF046 0x0608      ORR      R6,R6,#0x8
   \   0000003A   0x.... 0x....      BL       ?Subroutine2
    207                  USB_KHCI_BDT_SET_CONTROL((uint32_t)khciState->bdt, count, USB_IN, 0U, 0U);
   \                     ??CrossCallReturnLabel_5: (+1)
   \   0000003E   0xF046 0x0610      ORR      R6,R6,#0x10
   \   00000042   0x6035             STR      R5,[R6, #+0]
    208                  USB_KHCI_BDT_SET_CONTROL((uint32_t)khciState->bdt, count, USB_IN, 1U, 0U);
   \   00000044   0x680E             LDR      R6,[R1, #+0]
   \   00000046   0x0A76             LSRS     R6,R6,#+9
   \   00000048   0xEA44 0x2446      ORR      R4,R4,R6, LSL #+9
   \   0000004C   0xF044 0x0418      ORR      R4,R4,#0x18
   \   00000050   0x6025             STR      R5,[R4, #+0]
    209          
    210                  khciState->endpointState[((uint32_t)count << 1U) | USB_OUT].stateUnion.state = 0U;
   \   00000052   0xEB00 0x1543      ADD      R5,R0,R3, LSL #+5
   \   00000056   0x2400             MOVS     R4,#+0
   \   00000058   0x62EC             STR      R4,[R5, #+44]
    211                  khciState->endpointState[((uint32_t)count << 1U) | USB_IN].stateUnion.state = 0U;
   \   0000005A   0x2500             MOVS     R5,#+0
   \   0000005C   0x005C             LSLS     R4,R3,#+1
   \   0000005E   0xF044 0x0401      ORR      R4,R4,#0x1
   \   00000062   0xEB00 0x1404      ADD      R4,R0,R4, LSL #+4
   \   00000066   0x62E5             STR      R5,[R4, #+44]
    212                  khciState->registerBase->ENDPOINT[count].ENDPT = 0x00U;
   \   00000068   0x684C             LDR      R4,[R1, #+4]
   \   0000006A   0xEB04 0x0483      ADD      R4,R4,R3, LSL #+2
    213              }
   \   0000006E   0x1C5B             ADDS     R3,R3,#+1
   \   00000070   0x2B08             CMP      R3,#+8
   \   00000072   0xF884 0x50C0      STRB     R5,[R4, #+192]
   \   00000076   0xD3D4             BCC.N    ??USB_DeviceKhciSetDefaultState_0
    214              khciState->isDmaAlignBufferInusing = 0U;
   \   00000078   0xF44F 0x7390      MOV      R3,#+288
   \   0000007C   0x4418             ADD      R0,R0,R3
   \   0000007E   0x7005             STRB     R5,[R0, #+0]
    215          
    216              /* Clear the BDT odd reset flag */
    217              khciState->registerBase->CTL &= ~USB_CTL_ODDRST_MASK;
   \   00000080   0x684B             LDR      R3,[R1, #+4]
   \   00000082   0xF893 0x4094      LDRB     R4,[R3, #+148]
   \   00000086   0xF004 0x04FD      AND      R4,R4,#0xFD
   \   0000008A   0xF883 0x4094      STRB     R4,[R3, #+148]
    218          
    219              /* Enable all error */
    220              khciState->registerBase->ERREN = 0xFFU;
   \   0000008E   0x684B             LDR      R3,[R1, #+4]
   \   00000090   0xF883 0x208C      STRB     R2,[R3, #+140]
    221          
    222              /* Enable reset, sof, token, stall interrupt */
    223              interruptFlag = kUSB_KhciInterruptReset
    224          #if 0U
    225                              | kUSB_KhciInterruptSofToken
    226          #endif
    227                              | kUSB_KhciInterruptTokenDone | kUSB_KhciInterruptStall;
    228          
    229          #if ((defined(USB_DEVICE_CONFIG_LOW_POWER_MODE) && (USB_DEVICE_CONFIG_LOW_POWER_MODE > 0U)) || \
    230               (defined(USB_DEVICE_CONFIG_REMOTE_WAKEUP) && (USB_DEVICE_CONFIG_REMOTE_WAKEUP > 0U)))
    231              /* Enable suspend interruprt */
    232              interruptFlag |= kUSB_KhciInterruptSleep;
    233          #endif /* USB_DEVICE_CONFIG_LOW_POWER_MODE || USB_DEVICE_CONFIG_REMOTE_WAKEUP */
    234          
    235          #if defined(USB_DEVICE_CONFIG_KHCI_ERROR_HANDLING) && (USB_DEVICE_CONFIG_KHCI_ERROR_HANDLING > 0U)
    236              /* Enable error interruprt */
    237              interruptFlag |= kUSB_KhciInterruptError;
    238          #endif /* USB_DEVICE_CONFIG_KHCI_ERROR_HANDLING */
    239              /* Write the interrupt enable register */
    240              khciState->registerBase->INTEN = interruptFlag;
   \   00000094   0x2289             MOVS     R2,#+137
   \   00000096   0x684B             LDR      R3,[R1, #+4]
   \   00000098   0xF883 0x2084      STRB     R2,[R3, #+132]
    241          
    242              /* Clear reset flag */
    243              khciState->isResetting = 0U;
   \   0000009C   0x7045             STRB     R5,[R0, #+1]
    244          
    245              khciState->registerBase->CTL &= ~USB_CTL_TXSUSPENDTOKENBUSY_MASK;
   \   0000009E   0x6848             LDR      R0,[R1, #+4]
   \   000000A0   0x.... 0x....      BL       ?Subroutine1
    246          }
   \                     ??CrossCallReturnLabel_2: (+1)
   \   000000A4   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x6035             STR      R5,[R6, #+0]
   \   00000002   0x680E             LDR      R6,[R1, #+0]
   \   00000004   0x0A76             LSRS     R6,R6,#+9
   \   00000006   0xEA44 0x2646      ORR      R6,R4,R6, LSL #+9
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xF890 0x1094      LDRB     R1,[R0, #+148]
   \   00000004   0xF001 0x01DF      AND      R1,R1,#0xDF
   \   00000008   0xF880 0x1094      STRB     R1,[R0, #+148]
   \   0000000C   0x4770             BX       LR
    247          
    248          /*!
    249           * @brief Initialize a specified endpoint.
    250           *
    251           * The function is used to initialize a specified endpoint.
    252           *
    253           * @param khciState       Pointer of the device KHCI state structure.
    254           * @param epInit          The endpoint initialization structure pointer.
    255           *
    256           * @return A USB error code or kStatus_USB_Success.
    257           */

   \                                 In section .text, align 2, keep-with-next
    258          static usb_status_t USB_DeviceKhciEndpointInit(usb_device_khci_state_struct_t *khciState,
    259                                                         usb_device_endpoint_init_struct_t *epInit)
    260          {
   \                     USB_DeviceKhciEndpointInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    261              uint16_t maxPacketSize = epInit->maxPacketSize;
   \   00000002   0x880C             LDRH     R4,[R1, #+0]
    262              uint8_t endpoint = (epInit->endpointAddress & USB_ENDPOINT_NUMBER_MASK);
   \   00000004   0x788B             LDRB     R3,[R1, #+2]
    263              uint8_t direction = (epInit->endpointAddress & USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_MASK) >>
    264                                  USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT;
    265              uint8_t index = ((uint8_t)((uint32_t)endpoint << 1U)) | (uint8_t)direction;
    266          
    267              /* Make the endpoint max packet size align with USB Specification 2.0. */
    268              if (USB_ENDPOINT_ISOCHRONOUS == epInit->transferType)
   \   00000006   0x78C9             LDRB     R1,[R1, #+3]
   \   00000008   0xF003 0x020F      AND      R2,R3,#0xF
   \   0000000C   0x09DB             LSRS     R3,R3,#+7
   \   0000000E   0x2901             CMP      R1,#+1
   \   00000010   0xEA43 0x0542      ORR      R5,R3,R2, LSL #+1
   \   00000014   0xD105             BNE.N    ??USB_DeviceKhciEndpointInit_0
    269              {
    270                  if (maxPacketSize > USB_DEVICE_MAX_FS_ISO_MAX_PACKET_SIZE)
   \   00000016   0xF5B4 0x6F80      CMP      R4,#+1024
   \   0000001A   0xD30E             BCC.N    ??USB_DeviceKhciEndpointInit_1
    271                  {
    272                      maxPacketSize = USB_DEVICE_MAX_FS_ISO_MAX_PACKET_SIZE;
   \   0000001C   0xF240 0x34FF      MOVW     R4,#+1023
   \   00000020   0xE00B             B.N      ??USB_DeviceKhciEndpointInit_1
    273                  }
    274              }
    275              else
    276              {
    277                  if (maxPacketSize > USB_DEVICE_MAX_FS_NONE_ISO_MAX_PACKET_SIZE)
    278                  {
    279                      maxPacketSize = USB_DEVICE_MAX_FS_NONE_ISO_MAX_PACKET_SIZE;
    280                  }
    281                  /* Enable an endpoint to perform handshaking during a transaction to this endpoint. */
    282                  khciState->registerBase->ENDPOINT[endpoint].ENDPT |= USB_ENDPT_EPHSHK_MASK;
   \                     ??USB_DeviceKhciEndpointInit_0: (+1)
   \   00000022   0x6881             LDR      R1,[R0, #+8]
   \   00000024   0xEB01 0x0182      ADD      R1,R1,R2, LSL #+2
   \   00000028   0x2C41             CMP      R4,#+65
   \   0000002A   0xF891 0x60C0      LDRB     R6,[R1, #+192]
   \   0000002E   0xF046 0x0601      ORR      R6,R6,#0x1
   \   00000032   0xBF28             IT       CS 
   \   00000034   0x2440             MOVCS    R4,#+64
   \   00000036   0xF881 0x60C0      STRB     R6,[R1, #+192]
    283              }
    284              /* Set the endpoint idle */
    285              khciState->endpointState[index].stateUnion.stateBitField.transferring = 0U;
   \                     ??USB_DeviceKhciEndpointInit_1: (+1)
   \   0000003A   0xEB00 0x1105      ADD      R1,R0,R5, LSL #+4
    286              /* Save the max packet size of the endpoint */
    287              khciState->endpointState[index].stateUnion.stateBitField.maxPacketSize = maxPacketSize;
    288              /* Set the data toggle to DATA0 */
    289              khciState->endpointState[index].stateUnion.stateBitField.data0 = 0U;
    290              /* Clear the endpoint stalled state */
    291              khciState->endpointState[index].stateUnion.stateBitField.stalled = 0U;
    292              /* Enable the endpoint. */
    293              khciState->registerBase->ENDPOINT[endpoint].ENDPT |=
    294                  (USB_IN == direction) ? USB_ENDPT_EPTXEN_MASK : USB_ENDPT_EPRXEN_MASK;
   \   0000003E   0x2B00             CMP      R3,#+0
   \   00000040   0x6ACD             LDR      R5,[R1, #+44]
   \   00000042   0xF425 0x4580      BIC      R5,R5,#0x4000
   \   00000046   0x62CD             STR      R5,[R1, #+44]
   \   00000048   0xF364 0x0509      BFI      R5,R4,#+0,#+10
   \   0000004C   0x62CD             STR      R5,[R1, #+44]
   \   0000004E   0x6ACC             LDR      R4,[R1, #+44]
   \   00000050   0xF424 0x6400      BIC      R4,R4,#0x800
   \   00000054   0x62CC             STR      R4,[R1, #+44]
   \   00000056   0xF424 0x6480      BIC      R4,R4,#0x400
   \   0000005A   0x62CC             STR      R4,[R1, #+44]
   \   0000005C   0xBF14             ITE      NE 
   \   0000005E   0x2104             MOVNE    R1,#+4
   \   00000060   0x2108             MOVEQ    R1,#+8
   \   00000062   0x6884             LDR      R4,[R0, #+8]
   \   00000064   0xEB04 0x0482      ADD      R4,R4,R2, LSL #+2
   \   00000068   0xF894 0x50C0      LDRB     R5,[R4, #+192]
   \   0000006C   0x4329             ORRS     R1,R1,R5
   \   0000006E   0xF884 0x10C0      STRB     R1,[R4, #+192]
    295          
    296              /* Prime a transfer to receive next setup packet when the endpoint is control out endpoint. */
    297              if ((USB_CONTROL_ENDPOINT == endpoint) && (USB_OUT == direction))
   \   00000072   0xEA53 0x0102      ORRS     R1,R3,R2
   \   00000076   0xBF08             IT       EQ 
    298              {
    299                  USB_DeviceKhciPrimeNextSetup(khciState);
   \   00000078   0x.... 0x....      BLEQ     USB_DeviceKhciPrimeNextSetup
    300              }
    301          
    302              return kStatus_USB_Success;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xBD70             POP      {R4-R6,PC}       ;; return
    303          }
    304          
    305          /*!
    306           * @brief De-initialize a specified endpoint.
    307           *
    308           * The function is used to de-initialize a specified endpoint.
    309           * Current transfer of the endpoint will be canceled and the specified endpoint will be disabled.
    310           *
    311           * @param khciState       Pointer of the device KHCI state structure.
    312           * @param ep               The endpoint address, Bit7, 0U - USB_OUT, 1U - USB_IN.
    313           *
    314           * @return A USB error code or kStatus_USB_Success.
    315           */

   \                                 In section .text, align 2, keep-with-next
    316          static usb_status_t USB_DeviceKhciEndpointDeinit(usb_device_khci_state_struct_t *khciState, uint8_t ep)
    317          {
   \                     USB_DeviceKhciEndpointDeinit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    318              uint8_t endpoint = (ep & USB_ENDPOINT_NUMBER_MASK);
   \   00000004   0xF001 0x050F      AND      R5,R1,#0xF
    319              uint8_t direction =
    320                  (ep & USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_MASK) >> USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT;
    321              uint8_t index = ((uint8_t)((uint32_t)endpoint << 1U)) | (uint8_t)direction;
   \   00000008   0x09C8             LSRS     R0,R1,#+7
   \   0000000A   0xEA40 0x0645      ORR      R6,R0,R5, LSL #+1
    322          
    323              /* Cancel the transfer of the endpoint */
    324              USB_DeviceKhciCancel(khciState, ep);
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       USB_DeviceKhciCancel
    325          
    326              /* Disable the endpoint */
    327              khciState->registerBase->ENDPOINT[endpoint].ENDPT = 0x00U;
   \   00000014   0x68A0             LDR      R0,[R4, #+8]
   \   00000016   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0xF880 0x10C0      STRB     R1,[R0, #+192]
    328              /* Clear the max packet size */
    329              khciState->endpointState[index].stateUnion.stateBitField.maxPacketSize = 0U;
   \   00000020   0xEB04 0x1006      ADD      R0,R4,R6, LSL #+4
   \   00000024   0x6AC1             LDR      R1,[R0, #+44]
   \   00000026   0x0A89             LSRS     R1,R1,#+10
   \   00000028   0x0289             LSLS     R1,R1,#+10
   \   0000002A   0x62C1             STR      R1,[R0, #+44]
    330          
    331              return kStatus_USB_Success;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
    332          }
    333          
    334          /*!
    335           * @brief Stall a specified endpoint.
    336           *
    337           * The function is used to stall a specified endpoint.
    338           * Current transfer of the endpoint will be canceled and the specified endpoint will be stalled.
    339           *
    340           * @param khciState       Pointer of the device KHCI state structure.
    341           * @param ep               The endpoint address, Bit7, 0U - USB_OUT, 1U - USB_IN.
    342           *
    343           * @return A USB error code or kStatus_USB_Success.
    344           */
    345          static usb_status_t USB_DeviceKhciEndpointStall(usb_device_khci_state_struct_t *khciState, uint8_t ep)
    346          {
    347              uint8_t endpoint = ep & USB_ENDPOINT_NUMBER_MASK;
    348              uint8_t direction =
    349                  (ep & USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_MASK) >> USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT;
    350              uint8_t index = ((uint8_t)((uint32_t)endpoint << 1U)) | (uint8_t)direction;
    351          
    352              /* Cancel the transfer of the endpoint */
    353              USB_DeviceKhciCancel(khciState, ep);
    354          
    355              /* Set endpoint stall flag. */
    356              khciState->endpointState[index].stateUnion.stateBitField.stalled = 1U;
    357          
    358              /* Set endpoint stall in BDT. And then if the host send a IN/OUT tanscation, the device will response a STALL state.
    359               */
    360              USB_KHCI_BDT_SET_CONTROL(
    361                  (uint32_t)khciState->bdt, endpoint, direction, khciState->endpointState[index].stateUnion.stateBitField.bdtOdd,
    362                  USB_LONG_TO_LITTLE_ENDIAN(
    363                      (uint32_t)(USB_KHCI_BDT_BC(khciState->endpointState[index].stateUnion.stateBitField.maxPacketSize) |
    364                                 USB_KHCI_BDT_DTS | USB_KHCI_BDT_STALL | USB_KHCI_BDT_OWN)));
    365          
    366              khciState->registerBase->CTL &= ~USB_CTL_TXSUSPENDTOKENBUSY_MASK;
    367          
    368              return kStatus_USB_Success;
    369          }
    370          
    371          /*!
    372           * @brief Un-stall a specified endpoint.
    373           *
    374           * The function is used to un-stall a specified endpoint.
    375           * Current transfer of the endpoint will be canceled and the specified endpoint will be un-stalled.
    376           *
    377           * @param khciState       Pointer of the device KHCI state structure.
    378           * @param ep               The endpoint address, Bit7, 0U - USB_OUT, 1U - USB_IN.
    379           *
    380           * @return A USB error code or kStatus_USB_Success.
    381           */

   \                                 In section .text, align 2, keep-with-next
    382          static usb_status_t USB_DeviceKhciEndpointUnstall(usb_device_khci_state_struct_t *khciState, uint8_t ep)
    383          {
   \                     USB_DeviceKhciEndpointUnstall: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    384              uint32_t control;
    385              uint8_t endpoint = ep & USB_ENDPOINT_NUMBER_MASK;
   \   00000004   0xF001 0x000F      AND      R0,R1,#0xF
    386              uint8_t direction =
    387                  (ep & USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_MASK) >> USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT;
   \   00000008   0x09C9             LSRS     R1,R1,#+7
    388              uint8_t index = ((uint8_t)((uint32_t)endpoint << 1U)) | (uint8_t)direction;
   \   0000000A   0xEA41 0x0240      ORR      R2,R1,R0, LSL #+1
    389          
    390              /* Clear the endpoint stall state */
    391              khciState->endpointState[index].stateUnion.stateBitField.stalled = 0U;
   \   0000000E   0xEB04 0x1202      ADD      R2,R4,R2, LSL #+4
    392              /* Reset the endpoint data toggle to DATA0 */
    393              khciState->endpointState[index].stateUnion.stateBitField.data0 = 0U;
    394          
    395              /* Clear stall state in BDT */
    396              for (uint8_t i = 0U; i < 2U; i++)
   \   00000012   0x.... 0x....      LDR.W    R7,??DataTable4  ;; 0x3ff0000
   \   00000016   0x6AD3             LDR      R3,[R2, #+44]
   \   00000018   0xF423 0x6380      BIC      R3,R3,#0x400
   \   0000001C   0x62D3             STR      R3,[R2, #+44]
   \   0000001E   0xF423 0x6300      BIC      R3,R3,#0x800
   \   00000022   0x62D3             STR      R3,[R2, #+44]
   \   00000024   0x2300             MOVS     R3,#+0
    397              {
    398                  control = USB_KHCI_BDT_GET_CONTROL((uint32_t)khciState->bdt, endpoint, direction, i);
   \                     ??USB_DeviceKhciEndpointUnstall_0: (+1)
   \   00000026   0x6866             LDR      R6,[R4, #+4]
   \   00000028   0x0145             LSLS     R5,R0,#+5
   \   0000002A   0xEA45 0x1501      ORR      R5,R5,R1, LSL #+4
   \   0000002E   0x0A76             LSRS     R6,R6,#+9
   \   00000030   0xEA45 0x2546      ORR      R5,R5,R6, LSL #+9
   \   00000034   0x00DE             LSLS     R6,R3,#+3
   \   00000036   0xF006 0x0608      AND      R6,R6,#0x8
   \   0000003A   0x4335             ORRS     R5,R6,R5
   \   0000003C   0x682E             LDR      R6,[R5, #+0]
    399                  if (control & USB_KHCI_BDT_STALL)
   \   0000003E   0x0776             LSLS     R6,R6,#+29
   \   00000040   0xD505             BPL.N    ??USB_DeviceKhciEndpointUnstall_1
    400                  {
    401                      USB_KHCI_BDT_SET_CONTROL(
    402                          (uint32_t)khciState->bdt, endpoint, direction, i,
    403                          USB_LONG_TO_LITTLE_ENDIAN(
    404                              (uint32_t)(USB_KHCI_BDT_BC(khciState->endpointState[index].stateUnion.stateBitField.maxPacketSize) |
    405                                         USB_KHCI_BDT_DTS | USB_KHCI_BDT_DATA01(0U))));
   \   00000042   0x6AD6             LDR      R6,[R2, #+44]
   \   00000044   0xEA07 0x4606      AND      R6,R7,R6, LSL #+16
   \   00000048   0xF046 0x0608      ORR      R6,R6,#0x8
   \   0000004C   0x602E             STR      R6,[R5, #+0]
    406                  }
    407              }
   \                     ??USB_DeviceKhciEndpointUnstall_1: (+1)
   \   0000004E   0x1C5B             ADDS     R3,R3,#+1
   \   00000050   0x2B02             CMP      R3,#+2
   \   00000052   0xD3E8             BCC.N    ??USB_DeviceKhciEndpointUnstall_0
    408          
    409              /* Clear stall state in endpoint control register */
    410              khciState->registerBase->ENDPOINT[endpoint].ENDPT &= ~USB_ENDPT_EPSTALL_MASK;
   \   00000054   0x68A2             LDR      R2,[R4, #+8]
   \   00000056   0xEB02 0x0280      ADD      R2,R2,R0, LSL #+2
    411          
    412              /* Prime a transfer to receive next setup packet when the endpoint is a control out endpoint. */
    413              if ((USB_CONTROL_ENDPOINT == endpoint) && (USB_OUT == direction))
   \   0000005A   0x4308             ORRS     R0,R1,R0
   \   0000005C   0xF892 0x30C0      LDRB     R3,[R2, #+192]
   \   00000060   0xF003 0x03FD      AND      R3,R3,#0xFD
   \   00000064   0xF882 0x30C0      STRB     R3,[R2, #+192]
   \   00000068   0xBF04             ITT      EQ 
    414              {
    415                  USB_DeviceKhciPrimeNextSetup(khciState);
   \   0000006A   0x4620             MOVEQ    R0,R4
   \   0000006C   0x.... 0x....      BLEQ     USB_DeviceKhciPrimeNextSetup
    416              }
    417          
    418              khciState->registerBase->CTL &= ~USB_CTL_TXSUSPENDTOKENBUSY_MASK;
   \   00000070   0x.... 0x....      BL       ?Subroutine0
    419          
    420              return kStatus_USB_Success;
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000074   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    421          }
    422          
    423          /*!
    424           * @brief Handle the token done interrupt.
    425           *
    426           * The function is used to handle the token done interrupt.
    427           *
    428           * @param khciState       Pointer of the device KHCI state structure.
    429           *
    430           */

   \                                 In section .text, align 2, keep-with-next
    431          static void USB_DeviceKhciInterruptTokenDone(usb_device_khci_state_struct_t *khciState)
    432          {
   \                     USB_DeviceKhciInterruptTokenDone: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB084             SUB      SP,SP,#+16
    433              uint32_t control;
    434              uint32_t length;
    435              uint32_t remainingLength;
    436              usb_device_callback_message_struct_t message;
    437              uint8_t endpoint;
    438              uint8_t direction;
    439              uint8_t bdtOdd;
    440              uint8_t isSetup;
    441              uint8_t index;
    442              uint8_t stateRegister = khciState->registerBase->STAT;
   \   00000008   0x68A0             LDR      R0,[R4, #+8]
    443          
    444              /* Get the endpoint number to identify which one triggers the token done interrupt. */
    445              endpoint = (stateRegister & USB_STAT_ENDP_MASK) >> USB_STAT_ENDP_SHIFT;
    446          
    447              /* Get the direction of the endpoint number. */
    448              direction = (stateRegister & USB_STAT_TX_MASK) >> USB_STAT_TX_SHIFT;
    449          
    450              /* Get the finished BDT ODD. */
    451              bdtOdd = (stateRegister & USB_STAT_ODD_MASK) >> USB_STAT_ODD_SHIFT;
    452          
    453              /* Clear token done interrupt flag. */
    454              khciState->registerBase->ISTAT = kUSB_KhciInterruptTokenDone;
   \   0000000A   0x2208             MOVS     R2,#+8
   \   0000000C   0x3080             ADDS     R0,R0,#+128
   \   0000000E   0x7C01             LDRB     R1,[R0, #+16]
   \   00000010   0x7002             STRB     R2,[R0, #+0]
   \   00000012   0xF3C1 0x1503      UBFX     R5,R1,#+4,#+4
    455          
    456              /* Get the Control field of the BDT element according to the endpoint number, the direction and finished BDT ODD. */
    457              control = USB_KHCI_BDT_GET_CONTROL((uint32_t)khciState->bdt, endpoint, direction, bdtOdd);
   \   00000016   0x6860             LDR      R0,[R4, #+4]
   \   00000018   0x0A40             LSRS     R0,R0,#+9
   \   0000001A   0x0240             LSLS     R0,R0,#+9
   \   0000001C   0xF3C1 0x08C0      UBFX     R8,R1,#+3,#+1
   \   00000020   0xEA40 0x1045      ORR      R0,R0,R5, LSL #+5
   \   00000024   0xF3C1 0x0180      UBFX     R1,R1,#+2,#+1
   \   00000028   0xEA40 0x1008      ORR      R0,R0,R8, LSL #+4
   \   0000002C   0xEA40 0x00C1      ORR      R0,R0,R1, LSL #+3
   \   00000030   0x6800             LDR      R0,[R0, #+0]
    458          
    459              /* Get the transferred length. */
    460              length = ((USB_LONG_FROM_LITTLE_ENDIAN(control)) >> 16U) & 0x3FFU;
   \   00000032   0xF3C0 0x4909      UBFX     R9,R0,#+16,#+10
    461          
    462              /* Get the transferred length. */
    463              isSetup = (USB_KHCI_BDT_DEVICE_SETUP_TOKEN == ((uint8_t)(((USB_LONG_FROM_LITTLE_ENDIAN(control)) >> 2U) & 0x0FU))) ?
    464                            1U :
    465                            0U;
   \   00000036   0xF3C0 0x0083      UBFX     R0,R0,#+2,#+4
   \   0000003A   0x280D             CMP      R0,#+13
    466          
    467              index = ((uint8_t)((uint32_t)endpoint << 1U)) | (uint8_t)direction;
   \   0000003C   0xEA48 0x0045      ORR      R0,R8,R5, LSL #+1
    468          
    469              if (0U == khciState->endpointState[index].stateUnion.stateBitField.transferring)
   \   00000040   0xEB04 0x1600      ADD      R6,R4,R0, LSL #+4
   \   00000044   0xBF0C             ITE      EQ 
   \   00000046   0xF04F 0x0A01      MOVEQ    R10,#+1
   \   0000004A   0xF04F 0x0A00      MOVNE    R10,#+0
   \   0000004E   0x6AF0             LDR      R0,[R6, #+44]
   \   00000050   0xF3C0 0x3080      UBFX     R0,R0,#+14,#+1
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD051             BEQ.N    ??CrossCallReturnLabel_3
    470              {
    471                  return;
    472              }
    473          
    474              if (isSetup)
   \   00000058   0xF44F 0x7090      MOV      R0,#+288
   \   0000005C   0x4420             ADD      R0,R4,R0
   \   0000005E   0xEA5F 0x030A      MOVS     R3,R10
   \   00000062   0xBF18             IT       NE 
   \   00000064   0x70C1             STRBNE   R1,[R0, #+3]
    475              {
    476                  khciState->setupBufferIndex = bdtOdd;
    477              }
    478          
    479              /* USB_IN, Send completed */
    480              if (direction == USB_IN)
   \   00000066   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000006A   0xD034             BEQ.N    ??USB_DeviceKhciInterruptTokenDone_0
   \   0000006C   0x6AB1             LDR      R1,[R6, #+40]
   \   0000006E   0x4449             ADD      R1,R9,R1
   \   00000070   0x62B1             STR      R1,[R6, #+40]
    481              {
    482                  /* The transferred length */
    483                  khciState->endpointState[index].transferDone += length;
    484          
    485                  /* Remaining length */
    486                  remainingLength = khciState->endpointState[index].transferLength - khciState->endpointState[index].transferDone;
   \   00000072   0x6A72             LDR      R2,[R6, #+36]
   \   00000074   0x1A57             SUBS     R7,R2,R1
    487          
    488                  /* Change the data toggle flag */
    489                  khciState->endpointState[index].stateUnion.stateBitField.data0 ^= 1U;
   \   00000076   0x6AF1             LDR      R1,[R6, #+44]
   \   00000078   0xF481 0x6100      EOR      R1,R1,#0x800
   \   0000007C   0x62F1             STR      R1,[R6, #+44]
    490                  /* Change the BDT odd toggle flag */
    491                  khciState->endpointState[index].stateUnion.stateBitField.bdtOdd ^= 1U;
   \   0000007E   0xF481 0x5180      EOR      R1,R1,#0x1000
   \   00000082   0x62F1             STR      R1,[R6, #+44]
    492          
    493                  /* Whether the transfer is completed or not. */
    494                  /*
    495                   * The transfer is completed when one of the following conditions meet:
    496                   * 1. The remaining length is zero.
    497                   * 2. The length of current transcation is less than the max packet size of the current pipe.
    498                   */
    499                  if ((0U == remainingLength) ||
    500                      (khciState->endpointState[index].stateUnion.stateBitField.maxPacketSize > length))
   \   00000084   0xD003             BEQ.N    ??USB_DeviceKhciInterruptTokenDone_1
   \   00000086   0xF3C1 0x0109      UBFX     R1,R1,#+0,#+10
   \   0000008A   0x4589             CMP      R9,R1
   \   0000008C   0xD21B             BCS.N    ??USB_DeviceKhciInterruptTokenDone_2
    501                  {
    502                      message.length = khciState->endpointState[index].transferDone;
   \                     ??USB_DeviceKhciInterruptTokenDone_1: (+1)
   \   0000008E   0x6AB1             LDR      R1,[R6, #+40]
   \   00000090   0x9101             STR      R1,[SP, #+4]
    503                      message.buffer = khciState->endpointState[index].transferBuffer;
   \   00000092   0x6A31             LDR      R1,[R6, #+32]
   \   00000094   0x9100             STR      R1,[SP, #+0]
    504                      khciState->endpointState[index].stateUnion.stateBitField.transferring = 0U;
   \   00000096   0x6AF1             LDR      R1,[R6, #+44]
   \   00000098   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   0000009C   0x62F1             STR      R1,[R6, #+44]
    505          
    506                      /*
    507                       * Whether need to send ZLT when the pipe is control in pipe and the transferred length of current
    508                       * transaction equals to max packet size.
    509                       */
    510                      if ((length == khciState->endpointState[index].stateUnion.stateBitField.maxPacketSize) &&
    511                          (USB_CONTROL_ENDPOINT == endpoint))
   \   0000009E   0xF3C1 0x0109      UBFX     R1,R1,#+0,#+10
   \   000000A2   0x4589             CMP      R9,R1
   \   000000A4   0xBF08             IT       EQ 
   \   000000A6   0x2D00             CMPEQ    R5,#+0
   \   000000A8   0xD11B             BNE.N    ??USB_DeviceKhciInterruptTokenDone_3
    512                      {
    513                          usb_setup_struct_t *setup_packet =
    514                              (usb_setup_struct_t
    515                                   *)(&khciState->setupPacketBuffer[(USB_SETUP_PACKET_SIZE * khciState->setupBufferIndex)]);
    516                          /*
    517                           * Send the ZLT and terminate the token done interrupt service when the tranferred length in data phase
    518                           * is less than the host request.
    519                           */
    520                          if (USB_SHORT_FROM_LITTLE_ENDIAN(setup_packet->wLength) >
    521                              khciState->endpointState[index].transferLength)
   \   000000AA   0x78C0             LDRB     R0,[R0, #+3]
   \   000000AC   0x6A71             LDR      R1,[R6, #+36]
   \   000000AE   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \   000000B2   0x8A40             LDRH     R0,[R0, #+18]
   \   000000B4   0x4281             CMP      R1,R0
   \   000000B6   0xD214             BCS.N    ??USB_DeviceKhciInterruptTokenDone_3
    522                          {
    523                              (void)USB_DeviceSendRequest(khciState->deviceHandle, endpoint, (uint8_t *)NULL, 0U);
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x2300             MOVS     R3,#+0
   \   000000BC   0x2200             MOVS     R2,#+0
   \   000000BE   0x2100             MOVS     R1,#+0
   \   000000C0   0x.... 0x....      BL       USB_DeviceSendRequest
    524                              return;
   \   000000C4   0xE01A             B.N      ??CrossCallReturnLabel_3
    525                          }
    526                      }
    527                  }
    528                  else
    529                  {
    530                      /* Send remaining data and terminate the token done interrupt service. */
    531                      (void)USB_DeviceKhciSend(khciState, endpoint | (USB_IN << 0x07U),
    532                                               khciState->endpointState[index].transferBuffer, remainingLength);
   \                     ??USB_DeviceKhciInterruptTokenDone_2: (+1)
   \   000000C6   0x6A32             LDR      R2,[R6, #+32]
   \   000000C8   0x463B             MOV      R3,R7
   \   000000CA   0xF045 0x0180      ORR      R1,R5,#0x80
   \   000000CE   0x4620             MOV      R0,R4
   \   000000D0   0x.... 0x....      BL       USB_DeviceKhciSend
    533                      return;
   \   000000D4   0xE012             B.N      ??CrossCallReturnLabel_3
    534                  }
    535              }
    536              else
    537              {
    538                  if ((USB_CONTROL_ENDPOINT == endpoint) && (0U == length))
   \                     ??USB_DeviceKhciInterruptTokenDone_0: (+1)
   \   000000D6   0xEA59 0x0105      ORRS     R1,R9,R5
   \   000000DA   0xD111             BNE.N    ??USB_DeviceKhciInterruptTokenDone_4
    539                  {
    540                      message.length = 0U;
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x9001             STR      R0,[SP, #+4]
    541                      message.buffer = (uint8_t *)NULL;
   \   000000E0   0x9000             STR      R0,[SP, #+0]
    542                  }
    543                  else
    544                  {
    545                      if (0U == khciState->endpointState[index].stateUnion.stateBitField.dmaAlign)
    546                      {
    547                          uint8_t *buffer = (uint8_t *)USB_LONG_FROM_LITTLE_ENDIAN(
    548                              USB_KHCI_BDT_GET_ADDRESS((uint32_t)khciState->bdt, endpoint, USB_OUT,
    549                                                       khciState->endpointState[index].stateUnion.stateBitField.bdtOdd));
    550                          uint8_t *transferBuffer =
    551                              khciState->endpointState[index].transferBuffer + khciState->endpointState[index].transferDone;
    552                          if (buffer != transferBuffer)
    553                          {
    554                              for (uint32_t i = 0U; i < length; i++)
    555                              {
    556                                  transferBuffer[i] = buffer[i];
    557                              }
    558                          }
    559                          khciState->isDmaAlignBufferInusing = 0U;
    560                      }
    561                      /* The transferred length */
    562                      khciState->endpointState[index].transferDone += length;
    563                      /* Remaining length */
    564                      remainingLength =
    565                          khciState->endpointState[index].transferLength - khciState->endpointState[index].transferDone;
    566          
    567                      if ((USB_CONTROL_ENDPOINT == endpoint) && isSetup)
    568                      {
    569                          USB_DeviceKhciCancel(khciState,
    570                                               (endpoint | (USB_IN << USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT)));
    571                          khciState->endpointState[(USB_CONTROL_ENDPOINT << 1U) | USB_OUT].stateUnion.stateBitField.data0 = 1U;
    572                          khciState->endpointState[(USB_CONTROL_ENDPOINT << 1U) | USB_IN].stateUnion.stateBitField.data0 = 1U;
    573                      }
    574                      else
    575                      {
    576                          khciState->endpointState[index].stateUnion.stateBitField.data0 ^= 1U;
    577                      }
    578                      khciState->endpointState[index].stateUnion.stateBitField.bdtOdd ^= 1U;
    579                      if ((!khciState->endpointState[index].transferLength) || (!remainingLength) ||
    580                          (khciState->endpointState[index].stateUnion.stateBitField.maxPacketSize > length))
    581                      {
    582                          message.length = khciState->endpointState[index].transferDone;
    583                          message.buffer = khciState->endpointState[index].transferBuffer;
    584                          khciState->endpointState[index].stateUnion.stateBitField.transferring = 0U;
    585                      }
    586                      else
    587                      {
    588                          /* Receive remaining data and terminate the token done interrupt service. */
    589                          USB_DeviceKhciRecv(khciState, (endpoint) | (USB_OUT << 0x07U),
    590                                             khciState->endpointState[index].transferBuffer, remainingLength);
    591                          return;
    592                      }
    593                  }
    594              }
    595          
    596              message.isSetup = isSetup;
    597              message.code = (endpoint) | (uint8_t)(((uint32_t)direction << 0x07U));
   \                     ??USB_DeviceKhciInterruptTokenDone_3: (+1)
   \   000000E2   0xEA45 0x10C8      ORR      R0,R5,R8, LSL #+7
   \   000000E6   0xF88D 0x0008      STRB     R0,[SP, #+8]
   \   000000EA   0xF88D 0xA009      STRB     R10,[SP, #+9]
    598          
    599              /* Notify the up layer the KHCI status changed. */
    600              USB_DeviceNotificationTrigger(khciState->deviceHandle, &message);
   \   000000EE   0x4669             MOV      R1,SP
   \   000000F0   0x6820             LDR      R0,[R4, #+0]
   \   000000F2   0x.... 0x....      BL       USB_DeviceNotificationTrigger
    601          
    602              khciState->registerBase->CTL &= ~USB_CTL_TXSUSPENDTOKENBUSY_MASK;
   \   000000F6   0x68A0             LDR      R0,[R4, #+8]
   \   000000F8   0x.... 0x....      BL       ?Subroutine1
    603          }
   \                     ??CrossCallReturnLabel_3: (+1)
   \   000000FC   0xE8BD 0x87FF      POP      {R0-R10,PC}      ;; return
   \                     ??USB_DeviceKhciInterruptTokenDone_4: (+1)
   \   00000100   0x6AF1             LDR      R1,[R6, #+44]
   \   00000102   0xF3C1 0x3340      UBFX     R3,R1,#+13,#+1
   \   00000106   0xB9BB             CBNZ.N   R3,??USB_DeviceKhciInterruptTokenDone_5
   \   00000108   0x6863             LDR      R3,[R4, #+4]
   \   0000010A   0x0A5B             LSRS     R3,R3,#+9
   \   0000010C   0x025B             LSLS     R3,R3,#+9
   \   0000010E   0x0A49             LSRS     R1,R1,#+9
   \   00000110   0xEA43 0x1245      ORR      R2,R3,R5, LSL #+5
   \   00000114   0xF001 0x0108      AND      R1,R1,#0x8
   \   00000118   0x4311             ORRS     R1,R1,R2
   \   0000011A   0x6849             LDR      R1,[R1, #+4]
   \   0000011C   0x6A32             LDR      R2,[R6, #+32]
   \   0000011E   0x6AB3             LDR      R3,[R6, #+40]
   \   00000120   0x441A             ADD      R2,R2,R3
   \   00000122   0x4291             CMP      R1,R2
   \   00000124   0xD006             BEQ.N    ??USB_DeviceKhciInterruptTokenDone_6
   \   00000126   0x2300             MOVS     R3,#+0
   \   00000128   0xE002             B.N      ??USB_DeviceKhciInterruptTokenDone_7
   \                     ??USB_DeviceKhciInterruptTokenDone_8: (+1)
   \   0000012A   0x5CCF             LDRB     R7,[R1, R3]
   \   0000012C   0x54D7             STRB     R7,[R2, R3]
   \   0000012E   0x1C5B             ADDS     R3,R3,#+1
   \                     ??USB_DeviceKhciInterruptTokenDone_7: (+1)
   \   00000130   0x454B             CMP      R3,R9
   \   00000132   0xD3FA             BCC.N    ??USB_DeviceKhciInterruptTokenDone_8
   \                     ??USB_DeviceKhciInterruptTokenDone_6: (+1)
   \   00000134   0x2100             MOVS     R1,#+0
   \   00000136   0x7001             STRB     R1,[R0, #+0]
   \                     ??USB_DeviceKhciInterruptTokenDone_5: (+1)
   \   00000138   0x6AB0             LDR      R0,[R6, #+40]
   \   0000013A   0x4448             ADD      R0,R9,R0
   \   0000013C   0x62B0             STR      R0,[R6, #+40]
   \   0000013E   0x6A71             LDR      R1,[R6, #+36]
   \   00000140   0x1A0F             SUBS     R7,R1,R0
   \   00000142   0xB97D             CBNZ.N   R5,??USB_DeviceKhciInterruptTokenDone_9
   \   00000144   0xEA5F 0x000A      MOVS     R0,R10
   \   00000148   0xD00C             BEQ.N    ??USB_DeviceKhciInterruptTokenDone_9
   \   0000014A   0x2180             MOVS     R1,#+128
   \   0000014C   0x4620             MOV      R0,R4
   \   0000014E   0x.... 0x....      BL       USB_DeviceKhciCancel
   \   00000152   0x6AE0             LDR      R0,[R4, #+44]
   \   00000154   0xF440 0x6000      ORR      R0,R0,#0x800
   \   00000158   0x62E0             STR      R0,[R4, #+44]
   \   0000015A   0x6BE0             LDR      R0,[R4, #+60]
   \   0000015C   0xF440 0x6000      ORR      R0,R0,#0x800
   \   00000160   0x63E0             STR      R0,[R4, #+60]
   \   00000162   0xE003             B.N      ??USB_DeviceKhciInterruptTokenDone_10
   \                     ??USB_DeviceKhciInterruptTokenDone_9: (+1)
   \   00000164   0x6AF0             LDR      R0,[R6, #+44]
   \   00000166   0xF480 0x6000      EOR      R0,R0,#0x800
   \   0000016A   0x62F0             STR      R0,[R6, #+44]
   \                     ??USB_DeviceKhciInterruptTokenDone_10: (+1)
   \   0000016C   0x6AF0             LDR      R0,[R6, #+44]
   \   0000016E   0xF480 0x5080      EOR      R0,R0,#0x1000
   \   00000172   0x62F0             STR      R0,[R6, #+44]
   \   00000174   0x6A71             LDR      R1,[R6, #+36]
   \   00000176   0x2900             CMP      R1,#+0
   \   00000178   0xBF18             IT       NE 
   \   0000017A   0x2F00             CMPNE    R7,#+0
   \   0000017C   0xD003             BEQ.N    ??USB_DeviceKhciInterruptTokenDone_11
   \   0000017E   0xF3C0 0x0009      UBFX     R0,R0,#+0,#+10
   \   00000182   0x4581             CMP      R9,R0
   \   00000184   0xD208             BCS.N    ??USB_DeviceKhciInterruptTokenDone_12
   \                     ??USB_DeviceKhciInterruptTokenDone_11: (+1)
   \   00000186   0x6AB0             LDR      R0,[R6, #+40]
   \   00000188   0x9001             STR      R0,[SP, #+4]
   \   0000018A   0x6A30             LDR      R0,[R6, #+32]
   \   0000018C   0x9000             STR      R0,[SP, #+0]
   \   0000018E   0x6AF0             LDR      R0,[R6, #+44]
   \   00000190   0xF420 0x4080      BIC      R0,R0,#0x4000
   \   00000194   0x62F0             STR      R0,[R6, #+44]
   \   00000196   0xE7A4             B.N      ??USB_DeviceKhciInterruptTokenDone_3
   \                     ??USB_DeviceKhciInterruptTokenDone_12: (+1)
   \   00000198   0x6A32             LDR      R2,[R6, #+32]
   \   0000019A   0x463B             MOV      R3,R7
   \   0000019C   0x4629             MOV      R1,R5
   \   0000019E   0x4620             MOV      R0,R4
   \   000001A0   0x.... 0x....      BL       USB_DeviceKhciRecv
   \   000001A4   0xE7AA             B.N      ??CrossCallReturnLabel_3
    604          
    605          /*!
    606           * @brief Handle the USB bus reset interrupt.
    607           *
    608           * The function is used to handle the USB bus reset interrupt.
    609           *
    610           * @param khciState       Pointer of the device KHCI state structure.
    611           *
    612           */
    613          static void USB_DeviceKhciInterruptReset(usb_device_khci_state_struct_t *khciState)
    614          {
    615              usb_device_callback_message_struct_t message;
    616          
    617              /* Set KHCI reset flag */
    618              khciState->isResetting = 1U;
    619          
    620              /* Clear the reset interrupt */
    621              khciState->registerBase->ISTAT = (kUSB_KhciInterruptReset);
    622          
    623              message.buffer = (uint8_t *)NULL;
    624              message.code = kUSB_DeviceNotifyBusReset;
    625              message.length = 0U;
    626              message.isSetup = 0U;
    627              /* Notify up layer the USB bus reset signal detected. */
    628              USB_DeviceNotificationTrigger(khciState->deviceHandle, &message);
    629          }
    630          
    631          /* The USB suspend and resume signals need to be detected and handled when the low power or remote wakeup function
    632           * enabled. */
    633          #if ((defined(USB_DEVICE_CONFIG_LOW_POWER_MODE) && (USB_DEVICE_CONFIG_LOW_POWER_MODE > 0U)) || \
    634               (defined(USB_DEVICE_CONFIG_REMOTE_WAKEUP) && (USB_DEVICE_CONFIG_REMOTE_WAKEUP > 0U)))
    635          
    636          /*!
    637           * @brief Handle the suspend interrupt.
    638           *
    639           * The function is used to handle the suspend interrupt when the suspend signal detected.
    640           *
    641           * @param khciState       Pointer of the device KHCI state structure.
    642           *
    643           */
    644          static void USB_DeviceKhciInterruptSleep(usb_device_khci_state_struct_t *khciState)
    645          {
    646              usb_device_callback_message_struct_t message;
    647          
    648              /* Enable the resume interrupt */
    649              khciState->registerBase->INTEN |= kUSB_KhciInterruptResume;
    650              /* Disable the suspend interrupt */
    651              khciState->registerBase->INTEN &= ~kUSB_KhciInterruptSleep;
    652          
    653              /* Clear the suspend interrupt */
    654              khciState->registerBase->ISTAT = (kUSB_KhciInterruptSleep);
    655              /* Clear the resume interrupt */
    656              khciState->registerBase->ISTAT = (kUSB_KhciInterruptResume);
    657          
    658              message.buffer = (uint8_t *)NULL;
    659              message.code = kUSB_DeviceNotifySuspend;
    660              message.length = 0U;
    661              message.isSetup = 0U;
    662          
    663              /* Notify up layer the USB suspend signal detected. */
    664              USB_DeviceNotificationTrigger(khciState->deviceHandle, &message);
    665          }
    666          
    667          /*!
    668           * @brief Handle the resume interrupt.
    669           *
    670           * The function is used to handle the resume interrupt when the resume signal detected.
    671           *
    672           * @param khciState       Pointer of the device KHCI state structure.
    673           *
    674           */
    675          static void USB_DeviceKhciInterruptResume(usb_device_khci_state_struct_t *khciState)
    676          {
    677              usb_device_callback_message_struct_t message;
    678          
    679              /* Enable the suspend interrupt */
    680              khciState->registerBase->INTEN |= kUSB_KhciInterruptSleep;
    681              /* Disable the resume interrupt */
    682              khciState->registerBase->INTEN &= ~kUSB_KhciInterruptResume;
    683          
    684              /* Clear the resume interrupt */
    685              khciState->registerBase->ISTAT = (kUSB_KhciInterruptResume);
    686              /* Clear the suspend interrupt */
    687              khciState->registerBase->ISTAT = (kUSB_KhciInterruptSleep);
    688          
    689              message.buffer = (uint8_t *)NULL;
    690              message.code = kUSB_DeviceNotifyResume;
    691              message.length = 0U;
    692              message.isSetup = 0U;
    693          
    694              /* Notify up layer the USB resume signal detected. */
    695              USB_DeviceNotificationTrigger(khciState->deviceHandle, &message);
    696          }
    697          #endif /* USB_DEVICE_CONFIG_LOW_POWER_MODE || USB_DEVICE_CONFIG_REMOTE_WAKEUP */
    698          
    699          #if (defined(USB_DEVICE_CONFIG_DETACH_ENABLE) && (USB_DEVICE_CONFIG_DETACH_ENABLE > 0U)) && \
    700              (defined(FSL_FEATURE_USB_KHCI_VBUS_DETECT_ENABLED) && (FSL_FEATURE_USB_KHCI_VBUS_DETECT_ENABLED > 0U))
    701          /*!
    702           * @brief Handle the VBUS rising interrupt.
    703           *
    704           * The function is used to handle the VBUS rising interrupt when the VBUS rising signal detected.
    705           *
    706           * @param khciState       Pointer of the device KHCI state structure.
    707           *
    708           */
    709          static void USB_DeviceKhciInterruptVbusRising(usb_device_khci_state_struct_t *khciState)
    710          {
    711              usb_device_callback_message_struct_t message;
    712          
    713              /* Disable the VBUS rising interrupt */
    714              khciState->registerBase->MISCCTRL &= ~USB_MISCCTRL_VREDG_EN_MASK;
    715              /* Enable the VBUS rising interrupt */
    716              khciState->registerBase->MISCCTRL |= USB_MISCCTRL_VREDG_EN_MASK;
    717          
    718              message.buffer = (uint8_t *)NULL;
    719              message.code = kUSB_DeviceNotifyAttach;
    720              message.length = 0U;
    721              message.isSetup = 0U;
    722          
    723              /* Notify up layer the USB VBUS rising signal detected. */
    724              USB_DeviceNotificationTrigger(khciState->deviceHandle, &message);
    725          }
    726          
    727          /*!
    728           * @brief Handle the VBUS falling interrupt.
    729           *
    730           * The function is used to handle the VBUS falling interrupt when the VBUS falling signal detected.
    731           *
    732           * @param khciState       Pointer of the device KHCI state structure.
    733           *
    734           */
    735          static void USB_DeviceKhciInterruptVbusFalling(usb_device_khci_state_struct_t *khciState)
    736          {
    737              usb_device_callback_message_struct_t message;
    738          
    739              /* Disable the VBUS rising interrupt */
    740              khciState->registerBase->MISCCTRL &= ~USB_MISCCTRL_VFEDG_EN_MASK;
    741              /* Enable the VBUS rising interrupt */
    742              khciState->registerBase->MISCCTRL |= USB_MISCCTRL_VFEDG_EN_MASK;
    743          
    744              message.buffer = (uint8_t *)NULL;
    745              message.code = kUSB_DeviceNotifyDetach;
    746              message.length = 0U;
    747              message.isSetup = 0U;
    748          
    749              /* Notify up layer the USB VBUS falling signal detected. */
    750              USB_DeviceNotificationTrigger(khciState->deviceHandle, &message);
    751          }
    752          #endif /* USB_DEVICE_CONFIG_DETACH_ENABLE || FSL_FEATURE_USB_KHCI_VBUS_DETECT_ENABLED */
    753          
    754          #if 0U
    755          /*!
    756           * @brief Handle the sof interrupt.
    757           *
    758           * The function is used to handle the sof interrupt.
    759           *
    760           * @param khciState       Pointer of the device KHCI state structure.
    761           *
    762           */
    763          void USB_DeviceKhciInterruptSof(usb_device_khci_state_struct_t *khciState)
    764          {
    765              khciState->registerBase->ISTAT = (kUSB_KhciInterruptSofToken);
    766          
    767              khciState->registerBase->ISTAT = (kUSB_KhciInterruptResume);
    768          }
    769          #endif
    770          
    771          /*!
    772           * @brief Handle endpoint stalled interrupt.
    773           *
    774           * The function is used to handle  endpoint stalled interrupt.
    775           *
    776           * @param khciState       Pointer of the device KHCI state structure.
    777           *
    778           */
    779          static void USB_DeviceKhciInterruptStall(usb_device_khci_state_struct_t *khciState)
    780          {
    781              /* Clear the endpoint stalled interrupt flag */
    782              khciState->registerBase->ISTAT = (kUSB_KhciInterruptStall);
    783          
    784              /* Un-stall the control in and out pipe when the control in or out pipe stalled. */
    785              if ((khciState->endpointState[(USB_CONTROL_ENDPOINT << 1U) | USB_IN].stateUnion.stateBitField.stalled) ||
    786                  (khciState->endpointState[(USB_CONTROL_ENDPOINT << 1U) | USB_OUT].stateUnion.stateBitField.stalled))
    787              {
    788                  USB_DeviceKhciEndpointUnstall(
    789                      khciState, (USB_CONTROL_ENDPOINT | (USB_IN << USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT)));
    790                  USB_DeviceKhciEndpointUnstall(
    791                      khciState, (USB_CONTROL_ENDPOINT | (USB_OUT << USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT)));
    792              }
    793          }
    794          
    795          #if defined(USB_DEVICE_CONFIG_KHCI_ERROR_HANDLING) && (USB_DEVICE_CONFIG_KHCI_ERROR_HANDLING > 0U)
    796          static void USB_DeviceKhciInterruptError(usb_device_khci_state_struct_t *khciState)
    797          {
    798              usb_device_callback_message_struct_t message;
    799          
    800              khciState->registerBase->ISTAT = (kUSB_KhciInterruptError);
    801          
    802              message.buffer = (uint8_t *)NULL;
    803              message.code = kUSB_DeviceNotifyError;
    804              message.length = 0U;
    805              message.isSetup = 0U;
    806          
    807              /* Notify up layer the USB error detected. */
    808              USB_DeviceNotificationTrigger(khciState->deviceHandle, &message);
    809          }
    810          #endif /* USB_DEVICE_CONFIG_KHCI_ERROR_HANDLING */
    811          
    812          /*!
    813           * @brief Initialize the USB device KHCI instance.
    814           *
    815           * This function initizlizes the USB device KHCI module specified by the controllerId.
    816           *
    817           * @param controllerId The controller id of the USB IP. Please refer to enumeration type usb_controller_index_t.
    818           * @param handle        Pointer of the device handle, used to identify the device object is belonged to.
    819           * @param khciHandle   It is out parameter, is used to return pointer of the device KHCI handle to the caller.
    820           *
    821           * @return A USB error code or kStatus_USB_Success.
    822           */

   \                                 In section .text, align 2, keep-with-next
    823          usb_status_t USB_DeviceKhciInit(uint8_t controllerId,
    824                                          usb_device_handle handle,
    825                                          usb_device_controller_handle *khciHandle)
    826          {
   \                     USB_DeviceKhciInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4615             MOV      R5,R2
    827              usb_device_khci_state_struct_t *khciState;
    828              uint32_t khci_base[] = USB_BASE_ADDRS;
   \   00000004   0x.... 0x....      ADR.W    R2,?_0
   \   00000008   0x6813             LDR      R3,[R2, #0]
   \   0000000A   0xB082             SUB      SP,SP,#+8
   \   0000000C   0x460C             MOV      R4,R1
   \   0000000E   0x9300             STR      R3,[SP, #+0]
    829          
    830              if (((controllerId - kUSB_ControllerKhci0) >= (uint8_t)USB_DEVICE_CONFIG_KHCI) ||
    831                  ((controllerId - kUSB_ControllerKhci0) >= (sizeof(khci_base) / sizeof(uint32_t))))
   \   00000010   0xBB38             CBNZ.N   R0,??USB_DeviceKhciInit_0
    832              {
    833                  return kStatus_USB_ControllerNotFound;
    834              }
    835              khciState = &s_UsbDeviceKhciState[controllerId - kUSB_ControllerKhci0];
    836          
    837              khciState->controllerId = controllerId;
   \   00000012   0x....             LDR.N    R6,??DataTable4_1
   \   00000014   0xF886 0x0122      STRB     R0,[R6, #+290]
    838          
    839              khciState->registerBase = (USB_Type *)khci_base[controllerId - kUSB_ControllerKhci0];
    840          
    841              khciState->dmaAlignBuffer = (uint8_t *)&s_UsbDeviceKhciDmaAlignBuffer[controllerId - kUSB_ControllerKhci0][0];
   \   00000018   0xF44F 0x7192      MOV      R1,#+292
   \   0000001C   0x4431             ADD      R1,R6,R1
   \   0000001E   0x9800             LDR      R0,[SP, #+0]
   \   00000020   0x61F1             STR      R1,[R6, #+28]
   \   00000022   0x60B0             STR      R0,[R6, #+8]
    842          
    843              /* Clear all interrupt flags. */
    844              khciState->registerBase->ISTAT = 0xFFU;
   \   00000024   0x21FF             MOVS     R1,#+255
   \   00000026   0xF880 0x1080      STRB     R1,[R0, #+128]
    845          
    846              /* Disable the device functionality. */
    847              USB_DeviceKhciControl(khciState, kUSB_DeviceControlStop, NULL);
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x4630             MOV      R0,R6
   \   00000030   0x.... 0x....      BL       USB_DeviceKhciControl
    848          
    849              khciState->bdt = s_UsbDeviceKhciBdtBuffer[controllerId - kUSB_ControllerKhci0];
   \   00000034   0x....             LDR.N    R0,??DataTable4_2
    850          
    851              /* Set BDT buffer address */
    852              khciState->registerBase->BDTPAGE1 = (uint8_t)((((uint32_t)khciState->bdt) >> 8U) & 0xFFU);
   \   00000036   0x68B1             LDR      R1,[R6, #+8]
   \   00000038   0x6070             STR      R0,[R6, #+4]
   \   0000003A   0x0A00             LSRS     R0,R0,#+8
   \   0000003C   0xF881 0x009C      STRB     R0,[R1, #+156]
    853              khciState->registerBase->BDTPAGE2 = (uint8_t)((((uint32_t)khciState->bdt) >> 16U) & 0xFFU);
   \   00000040   0x68B1             LDR      R1,[R6, #+8]
   \   00000042   0x6870             LDR      R0,[R6, #+4]
   \   00000044   0x0C00             LSRS     R0,R0,#+16
   \   00000046   0xF881 0x00B0      STRB     R0,[R1, #+176]
    854              khciState->registerBase->BDTPAGE3 = (uint8_t)((((uint32_t)khciState->bdt) >> 24U) & 0xFFU);
   \   0000004A   0x68B1             LDR      R1,[R6, #+8]
   \   0000004C   0x6870             LDR      R0,[R6, #+4]
   \   0000004E   0x0E00             LSRS     R0,R0,#+24
   \   00000050   0xF881 0x00B4      STRB     R0,[R1, #+180]
    855          
    856          #if (defined(USB_DEVICE_CONFIG_DETACH_ENABLE) && (USB_DEVICE_CONFIG_DETACH_ENABLE > 0U)) && \
    857              (defined(FSL_FEATURE_USB_KHCI_VBUS_DETECT_ENABLED) && (FSL_FEATURE_USB_KHCI_VBUS_DETECT_ENABLED > 0U))
    858              khciState->registerBase->MISCCTRL |= USB_MISCCTRL_VREDG_EN_MASK | USB_MISCCTRL_VFEDG_EN_MASK;
    859          #endif
    860          
    861          #if defined(FSL_FEATURE_USB_KHCI_KEEP_ALIVE_ENABLED) && (FSL_FEATURE_USB_KHCI_KEEP_ALIVE_ENABLED > 0U) \
    862          && defined(USB_DEVICE_CONFIG_KEEP_ALIVE_MODE) &&                                         \
    863              (USB_DEVICE_CONFIG_KEEP_ALIVE_MODE > 0U) && defined(FSL_FEATURE_USB_KHCI_USB_RAM) && \
    864              (FSL_FEATURE_USB_KHCI_USB_RAM > 0U)
    865              khciState->registerBase->CLK_RECOVER_CTRL |= USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_MASK;
    866              khciState->registerBase->KEEP_ALIVE_CTRL =
    867                  USB_KEEP_ALIVE_CTRL_KEEP_ALIVE_EN_MASK | USB_KEEP_ALIVE_CTRL_OWN_OVERRD_EN_MASK |
    868                  USB_KEEP_ALIVE_CTRL_STOP_ACK_DLY_EN_MASK | USB_KEEP_ALIVE_CTRL_AHB_DLY_EN_MASK |
    869                  USB_KEEP_ALIVE_CTRL_WAKE_INT_EN_MASK;
    870              /* wake on out and setup transaction */
    871              khciState->registerBase->KEEP_ALIVE_WKCTRL = 0x1U;
    872              MCG->MC |= MCG_MC_HIRCLPEN_MASK;
    873              PMC->REGSC |= PMC_REGSC_BGEN_MASK | PMC_REGSC_VLPO_MASK;
    874          #endif
    875              /* Set KHCI device state to default value. */
    876              USB_DeviceKhciSetDefaultState(khciState);
   \   00000054   0x4630             MOV      R0,R6
   \   00000056   0x.... 0x....      BL       USB_DeviceKhciSetDefaultState
    877          
    878              *khciHandle = khciState;
   \   0000005A   0x602E             STR      R6,[R5, #+0]
    879              khciState->deviceHandle = (usb_device_struct_t *)handle;
   \   0000005C   0x6034             STR      R4,[R6, #+0]
    880          
    881              return kStatus_USB_Success;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xBD76             POP      {R1,R2,R4-R6,PC}
   \                     ??USB_DeviceKhciInit_0: (+1)
   \   00000062   0x2006             MOVS     R0,#+6
   \   00000064   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    882          }
    883          
    884          /*!
    885           * @brief De-initialize the USB device KHCI instance.
    886           *
    887           * This function de-initizlizes the USB device KHCI module.
    888           *
    889           * @param khciHandle   Pointer of the device KHCI handle.
    890           *
    891           * @return A USB error code or kStatus_USB_Success.
    892           */

   \                                 In section .text, align 2, keep-with-next
    893          usb_status_t USB_DeviceKhciDeinit(usb_device_controller_handle khciHandle)
    894          {
    895              usb_device_khci_state_struct_t *khciState = (usb_device_khci_state_struct_t *)khciHandle;
    896          
    897              if (!khciHandle)
   \                     USB_DeviceKhciDeinit: (+1)
   \   00000000   0xB908             CBNZ.N   R0,??USB_DeviceKhciDeinit_0
    898              {
    899                  return kStatus_USB_InvalidHandle;
   \   00000002   0x2003             MOVS     R0,#+3
   \   00000004   0x4770             BX       LR
    900              }
    901              /* Clear all interrupt flags. */
    902              khciState->registerBase->ISTAT = 0xFFU;
   \                     ??USB_DeviceKhciDeinit_0: (+1)
   \   00000006   0x6882             LDR      R2,[R0, #+8]
   \   00000008   0x21FF             MOVS     R1,#+255
   \   0000000A   0xF882 0x1080      STRB     R1,[R2, #+128]
    903              /* Disable all interrupts. */
    904              khciState->registerBase->INTEN &= ~(0xFFU);
   \   0000000E   0x6881             LDR      R1,[R0, #+8]
   \   00000010   0xF891 0x2084      LDRB     R2,[R1, #+132]
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xF881 0x2084      STRB     R2,[R1, #+132]
    905              /* Clear device address. */
    906              khciState->registerBase->ADDR = (0U);
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x6882             LDR      R2,[R0, #+8]
   \   0000001E   0xF882 0x1098      STRB     R1,[R2, #+152]
    907          
    908              /* Clear USB_CTL register */
    909              khciState->registerBase->CTL = 0x00U;
   \   00000022   0x6882             LDR      R2,[R0, #+8]
   \   00000024   0xF882 0x1094      STRB     R1,[R2, #+148]
    910              khciState->registerBase->USBCTRL |= USB_USBCTRL_PDE_MASK | USB_USBCTRL_SUSP_MASK;
   \   00000028   0x6880             LDR      R0,[R0, #+8]
   \   0000002A   0xF890 0x1100      LDRB     R1,[R0, #+256]
   \   0000002E   0xF041 0x01C0      ORR      R1,R1,#0xC0
   \   00000032   0xF880 0x1100      STRB     R1,[R0, #+256]
    911          
    912              return kStatus_USB_Success;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x4770             BX       LR               ;; return
    913          }
    914          
    915          /*!
    916           * @brief Send data through a specified endpoint.
    917           *
    918           * This function sends data through a specified endpoint.
    919           *
    920           * @param khciHandle      Pointer of the device KHCI handle.
    921           * @param endpointAddress Endpoint index.
    922           * @param buffer           The memory address to hold the data need to be sent.
    923           * @param length           The data length need to be sent.
    924           *
    925           * @return A USB error code or kStatus_USB_Success.
    926           *
    927           * @note The return value just means if the sending request is successful or not; the transfer done is notified by the
    928           * corresponding callback function.
    929           * Currently, only one transfer request can be supported for one specific endpoint.
    930           * If there is a specific requirement to support multiple transfer requests for one specific endpoint, the application
    931           * should implement a queue in the application level.
    932           * The subsequent transfer could begin only when the previous transfer is done (get notification through the endpoint
    933           * callback).
    934           */

   \                                 In section .text, align 2, keep-with-next
    935          usb_status_t USB_DeviceKhciSend(usb_device_controller_handle khciHandle,
    936                                          uint8_t endpointAddress,
    937                                          uint8_t *buffer,
    938                                          uint32_t length)
    939          {
   \                     USB_DeviceKhciSend: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x460D             MOV      R5,R1
    940              usb_device_khci_state_struct_t *khciState = (usb_device_khci_state_struct_t *)khciHandle;
    941              uint32_t index = ((endpointAddress & USB_ENDPOINT_NUMBER_MASK) << 1U) | USB_IN;
   \   00000008   0x0068             LSLS     R0,R5,#+1
   \   0000000A   0xF000 0x001E      AND      R0,R0,#0x1E
   \   0000000E   0xF040 0x0001      ORR      R0,R0,#0x1
    942              usb_status_t error = kStatus_USB_Error;
    943          
    944              /* Save the tansfer information */
    945              if (0U == khciState->endpointState[index].stateUnion.stateBitField.transferring)
   \   00000012   0xEB08 0x1400      ADD      R4,R8,R0, LSL #+4
   \   00000016   0xB082             SUB      SP,SP,#+8
   \   00000018   0x6AE0             LDR      R0,[R4, #+44]
   \   0000001A   0x461E             MOV      R6,R3
   \   0000001C   0x2701             MOVS     R7,#+1
   \   0000001E   0xF3C0 0x3080      UBFX     R0,R0,#+14,#+1
   \   00000022   0xB930             CBNZ.N   R0,??USB_DeviceKhciSend_0
    946              {
    947                  khciState->endpointState[index].transferDone = 0U;
   \   00000024   0x62A0             STR      R0,[R4, #+40]
    948                  khciState->endpointState[index].transferBuffer = buffer;
   \   00000026   0x6222             STR      R2,[R4, #+32]
    949                  khciState->endpointState[index].transferLength = length;
   \   00000028   0x6266             STR      R6,[R4, #+36]
    950                  khciState->endpointState[index].stateUnion.stateBitField.dmaAlign = 1U;
   \   0000002A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000002C   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   00000030   0x62E0             STR      R0,[R4, #+44]
    951              }
    952          
    953              /* Data length needs to less than max packet size in each call. */
    954              if (length > khciState->endpointState[index].stateUnion.stateBitField.maxPacketSize)
   \                     ??USB_DeviceKhciSend_0: (+1)
   \   00000032   0x6AE0             LDR      R0,[R4, #+44]
   \   00000034   0xF3C0 0x0009      UBFX     R0,R0,#+0,#+10
   \   00000038   0x42B0             CMP      R0,R6
   \   0000003A   0xBF38             IT       CC 
   \   0000003C   0x4606             MOVCC    R6,R0
    955              {
    956                  length = khciState->endpointState[index].stateUnion.stateBitField.maxPacketSize;
    957              }
    958          
    959              /* Send data when the device is not resetting. */
    960              if (0U == khciState->isResetting)
   \   0000003E   0xF898 0x0121      LDRB     R0,[R8, #+289]
   \   00000042   0xB950             CBNZ.N   R0,??USB_DeviceKhciSend_1
    961              {
    962                  error = USB_DeviceKhciEndpointTransfer(khciState, endpointAddress & USB_ENDPOINT_NUMBER_MASK, USB_IN,
    963                                                         (uint8_t *)((uint32_t)khciState->endpointState[index].transferBuffer +
    964                                                                     (uint32_t)khciState->endpointState[index].transferDone),
    965                                                         length);
   \   00000044   0x9600             STR      R6,[SP, #+0]
   \   00000046   0x6A20             LDR      R0,[R4, #+32]
   \   00000048   0x6AA1             LDR      R1,[R4, #+40]
   \   0000004A   0x180B             ADDS     R3,R1,R0
   \   0000004C   0x2201             MOVS     R2,#+1
   \   0000004E   0xF005 0x010F      AND      R1,R5,#0xF
   \   00000052   0x4640             MOV      R0,R8
   \   00000054   0x.... 0x....      BL       USB_DeviceKhciEndpointTransfer
   \   00000058   0x4607             MOV      R7,R0
    966              }
    967          
    968              /* Prime a transfer to receive next setup packet if the dat length is zero in a control in endpoint. */
    969              if ((0U == khciState->endpointState[index].transferDone) && (0U == length) &&
    970                  (USB_CONTROL_ENDPOINT == (endpointAddress & USB_ENDPOINT_NUMBER_MASK)))
   \                     ??USB_DeviceKhciSend_1: (+1)
   \   0000005A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000005C   0x4330             ORRS     R0,R6,R0
   \   0000005E   0xBF01             ITTTT    EQ 
   \   00000060   0x200F             MOVEQ    R0,#+15
   \   00000062   0x4205             TSTEQ    R5,R0
    971              {
    972                  USB_DeviceKhciPrimeNextSetup(khciState);
   \   00000064   0x4640             MOVEQ    R0,R8
   \   00000066   0x.... 0x....      BLEQ     USB_DeviceKhciPrimeNextSetup
    973              }
    974              return error;
   \   0000006A   0x4638             MOV      R0,R7
   \   0000006C   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    975          }
    976          
    977          /*!
    978           * @brief Receive data through a specified endpoint.
    979           *
    980           * This function Receives data through a specified endpoint.
    981           *
    982           * @param khciHandle      Pointer of the device KHCI handle.
    983           * @param endpointAddress Endpoint index.
    984           * @param buffer           The memory address to save the received data.
    985           * @param length           The data length want to be received.
    986           *
    987           * @return A USB error code or kStatus_USB_Success.
    988           *
    989           * @note The return value just means if the receiving request is successful or not; the transfer done is notified by the
    990           * corresponding callback function.
    991           * Currently, only one transfer request can be supported for one specific endpoint.
    992           * If there is a specific requirement to support multiple transfer requests for one specific endpoint, the application
    993           * should implement a queue in the application level.
    994           * The subsequent transfer could begin only when the previous transfer is done (get notification through the endpoint
    995           * callback).
    996           */

   \                                 In section .text, align 2, keep-with-next
    997          usb_status_t USB_DeviceKhciRecv(usb_device_controller_handle khciHandle,
    998                                          uint8_t endpointAddress,
    999                                          uint8_t *buffer,
   1000                                          uint32_t length)
   1001          {
   \                     USB_DeviceKhciRecv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   1002              usb_device_khci_state_struct_t *khciState = (usb_device_khci_state_struct_t *)khciHandle;
   1003              uint32_t index = ((endpointAddress & USB_ENDPOINT_NUMBER_MASK) << 1U) | USB_OUT;
   \   00000008   0x0068             LSLS     R0,R5,#+1
   \   0000000A   0xF000 0x001E      AND      R0,R0,#0x1E
   1004              usb_status_t error = kStatus_USB_Error;
   1005          
   1006              /* Save the tansfer information */
   1007              if (0U == khciState->endpointState[index].stateUnion.stateBitField.transferring)
   \   0000000E   0xEB04 0x1700      ADD      R7,R4,R0, LSL #+4
   \   00000012   0xB082             SUB      SP,SP,#+8
   \   00000014   0x6AF8             LDR      R0,[R7, #+44]
   \   00000016   0x461E             MOV      R6,R3
   \   00000018   0xF04F 0x0801      MOV      R8,#+1
   \   0000001C   0xF3C0 0x3080      UBFX     R0,R0,#+14,#+1
   \   00000020   0xB910             CBNZ.N   R0,??USB_DeviceKhciRecv_0
   1008              {
   1009                  khciState->endpointState[index].transferDone = 0U;
   \   00000022   0x62B8             STR      R0,[R7, #+40]
   1010                  khciState->endpointState[index].transferBuffer = buffer;
   \   00000024   0x623A             STR      R2,[R7, #+32]
   1011                  khciState->endpointState[index].transferLength = length;
   \   00000026   0x627E             STR      R6,[R7, #+36]
   1012              }
   1013              khciState->endpointState[index].stateUnion.stateBitField.dmaAlign = 1U;
   \                     ??USB_DeviceKhciRecv_0: (+1)
   \   00000028   0x6AF8             LDR      R0,[R7, #+44]
   \   0000002A   0xF440 0x5000      ORR      R0,R0,#0x2000
   1014          
   1015              /* Data length needs to less than max packet size in each call. */
   1016              if (length > khciState->endpointState[index].stateUnion.stateBitField.maxPacketSize)
   \   0000002E   0xF3C0 0x0109      UBFX     R1,R0,#+0,#+10
   \   00000032   0x42B1             CMP      R1,R6
   \   00000034   0x62F8             STR      R0,[R7, #+44]
   \   00000036   0xBF38             IT       CC 
   \   00000038   0x460E             MOVCC    R6,R1
   1017              {
   1018                  length = khciState->endpointState[index].stateUnion.stateBitField.maxPacketSize;
   1019              }
   1020          
   1021              buffer = (uint8_t *)((uint32_t)buffer + (uint32_t)khciState->endpointState[index].transferDone);
   \   0000003A   0x6AB9             LDR      R1,[R7, #+40]
   \   0000003C   0x188B             ADDS     R3,R1,R2
   1022          
   1023              if ((khciState->dmaAlignBuffer) && (0U == khciState->isDmaAlignBufferInusing) &&
   1024                  (USB_DEVICE_CONFIG_KHCI_DMA_ALIGN_BUFFER_LENGTH >= length) &&
   1025                  ((length & 0x03U) || (((uint32_t)buffer) & 0x03U)))
   \   0000003E   0xF44F 0x7190      MOV      R1,#+288
   \   00000042   0x69E2             LDR      R2,[R4, #+28]
   \   00000044   0x4421             ADD      R1,R4,R1
   \   00000046   0xB17A             CBZ.N    R2,??USB_DeviceKhciRecv_1
   \   00000048   0x780A             LDRB     R2,[R1, #+0]
   \   0000004A   0xB96A             CBNZ.N   R2,??USB_DeviceKhciRecv_1
   \   0000004C   0x2E41             CMP      R6,#+65
   \   0000004E   0xD20B             BCS.N    ??USB_DeviceKhciRecv_1
   \   00000050   0xF016 0x0F03      TST      R6,#0x3
   \   00000054   0xBF08             IT       EQ 
   \   00000056   0xF013 0x0203      ANDSEQ   R2,R3,#0x3
   \   0000005A   0xD005             BEQ.N    ??USB_DeviceKhciRecv_1
   1026              {
   1027                  khciState->endpointState[index].stateUnion.stateBitField.dmaAlign = 0U;
   \   0000005C   0xF420 0x5000      BIC      R0,R0,#0x2000
   \   00000060   0x62F8             STR      R0,[R7, #+44]
   1028                  buffer = khciState->dmaAlignBuffer;
   \   00000062   0x69E3             LDR      R3,[R4, #+28]
   1029                  khciState->isDmaAlignBufferInusing = 1U;
   \   00000064   0xF881 0x8000      STRB     R8,[R1, #+0]
   1030              }
   1031          
   1032              /* Receive data when the device is not resetting. */
   1033              if (0U == khciState->isResetting)
   \                     ??USB_DeviceKhciRecv_1: (+1)
   \   00000068   0x7848             LDRB     R0,[R1, #+1]
   \   0000006A   0xB938             CBNZ.N   R0,??USB_DeviceKhciRecv_2
   1034              {
   1035                  error = USB_DeviceKhciEndpointTransfer(khciState, endpointAddress & USB_ENDPOINT_NUMBER_MASK, USB_OUT, buffer,
   1036                                                         length);
   \   0000006C   0x9600             STR      R6,[SP, #+0]
   \   0000006E   0x2200             MOVS     R2,#+0
   \   00000070   0xF005 0x010F      AND      R1,R5,#0xF
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x.... 0x....      BL       USB_DeviceKhciEndpointTransfer
   \   0000007A   0x4680             MOV      R8,R0
   1037              }
   1038          
   1039              /* Prime a transfer to receive next setup packet if the dat length is zero in a control out endpoint. */
   1040              if ((0U == length) && (USB_CONTROL_ENDPOINT == (endpointAddress & USB_ENDPOINT_NUMBER_MASK)))
   \                     ??USB_DeviceKhciRecv_2: (+1)
   \   0000007C   0x2E00             CMP      R6,#+0
   \   0000007E   0xBF04             ITT      EQ 
   \   00000080   0x200F             MOVEQ    R0,#+15
   \   00000082   0x4205             TSTEQ    R5,R0
   \   00000084   0xD109             BNE.N    ??USB_DeviceKhciRecv_3
   1041              {
   1042                  khciState->endpointState[index].stateUnion.stateBitField.bdtOdd ^= 1U;
   \   00000086   0x6AF8             LDR      R0,[R7, #+44]
   \   00000088   0xF480 0x5080      EOR      R0,R0,#0x1000
   \   0000008C   0x62F8             STR      R0,[R7, #+44]
   1043                  khciState->endpointState[index].stateUnion.stateBitField.transferring = 0U;
   \   0000008E   0xF420 0x4080      BIC      R0,R0,#0x4000
   \   00000092   0x62F8             STR      R0,[R7, #+44]
   1044                  USB_DeviceKhciPrimeNextSetup(khciState);
   \   00000094   0x4620             MOV      R0,R4
   \   00000096   0x.... 0x....      BL       USB_DeviceKhciPrimeNextSetup
   1045              }
   1046              return error;
   \                     ??USB_DeviceKhciRecv_3: (+1)
   \   0000009A   0x4640             MOV      R0,R8
   \   0000009C   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   1047          }
   1048          
   1049          /*!
   1050           * @brief Cancel the pending transfer in a specified endpoint.
   1051           *
   1052           * The function is used to cancel the pending transfer in a specified endpoint.
   1053           *
   1054           * @param khciHandle      Pointer of the device KHCI handle.
   1055           * @param ep               Endpoint address, bit7 is the direction of endpoint, 1U - IN, abd 0U - OUT.
   1056           *
   1057           * @return A USB error code or kStatus_USB_Success.
   1058           */

   \                                 In section .text, align 2, keep-with-next
   1059          usb_status_t USB_DeviceKhciCancel(usb_device_controller_handle khciHandle, uint8_t ep)
   1060          {
   \                     USB_DeviceKhciCancel: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
   1061              usb_device_khci_state_struct_t *khciState = (usb_device_khci_state_struct_t *)khciHandle;
   1062              usb_device_callback_message_struct_t message;
   1063              uint8_t index = ((ep & USB_ENDPOINT_NUMBER_MASK) << 1U) | ((ep & USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_MASK) >>
   1064                                                                         USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT);
   \   00000002   0x004A             LSLS     R2,R1,#+1
   \   00000004   0xF002 0x031E      AND      R3,R2,#0x1E
   \   00000008   0xEA43 0x12D1      ORR      R2,R3,R1, LSR #+7
   1065          
   1066              /* Cancel the transfer and notify the up layer when the endpoint is busy. */
   1067              if (khciState->endpointState[index].stateUnion.stateBitField.transferring)
   \   0000000C   0xEB00 0x1202      ADD      R2,R0,R2, LSL #+4
   \   00000010   0x6AD3             LDR      R3,[R2, #+44]
   \   00000012   0xF3C3 0x3380      UBFX     R3,R3,#+14,#+1
   \   00000016   0xB18B             CBZ.N    R3,??USB_DeviceKhciCancel_0
   1068              {
   1069                  message.length = USB_UNINITIALIZED_VAL_32;
   \   00000018   0xF04F 0x33FF      MOV      R3,#-1
   \   0000001C   0x9301             STR      R3,[SP, #+4]
   1070                  message.buffer = khciState->endpointState[index].transferBuffer;
   \   0000001E   0x6A13             LDR      R3,[R2, #+32]
   1071                  message.code = ep;
   \   00000020   0xF88D 0x1008      STRB     R1,[SP, #+8]
   \   00000024   0x9300             STR      R3,[SP, #+0]
   1072                  message.isSetup = 0U;
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0xF88D 0x1009      STRB     R1,[SP, #+9]
   1073                  khciState->endpointState[index].stateUnion.stateBitField.transferring = 0U;
   \   0000002C   0x6AD1             LDR      R1,[R2, #+44]
   \   0000002E   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   00000032   0x62D1             STR      R1,[R2, #+44]
   1074                  USB_DeviceNotificationTrigger(khciState->deviceHandle, &message);
   \   00000034   0x4669             MOV      R1,SP
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x.... 0x....      BL       USB_DeviceNotificationTrigger
   1075              }
   1076              return kStatus_USB_Success;
   \                     ??USB_DeviceKhciCancel_0: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xBD0E             POP      {R1-R3,PC}       ;; return
   1077          }
   1078          
   1079          /*!
   1080           * @brief Control the status of the selected item.
   1081           *
   1082           * The function is used to control the status of the selected item.
   1083           *
   1084           * @param khciHandle      Pointer of the device KHCI handle.
   1085           * @param type             The selected item. Please refer to enumeration type usb_device_control_type_t.
   1086           * @param param            The param type is determined by the selected item.
   1087           *
   1088           * @return A USB error code or kStatus_USB_Success.
   1089           */

   \                                 In section .text, align 4, keep-with-next
   1090          usb_status_t USB_DeviceKhciControl(usb_device_controller_handle khciHandle, usb_device_control_type_t type, void *param)
   1091          {
   \                     USB_DeviceKhciControl: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460B             MOV      R3,R1
   \   00000006   0x4611             MOV      R1,R2
   1092              usb_device_khci_state_struct_t *khciState = (usb_device_khci_state_struct_t *)khciHandle;
   1093              usb_status_t error = kStatus_USB_Error;
   \   00000008   0x2001             MOVS     R0,#+1
   1094              uint16_t *temp16;
   1095              uint8_t *temp8;
   1096          #if defined(USB_DEVICE_CONFIG_REMOTE_WAKEUP) && (USB_DEVICE_CONFIG_REMOTE_WAKEUP > 0U)
   1097              USB_OSA_SR_ALLOC();
   1098          #endif /* USB_DEVICE_CONFIG_REMOTE_WAKEUP */
   1099          
   1100              if (!khciHandle)
   \   0000000A   0xB90C             CBNZ.N   R4,??USB_DeviceKhciControl_1
   1101              {
   1102                  return kStatus_USB_InvalidHandle;
   \   0000000C   0x2003             MOVS     R0,#+3
   \                     ??USB_DeviceKhciControl_2: (+1)
   \   0000000E   0xBDF2             POP      {R1,R4-R7,PC}
   1103              }
   1104          
   1105              switch (type)
   \                     ??USB_DeviceKhciControl_1: (+1)
   \   00000010   0x2B0C             CMP      R3,#+12
   \   00000012   0xD8FC             BHI.N    ??USB_DeviceKhciControl_2
   \   00000014   0xE8DF 0xF003      TBB      [PC, R3]
   \                     ??USB_DeviceKhciControl_0:
   \   00000018   0x07 0x20          DC8      0x7,0x20,0x30,0x36
   \              0x30 0x36    
   \   0000001C   0x3D 0x68          DC8      0x3D,0x68,0x6F,0x72
   \              0x6F 0x72    
   \   00000020   0x85 0xA1          DC8      0x85,0xA1,0xA1,0x8B
   \              0xA1 0x8B    
   \   00000024   0x9E 0x00          DC8      0x9E,0x0
   1106              {
   1107                  case kUSB_DeviceControlRun:
   1108                      khciState->registerBase->USBCTRL = 0U;
   \                     ??USB_DeviceKhciControl_3: (+1)
   \   00000026   0x68A1             LDR      R1,[R4, #+8]
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF881 0x0100      STRB     R0,[R1, #+256]
   1109          #if defined(FSL_FEATURE_USB_KHCI_OTG_ENABLED) && (FSL_FEATURE_USB_KHCI_OTG_ENABLED > 0U)
   1110                      if (khciState->registerBase->OTGCTL & USB_OTGCTL_OTGEN_MASK)
   \   0000002E   0x68A0             LDR      R0,[R4, #+8]
   \   00000030   0x7F01             LDRB     R1,[R0, #+28]
   \   00000032   0x0749             LSLS     R1,R1,#+29
   \   00000034   0xD503             BPL.N    ??USB_DeviceKhciControl_4
   1111                      {
   1112                          khciState->registerBase->OTGCTL |= USB_OTGCTL_DPHIGH_MASK;
   \   00000036   0x7F01             LDRB     R1,[R0, #+28]
   \   00000038   0xF041 0x0180      ORR      R1,R1,#0x80
   \   0000003C   0x7701             STRB     R1,[R0, #+28]
   1113                      }
   1114          #endif /* FSL_FEATURE_USB_KHCI_OTG_ENABLED */
   1115                      khciState->registerBase->CONTROL |= USB_CONTROL_DPPULLUPNONOTG_MASK;
   \                     ??USB_DeviceKhciControl_4: (+1)
   \   0000003E   0x68A0             LDR      R0,[R4, #+8]
   \   00000040   0xF890 0x1108      LDRB     R1,[R0, #+264]
   \   00000044   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000048   0xF880 0x1108      STRB     R1,[R0, #+264]
   1116                      khciState->registerBase->CTL |= USB_CTL_USBENSOFEN_MASK;
   \   0000004C   0x68A0             LDR      R0,[R4, #+8]
   \   0000004E   0xF890 0x1094      LDRB     R1,[R0, #+148]
   \   00000052   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000056   0xE044             B.N      ??USB_DeviceKhciControl_5
   1117          
   1118                      error = kStatus_USB_Success;
   1119                      break;
   1120                  case kUSB_DeviceControlStop:
   1121          #if defined(FSL_FEATURE_USB_KHCI_OTG_ENABLED) && (FSL_FEATURE_USB_KHCI_OTG_ENABLED > 0U)
   1122                      if (khciState->registerBase->OTGCTL & USB_OTGCTL_OTGEN_MASK)
   \                     ??USB_DeviceKhciControl_6: (+1)
   \   00000058   0x68A0             LDR      R0,[R4, #+8]
   \   0000005A   0x7F01             LDRB     R1,[R0, #+28]
   \   0000005C   0x0749             LSLS     R1,R1,#+29
   \   0000005E   0xD503             BPL.N    ??USB_DeviceKhciControl_7
   1123                      {
   1124                          khciState->registerBase->OTGCTL &= ~USB_OTGCTL_DPHIGH_MASK;
   \   00000060   0x7F01             LDRB     R1,[R0, #+28]
   \   00000062   0xF001 0x017F      AND      R1,R1,#0x7F
   \   00000066   0x7701             STRB     R1,[R0, #+28]
   1125                      }
   1126          #endif /* FSL_FEATURE_USB_KHCI_OTG_ENABLED */
   1127                      khciState->registerBase->CONTROL &= ~USB_CONTROL_DPPULLUPNONOTG_MASK;
   \                     ??USB_DeviceKhciControl_7: (+1)
   \   00000068   0x68A0             LDR      R0,[R4, #+8]
   \   0000006A   0xF890 0x1108      LDRB     R1,[R0, #+264]
   \   0000006E   0xF001 0x01EF      AND      R1,R1,#0xEF
   \   00000072   0xF880 0x1108      STRB     R1,[R0, #+264]
   1128                      error = kStatus_USB_Success;
   \   00000076   0xE06B             B.N      ??USB_DeviceKhciControl_8
   1129                      break;
   1130                  case kUSB_DeviceControlEndpointInit:
   1131                      if (param)
   \                     ??USB_DeviceKhciControl_9: (+1)
   \   00000078   0x2900             CMP      R1,#+0
   \   0000007A   0xD06E             BEQ.N    ??USB_DeviceKhciControl_10
   1132                      {
   1133                          error = USB_DeviceKhciEndpointInit(khciState, (usb_device_endpoint_init_struct_t *)param);
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   00000082   0x....             B.N      USB_DeviceKhciEndpointInit
   1134                      }
   1135                      break;
   1136                  case kUSB_DeviceControlEndpointDeinit:
   1137                      if (param)
   \                     ??USB_DeviceKhciControl_11: (+1)
   \   00000084   0x2900             CMP      R1,#+0
   \   00000086   0xD068             BEQ.N    ??USB_DeviceKhciControl_10
   1138                      {
   1139                          temp8 = (uint8_t *)param;
   1140                          error = USB_DeviceKhciEndpointDeinit(khciState, *temp8);
   \   00000088   0x7809             LDRB     R1,[R1, #+0]
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   00000090   0x....             B.N      USB_DeviceKhciEndpointDeinit
   1141                      }
   1142                      break;
   1143                  case kUSB_DeviceControlEndpointStall:
   1144                      if (param)
   \                     ??USB_DeviceKhciControl_12: (+1)
   \   00000092   0x2900             CMP      R1,#+0
   \   00000094   0xD061             BEQ.N    ??USB_DeviceKhciControl_10
   1145                      {
   1146                          temp8 = (uint8_t *)param;
   1147                          error = USB_DeviceKhciEndpointStall(khciState, *temp8);
   \   00000096   0x780A             LDRB     R2,[R1, #+0]
   \   00000098   0x4611             MOV      R1,R2
   \   0000009A   0x4620             MOV      R0,R4
   \   0000009C   0xF002 0x050F      AND      R5,R2,#0xF
   \   000000A0   0x09D6             LSRS     R6,R2,#+7
   \   000000A2   0x.... 0x....      BL       USB_DeviceKhciCancel
   \   000000A6   0xEA46 0x0745      ORR      R7,R6,R5, LSL #+1
   \   000000AA   0xEB04 0x1007      ADD      R0,R4,R7, LSL #+4
   \   000000AE   0x6AC1             LDR      R1,[R0, #+44]
   \   000000B0   0xF441 0x6180      ORR      R1,R1,#0x400
   \   000000B4   0x62C1             STR      R1,[R0, #+44]
   \   000000B6   0x0A4A             LSRS     R2,R1,#+9
   \   000000B8   0x6860             LDR      R0,[R4, #+4]
   \   000000BA   0x0A40             LSRS     R0,R0,#+9
   \   000000BC   0x0240             LSLS     R0,R0,#+9
   \   000000BE   0xEA40 0x1045      ORR      R0,R0,R5, LSL #+5
   \   000000C2   0xEA40 0x1006      ORR      R0,R0,R6, LSL #+4
   \   000000C6   0xF002 0x0208      AND      R2,R2,#0x8
   \   000000CA   0x4310             ORRS     R0,R2,R0
   \   000000CC   0x....             LDR.N    R2,??DataTable4  ;; 0x3ff0000
   \   000000CE   0xEA02 0x4101      AND      R1,R2,R1, LSL #+16
   \   000000D2   0xF041 0x018C      ORR      R1,R1,#0x8C
   \   000000D6   0x6001             STR      R1,[R0, #+0]
   \   000000D8   0x68A0             LDR      R0,[R4, #+8]
   \   000000DA   0xF890 0x1094      LDRB     R1,[R0, #+148]
   \   000000DE   0xF001 0x01DF      AND      R1,R1,#0xDF
   \                     ??USB_DeviceKhciControl_5: (+1)
   \   000000E2   0xF880 0x1094      STRB     R1,[R0, #+148]
   1148                      }
   \   000000E6   0xE033             B.N      ??USB_DeviceKhciControl_8
   1149                      break;
   1150                  case kUSB_DeviceControlEndpointUnstall:
   1151                      if (param)
   \                     ??USB_DeviceKhciControl_13: (+1)
   \   000000E8   0x2900             CMP      R1,#+0
   \   000000EA   0xD036             BEQ.N    ??USB_DeviceKhciControl_10
   1152                      {
   1153                          temp8 = (uint8_t *)param;
   1154                          error = USB_DeviceKhciEndpointUnstall(khciState, *temp8);
   \   000000EC   0x7809             LDRB     R1,[R1, #+0]
   \   000000EE   0x4620             MOV      R0,R4
   \   000000F0   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   000000F4   0x....             B.N      USB_DeviceKhciEndpointUnstall
   1155                      }
   1156                      break;
   1157                  case kUSB_DeviceControlGetDeviceStatus:
   1158                      if (param)
   \                     ??USB_DeviceKhciControl_14: (+1)
   \   000000F6   0xB381             CBZ.N    R1,??USB_DeviceKhciControl_10
   1159                      {
   1160                          temp16 = (uint16_t *)param;
   1161                          *temp16 =
   1162                              (USB_DEVICE_CONFIG_SELF_POWER << (USB_REQUSET_STANDARD_GET_STATUS_DEVICE_SELF_POWERED_SHIFT)) |
   1163                              (USB_DEVICE_CONFIG_REMOTE_WAKEUP << (USB_REQUSET_STANDARD_GET_STATUS_DEVICE_REMOTE_WARKUP_SHIFT));
   \   000000F8   0x8008             STRH     R0,[R1, #+0]
   1164                          error = kStatus_USB_Success;
   \   000000FA   0xE029             B.N      ??USB_DeviceKhciControl_8
   1165                      }
   1166                      break;
   1167                  case kUSB_DeviceControlGetEndpointStatus:
   1168                      if (param)
   \                     ??USB_DeviceKhciControl_15: (+1)
   \   000000FC   0xB369             CBZ.N    R1,??USB_DeviceKhciControl_10
   \   000000FE   0x780A             LDRB     R2,[R1, #+0]
   \   00000100   0xF002 0x030F      AND      R3,R2,#0xF
   \   00000104   0x2B08             CMP      R3,#+8
   \   00000106   0xD228             BCS.N    ??USB_DeviceKhciControl_10
   1169                      {
   1170                          usb_device_endpoint_status_struct_t *endpointStatus = (usb_device_endpoint_status_struct_t *)param;
   1171          
   1172                          if (((endpointStatus->endpointAddress) & USB_ENDPOINT_NUMBER_MASK) < USB_DEVICE_CONFIG_ENDPOINTS)
   1173                          {
   1174                              endpointStatus->endpointStatus =
   1175                                  (uint16_t)(
   1176                                      khciState
   1177                                          ->endpointState[(((endpointStatus->endpointAddress) & USB_ENDPOINT_NUMBER_MASK) << 1U) |
   1178                                                          (((endpointStatus->endpointAddress) &
   1179                                                            USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_MASK) >>
   1180                                                           USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT)]
   1181                                          .stateUnion.stateBitField.stalled == 1U) ?
   1182                                      kUSB_DeviceEndpointStateStalled :
   1183                                      kUSB_DeviceEndpointStateIdle;
   \   00000108   0x0050             LSLS     R0,R2,#+1
   \   0000010A   0xF000 0x001E      AND      R0,R0,#0x1E
   \   0000010E   0xEA40 0x10D2      ORR      R0,R0,R2, LSR #+7
   \   00000112   0xEB04 0x1000      ADD      R0,R4,R0, LSL #+4
   \   00000116   0x6AC0             LDR      R0,[R0, #+44]
   \   00000118   0x0A80             LSRS     R0,R0,#+10
   \   0000011A   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000011E   0x8048             STRH     R0,[R1, #+2]
   1184                              error = kStatus_USB_Success;
   \   00000120   0xE016             B.N      ??USB_DeviceKhciControl_8
   1185                          }
   1186                      }
   1187                      break;
   1188                  case kUSB_DeviceControlSetDeviceAddress:
   1189                      if (param)
   \                     ??USB_DeviceKhciControl_16: (+1)
   \   00000122   0xB1D1             CBZ.N    R1,??USB_DeviceKhciControl_10
   1190                      {
   1191                          temp8 = (uint8_t *)param;
   1192                          khciState->registerBase->ADDR = (*temp8);
   \   00000124   0x7808             LDRB     R0,[R1, #+0]
   \   00000126   0x68A1             LDR      R1,[R4, #+8]
   \   00000128   0xF881 0x0098      STRB     R0,[R1, #+152]
   1193                          error = kStatus_USB_Success;
   \   0000012C   0xE010             B.N      ??USB_DeviceKhciControl_8
   1194                      }
   1195                      break;
   1196                  case kUSB_DeviceControlGetSynchFrame:
   1197                      break;
   1198                  case kUSB_DeviceControlResume:
   1199          #if defined(USB_DEVICE_CONFIG_REMOTE_WAKEUP) && (USB_DEVICE_CONFIG_REMOTE_WAKEUP > 0U)
   1200                      USB_OSA_ENTER_CRITICAL();
   1201                      khciState->registerBase->CTL |= USB_CTL_RESUME_MASK;
   1202                      for (uint32_t i = 500U; i > 0U; i--)
   1203                      {
   1204                          __ASM("nop");
   1205                      }
   1206                      khciState->registerBase->CTL &= ~USB_CTL_RESUME_MASK;
   1207                      USB_OSA_EXIT_CRITICAL();
   1208                      error = kStatus_USB_Success;
   1209          #endif /* USB_DEVICE_CONFIG_REMOTE_WAKEUP */
   1210                      break;
   1211                  case kUSB_DeviceControlSetDefaultStatus:
   1212                      for (uint8_t count = 0U; count < USB_DEVICE_CONFIG_ENDPOINTS; count++)
   \                     ??USB_DeviceKhciControl_17: (+1)
   \   0000012E   0x2500             MOVS     R5,#+0
   1213                      {
   1214                          USB_DeviceKhciEndpointDeinit(khciState, (count | (USB_IN << 0x07U)));
   \                     ??USB_DeviceKhciControl_18: (+1)
   \   00000130   0xF045 0x0180      ORR      R1,R5,#0x80
   \   00000134   0xB2C9             UXTB     R1,R1
   \   00000136   0x4620             MOV      R0,R4
   \   00000138   0x.... 0x....      BL       USB_DeviceKhciEndpointDeinit
   1215                          USB_DeviceKhciEndpointDeinit(khciState, (count | (USB_OUT << 0x07U)));
   \   0000013C   0xB2E9             UXTB     R1,R5
   \   0000013E   0x4620             MOV      R0,R4
   \   00000140   0x.... 0x....      BL       USB_DeviceKhciEndpointDeinit
   1216                      }
   \   00000144   0x1C6D             ADDS     R5,R5,#+1
   \   00000146   0x2D08             CMP      R5,#+8
   \   00000148   0xD3F2             BCC.N    ??USB_DeviceKhciControl_18
   1217                      USB_DeviceKhciSetDefaultState(khciState);
   \   0000014A   0x4620             MOV      R0,R4
   \   0000014C   0x.... 0x....      BL       USB_DeviceKhciSetDefaultState
   1218                      error = kStatus_USB_Success;
   \                     ??USB_DeviceKhciControl_8: (+1)
   \   00000150   0x2000             MOVS     R0,#+0
   1219                      break;
   \   00000152   0xBDF2             POP      {R1,R4-R7,PC}
   1220                  case kUSB_DeviceControlGetSpeed:
   1221                      if (param)
   \                     ??USB_DeviceKhciControl_19: (+1)
   \   00000154   0xB109             CBZ.N    R1,??USB_DeviceKhciControl_10
   1222                      {
   1223                          temp8 = (uint8_t *)param;
   1224                          *temp8 = USB_SPEED_FULL;
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0x7008             STRB     R0,[R1, #+0]
   1225                          error = kStatus_USB_Success;
   1226                      }
   1227                      break;
   1228                  case kUSB_DeviceControlGetOtgStatus:
   1229                      break;
   1230                  case kUSB_DeviceControlSetOtgStatus:
   1231                      break;
   1232                  case kUSB_DeviceControlSetTestMode:
   1233                      break;
   1234                  default:
   1235                      break;
   1236              }
   1237          
   1238              return error;
   \                     ??USB_DeviceKhciControl_10: (+1)
   \   0000015A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1239          }
   1240          
   1241          /*!
   1242           * @brief Handle the KHCI device interrupt.
   1243           *
   1244           * The function is used to handle the KHCI device interrupt.
   1245           *
   1246           * @param deviceHandle    The device handle got from USB_DeviceInit.
   1247           *
   1248           */

   \                                 In section .text, align 2, keep-with-next
   1249          void USB_DeviceKhciIsrFunction(void *deviceHandle)
   1250          {
   1251              usb_device_struct_t *handle = (usb_device_struct_t *)deviceHandle;
   1252              usb_device_khci_state_struct_t *khciState;
   1253              uint8_t status;
   1254          
   1255              if (NULL == deviceHandle)
   \                     USB_DeviceKhciIsrFunction: (+1)
   \   00000000   0xB900             CBNZ.N   R0,??USB_DeviceKhciIsrFunction_0
   \   00000002   0x4770             BX       LR
   1256              {
   1257                  return;
   1258              }
   1259          
   1260              khciState = (usb_device_khci_state_struct_t *)(handle->controllerHandle);
   \                     ??USB_DeviceKhciIsrFunction_0: (+1)
   \   00000004   0xB53E             PUSH     {R1-R5,LR}
   \   00000006   0x6804             LDR      R4,[R0, #+0]
   1261          
   1262              status = khciState->registerBase->ISTAT;
   \   00000008   0x68A0             LDR      R0,[R4, #+8]
   \   0000000A   0xF890 0x5080      LDRB     R5,[R0, #+128]
   1263          #if defined(FSL_FEATURE_USB_KHCI_KEEP_ALIVE_ENABLED) && (FSL_FEATURE_USB_KHCI_KEEP_ALIVE_ENABLED > 0U) \
   1264          && defined(USB_DEVICE_CONFIG_KEEP_ALIVE_MODE) &&                                         \
   1265              (USB_DEVICE_CONFIG_KEEP_ALIVE_MODE > 0U) && defined(FSL_FEATURE_USB_KHCI_USB_RAM) && \
   1266              (FSL_FEATURE_USB_KHCI_USB_RAM > 0U)
   1267              /* Clear EEP_ALIVE_CTRL_WAKE_INT interrupt state */
   1268              if (khciState->registerBase->KEEP_ALIVE_CTRL & USB_KEEP_ALIVE_CTRL_WAKE_INT_STS_MASK)
   1269              {
   1270                  khciState->registerBase->KEEP_ALIVE_CTRL |= USB_KEEP_ALIVE_CTRL_WAKE_INT_STS_MASK;
   1271              }
   1272              /* Clear SOFTOK interrupt state */
   1273              if (khciState->registerBase->ISTAT & USB_ISTAT_SOFTOK_MASK)
   1274              {
   1275                  khciState->registerBase->ISTAT = USB_ISTAT_SOFTOK_MASK;
   1276              }
   1277          #endif
   1278          #if defined(USB_DEVICE_CONFIG_KHCI_ERROR_HANDLING) && (USB_DEVICE_CONFIG_KHCI_ERROR_HANDLING > 0U)
   1279              /* Error interrupt */
   1280              if (status & kUSB_KhciInterruptError)
   1281              {
   1282                  USB_DeviceKhciInterruptError(khciState);
   1283              }
   1284          #endif /* USB_DEVICE_CONFIG_KHCI_ERROR_HANDLING */
   1285              /* Token done interrupt */
   1286              if (status & kUSB_KhciInterruptTokenDone)
   \   0000000E   0x0728             LSLS     R0,R5,#+28
   \   00000010   0xBF44             ITT      MI 
   1287              {
   1288                  USB_DeviceKhciInterruptTokenDone(khciState);
   \   00000012   0x4620             MOVMI    R0,R4
   \   00000014   0x.... 0x....      BLMI     USB_DeviceKhciInterruptTokenDone
   1289              }
   1290          
   1291              /* Reset interrupt */
   1292              if (status & kUSB_KhciInterruptReset)
   \   00000018   0x07E8             LSLS     R0,R5,#+31
   \   0000001A   0xD512             BPL.N    ??USB_DeviceKhciIsrFunction_1
   1293              {
   1294                  USB_DeviceKhciInterruptReset(khciState);
   \   0000001C   0x68A1             LDR      R1,[R4, #+8]
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF884 0x0121      STRB     R0,[R4, #+289]
   \   00000024   0xF881 0x0080      STRB     R0,[R1, #+128]
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   \   0000002E   0x2010             MOVS     R0,#+16
   \   00000030   0xF88D 0x0008      STRB     R0,[SP, #+8]
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x9001             STR      R0,[SP, #+4]
   \   00000038   0xF88D 0x0009      STRB     R0,[SP, #+9]
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x.... 0x....      BL       USB_DeviceNotificationTrigger
   1295              }
   1296          
   1297          #if ((defined(USB_DEVICE_CONFIG_LOW_POWER_MODE) && (USB_DEVICE_CONFIG_LOW_POWER_MODE > 0U)) || \
   1298               (defined(USB_DEVICE_CONFIG_REMOTE_WAKEUP) && (USB_DEVICE_CONFIG_REMOTE_WAKEUP > 0U)))
   1299              /* Suspend interrupt */
   1300              if (status & kUSB_KhciInterruptSleep)
   1301              {
   1302                  USB_DeviceKhciInterruptSleep(khciState);
   1303              }
   1304          
   1305              /* Resume interrupt */
   1306              if (status & kUSB_KhciInterruptResume)
   1307              {
   1308                  USB_DeviceKhciInterruptResume(khciState);
   1309              }
   1310          #endif /* USB_DEVICE_CONFIG_LOW_POWER_MODE || USB_DEVICE_CONFIG_REMOTE_WAKEUP */
   1311          
   1312              /* Endpoint stalled interrupt */
   1313              if (status & kUSB_KhciInterruptStall)
   \                     ??USB_DeviceKhciIsrFunction_1: (+1)
   \   00000042   0x0628             LSLS     R0,R5,#+24
   \   00000044   0xD515             BPL.N    ??USB_DeviceKhciIsrFunction_2
   1314              {
   1315                  USB_DeviceKhciInterruptStall(khciState);
   \   00000046   0x68A1             LDR      R1,[R4, #+8]
   \   00000048   0x2080             MOVS     R0,#+128
   \   0000004A   0xF881 0x0080      STRB     R0,[R1, #+128]
   \   0000004E   0x6BE0             LDR      R0,[R4, #+60]
   \   00000050   0xF3C0 0x2080      UBFX     R0,R0,#+10,#+1
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xBF02             ITTT     EQ 
   \   00000058   0x6AE0             LDREQ    R0,[R4, #+44]
   \   0000005A   0xF3C0 0x2080      UBFXEQ   R0,R0,#+10,#+1
   \   0000005E   0x2800             CMPEQ    R0,#+0
   \   00000060   0xD007             BEQ.N    ??USB_DeviceKhciIsrFunction_2
   \   00000062   0x2180             MOVS     R1,#+128
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x.... 0x....      BL       USB_DeviceKhciEndpointUnstall
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0x.... 0x....      BL       USB_DeviceKhciEndpointUnstall
   1316              }
   1317          
   1318          #if (defined(USB_DEVICE_CONFIG_DETACH_ENABLE) && (USB_DEVICE_CONFIG_DETACH_ENABLE > 0U)) && \
   1319              (defined(FSL_FEATURE_USB_KHCI_VBUS_DETECT_ENABLED) && (FSL_FEATURE_USB_KHCI_VBUS_DETECT_ENABLED > 0U))
   1320              if (khciState->registerBase->USBTRC0 & USB_USBTRC0_VREDG_DET_MASK)
   1321              {
   1322                  USB_DeviceKhciInterruptVbusRising(khciState);
   1323              }
   1324          
   1325              if (khciState->registerBase->USBTRC0 & USB_USBTRC0_VFEDG_DET_MASK)
   1326              {
   1327                  USB_DeviceKhciInterruptVbusFalling(khciState);
   1328              }
   1329          #endif /* USB_DEVICE_CONFIG_DETACH_ENABLE && FSL_FEATURE_USB_KHCI_VBUS_DETECT_ENABLED */
   1330          
   1331          #if 0U
   1332              /* Sof token interrupt */
   1333              if (status & kUSB_KhciInterruptSofToken)
   1334              {
   1335                  USB_DeviceKhciInterruptSof(khciState);
   1336              }
   1337          #endif
   1338          
   1339          #if ((defined FSL_FEATURE_USB_KHCI_IRC48M_MODULE_CLOCK_ENABLED) && \
   1340               (FSL_FEATURE_USB_KHCI_IRC48M_MODULE_CLOCK_ENABLED > 0U))
   1341              status = khciState->registerBase->CLK_RECOVER_INT_STATUS;
   \                     ??USB_DeviceKhciIsrFunction_2: (+1)
   \   00000072   0x68A0             LDR      R0,[R4, #+8]
   \   00000074   0xF890 0x115C      LDRB     R1,[R0, #+348]
   1342              if (status)
   \   00000078   0xB109             CBZ.N    R1,??USB_DeviceKhciIsrFunction_3
   1343              {
   1344                  /* USB RECOVER interrupt is happenned */
   1345                  if (USB_CLK_RECOVER_INT_STATUS_OVF_ERROR_MASK & status)
   1346                  {
   1347                      /* Indicates that the USB clock recovery algorithm has detected that the frequency trim adjustment needed
   1348                       * for the IRC48M output clock is outside the available TRIM_FINE adjustment range for the IRC48M
   1349                       * module.
   1350                       */
   1351                  }
   1352                  khciState->registerBase->CLK_RECOVER_INT_STATUS = status;
   \   0000007A   0xF880 0x115C      STRB     R1,[R0, #+348]
   1353              }
   1354          #endif
   1355          }
   \                     ??USB_DeviceKhciIsrFunction_3: (+1)
   \   0000007E   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x03FF0000         DC32     0x3ff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     s_UsbDeviceKhciState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     s_UsbDeviceKhciBdtBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x40072000         DC32 1074208768
   1356          
   1357          #endif /* USB_DEVICE_CONFIG_KHCI */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   USB_DeviceKhciCancel
        16   -> USB_DeviceNotificationTrigger
      24   USB_DeviceKhciControl
        24   -> USB_DeviceKhciCancel
         0   -> USB_DeviceKhciEndpointDeinit
        24   -> USB_DeviceKhciEndpointDeinit
         0   -> USB_DeviceKhciEndpointInit
         0   -> USB_DeviceKhciEndpointUnstall
        24   -> USB_DeviceKhciSetDefaultState
       0   USB_DeviceKhciDeinit
      16   USB_DeviceKhciEndpointDeinit
        16   -> USB_DeviceKhciCancel
      16   USB_DeviceKhciEndpointInit
        16   -> USB_DeviceKhciPrimeNextSetup
      24   USB_DeviceKhciEndpointTransfer
        24   -> USB_BmEnterCritical
        24   -> USB_BmExitCritical
      24   USB_DeviceKhciEndpointUnstall
        24   -> USB_DeviceKhciPrimeNextSetup
      24   USB_DeviceKhciInit
        24   -> USB_DeviceKhciControl
        24   -> USB_DeviceKhciSetDefaultState
      48   USB_DeviceKhciInterruptTokenDone
        48   -> USB_DeviceKhciCancel
        48   -> USB_DeviceKhciRecv
        48   -> USB_DeviceKhciSend
        48   -> USB_DeviceNotificationTrigger
        48   -> USB_DeviceSendRequest
      24   USB_DeviceKhciIsrFunction
        24   -> USB_DeviceKhciEndpointUnstall
        24   -> USB_DeviceKhciInterruptTokenDone
        24   -> USB_DeviceNotificationTrigger
       8   USB_DeviceKhciPrimeNextSetup
         8   -> USB_DeviceKhciEndpointTransfer
      32   USB_DeviceKhciRecv
        32   -> USB_DeviceKhciEndpointTransfer
        32   -> USB_DeviceKhciPrimeNextSetup
      32   USB_DeviceKhciSend
        32   -> USB_DeviceKhciEndpointTransfer
        32   -> USB_DeviceKhciPrimeNextSetup
      16   USB_DeviceKhciSetDefaultState


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
      18  ?Subroutine0
      14  ?Subroutine1
      12  ?Subroutine2
       4  ?_0
      64  USB_DeviceKhciCancel
     348  USB_DeviceKhciControl
      58  USB_DeviceKhciDeinit
      48  USB_DeviceKhciEndpointDeinit
     128  USB_DeviceKhciEndpointInit
     120  USB_DeviceKhciEndpointTransfer
     118  USB_DeviceKhciEndpointUnstall
     102  USB_DeviceKhciInit
     422  USB_DeviceKhciInterruptTokenDone
     128  USB_DeviceKhciIsrFunction
      48  USB_DeviceKhciPrimeNextSetup
     160  USB_DeviceKhciRecv
     112  USB_DeviceKhciSend
     166  USB_DeviceKhciSetDefaultState
     512  s_UsbDeviceKhciBdtBuffer
     356  s_UsbDeviceKhciState
          s_UsbDeviceKhciDmaAlignBuffer

 
 2 082 bytes in section .text
   512 bytes in section m_usb_bdt
   356 bytes in section m_usb_global
 
 2 082 bytes of CODE memory
   868 bytes of DATA memory

Errors: none
Warnings: none
