###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Aug/2016  13:15:59
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\scuart_peripheral_interface.c
#    Command line =  
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\scuart_peripheral_interface.c"
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN256VDC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D BL_TARGET_RAM -lC
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj"
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices/MK22F25612\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/autobaud\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/osa\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device/class\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/bm_usb\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/CMSIS/Include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers/common\"
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list\scuart_peripheral_interface.lst
#    Object file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj\scuart_peripheral_interface.o
#
###############################################################################

C:\Users\cwati\Documents\My Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\scuart_peripheral_interface.c
      1          /*
      2           * Copyright (c) 2013, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "bootloader/bl_context.h"
     32          #include "bootloader/bl_irq_common.h"
     33          #include "bootloader_common.h"
     34          #include "autobaud/autobaud.h"
     35          #include "packet/serial_packet.h"
     36          #include "fsl_device_registers.h"
     37          #include "uart/fsl_uart.h"
     38          #include "utilities/fsl_assert.h"
     39          
     40          #if BL_CONFIG_SCUART
     41          
     42          //! @addtogroup scuart_peripheral
     43          //! @{
     44          
     45          ////////////////////////////////////////////////////////////////////////////////
     46          // Definitions
     47          ////////////////////////////////////////////////////////////////////////////////
     48          
     49          ////////////////////////////////////////////////////////////////////////////////
     50          // Prototypes
     51          ////////////////////////////////////////////////////////////////////////////////
     52          
     53          static bool scuart_poll_for_activity(const peripheral_descriptor_t *self);
     54          static status_t scuart_full_init(const peripheral_descriptor_t *self, serial_byte_receive_func_t function);
     55          static void scuart_full_shutdown(const peripheral_descriptor_t *self);
     56          
     57          static status_t scuart_write(const peripheral_descriptor_t *self, const uint8_t *buffer, uint32_t byteCount);
     58          
     59          ////////////////////////////////////////////////////////////////////////////////
     60          // Variables
     61          ////////////////////////////////////////////////////////////////////////////////
     62          

   \                                 In section .rodata, align 4, keep-with-next
     63          const peripheral_control_interface_t g_scuartControlInterface = {
   \                     g_scuartControlInterface:
   \   00000000   0x........         DC32 scuart_poll_for_activity, scuart_full_init, scuart_full_shutdown
   \              0x........   
   \              0x........   
   \   0000000C   0x00000000         DC32 0H
     64              .pollForActivity = scuart_poll_for_activity, .init = scuart_full_init, .shutdown = scuart_full_shutdown, .pump = 0
     65          };
     66          

   \                                 In section .rodata, align 4, keep-with-next
     67          const peripheral_byte_inteface_t g_scuartByteInterface = {.init = NULL, .write = scuart_write };
   \                     g_scuartByteInterface:
   \   00000000   0x00000000         DC32 0H, scuart_write
   \              0x........   
     68          

   \                                 In section .bss, align 4
     69          static serial_byte_receive_func_t s_scuart_byte_receive_callback;
     70          static bool g_uartInitDone = false;
   \                     g_uartInitDone:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \   00000004                      DS8 4
     71          
     72          ////////////////////////////////////////////////////////////////////////////////
     73          // Code
     74          ////////////////////////////////////////////////////////////////////////////////
     75          static UART_Type *get_uart_baseAddr(uint32_t instance)
     76          {
     77              switch (instance)
     78              {
     79                  default:
     80                  case 0:
     81                      return UART0;
     82                  case 1:
     83                      return UART1;
     84          #if (FSL_FEATURE_SOC_UART_COUNT > 2U)
     85                  case 2:
     86                      return UART2;
     87          #if (FSL_FEATURE_SOC_UART_COUNT > 3U)
     88                  case 3:
     89                      return UART3;
     90          #if (FSL_FEATURE_SOC_UART_COUNT > 4U)
     91                  case 4:
     92                      return UART4;
     93          #if (FSL_FEATURE_SOC_UART_COUNT > 5U)
     94                  case 5:
     95                      return UART5;
     96          #endif // (FSL_FEATURE_SOC_UART_COUNT > 5U)
     97          #endif // (FSL_FEATURE_SOC_UART_COUNT > 4U)
     98          #endif // (FSL_FEATURE_SOC_UART_COUNT > 3U)
     99          #endif // (FSL_FEATURE_SOC_UART_COUNT > 2U)
    100              }
    101          }
    102          

   \                                 In section .text, align 2, keep-with-next
    103          bool scuart_poll_for_activity(const peripheral_descriptor_t *self)
    104          {
   \                     scuart_poll_for_activity: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB085             SUB      SP,SP,#+20
    105              uint32_t baud;
    106              status_t autoBaudCompleted = autobaud_get_rate(self->instance, &baud);
    107          
    108              if (autoBaudCompleted == kStatus_Success)
   \   00000006   0x6860             LDR      R0,[R4, #+4]
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x.... 0x....      BL       autobaud_get_rate
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD135             BNE.N    ??scuart_poll_for_activity_0
    109              {
    110                  uart_config_t userConfig;
    111                  UART_Type *base = get_uart_baseAddr(self->instance);
   \   00000012   0x6860             LDR      R0,[R4, #+4]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD004             BEQ.N    ??scuart_poll_for_activity_1
   \   00000018   0x2802             CMP      R0,#+2
   \   0000001A   0xBF0C             ITE      EQ 
   \   0000001C   0x....             LDREQ.N  R5,??DataTable9  ;; 0x4006c000
   \   0000001E   0x....             LDRNE.N  R5,??DataTable9_1  ;; 0x4006a000
   \   00000020   0xE000             B.N      ??scuart_poll_for_activity_2
   \                     ??scuart_poll_for_activity_1: (+1)
   \   00000022   0x....             LDR.N    R5,??DataTable9_2  ;; 0x4006b000
    112                  UART_GetDefaultConfig(&userConfig);
   \                     ??scuart_poll_for_activity_2: (+1)
   \   00000024   0xA801             ADD      R0,SP,#+4
   \   00000026   0x.... 0x....      BL       UART_GetDefaultConfig
    113          
    114                  userConfig.baudRate_Bps = baud;
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
   \   0000002C   0x9001             STR      R0,[SP, #+4]
    115                  userConfig.enableTx = true;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF88D 0x000B      STRB     R0,[SP, #+11]
    116                  userConfig.enableRx = true;
   \   00000034   0xF88D 0x000C      STRB     R0,[SP, #+12]
    117          
    118                  if (UART_Init(base, &userConfig, get_uart_clock(self->instance)) == kStatus_Success)
   \   00000038   0x6860             LDR      R0,[R4, #+4]
   \   0000003A   0x.... 0x....      BL       get_uart_clock
   \   0000003E   0x4602             MOV      R2,R0
   \   00000040   0xA901             ADD      R1,SP,#+4
   \   00000042   0x4628             MOV      R0,R5
   \   00000044   0x.... 0x....      BL       UART_Init
   \   00000048   0xB9B0             CBNZ.N   R0,??scuart_poll_for_activity_3
    119                  {
    120                      UART_SetSystemIRQ(self->instance, kPeripheralEnableIRQ);
   \   0000004A   0x6860             LDR      R0,[R4, #+4]
   \   0000004C   0x2101             MOVS     R1,#+1
   \   0000004E   0x.... 0x....      BL       UART_SetSystemIRQ
    121                      UART_EnableInterrupts(base, kUART_RxDataRegFullInterruptEnable);
   \   00000052   0xF44F 0x5100      MOV      R1,#+8192
   \   00000056   0x4628             MOV      R0,R5
   \   00000058   0x.... 0x....      BL       UART_EnableInterrupts
    122                      // Configure selected pin as uart peripheral interface
    123                      self->pinmuxConfig(self->instance, kPinmuxType_Peripheral);
   \   0000005C   0x6860             LDR      R0,[R4, #+4]
   \   0000005E   0x68A2             LDR      R2,[R4, #+8]
   \   00000060   0x....             LDR.N    R4,??DataTable9_3
   \   00000062   0x2102             MOVS     R1,#+2
   \   00000064   0x4790             BLX      R2
    124          
    125                      // This was the byte pattern identified in autobaud detection, inform the command layer
    126                      s_scuart_byte_receive_callback(kFramingPacketStartByte);
   \   00000066   0x6861             LDR      R1,[R4, #+4]
   \   00000068   0x205A             MOVS     R0,#+90
   \   0000006A   0x4788             BLX      R1
    127                      s_scuart_byte_receive_callback(kFramingPacketType_Ping);
   \   0000006C   0x6861             LDR      R1,[R4, #+4]
   \   0000006E   0x20A6             MOVS     R0,#+166
   \   00000070   0x4788             BLX      R1
    128          
    129                      g_uartInitDone = true;
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x7020             STRB     R0,[R4, #+0]
    130          
    131                      return true;
   \   00000076   0xE003             B.N      ??scuart_poll_for_activity_4
    132                  }
    133                  else
    134                  {
    135                      autobaud_init(self->instance);
   \                     ??scuart_poll_for_activity_3: (+1)
   \   00000078   0x6860             LDR      R0,[R4, #+4]
   \   0000007A   0x.... 0x....      BL       autobaud_init
    136                  }  
    137              }
    138          
    139              return false;
   \                     ??scuart_poll_for_activity_0: (+1)
   \   0000007E   0x2000             MOVS     R0,#+0
   \                     ??scuart_poll_for_activity_4: (+1)
   \   00000080   0xB005             ADD      SP,SP,#+20
   \   00000082   0xBD30             POP      {R4,R5,PC}       ;; return
    140          }
    141          

   \                                 In section .text, align 2, keep-with-next
    142          status_t scuart_full_init(const peripheral_descriptor_t *self, serial_byte_receive_func_t function)
    143          {
   \                     scuart_full_init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    144              s_scuart_byte_receive_callback = function;
   \   00000004   0x....             LDR.N    R0,??DataTable9_3
   \   00000006   0x6041             STR      R1,[R0, #+4]
    145          
    146              // Since we are using autobaud once the detection is completed
    147              // it will call the UART initialization and remux the pins when it completes
    148              self->pinmuxConfig(self->instance, kPinmuxType_GPIO);
   \   00000008   0x6860             LDR      R0,[R4, #+4]
   \   0000000A   0x68A2             LDR      R2,[R4, #+8]
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x4790             BLX      R2
    149          
    150              // Init autobaud detector.
    151              autobaud_init(self->instance);
   \   00000010   0x6860             LDR      R0,[R4, #+4]
   \   00000012   0x.... 0x....      BL       autobaud_init
    152          
    153              return kStatus_Success;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    154          }
    155          

   \                                 In section .text, align 2, keep-with-next
    156          void scuart_full_shutdown(const peripheral_descriptor_t *self)
    157          {
   \                     scuart_full_shutdown: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    158              if (g_uartInitDone)
   \   00000004   0x....             LDR.N    R0,??DataTable9_3
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xB170             CBZ.N    R0,??scuart_full_shutdown_0
    159              {
    160                  UART_SetSystemIRQ(self->instance, kPeripheralDisableIRQ);
   \   0000000A   0x6860             LDR      R0,[R4, #+4]
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x.... 0x....      BL       UART_SetSystemIRQ
    161                  UART_Deinit(get_uart_baseAddr(self->instance));
   \   00000012   0x6860             LDR      R0,[R4, #+4]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD004             BEQ.N    ??scuart_full_shutdown_1
   \   00000018   0x2802             CMP      R0,#+2
   \   0000001A   0xBF0C             ITE      EQ 
   \   0000001C   0x....             LDREQ.N  R0,??DataTable9  ;; 0x4006c000
   \   0000001E   0x....             LDRNE.N  R0,??DataTable9_1  ;; 0x4006a000
   \   00000020   0xE000             B.N      ??scuart_full_shutdown_2
   \                     ??scuart_full_shutdown_1: (+1)
   \   00000022   0x....             LDR.N    R0,??DataTable9_2  ;; 0x4006b000
    162              }
   \                     ??scuart_full_shutdown_2: (+1)
   \   00000024   0x.... 0x....      BL       UART_Deinit
    163          
    164          //! Note: if not deinit autobaud(IRQ method), user app may encounters hardfault
    165          //! if it doesn't provide related pin interrupt service routine.
    166          #if BL_FEATURE_UART_AUTOBAUD_IRQ
    167              // De-init autobaud detector.
    168              autobaud_deinit(self->instance);
   \                     ??scuart_full_shutdown_0: (+1)
   \   00000028   0x6860             LDR      R0,[R4, #+4]
   \   0000002A   0x.... 0x....      BL       autobaud_deinit
    169          #endif
    170              // Restore selected pin to default state to reduce IDD.
    171              self->pinmuxConfig(self->instance, kPinmuxType_Default);
   \   0000002E   0x6860             LDR      R0,[R4, #+4]
   \   00000030   0x68A2             LDR      R2,[R4, #+8]
   \   00000032   0xE8BD 0x4010      POP      {R4,LR}
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x4710             BX       R2
    172          }
    173          

   \                                 In section .text, align 2, keep-with-next
    174          status_t scuart_write(const peripheral_descriptor_t *self, const uint8_t *buffer, uint32_t byteCount)
    175          {
   \                     scuart_write: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    176              UART_WriteBlocking(get_uart_baseAddr(self->instance), buffer, byteCount);
   \   00000002   0x6840             LDR      R0,[R0, #+4]
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD004             BEQ.N    ??scuart_write_0
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xBF0C             ITE      EQ 
   \   0000000C   0x....             LDREQ.N  R0,??DataTable9  ;; 0x4006c000
   \   0000000E   0x....             LDRNE.N  R0,??DataTable9_1  ;; 0x4006a000
   \   00000010   0xE000             B.N      ??scuart_write_1
   \                     ??scuart_write_0: (+1)
   \   00000012   0x....             LDR.N    R0,??DataTable9_2  ;; 0x4006b000
   \                     ??scuart_write_1: (+1)
   \   00000014   0x.... 0x....      BL       UART_WriteBlocking
    177              return kStatus_Success;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD02             POP      {R1,PC}          ;; return
    178          }
    179          
    180          /********************************************************************/
    181          /*
    182           * UART0 IRQ Handler
    183           *
    184           */
    185          

   \                                 In section .text, align 2, keep-with-next
    186          void UART0_RX_TX_IRQHandler(void)
    187          {
    188              if (UART0->S1 & UART_S1_RDRF_MASK)
   \                     UART0_RX_TX_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable9_4  ;; 0x4006a004
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x0689             LSLS     R1,R1,#+26
   \   00000006   0xD500             BPL.N    ??UART0_RX_TX_IRQHandler_0
    189              {
    190                  s_scuart_byte_receive_callback(UART0->D);
   \   00000008   0x....             B.N      ?Subroutine0
    191              }
    192          }
   \                     ??UART0_RX_TX_IRQHandler_0: (+1)
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x78C0             LDRB     R0,[R0, #+3]
   \   00000002   0x....             LDR.N    R1,??DataTable9_3
   \   00000004   0x6849             LDR      R1,[R1, #+4]
   \   00000006   0x4708             BX       R1
    193          
    194          /********************************************************************/
    195          /*
    196           * UART1 IRQ Handler
    197           *
    198           */
    199          

   \                                 In section .text, align 2, keep-with-next
    200          void UART1_RX_TX_IRQHandler(void)
    201          {
    202              uint8_t s1 = UART1->S1;
   \                     UART1_RX_TX_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable9_5  ;; 0x4006b004
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
    203              uint8_t d;
    204          
    205              if (s1 & UART_S1_FE_MASK)
   \   00000004   0x078A             LSLS     R2,R1,#+30
   \   00000006   0xD501             BPL.N    ??UART1_RX_TX_IRQHandler_0
    206              {
    207                  d = UART1->D;
   \   00000008   0x78C0             LDRB     R0,[R0, #+3]
   \   0000000A   0x4770             BX       LR
    208              }
    209              else if (s1 & UART_S1_RDRF_MASK)
   \                     ??UART1_RX_TX_IRQHandler_0: (+1)
   \   0000000C   0x0689             LSLS     R1,R1,#+26
   \   0000000E   0xD500             BPL.N    ??UART1_RX_TX_IRQHandler_1
    210              {
    211                  d = UART1->D;
   \   00000010   0x....             B.N      ?Subroutine0
    212                  s_scuart_byte_receive_callback(d);
    213              }
    214          }
   \                     ??UART1_RX_TX_IRQHandler_1: (+1)
   \   00000012   0x4770             BX       LR               ;; return
    215          
    216          #if (FSL_FEATURE_SOC_UART_COUNT > 2U)
    217          /********************************************************************/
    218          /*
    219           * UART2 IRQ Handler
    220           *
    221           */
    222          

   \                                 In section .text, align 2, keep-with-next
    223          void UART2_RX_TX_IRQHandler(void)
    224          {
    225              if (UART2->S1 & UART_S1_RDRF_MASK)
   \                     UART2_RX_TX_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable9_6  ;; 0x4006c004
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x0689             LSLS     R1,R1,#+26
   \   00000006   0xD500             BPL.N    ??UART2_RX_TX_IRQHandler_0
    226              {
    227                  s_scuart_byte_receive_callback(UART2->D);
   \   00000008   0x....             B.N      ?Subroutine0
    228              }
    229          }
   \                     ??UART2_RX_TX_IRQHandler_0: (+1)
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x4006C000         DC32     0x4006c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x4006A000         DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x4006B000         DC32     0x4006b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     g_uartInitDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x4006A004         DC32     0x4006a004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x4006B004         DC32     0x4006b004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x4006C004         DC32     0x4006c004
    230          
    231          #if (FSL_FEATURE_SOC_UART_COUNT > 3U)
    232          
    233          /********************************************************************/
    234          /*
    235           * UART3 IRQ Handler
    236           *
    237           */
    238          
    239          void UART3_RX_TX_IRQHandler(void)
    240          {
    241              if (UART3->S1 & UART_S1_RDRF_MASK)
    242              {
    243                  s_scuart_byte_receive_callback(UART3->D);
    244              }
    245          }
    246          
    247          /********************************************************************/
    248          /*
    249           * UART4 IRQ Handler
    250           *
    251           */
    252          
    253          void UART4_RX_TX_IRQHandler(void)
    254          {
    255              if (UART4->S1 & UART_S1_RDRF_MASK)
    256              {
    257                  s_scuart_byte_receive_callback(UART4->D);
    258              }
    259          }
    260          
    261          #if (FSL_FEATURE_SOC_UART_COUNT > 5U)
    262          /********************************************************************/
    263          /*
    264           * UART5 IRQ Handler
    265           *
    266           */
    267          
    268          void UART5_RX_TX_IRQHandler(void)
    269          {
    270              if (UART5->S1 & UART_S1_RDRF_MASK)
    271              {
    272                  s_scuart_byte_receive_callback(UART5->D);
    273              }
    274          }
    275          
    276          #endif // (FSL_FEATURE_SOC_UART_COUNT > 5U)
    277          #endif // (FSL_FEATURE_SOC_UART_COUNT > 3U)
    278          #endif // (FSL_FEATURE_SOC_UART_COUNT > 2U)
    279          
    280          //! @}
    281          
    282          #endif // BL_CONFIG_SCUART
    283          
    284          ////////////////////////////////////////////////////////////////////////////////
    285          // EOF
    286          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   UART0_RX_TX_IRQHandler
         0   -- Indirect call
       0   UART1_RX_TX_IRQHandler
         0   -- Indirect call
       0   UART2_RX_TX_IRQHandler
         0   -- Indirect call
       8   scuart_full_init
         8   -- Indirect call
         8   -> autobaud_init
       8   scuart_full_shutdown
         0   -- Indirect call
         8   -> UART_Deinit
         8   -> UART_SetSystemIRQ
         8   -> autobaud_deinit
      32   scuart_poll_for_activity
        32   -- Indirect call
        32   -> UART_EnableInterrupts
        32   -> UART_GetDefaultConfig
        32   -> UART_Init
        32   -> UART_SetSystemIRQ
        32   -> autobaud_get_rate
        32   -> autobaud_init
        32   -> get_uart_clock
       8   scuart_write
         8   -> UART_WriteBlocking


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       8  ?Subroutine0
      12  UART0_RX_TX_IRQHandler
      20  UART1_RX_TX_IRQHandler
      12  UART2_RX_TX_IRQHandler
       8  g_scuartByteInterface
      16  g_scuartControlInterface
       8  g_uartInitDone
          s_scuart_byte_receive_callback
      26  scuart_full_init
      58  scuart_full_shutdown
     132  scuart_poll_for_activity
      28  scuart_write

 
   8 bytes in section .bss
  24 bytes in section .rodata
 324 bytes in section .text
 
 324 bytes of CODE  memory
  24 bytes of CONST memory
   8 bytes of DATA  memory

Errors: none
Warnings: none
