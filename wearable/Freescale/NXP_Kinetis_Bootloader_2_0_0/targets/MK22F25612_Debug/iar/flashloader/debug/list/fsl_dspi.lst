###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Aug/2016  13:15:55
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\dspi\fsl_dspi.c
#    Command line =  
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\dspi\fsl_dspi.c"
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN256VDC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D BL_TARGET_RAM -lC
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj"
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices/MK22F25612\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/autobaud\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/osa\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device/class\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/bm_usb\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/CMSIS/Include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers/common\"
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list\fsl_dspi.lst
#    Object file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj\fsl_dspi.o
#
###############################################################################

C:\Users\cwati\Documents\My Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\dspi\fsl_dspi.c
      1          /*
      2          * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3          * All rights reserved.
      4          *
      5          * Redistribution and use in source and binary forms, with or without modification,
      6          * are permitted provided that the following conditions are met:
      7          *
      8          * o Redistributions of source code must retain the above copyright notice, this list
      9          *   of conditions and the following disclaimer.
     10          *
     11          * o Redistributions in binary form must reproduce the above copyright notice, this
     12          *   list of conditions and the following disclaimer in the documentation and/or
     13          *   other materials provided with the distribution.
     14          *
     15          * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16          *   contributors may be used to endorse or promote products derived from this
     17          *   software without specific prior written permission.
     18          *
     19          * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20          * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21          * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22          * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23          * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25          * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26          * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27          * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28          * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29          */
     30          
     31          #include "fsl_dspi.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_EnableClock(clock_ip_name_t)
   \                     CLOCK_EnableClock: (+1)
   \   00000000   0x0C01             LSRS     R1,R0,#+16
   \   00000002   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000006   0xF501 0x218E      ADD      R1,R1,#+290816
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0x680A             LDR      R2,[R1, #+0]
   \   0000000E   0xFA03 0xF000      LSL      R0,R3,R0
   \   00000012   0x4310             ORRS     R0,R0,R2
   \   00000014   0x6008             STR      R0,[R1, #+0]
   \   00000016   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void EnableIRQ(IRQn_Type)
   \                     EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF000 0x021F      AND      R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable25  ;; 0xe000e100
   \   0000000C   0x0940             LSRS     R0,R0,#+5
   \   0000000E   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void DSPI_Enable(SPI_Type *, bool)
   \                     DSPI_Enable: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xBF14             ITE      NE 
   \   00000006   0xF421 0x4180      BICNE    R1,R1,#0x4000
   \   0000000A   0xF441 0x4180      ORREQ    R1,R1,#0x4000
   \   0000000E   0x6001             STR      R1,[R0, #+0]
   \   00000010   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void DSPI_FlushFifo(SPI_Type *, bool, bool)
   \                     DSPI_FlushFifo: (+1)
   \   00000000   0x6803             LDR      R3,[R0, #+0]
   \   00000002   0xF423 0x6340      BIC      R3,R3,#0xC00
   \   00000006   0xEA43 0x21C1      ORR      R1,R3,R1, LSL #+11
   \   0000000A   0xEA41 0x2182      ORR      R1,R1,R2, LSL #+10
   \   0000000E   0x6001             STR      R1,[R0, #+0]
   \   00000010   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t DSPI_MasterGetFormattedCommand(dspi_command_data_config_t *)
   \                     DSPI_MasterGetFormattedCommand: (+1)
   \   00000000   0x7842             LDRB     R2,[R0, #+1]
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x0712             LSLS     R2,R2,#+28
   \   00000006   0xF002 0x42E0      AND      R2,R2,#0x70000000
   \   0000000A   0xEA42 0x71C1      ORR      R1,R2,R1, LSL #+31
   \   0000000E   0x7882             LDRB     R2,[R0, #+2]
   \   00000010   0x0412             LSLS     R2,R2,#+16
   \   00000012   0xF402 0x127C      AND      R2,R2,#0x3F0000
   \   00000016   0x4311             ORRS     R1,R2,R1
   \   00000018   0x78C2             LDRB     R2,[R0, #+3]
   \   0000001A   0x7900             LDRB     R0,[R0, #+4]
   \   0000001C   0xEA41 0x61C2      ORR      R1,R1,R2, LSL #+27
   \   00000020   0xEA41 0x6080      ORR      R0,R1,R0, LSL #+26
   \   00000024   0x4770             BX       LR               ;; return
     32          
     33          /*******************************************************************************
     34           * Definitions
     35           ******************************************************************************/
     36          /*! @brief Typedef for master interrupt handler. */
     37          typedef void (*dspi_master_isr_t)(SPI_Type *base, dspi_master_handle_t *handle);
     38          
     39          /*! @brief Typedef for slave interrupt handler. */
     40          typedef void (*dspi_slave_isr_t)(SPI_Type *base, dspi_slave_handle_t *handle);
     41          
     42          /*******************************************************************************
     43           * Prototypes
     44           ******************************************************************************/
     45          /*!
     46           * @brief Get instance number for DSPI module.
     47           *
     48           * @param base DSPI peripheral base address.
     49           */
     50          uint32_t DSPI_GetInstance(SPI_Type *base);
     51          
     52          /*!
     53           * @brief Configures the DSPI peripheral chip select polarity.
     54           *
     55           * This function  takes in the desired peripheral chip select (Pcs) and it's corresponding desired polarity and
     56           * configures the Pcs signal to operate with the desired characteristic.
     57           *
     58           * @param base DSPI peripheral address.
     59           * @param pcs The particular peripheral chip select (parameter value is of type dspi_which_pcs_t) for which we wish to
     60           *            apply the active high or active low characteristic.
     61           * @param activeLowOrHigh The setting for either "active high, inactive low (0)"  or "active low, inactive high(1)" of
     62           *                        type dspi_pcs_polarity_config_t.
     63           */
     64          static void DSPI_SetOnePcsPolarity(SPI_Type *base, dspi_which_pcs_t pcs, dspi_pcs_polarity_config_t activeLowOrHigh);
     65          
     66          /*!
     67           * @brief Master fill up the TX FIFO with data.
     68           * This is not a public API as it is called from other driver functions.
     69           */
     70          static void DSPI_MasterFillUpTxFifo(SPI_Type *base, dspi_master_handle_t *handle);
     71          
     72          /*!
     73           * @brief Master finish up a transfer.
     74           * It would call back if there is callback function and set the state to idle.
     75           * This is not a public API as it is called from other driver functions.
     76           */
     77          static void DSPI_MasterCompleteTransfer(SPI_Type *base, dspi_master_handle_t *handle);
     78          
     79          /*!
     80           * @brief Slave fill up the TX FIFO with data.
     81           * This is not a public API as it is called from other driver functions.
     82           */
     83          static void DSPI_SlaveFillUpTxFifo(SPI_Type *base, dspi_slave_handle_t *handle);
     84          
     85          /*!
     86           * @brief Slave finish up a transfer.
     87           * It would call back if there is callback function and set the state to idle.
     88           * This is not a public API as it is called from other driver functions.
     89           */
     90          static void DSPI_SlaveCompleteTransfer(SPI_Type *base, dspi_slave_handle_t *handle);
     91          
     92          /*!
     93           * @brief DSPI common interrupt handler.
     94           *
     95           * @param base DSPI peripheral address.
     96           * @param handle pointer to g_dspiHandle which stores the transfer state.
     97           */
     98          static void DSPI_CommonIRQHandler(SPI_Type *base, void *param);
     99          
    100          /*!
    101           * @brief Master prepare the transfer.
    102           * Basically it set up dspi_master_handle .
    103           * This is not a public API as it is called from other driver functions. fsl_dspi_edma.c also call this function.
    104           */
    105          static void DSPI_MasterPrepareTransfer(SPI_Type *base, dspi_master_handle_t *handle, dspi_transfer_t *transfer);
    106          
    107          /*******************************************************************************
    108           * Variables
    109           ******************************************************************************/
    110          
    111          /* Defines constant value arrays for the baud rate pre-scalar and scalar divider values.*/

   \                                 In section .text, align 4, keep-with-next
    112          static const uint32_t s_baudratePrescaler[] = {2, 3, 5, 7};
   \                     s_baudratePrescaler:
   \   00000000   0x00000002         DC32 2, 3, 5, 7
   \              0x00000003   
   \              0x00000005   
   \              0x00000007   

   \                                 In section .text, align 4, keep-with-next
    113          static const uint32_t s_baudrateScaler[] = {2,   4,   6,    8,    16,   32,   64,    128,
   \                     s_baudrateScaler:
   \   00000000   0x00000002         DC32 2, 4, 6, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192
   \              0x00000004   
   \              0x00000006   
   \              0x00000008   
   \              0x00000010   
   \              0x00000020   
   \              0x00000040   
   \              0x00000080   
   \              0x00000100   
   \              0x00000200   
   \              0x00000400   
   \              0x00000800   
   \              0x00001000   
   \              0x00002000   
   \   00000038   0x00004000         DC32 16384, 32768
   \              0x00008000   
    114                                                      256, 512, 1024, 2048, 4096, 8192, 16384, 32768};
    115          

   \                                 In section .text, align 4, keep-with-next
    116          static const uint32_t s_delayPrescaler[] = {1, 3, 5, 7};
   \                     s_delayPrescaler:
   \   00000000   0x00000001         DC32 1, 3, 5, 7
   \              0x00000003   
   \              0x00000005   
   \              0x00000007   

   \                                 In section .text, align 4, keep-with-next
    117          static const uint32_t s_delayScaler[] = {2,   4,    8,    16,   32,   64,    128,   256,
   \                     s_delayScaler:
   \   00000000   0x00000002         DC32 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384
   \              0x00000004   
   \              0x00000008   
   \              0x00000010   
   \              0x00000020   
   \              0x00000040   
   \              0x00000080   
   \              0x00000100   
   \              0x00000200   
   \              0x00000400   
   \              0x00000800   
   \              0x00001000   
   \              0x00002000   
   \              0x00004000   
   \   00000038   0x00008000         DC32 32768, 65536
   \              0x00010000   
    118                                                   512, 1024, 2048, 4096, 8192, 16384, 32768, 65536};
    119          
    120          /*! @brief Pointers to dspi bases for each instance. */

   \                                 In section .text, align 4, keep-with-next
    121          static SPI_Type *const s_dspiBases[] = SPI_BASE_PTRS;
   \                     s_dspiBases:
   \   00000000   0x4002C000         DC32 4002C000H, 4002D000H
   \              0x4002D000   
    122          
    123          /*! @brief Pointers to dspi IRQ number for each instance. */

   \                                 In section .text, align 4, keep-with-next
    124          static IRQn_Type const s_dspiIRQ[] = SPI_IRQS;
   \                     s_dspiIRQ:
   \   00000000   0x1A 0x1B          DC8 26, 27
    125          
    126          /*! @brief Pointers to dspi clocks for each instance. */

   \                                 In section .text, align 4, keep-with-next
    127          static clock_ip_name_t const s_dspiClock[] = DSPI_CLOCKS;
   \                     s_dspiClock:
   \   00000000   0x103C000C         DC32 272367628, 272367629
   \              0x103C000D   
    128          
    129          /*! @brief Pointers to dspi handles for each instance. */

   \                                 In section .bss, align 4
    130          static void *g_dspiHandle[FSL_FEATURE_SOC_DSPI_COUNT];
   \                     g_dspiHandle:
   \   00000000                      DS8 8
    131          
    132          /*! @brief Pointer to master IRQ handler for each instance. */

   \                                 In section .bss, align 4
    133          static dspi_master_isr_t s_dspiMasterIsr;
   \                     s_dspiMasterIsr:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
    134          
    135          /*! @brief Pointer to slave IRQ handler for each instance. */
    136          static dspi_slave_isr_t s_dspiSlaveIsr;
    137          
    138          /**********************************************************************************************************************
    139          * Code
    140          *********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    141          uint32_t DSPI_GetInstance(SPI_Type *base)
    142          {
    143              uint32_t instance;
    144          
    145              /* Find the instance index from base address mappings. */
    146              for (instance = 0; instance < FSL_FEATURE_SOC_DSPI_COUNT; instance++)
   \                     DSPI_GetInstance: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x.... 0x....      ADR.W    R2,s_dspiBases
    147              {
    148                  if (s_dspiBases[instance] == base)
   \                     ??DSPI_GetInstance_0: (+1)
   \   00000006   0xF852 0x3021      LDR      R3,[R2, R1, LSL #+2]
   \   0000000A   0x4283             CMP      R3,R0
   \   0000000C   0xD002             BEQ.N    ??DSPI_GetInstance_1
    149                  {
    150                      break;
    151                  }
    152              }
   \   0000000E   0x1C49             ADDS     R1,R1,#+1
   \   00000010   0x2902             CMP      R1,#+2
   \   00000012   0xD3F8             BCC.N    ??DSPI_GetInstance_0
    153          
    154              assert(instance < FSL_FEATURE_SOC_DSPI_COUNT);
    155          
    156              return instance;
   \                     ??DSPI_GetInstance_1: (+1)
   \   00000014   0x4608             MOV      R0,R1
   \   00000016   0x4770             BX       LR               ;; return
    157          }
    158          

   \                                 In section .text, align 2, keep-with-next
    159          void DSPI_MasterInit(SPI_Type *base, const dspi_master_config_t *masterConfig, uint32_t srcClock_Hz)
    160          {
   \                     DSPI_MasterInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    161              uint32_t temp;
    162              /* enable DSPI clock */
    163              CLOCK_EnableClock(s_dspiClock[DSPI_GetInstance(base)]);
   \   0000000A   0x.... 0x....      BL       DSPI_GetInstance
   \   0000000E   0x.... 0x....      BL       ?Subroutine4
    164          
    165              DSPI_Enable(base, true);
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000012   0x.... 0x....      BL       ?Subroutine8
    166              DSPI_StopTransfer(base);
   \                     ??CrossCallReturnLabel_23: (+1)
   \   00000016   0x.... 0x....      BL       ?Subroutine3
    167          
    168              DSPI_SetMasterSlaveMode(base, kDSPI_Master);
    169          
    170              temp = base->MCR & (~(SPI_MCR_CONT_SCKE_MASK | SPI_MCR_MTFE_MASK | SPI_MCR_ROOE_MASK | SPI_MCR_SMPL_PT_MASK |
    171                                    SPI_MCR_DIS_TXF_MASK | SPI_MCR_DIS_RXF_MASK));
    172          
    173              base->MCR = temp | SPI_MCR_CONT_SCKE(masterConfig->enableContinuousSCK) |
    174                          SPI_MCR_MTFE(masterConfig->enableModifiedTimingFormat) |
    175                          SPI_MCR_ROOE(masterConfig->enableRxFifoOverWrite) | SPI_MCR_SMPL_PT(masterConfig->samplePoint) |
    176                          SPI_MCR_DIS_TXF(false) | SPI_MCR_DIS_RXF(false);
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \   00000020   0x6020             STR      R0,[R4, #+0]
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x4008             ANDS     R0,R1,R0
   \   00000026   0x7FA9             LDRB     R1,[R5, #+30]
   \   00000028   0xEA40 0x7081      ORR      R0,R0,R1, LSL #+30
   \   0000002C   0xF895 0x1020      LDRB     R1,[R5, #+32]
   \   00000030   0xEA40 0x6081      ORR      R0,R0,R1, LSL #+26
   \   00000034   0x7FE9             LDRB     R1,[R5, #+31]
   \   00000036   0xEA40 0x6001      ORR      R0,R0,R1, LSL #+24
   \   0000003A   0xF895 0x1021      LDRB     R1,[R5, #+33]
   \   0000003E   0x.... 0x....      BL       ?Subroutine9
    177          
    178              DSPI_SetOnePcsPolarity(base, masterConfig->whichPcs, masterConfig->pcsActiveHighOrLow);
   \                     ??CrossCallReturnLabel_24: (+1)
   \   00000042   0x7F6A             LDRB     R2,[R5, #+29]
   \   00000044   0x7F29             LDRB     R1,[R5, #+28]
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       DSPI_SetOnePcsPolarity
    179          
    180              if (0 == DSPI_MasterSetBaudRate(base, masterConfig->whichCtar, masterConfig->ctarConfig.baudRate, srcClock_Hz))
   \   0000004C   0x686A             LDR      R2,[R5, #+4]
   \   0000004E   0x7829             LDRB     R1,[R5, #+0]
   \   00000050   0x4633             MOV      R3,R6
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       DSPI_MasterSetBaudRate
   \   00000058   0x7828             LDRB     R0,[R5, #+0]
   \   0000005A   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
    181              {
    182                  assert(false);
    183              }
    184          
    185              temp = base->CTAR[masterConfig->whichCtar] &
    186                     ~(SPI_CTAR_FMSZ_MASK | SPI_CTAR_CPOL_MASK | SPI_CTAR_CPHA_MASK | SPI_CTAR_LSBFE_MASK);
    187          
    188              base->CTAR[masterConfig->whichCtar] =
    189                  temp | SPI_CTAR_FMSZ(masterConfig->ctarConfig.bitsPerFrame - 1) | SPI_CTAR_CPOL(masterConfig->ctarConfig.cpol) |
    190                  SPI_CTAR_CPHA(masterConfig->ctarConfig.cpha) | SPI_CTAR_LSBFE(masterConfig->ctarConfig.direction);
    191          
    192              DSPI_MasterSetDelayTimes(base, masterConfig->whichCtar, kDSPI_PcsToSck, srcClock_Hz,
    193                                       masterConfig->ctarConfig.pcsToSckDelayInNanoSec);
   \   0000005E   0x4633             MOV      R3,R6
   \   00000060   0x68C1             LDR      R1,[R0, #+12]
   \   00000062   0x68AA             LDR      R2,[R5, #+8]
   \   00000064   0x1E52             SUBS     R2,R2,#+1
   \   00000066   0x06D2             LSLS     R2,R2,#+27
   \   00000068   0xF021 0x41FE      BIC      R1,R1,#0x7F000000
   \   0000006C   0xF002 0x42F0      AND      R2,R2,#0x78000000
   \   00000070   0x4311             ORRS     R1,R2,R1
   \   00000072   0x7B2A             LDRB     R2,[R5, #+12]
   \   00000074   0x0692             LSLS     R2,R2,#+26
   \   00000076   0xF002 0x6280      AND      R2,R2,#0x4000000
   \   0000007A   0x4311             ORRS     R1,R2,R1
   \   0000007C   0x7B6A             LDRB     R2,[R5, #+13]
   \   0000007E   0x0652             LSLS     R2,R2,#+25
   \   00000080   0xF002 0x7200      AND      R2,R2,#0x2000000
   \   00000084   0x4311             ORRS     R1,R2,R1
   \   00000086   0x7BAA             LDRB     R2,[R5, #+14]
   \   00000088   0x0612             LSLS     R2,R2,#+24
   \   0000008A   0xF002 0x7280      AND      R2,R2,#0x1000000
   \   0000008E   0x4311             ORRS     R1,R2,R1
   \   00000090   0x60C1             STR      R1,[R0, #+12]
   \   00000092   0x2201             MOVS     R2,#+1
   \   00000094   0x6928             LDR      R0,[R5, #+16]
   \   00000096   0x9000             STR      R0,[SP, #+0]
   \   00000098   0x4620             MOV      R0,R4
   \   0000009A   0x7829             LDRB     R1,[R5, #+0]
   \   0000009C   0x.... 0x....      BL       DSPI_MasterSetDelayTimes
    194              DSPI_MasterSetDelayTimes(base, masterConfig->whichCtar, kDSPI_LastSckToPcs, srcClock_Hz,
    195                                       masterConfig->ctarConfig.lastSckToPcsDelayInNanoSec);
   \   000000A0   0x6968             LDR      R0,[R5, #+20]
   \   000000A2   0x9000             STR      R0,[SP, #+0]
   \   000000A4   0x4633             MOV      R3,R6
   \   000000A6   0x7829             LDRB     R1,[R5, #+0]
   \   000000A8   0x2202             MOVS     R2,#+2
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0x.... 0x....      BL       DSPI_MasterSetDelayTimes
    196              DSPI_MasterSetDelayTimes(base, masterConfig->whichCtar, kDSPI_BetweenTransfer, srcClock_Hz,
    197                                       masterConfig->ctarConfig.betweenTransferDelayInNanoSec);
   \   000000B0   0x69A8             LDR      R0,[R5, #+24]
   \   000000B2   0x9000             STR      R0,[SP, #+0]
   \   000000B4   0x4633             MOV      R3,R6
   \   000000B6   0x7829             LDRB     R1,[R5, #+0]
   \   000000B8   0x2203             MOVS     R2,#+3
   \   000000BA   0x4620             MOV      R0,R4
   \   000000BC   0x.... 0x....      BL       DSPI_MasterSetDelayTimes
    198          
    199              DSPI_StartTransfer(base);
   \   000000C0   0x.... 0x....      BL       ?Subroutine6
    200          }
   \                     ??CrossCallReturnLabel_13: (+1)
   \   000000C4   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \                     ??Subroutine8_0: (+1)
   \   00000002   0x4620             MOV      R0,R4
   \   00000004   0x....             B.N      DSPI_Enable

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \   00000000   0x0209             LSLS     R1,R1,#+8
   \   00000002   0xF401 0x7140      AND      R1,R1,#0x300
   \   00000006   0x4308             ORRS     R0,R1,R0
   \   00000008   0x6020             STR      R0,[R4, #+0]
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x.... 0x....      ADR.W    R1,s_dspiClock
   \   00000004   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000008   0x....             B.N      CLOCK_EnableClock

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x....             LDR.N    R1,??DataTable25_15  ;; 0xbaffccff
   \                     ??Subroutine3_0: (+1)
   \   00000004   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000008   0x6020             STR      R0,[R4, #+0]
   \   0000000A   0x4770             BX       LR
    201          

   \                                 In section .text, align 2, keep-with-next
    202          void DSPI_MasterGetDefaultConfig(dspi_master_config_t *masterConfig)
    203          {
    204              masterConfig->whichCtar = kDSPI_Ctar0;
   \                     DSPI_MasterGetDefaultConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7001             STRB     R1,[R0, #+0]
    205              masterConfig->ctarConfig.baudRate = 500000;
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable25_1  ;; 0x7a120
   \   00000008   0x6041             STR      R1,[R0, #+4]
    206              masterConfig->ctarConfig.bitsPerFrame = 8;
   \   0000000A   0x2108             MOVS     R1,#+8
   \   0000000C   0x6081             STR      R1,[R0, #+8]
    207              masterConfig->ctarConfig.cpol = kDSPI_ClockPolarityActiveHigh;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x7301             STRB     R1,[R0, #+12]
    208              masterConfig->ctarConfig.cpha = kDSPI_ClockPhaseFirstEdge;
   \   00000012   0x7341             STRB     R1,[R0, #+13]
    209              masterConfig->ctarConfig.direction = kDSPI_MsbFirst;
   \   00000014   0x7381             STRB     R1,[R0, #+14]
    210          
    211              masterConfig->ctarConfig.pcsToSckDelayInNanoSec = 1000;
   \   00000016   0xF44F 0x717A      MOV      R1,#+1000
   \   0000001A   0x6101             STR      R1,[R0, #+16]
    212              masterConfig->ctarConfig.lastSckToPcsDelayInNanoSec = 1000;
   \   0000001C   0x6141             STR      R1,[R0, #+20]
    213              masterConfig->ctarConfig.betweenTransferDelayInNanoSec = 1000;
   \   0000001E   0x6181             STR      R1,[R0, #+24]
    214          
    215              masterConfig->whichPcs = kDSPI_Pcs0;
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x7701             STRB     R1,[R0, #+28]
    216              masterConfig->pcsActiveHighOrLow = kDSPI_PcsActiveLow;
   \   00000024   0x7741             STRB     R1,[R0, #+29]
    217          
    218              masterConfig->enableContinuousSCK = false;
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x7781             STRB     R1,[R0, #+30]
    219              masterConfig->enableRxFifoOverWrite = false;
   \   0000002A   0x77C1             STRB     R1,[R0, #+31]
    220              masterConfig->enableModifiedTimingFormat = false;
   \   0000002C   0xF880 0x1020      STRB     R1,[R0, #+32]
    221              masterConfig->samplePoint = kDSPI_SckToSin0Clock;
   \   00000030   0xF880 0x1021      STRB     R1,[R0, #+33]
    222          }
   \   00000034   0x4770             BX       LR               ;; return
    223          

   \                                 In section .text, align 2, keep-with-next
    224          void DSPI_SlaveInit(SPI_Type *base, const dspi_slave_config_t *slaveConfig)
    225          {
   \                     DSPI_SlaveInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    226              uint32_t temp = 0;
    227          
    228              /* enable DSPI clock */
    229              CLOCK_EnableClock(s_dspiClock[DSPI_GetInstance(base)]);
   \   00000006   0x.... 0x....      BL       DSPI_GetInstance
   \   0000000A   0x.... 0x....      BL       ?Subroutine4
    230          
    231              DSPI_Enable(base, true);
   \                     ??CrossCallReturnLabel_6: (+1)
   \   0000000E   0x.... 0x....      BL       ?Subroutine8
    232              DSPI_StopTransfer(base);
   \                     ??CrossCallReturnLabel_22: (+1)
   \   00000012   0x.... 0x....      BL       ?Subroutine3
    233          
    234              DSPI_SetMasterSlaveMode(base, kDSPI_Slave);
    235          
    236              temp = base->MCR & (~(SPI_MCR_CONT_SCKE_MASK | SPI_MCR_MTFE_MASK | SPI_MCR_ROOE_MASK | SPI_MCR_SMPL_PT_MASK |
    237                                    SPI_MCR_DIS_TXF_MASK | SPI_MCR_DIS_RXF_MASK));
    238          
    239              base->MCR = temp | SPI_MCR_CONT_SCKE(slaveConfig->enableContinuousSCK) |
    240                          SPI_MCR_MTFE(slaveConfig->enableModifiedTimingFormat) |
    241                          SPI_MCR_ROOE(slaveConfig->enableRxFifoOverWrite) | SPI_MCR_SMPL_PT(slaveConfig->samplePoint) |
    242                          SPI_MCR_DIS_TXF(false) | SPI_MCR_DIS_RXF(false);
    243          
    244              DSPI_SetOnePcsPolarity(base, kDSPI_Pcs0, kDSPI_PcsActiveLow);
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   0000001E   0x6020             STR      R0,[R4, #+0]
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x4008             ANDS     R0,R1,R0
   \   00000024   0x7B29             LDRB     R1,[R5, #+12]
   \   00000026   0xEA40 0x7081      ORR      R0,R0,R1, LSL #+30
   \   0000002A   0x7BA9             LDRB     R1,[R5, #+14]
   \   0000002C   0xEA40 0x6081      ORR      R0,R0,R1, LSL #+26
   \   00000030   0x7B69             LDRB     R1,[R5, #+13]
   \   00000032   0xEA40 0x6001      ORR      R0,R0,R1, LSL #+24
   \   00000036   0x7BE9             LDRB     R1,[R5, #+15]
   \   00000038   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_25: (+1)
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       DSPI_SetOnePcsPolarity
   \   00000044   0x7828             LDRB     R0,[R5, #+0]
   \   00000046   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   0000004A   0x68C1             LDR      R1,[R0, #+12]
    245          
    246              temp = base->CTAR[slaveConfig->whichCtar] &
    247                     ~(SPI_CTAR_FMSZ_MASK | SPI_CTAR_CPOL_MASK | SPI_CTAR_CPHA_MASK | SPI_CTAR_LSBFE_MASK);
    248          
    249              base->CTAR[slaveConfig->whichCtar] = temp | SPI_CTAR_SLAVE_FMSZ(slaveConfig->ctarConfig.bitsPerFrame - 1) |
    250                                                   SPI_CTAR_SLAVE_CPOL(slaveConfig->ctarConfig.cpol) |
    251                                                   SPI_CTAR_SLAVE_CPHA(slaveConfig->ctarConfig.cpha);
   \   0000004C   0x686A             LDR      R2,[R5, #+4]
   \   0000004E   0xF021 0x41FE      BIC      R1,R1,#0x7F000000
   \   00000052   0x1E52             SUBS     R2,R2,#+1
   \   00000054   0xEA41 0x61C2      ORR      R1,R1,R2, LSL #+27
   \   00000058   0x7A2A             LDRB     R2,[R5, #+8]
   \   0000005A   0x0692             LSLS     R2,R2,#+26
   \   0000005C   0xF002 0x6280      AND      R2,R2,#0x4000000
   \   00000060   0x4311             ORRS     R1,R2,R1
   \   00000062   0x7A6A             LDRB     R2,[R5, #+9]
   \   00000064   0x0652             LSLS     R2,R2,#+25
   \   00000066   0xF002 0x7200      AND      R2,R2,#0x2000000
   \   0000006A   0x4311             ORRS     R1,R2,R1
   \   0000006C   0x60C1             STR      R1,[R0, #+12]
    252          
    253              DSPI_StartTransfer(base);
   \   0000006E   0x.... 0x....      BL       ?Subroutine6
    254          }
   \                     ??CrossCallReturnLabel_14: (+1)
   \   00000072   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    255          

   \                                 In section .text, align 2, keep-with-next
    256          void DSPI_SlaveGetDefaultConfig(dspi_slave_config_t *slaveConfig)
    257          {
    258              slaveConfig->whichCtar = kDSPI_Ctar0;
   \                     DSPI_SlaveGetDefaultConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7001             STRB     R1,[R0, #+0]
    259              slaveConfig->ctarConfig.bitsPerFrame = 8;
   \   00000004   0x2108             MOVS     R1,#+8
   \   00000006   0x6041             STR      R1,[R0, #+4]
    260              slaveConfig->ctarConfig.cpol = kDSPI_ClockPolarityActiveHigh;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7201             STRB     R1,[R0, #+8]
    261              slaveConfig->ctarConfig.cpha = kDSPI_ClockPhaseFirstEdge;
   \   0000000C   0x7241             STRB     R1,[R0, #+9]
    262          
    263              slaveConfig->enableContinuousSCK = false;
   \   0000000E   0x7301             STRB     R1,[R0, #+12]
    264              slaveConfig->enableRxFifoOverWrite = false;
   \   00000010   0x7341             STRB     R1,[R0, #+13]
    265              slaveConfig->enableModifiedTimingFormat = false;
   \   00000012   0x7381             STRB     R1,[R0, #+14]
    266              slaveConfig->samplePoint = kDSPI_SckToSin0Clock;
   \   00000014   0x73C1             STRB     R1,[R0, #+15]
    267          }
   \   00000016   0x4770             BX       LR               ;; return
    268          

   \                                 In section .text, align 2, keep-with-next
    269          void DSPI_Deinit(SPI_Type *base)
    270          {
   \                     DSPI_Deinit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    271              DSPI_StopTransfer(base);
    272              DSPI_Enable(base, false);
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       ??Subroutine3_0
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000000C   0x.... 0x....      BL       ??Subroutine8_0
    273          
    274              /* disable DSPI clock */
    275              CLOCK_DisableClock(s_dspiClock[DSPI_GetInstance(base)]);
   \                     ??CrossCallReturnLabel_21: (+1)
   \   00000010   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000014   0x.... 0x....      ADR.W    R1,s_dspiClock
   \   00000018   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   0000001C   0x0C01             LSRS     R1,R0,#+16
   \   0000001E   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000022   0xF501 0x218E      ADD      R1,R1,#+290816
   \   00000026   0x2301             MOVS     R3,#+1
   \   00000028   0x680A             LDR      R2,[R1, #+0]
   \   0000002A   0xFA03 0xF000      LSL      R0,R3,R0
   \   0000002E   0xEA22 0x0000      BIC      R0,R2,R0
   \   00000032   0x6008             STR      R0,[R1, #+0]
    276          }
   \   00000034   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x4620             MOV      R0,R4
   \   00000002   0x....             B.N      DSPI_GetInstance
    277          

   \                                 In section .text, align 2, keep-with-next
    278          static void DSPI_SetOnePcsPolarity(SPI_Type *base, dspi_which_pcs_t pcs, dspi_pcs_polarity_config_t activeLowOrHigh)
    279          {
    280              uint32_t temp;
    281          
    282              temp = base->MCR;
   \                     DSPI_SetOnePcsPolarity: (+1)
   \   00000000   0x6803             LDR      R3,[R0, #+0]
    283          
    284              if (activeLowOrHigh == kDSPI_PcsActiveLow)
   \   00000002   0x0409             LSLS     R1,R1,#+16
   \   00000004   0xF401 0x117C      AND      R1,R1,#0x3F0000
   \   00000008   0x2A01             CMP      R2,#+1
   \   0000000A   0xBF0C             ITE      EQ 
   \   0000000C   0x4319             ORREQ    R1,R1,R3
   \   0000000E   0xEA23 0x0101      BICNE    R1,R3,R1
    285              {
    286                  temp |= SPI_MCR_PCSIS(pcs);
    287              }
    288              else
    289              {
    290                  temp &= ~SPI_MCR_PCSIS(pcs);
    291              }
    292          
    293              base->MCR = temp;
   \   00000012   0x6001             STR      R1,[R0, #+0]
    294          }
   \   00000014   0x4770             BX       LR               ;; return
    295          

   \                                 In section .text, align 2, keep-with-next
    296          uint32_t DSPI_MasterSetBaudRate(SPI_Type *base,
    297                                          dspi_ctar_selection_t whichCtar,
    298                                          uint32_t baudRate_Bps,
    299                                          uint32_t srcClock_Hz)
    300          {
   \                     DSPI_MasterSetBaudRate: (+1)
   \   00000000   0xE92D 0x4FFB      PUSH     {R0,R1,R3-R11,LR}
    301              /* for master mode configuration, if slave mode detected, return 0*/
    302              if (!DSPI_IsMaster(base))
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0FC0             LSRS     R0,R0,#+31
   \   00000008   0xD047             BEQ.N    ??DSPI_MasterSetBaudRate_0
    303              {
    304                  return 0;
    305              }
    306              uint32_t temp;
    307              uint32_t prescaler, bestPrescaler;
    308              uint32_t scaler, bestScaler;
    309              uint32_t dbr, bestDbr;
    310              uint32_t realBaudrate, bestBaudrate;
    311              uint32_t diff, min_diff;
    312              uint32_t baudrate = baudRate_Bps;
    313          
    314              /* find combination of prescaler and scaler resulting in baudrate closest to the requested value */
    315              min_diff = 0xFFFFFFFFU;
   \   0000000A   0xF04F 0x35FF      MOV      R5,#-1
    316              bestPrescaler = 0;
   \   0000000E   0x2100             MOVS     R1,#+0
    317              bestScaler = 0;
   \   00000010   0x2300             MOVS     R3,#+0
    318              bestDbr = 1;
   \   00000012   0x2401             MOVS     R4,#+1
    319              bestBaudrate = 0; /* required to avoid compilation warning */
   \   00000014   0x2000             MOVS     R0,#+0
    320          
    321              /* In all for loops, if min_diff = 0, the exit for loop*/
    322              for (prescaler = 0; (prescaler < 4) && min_diff; prescaler++)
   \   00000016   0x2600             MOVS     R6,#+0
   \   00000018   0x.... 0x....      ADR.W    R8,s_baudrateScaler
   \   0000001C   0x.... 0x....      ADR.W    R12,s_baudratePrescaler
    323              {
    324                  for (scaler = 0; (scaler < 16) && min_diff; scaler++)
   \                     ??DSPI_MasterSetBaudRate_1: (+1)
   \   00000020   0xF04F 0x0E00      MOV      LR,#+0
    325                  {
    326                      for (dbr = 1; (dbr < 3) && min_diff; dbr++)
   \                     ??DSPI_MasterSetBaudRate_2: (+1)
   \   00000024   0x2701             MOVS     R7,#+1
    327                      {
    328                          realBaudrate = ((srcClock_Hz * dbr) / (s_baudratePrescaler[prescaler] * (s_baudrateScaler[scaler])));
   \                     ??DSPI_MasterSetBaudRate_3: (+1)
   \   00000026   0xF8DD 0x9008      LDR      R9,[SP, #+8]
   \   0000002A   0xF85C 0xA026      LDR      R10,[R12, R6, LSL #+2]
   \   0000002E   0xF858 0xB02E      LDR      R11,[R8, LR, LSL #+2]
   \   00000032   0xFB07 0xF909      MUL      R9,R7,R9
   \   00000036   0xFB0B 0xFA0A      MUL      R10,R11,R10
   \   0000003A   0xFBB9 0xF9FA      UDIV     R9,R9,R10
    329          
    330                          /* calculate the baud rate difference based on the conditional statement that states that the calculated
    331                          * baud rate must not exceed the desired baud rate.
    332                          */
    333                          if (baudrate >= realBaudrate)
   \   0000003E   0x454A             CMP      R2,R9
   \   00000040   0xD308             BCC.N    ??DSPI_MasterSetBaudRate_4
    334                          {
    335                              diff = baudrate - realBaudrate;
   \   00000042   0xEBA2 0x0A09      SUB      R10,R2,R9
    336                              if (min_diff > diff)
   \   00000046   0x45AA             CMP      R10,R5
   \   00000048   0xD204             BCS.N    ??DSPI_MasterSetBaudRate_4
    337                              {
    338                                  /* a better match found */
    339                                  min_diff = diff;
   \   0000004A   0x4655             MOV      R5,R10
    340                                  bestPrescaler = prescaler;
   \   0000004C   0x4631             MOV      R1,R6
    341                                  bestScaler = scaler;
   \   0000004E   0x4673             MOV      R3,LR
    342                                  bestBaudrate = realBaudrate;
   \   00000050   0x4648             MOV      R0,R9
    343                                  bestDbr = dbr;
   \   00000052   0x463C             MOV      R4,R7
    344                              }
    345                          }
    346                      }
   \                     ??DSPI_MasterSetBaudRate_4: (+1)
   \   00000054   0x1C7F             ADDS     R7,R7,#+1
   \   00000056   0x2F03             CMP      R7,#+3
   \   00000058   0xD202             BCS.N    ??DSPI_MasterSetBaudRate_5
   \   0000005A   0x2D00             CMP      R5,#+0
   \   0000005C   0xD1E3             BNE.N    ??DSPI_MasterSetBaudRate_3
   \   0000005E   0xE00C             B.N      ??DSPI_MasterSetBaudRate_6
    347                  }
   \                     ??DSPI_MasterSetBaudRate_5: (+1)
   \   00000060   0xF10E 0x0E01      ADD      LR,LR,#+1
   \   00000064   0xF1BE 0x0F10      CMP      LR,#+16
   \   00000068   0xD202             BCS.N    ??DSPI_MasterSetBaudRate_7
   \   0000006A   0x2D00             CMP      R5,#+0
   \   0000006C   0xD1DA             BNE.N    ??DSPI_MasterSetBaudRate_2
   \   0000006E   0xE004             B.N      ??DSPI_MasterSetBaudRate_6
    348              }
   \                     ??DSPI_MasterSetBaudRate_7: (+1)
   \   00000070   0x1C76             ADDS     R6,R6,#+1
   \   00000072   0x2E04             CMP      R6,#+4
   \   00000074   0xD201             BCS.N    ??DSPI_MasterSetBaudRate_6
   \   00000076   0x2D00             CMP      R5,#+0
   \   00000078   0xD1D2             BNE.N    ??DSPI_MasterSetBaudRate_1
   \                     ??DSPI_MasterSetBaudRate_6: (+1)
   \   0000007A   0x9A00             LDR      R2,[SP, #+0]
   \   0000007C   0xF89D 0x5004      LDRB     R5,[SP, #+4]
   \   00000080   0x.... 0x....      LDR.W    R6,??DataTable25_2  ;; 0x7ffcfff0
   \   00000084   0xEB02 0x0285      ADD      R2,R2,R5, LSL #+2
   \   00000088   0x1E64             SUBS     R4,R4,#+1
   \   0000008A   0x68D5             LDR      R5,[R2, #+12]
   \   0000008C   0x4035             ANDS     R5,R6,R5
   \   0000008E   0xEA45 0x74C4      ORR      R4,R5,R4, LSL #+31
   \   00000092   0xEA44 0x4101      ORR      R1,R4,R1, LSL #+16
   \   00000096   0x4319             ORRS     R1,R3,R1
   \   00000098   0x60D1             STR      R1,[R2, #+12]
    349          
    350              /* write the best dbr, prescalar, and baud rate scalar to the CTAR */
    351              temp = base->CTAR[whichCtar] & ~(SPI_CTAR_DBR_MASK | SPI_CTAR_PBR_MASK | SPI_CTAR_BR_MASK);
    352          
    353              base->CTAR[whichCtar] = temp | ((bestDbr - 1) << SPI_CTAR_DBR_SHIFT) | (bestPrescaler << SPI_CTAR_PBR_SHIFT) |
    354                                      (bestScaler << SPI_CTAR_BR_SHIFT);
    355          
    356              /* return the actual calculated baud rate */
    357              return bestBaudrate;
   \                     ??DSPI_MasterSetBaudRate_0: (+1)
   \   0000009A   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    358          }
    359          

   \                                 In section .text, align 2, keep-with-next
    360          void DSPI_MasterSetDelayScaler(
    361              SPI_Type *base, dspi_ctar_selection_t whichCtar, uint32_t prescaler, uint32_t scaler, dspi_delay_type_t whichDelay)
    362          {
   \                     DSPI_MasterSetDelayScaler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    363              /* these settings are only relevant in master mode */
    364              if (DSPI_IsMaster(base))
   \   00000002   0x6804             LDR      R4,[R0, #+0]
   \   00000004   0x0FE4             LSRS     R4,R4,#+31
   \   00000006   0xD02E             BEQ.N    ??DSPI_MasterSetDelayScaler_0
   \   00000008   0xEB00 0x0181      ADD      R1,R0,R1, LSL #+2
   \   0000000C   0x9802             LDR      R0,[SP, #+8]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD004             BEQ.N    ??DSPI_MasterSetDelayScaler_1
   \   00000012   0xD328             BCC.N    ??DSPI_MasterSetDelayScaler_0
   \   00000014   0x2803             CMP      R0,#+3
   \   00000016   0xD019             BEQ.N    ??DSPI_MasterSetDelayScaler_2
   \   00000018   0xD30C             BCC.N    ??DSPI_MasterSetDelayScaler_3
   \   0000001A   0xBD10             POP      {R4,PC}
    365              {
    366                  switch (whichDelay)
    367                  {
    368                      case kDSPI_PcsToSck:
    369                          base->CTAR[whichCtar] = (base->CTAR[whichCtar] & (~SPI_CTAR_PCSSCK_MASK) & (~SPI_CTAR_CSSCK_MASK)) |
    370                                                  SPI_CTAR_PCSSCK(prescaler) | SPI_CTAR_CSSCK(scaler);
   \                     ??DSPI_MasterSetDelayScaler_1: (+1)
   \   0000001C   0x68C8             LDR      R0,[R1, #+12]
   \   0000001E   0x.... 0x....      LDR.W    R4,??DataTable25_3  ;; 0xff3f0fff
   \   00000022   0x0592             LSLS     R2,R2,#+22
   \   00000024   0x4020             ANDS     R0,R4,R0
   \   00000026   0xF402 0x0240      AND      R2,R2,#0xC00000
   \   0000002A   0x4310             ORRS     R0,R2,R0
   \   0000002C   0x031A             LSLS     R2,R3,#+12
   \   0000002E   0xF402 0x4270      AND      R2,R2,#0xF000
   \   00000032   0xE016             B.N      ??DSPI_MasterSetDelayScaler_4
    371                          break;
    372                      case kDSPI_LastSckToPcs:
    373                          base->CTAR[whichCtar] = (base->CTAR[whichCtar] & (~SPI_CTAR_PASC_MASK) & (~SPI_CTAR_ASC_MASK)) |
    374                                                  SPI_CTAR_PASC(prescaler) | SPI_CTAR_ASC(scaler);
   \                     ??DSPI_MasterSetDelayScaler_3: (+1)
   \   00000034   0x68C8             LDR      R0,[R1, #+12]
   \   00000036   0x.... 0x....      LDR.W    R4,??DataTable25_4  ;; 0xffcff0ff
   \   0000003A   0x0512             LSLS     R2,R2,#+20
   \   0000003C   0x4020             ANDS     R0,R4,R0
   \   0000003E   0xF402 0x1240      AND      R2,R2,#0x300000
   \   00000042   0x4310             ORRS     R0,R2,R0
   \   00000044   0x021A             LSLS     R2,R3,#+8
   \   00000046   0xF402 0x6270      AND      R2,R2,#0xF00
   \   0000004A   0xE00A             B.N      ??DSPI_MasterSetDelayScaler_4
    375                          break;
    376                      case kDSPI_BetweenTransfer:
    377                          base->CTAR[whichCtar] = (base->CTAR[whichCtar] & (~SPI_CTAR_PDT_MASK) & (~SPI_CTAR_DT_MASK)) |
    378                                                  SPI_CTAR_PDT(prescaler) | SPI_CTAR_DT(scaler);
   \                     ??DSPI_MasterSetDelayScaler_2: (+1)
   \   0000004C   0x68C8             LDR      R0,[R1, #+12]
   \   0000004E   0x.... 0x....      LDR.W    R4,??DataTable25_5  ;; 0xfff3ff0f
   \   00000052   0x0492             LSLS     R2,R2,#+18
   \   00000054   0x4020             ANDS     R0,R4,R0
   \   00000056   0xF402 0x2240      AND      R2,R2,#0xC0000
   \   0000005A   0x4310             ORRS     R0,R2,R0
   \   0000005C   0x011A             LSLS     R2,R3,#+4
   \   0000005E   0xF002 0x02F0      AND      R2,R2,#0xF0
   \                     ??DSPI_MasterSetDelayScaler_4: (+1)
   \   00000062   0x4310             ORRS     R0,R2,R0
   \   00000064   0x60C8             STR      R0,[R1, #+12]
    379                          break;
    380                      default:
    381                          break;
    382                  }
    383              }
    384          }
   \                     ??DSPI_MasterSetDelayScaler_0: (+1)
   \   00000066   0xBD10             POP      {R4,PC}          ;; return
    385          

   \                                 In section .text, align 2, keep-with-next
    386          uint32_t DSPI_MasterSetDelayTimes(SPI_Type *base,
    387                                            dspi_ctar_selection_t whichCtar,
    388                                            dspi_delay_type_t whichDelay,
    389                                            uint32_t srcClock_Hz,
    390                                            uint32_t delayTimeInNanoSec)
    391          {
   \                     DSPI_MasterSetDelayTimes: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
    392              /* for master mode configuration, if slave mode detected, return 0 */
    393              if (!DSPI_IsMaster(base))
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x0FC9             LSRS     R1,R1,#+31
   \   0000000A   0xBF08             IT       EQ 
   \   0000000C   0x2000             MOVEQ    R0,#+0
    394              {
    395                  return 0;
   \   0000000E   0xD04A             BEQ.N    ??DSPI_MasterSetDelayTimes_0
    396              }
    397          
    398              uint32_t prescaler, bestPrescaler;
    399              uint32_t scaler, bestScaler;
    400              uint32_t realDelay, bestDelay;
    401              uint32_t diff, min_diff;
    402              uint32_t initialDelayNanoSec;
    403          
    404              /* find combination of prescaler and scaler resulting in the delay closest to the
    405              * requested value
    406              */
    407              min_diff = 0xFFFFFFFFU;
    408              /* Initialize prescaler and scaler to their max values to generate the max delay */
    409              bestPrescaler = 0x3;
    410              bestScaler = 0xF;
    411              bestDelay = (((1000000000U * 4) / srcClock_Hz) * s_delayPrescaler[bestPrescaler] * s_delayScaler[bestScaler]) / 4;
   \   00000010   0x.... 0x....      LDR.W    R5,??DataTable25_6  ;; 0xee6b2800
    412          
    413              /* First calculate the initial, default delay */
    414              initialDelayNanoSec = 1000000000U / srcClock_Hz * 2;
   \   00000014   0x.... 0x....      LDR.W    R6,??DataTable25_7  ;; 0x3b9aca00
   \   00000018   0xFBB5 0xFCF3      UDIV     R12,R5,R3
   \   0000001C   0xFBB6 0xF3F3      UDIV     R3,R6,R3
   \   00000020   0xEBCC 0x05CC      RSB      R5,R12,R12, LSL #+3
   \   00000024   0x005E             LSLS     R6,R3,#+1
   \   00000026   0x042D             LSLS     R5,R5,#+16
   \   00000028   0x9B0C             LDR      R3,[SP, #+48]
   \   0000002A   0x2103             MOVS     R1,#+3
   \   0000002C   0x08AD             LSRS     R5,R5,#+2
    415          
    416              /* If the initial, default delay is already greater than the desired delay, then
    417              * set the delays to their initial value (0) and return the delay. In other words,
    418              * there is no way to decrease the delay value further.
    419              */
    420              if (initialDelayNanoSec >= delayTimeInNanoSec)
   \   0000002E   0x429E             CMP      R6,R3
   \   00000030   0xF04F 0x37FF      MOV      R7,#-1
   \   00000034   0xF04F 0x090F      MOV      R9,#+15
   \   00000038   0xD308             BCC.N    ??DSPI_MasterSetDelayTimes_1
    421              {
    422                  DSPI_MasterSetDelayScaler(base, whichCtar, 0, 0, whichDelay);
   \   0000003A   0x9200             STR      R2,[SP, #+0]
   \   0000003C   0x2300             MOVS     R3,#+0
   \   0000003E   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \   00000042   0x2200             MOVS     R2,#+0
   \   00000044   0x.... 0x....      BL       DSPI_MasterSetDelayScaler
    423                  return initialDelayNanoSec;
   \   00000048   0x4630             MOV      R0,R6
   \   0000004A   0xE02C             B.N      ??DSPI_MasterSetDelayTimes_0
    424              }
    425          
    426              /* In all for loops, if min_diff = 0, the exit for loop */
    427              for (prescaler = 0; (prescaler < 4) && min_diff; prescaler++)
   \                     ??DSPI_MasterSetDelayTimes_1: (+1)
   \   0000004C   0x2600             MOVS     R6,#+0
   \   0000004E   0x.... 0x....      ADR.W    LR,s_delayScaler
   \   00000052   0x.... 0x....      ADR.W    R8,s_delayPrescaler
    428              {
    429                  for (scaler = 0; (scaler < 16) && min_diff; scaler++)
   \                     ??DSPI_MasterSetDelayTimes_2: (+1)
   \   00000056   0x2400             MOVS     R4,#+0
    430                  {
    431                      realDelay = ((4000000000U / srcClock_Hz) * s_delayPrescaler[prescaler] * s_delayScaler[scaler]) / 4;
   \                     ??DSPI_MasterSetDelayTimes_3: (+1)
   \   00000058   0xF858 0xA026      LDR      R10,[R8, R6, LSL #+2]
   \   0000005C   0xF85E 0xB024      LDR      R11,[LR, R4, LSL #+2]
   \   00000060   0xFB0A 0xFA0C      MUL      R10,R10,R12
   \   00000064   0xFB0B 0xFA0A      MUL      R10,R11,R10
   \   00000068   0xEA4F 0x0A9A      LSR      R10,R10,#+2
    432          
    433                      /* calculate the delay difference based on the conditional statement
    434                      * that states that the calculated delay must not be less then the desired delay
    435                      */
    436                      if (realDelay >= delayTimeInNanoSec)
   \   0000006C   0x459A             CMP      R10,R3
   \   0000006E   0xD307             BCC.N    ??DSPI_MasterSetDelayTimes_4
    437                      {
    438                          diff = realDelay - delayTimeInNanoSec;
   \   00000070   0xEBAA 0x0B03      SUB      R11,R10,R3
    439                          if (min_diff > diff)
   \   00000074   0x45BB             CMP      R11,R7
   \   00000076   0xD203             BCS.N    ??DSPI_MasterSetDelayTimes_4
    440                          {
    441                              /* a better match found */
    442                              min_diff = diff;
   \   00000078   0x465F             MOV      R7,R11
    443                              bestPrescaler = prescaler;
   \   0000007A   0x4631             MOV      R1,R6
    444                              bestScaler = scaler;
   \   0000007C   0x46A1             MOV      R9,R4
    445                              bestDelay = realDelay;
   \   0000007E   0x4655             MOV      R5,R10
    446                          }
    447                      }
    448                  }
   \                     ??DSPI_MasterSetDelayTimes_4: (+1)
   \   00000080   0x1C64             ADDS     R4,R4,#+1
   \   00000082   0x2C10             CMP      R4,#+16
   \   00000084   0xD202             BCS.N    ??DSPI_MasterSetDelayTimes_5
   \   00000086   0x2F00             CMP      R7,#+0
   \   00000088   0xD1E6             BNE.N    ??DSPI_MasterSetDelayTimes_3
   \   0000008A   0xE004             B.N      ??DSPI_MasterSetDelayTimes_6
    449              }
   \                     ??DSPI_MasterSetDelayTimes_5: (+1)
   \   0000008C   0x1C76             ADDS     R6,R6,#+1
   \   0000008E   0x2E04             CMP      R6,#+4
   \   00000090   0xD201             BCS.N    ??DSPI_MasterSetDelayTimes_6
   \   00000092   0x2F00             CMP      R7,#+0
   \   00000094   0xD1DF             BNE.N    ??DSPI_MasterSetDelayTimes_2
    450          
    451              /* write the best dbr, prescalar, and baud rate scalar to the CTAR */
    452              DSPI_MasterSetDelayScaler(base, whichCtar, bestPrescaler, bestScaler, whichDelay);
   \                     ??DSPI_MasterSetDelayTimes_6: (+1)
   \   00000096   0x9200             STR      R2,[SP, #+0]
   \   00000098   0x464B             MOV      R3,R9
   \   0000009A   0x460A             MOV      R2,R1
   \   0000009C   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \   000000A0   0x.... 0x....      BL       DSPI_MasterSetDelayScaler
    453          
    454              /* return the actual calculated baud rate */
    455              return bestDelay;
   \   000000A4   0x4628             MOV      R0,R5
   \                     ??DSPI_MasterSetDelayTimes_0: (+1)
   \   000000A6   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    456          }
    457          

   \                                 In section .text, align 2, keep-with-next
    458          void DSPI_GetDefaultDataCommandConfig(dspi_command_data_config_t *command)
    459          {
    460              command->isPcsContinuous = false;
   \                     DSPI_GetDefaultDataCommandConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7001             STRB     R1,[R0, #+0]
    461              command->whichCtar = kDSPI_Ctar0;
   \   00000004   0x7041             STRB     R1,[R0, #+1]
    462              command->whichPcs = kDSPI_Pcs0;
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x7081             STRB     R1,[R0, #+2]
    463              command->isEndOfQueue = false;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x70C1             STRB     R1,[R0, #+3]
    464              command->clearTransferCount = false;
   \   0000000E   0x7101             STRB     R1,[R0, #+4]
    465          }
   \   00000010   0x4770             BX       LR               ;; return
    466          

   \                                 In section .text, align 2, keep-with-next
    467          void DSPI_MasterWriteDataBlocking(SPI_Type *base, dspi_command_data_config_t *command, uint16_t data)
    468          {
   \                     DSPI_MasterWriteDataBlocking: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    469              /* First, clear Transmit Complete Flag (TCF) */
    470              DSPI_ClearStatusFlags(base, kDSPI_TxCompleteFlag);
   \   00000002   0xF04F 0x4300      MOV      R3,#-2147483648
   \   00000006   0x62C3             STR      R3,[R0, #+44]
   \   00000008   0xF04F 0x7300      MOV      R3,#+33554432
   \   0000000C   0xE000             B.N      ??DSPI_MasterWriteDataBlocking_0
    471          
    472              while (!(DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag))
    473              {
    474                  DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \                     ??DSPI_MasterWriteDataBlocking_1: (+1)
   \   0000000E   0x62C3             STR      R3,[R0, #+44]
    475              }
   \                     ??DSPI_MasterWriteDataBlocking_0: (+1)
   \   00000010   0x6AC4             LDR      R4,[R0, #+44]
   \   00000012   0x01A4             LSLS     R4,R4,#+6
   \   00000014   0xD5FB             BPL.N    ??DSPI_MasterWriteDataBlocking_1
    476          
    477              base->PUSHR = SPI_PUSHR_CONT(command->isPcsContinuous) | SPI_PUSHR_CTAS(command->whichCtar) |
    478                            SPI_PUSHR_PCS(command->whichPcs) | SPI_PUSHR_EOQ(command->isEndOfQueue) |
    479                            SPI_PUSHR_CTCNT(command->clearTransferCount) | SPI_PUSHR_TXDATA(data);
   \   00000016   0x784D             LDRB     R5,[R1, #+1]
   \   00000018   0x780C             LDRB     R4,[R1, #+0]
   \   0000001A   0x072D             LSLS     R5,R5,#+28
   \   0000001C   0xF005 0x45E0      AND      R5,R5,#0x70000000
   \   00000020   0xEA45 0x74C4      ORR      R4,R5,R4, LSL #+31
   \   00000024   0x788D             LDRB     R5,[R1, #+2]
   \   00000026   0x042D             LSLS     R5,R5,#+16
   \   00000028   0xF405 0x157C      AND      R5,R5,#0x3F0000
   \   0000002C   0x432C             ORRS     R4,R5,R4
   \   0000002E   0x78CD             LDRB     R5,[R1, #+3]
   \   00000030   0x7909             LDRB     R1,[R1, #+4]
   \   00000032   0xEA44 0x64C5      ORR      R4,R4,R5, LSL #+27
   \   00000036   0xEA44 0x6181      ORR      R1,R4,R1, LSL #+26
   \   0000003A   0x4311             ORRS     R1,R2,R1
   \   0000003C   0x6341             STR      R1,[R0, #+52]
    480              DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \   0000003E   0x62C3             STR      R3,[R0, #+44]
    481          
    482              /* Wait till TCF sets */
    483              while (!(DSPI_GetStatusFlags(base) & kDSPI_TxCompleteFlag))
   \                     ??DSPI_MasterWriteDataBlocking_2: (+1)
   \   00000040   0x6AC1             LDR      R1,[R0, #+44]
   \   00000042   0x2900             CMP      R1,#+0
   \   00000044   0xD5FC             BPL.N    ??DSPI_MasterWriteDataBlocking_2
    484              {
    485              }
    486          }
   \   00000046   0xBD30             POP      {R4,R5,PC}       ;; return
    487          

   \                                 In section .text, align 2, keep-with-next
    488          void DSPI_MasterWriteCommandDataBlocking(SPI_Type *base, uint32_t data)
    489          {
    490              /* First, clear Transmit Complete Flag (TCF) */
    491              DSPI_ClearStatusFlags(base, kDSPI_TxCompleteFlag);
   \                     DSPI_MasterWriteCommandDataBlocking: (+1)
   \   00000000   0x....             B.N      ?Subroutine0
    492          
    493              while (!(DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag))
    494              {
    495                  DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
    496              }
    497          
    498              base->PUSHR = data;
    499          
    500              DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
    501          
    502              /* Wait till TCF sets */
    503              while (!(DSPI_GetStatusFlags(base) & kDSPI_TxCompleteFlag))
    504              {
    505              }
    506          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xF04F 0x4200      MOV      R2,#-2147483648
   \   00000004   0x62C2             STR      R2,[R0, #+44]
   \   00000006   0xF04F 0x7200      MOV      R2,#+33554432
   \   0000000A   0xE000             B.N      ??Subroutine0_0
   \                     ??Subroutine0_1: (+1)
   \   0000000C   0x62C2             STR      R2,[R0, #+44]
   \                     ??Subroutine0_0: (+1)
   \   0000000E   0x6AC3             LDR      R3,[R0, #+44]
   \   00000010   0x019B             LSLS     R3,R3,#+6
   \   00000012   0xD5FB             BPL.N    ??Subroutine0_1
   \   00000014   0x6341             STR      R1,[R0, #+52]
   \   00000016   0x62C2             STR      R2,[R0, #+44]
   \                     ??Subroutine0_2: (+1)
   \   00000018   0x6AC1             LDR      R1,[R0, #+44]
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD5FC             BPL.N    ??Subroutine0_2
   \   0000001E   0x4770             BX       LR               ;; return
    507          

   \                                 In section .text, align 2, keep-with-next
    508          void DSPI_SlaveWriteDataBlocking(SPI_Type *base, uint32_t data)
   \                     DSPI_SlaveWriteDataBlocking: (+1)
   \   00000000   0xBF00             Nop      
    509          {
    510              /* First, clear Transmit Complete Flag (TCF) */
    511              DSPI_ClearStatusFlags(base, kDSPI_TxCompleteFlag);
   \   00000002                      REQUIRE ?Subroutine0
   \   00000002                      ;; // Fall through to label ?Subroutine0
    512          
    513              while (!(DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag))
    514              {
    515                  DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
    516              }
    517          
    518              base->PUSHR_SLAVE = data;
    519          
    520              DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
    521          
    522              /* Wait till TCF sets */
    523              while (!(DSPI_GetStatusFlags(base) & kDSPI_TxCompleteFlag))
    524              {
    525              }
    526          }
    527          

   \                                 In section .text, align 2, keep-with-next
    528          void DSPI_EnableInterrupts(SPI_Type *base, uint32_t mask)
    529          {
    530              if (mask & SPI_RSER_TFFF_RE_MASK)
   \                     DSPI_EnableInterrupts: (+1)
   \   00000000   0x018A             LSLS     R2,R1,#+6
   \   00000002   0xD503             BPL.N    ??DSPI_EnableInterrupts_0
    531              {
    532                  base->RSER &= ~SPI_RSER_TFFF_DIRS_MASK;
   \   00000004   0x6B02             LDR      R2,[R0, #+48]
   \   00000006   0xF022 0x7280      BIC      R2,R2,#0x1000000
   \   0000000A   0x6302             STR      R2,[R0, #+48]
    533              }
    534              if (mask & SPI_RSER_RFDF_RE_MASK)
   \                     ??DSPI_EnableInterrupts_0: (+1)
   \   0000000C   0x038A             LSLS     R2,R1,#+14
   \   0000000E   0xD503             BPL.N    ??DSPI_EnableInterrupts_1
    535              {
    536                  base->RSER &= ~SPI_RSER_RFDF_DIRS_MASK;
   \   00000010   0x6B02             LDR      R2,[R0, #+48]
   \   00000012   0xF422 0x3280      BIC      R2,R2,#0x10000
   \   00000016   0x6302             STR      R2,[R0, #+48]
    537              }
    538              base->RSER |= mask;
   \                     ??DSPI_EnableInterrupts_1: (+1)
   \   00000018   0x6B02             LDR      R2,[R0, #+48]
   \   0000001A   0x4311             ORRS     R1,R1,R2
   \   0000001C   0x6301             STR      R1,[R0, #+48]
    539          }
   \   0000001E   0x4770             BX       LR               ;; return
    540          
    541          /*Transactional APIs -- Master*/
    542          

   \                                 In section .text, align 2, keep-with-next
    543          void DSPI_MasterTransferCreateHandle(SPI_Type *base,
    544                                               dspi_master_handle_t *handle,
    545                                               dspi_master_transfer_callback_t callback,
    546                                               void *userData)
    547          {
   \                     DSPI_MasterTransferCreateHandle: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
    548              assert(handle);
    549          
    550              /* Zero the handle. */
    551              memset(handle, 0, sizeof(*handle));
   \   0000000A   0x2130             MOVS     R1,#+48
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0x.... 0x....      BL       __aeabi_memclr4
    552          
    553              g_dspiHandle[DSPI_GetInstance(base)] = handle;
   \   00000012   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_11: (+1)
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable25_8
   \   0000001A   0xF841 0x5020      STR      R5,[R1, R0, LSL #+2]
    554          
    555              handle->callback = callback;
   \   0000001E   0x62AE             STR      R6,[R5, #+40]
    556              handle->userData = userData;
   \   00000020   0x62EF             STR      R7,[R5, #+44]
    557          }
   \   00000022   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    558          

   \                                 In section .text, align 2, keep-with-next
    559          status_t DSPI_MasterTransferBlocking(SPI_Type *base, dspi_transfer_t *transfer)
    560          {
   \                     DSPI_MasterTransferBlocking: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0xB083             SUB      SP,SP,#+12
   \   00000008   0x4604             MOV      R4,R0
    561              assert(transfer);
    562          
    563              uint16_t wordToSend = 0;
    564              uint16_t wordReceived = 0;
    565              uint8_t dummyData = DSPI_MASTER_DUMMY_DATA;
    566              uint8_t bitsPerFrame;
    567          
    568              uint32_t command;
    569              uint32_t lastCommand;
    570          
    571              uint8_t *txData;
    572              uint8_t *rxData;
    573              uint32_t remainingSendByteCount;
    574              uint32_t remainingReceiveByteCount;
    575          
    576              uint32_t fifoSize;
    577              dspi_command_data_config_t commandStruct;
    578          
    579              /* If the transfer count is zero, then return immediately.*/
    580              if (transfer->dataSize == 0)
   \   0000000A   0x68A8             LDR      R0,[R5, #+8]
   \   0000000C   0xB908             CBNZ.N   R0,??DSPI_MasterTransferBlocking_0
    581              {
    582                  return kStatus_InvalidArgument;
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0xE101             B.N      ??DSPI_MasterTransferBlocking_1
    583              }
    584          
    585              DSPI_StopTransfer(base);
   \                     ??DSPI_MasterTransferBlocking_0: (+1)
   \   00000012   0x6820             LDR      R0,[R4, #+0]
    586              DSPI_DisableInterrupts(base, kDSPI_AllInterruptEnable);
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable25_9  ;; 0x65f5ffff
   \   00000018   0x.... 0x....      BL       ??Subroutine3_0
    587              DSPI_FlushFifo(base, true, true);
   \                     ??CrossCallReturnLabel_3: (+1)
   \   0000001C   0x2201             MOVS     R2,#+1
   \   0000001E   0x6B20             LDR      R0,[R4, #+48]
   \   00000020   0x4008             ANDS     R0,R1,R0
   \   00000022   0x6320             STR      R0,[R4, #+48]
   \   00000024   0x.... 0x....      BL       ?Subroutine12
    588              DSPI_ClearStatusFlags(base, kDSPI_AllStatusFlag);
   \                     ??CrossCallReturnLabel_32: (+1)
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable25_10  ;; 0xda0a0000
   \   0000002C   0x62E0             STR      R0,[R4, #+44]
    589          
    590              /*Calculate the command and lastCommand*/
    591              commandStruct.whichPcs =
    592                  (dspi_which_pcs_t)(1U << ((transfer->configFlags & DSPI_MASTER_PCS_MASK) >> DSPI_MASTER_PCS_SHIFT));
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x68E9             LDR      R1,[R5, #+12]
   \   00000032   0x.... 0x....      BL       ?Subroutine10
    593              commandStruct.isEndOfQueue = false;
    594              commandStruct.clearTransferCount = false;
    595              commandStruct.whichCtar =
    596                  (dspi_ctar_selection_t)((transfer->configFlags & DSPI_MASTER_CTAR_MASK) >> DSPI_MASTER_CTAR_SHIFT);
   \                     ??CrossCallReturnLabel_26: (+1)
   \   00000036   0x7B28             LDRB     R0,[R5, #+12]
   \   00000038   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000003C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    597              commandStruct.isPcsContinuous = (bool)(transfer->configFlags & kDSPI_MasterPcsContinuous);
   \   00000040   0x68E8             LDR      R0,[R5, #+12]
   \   00000042   0x.... 0x....      BL       ?Subroutine11
    598          
    599              command = DSPI_MasterGetFormattedCommand(&(commandStruct));
   \                     ??CrossCallReturnLabel_29: (+1)
   \   00000046   0x4680             MOV      R8,R0
    600          
    601              commandStruct.isPcsContinuous = (bool)(transfer->configFlags & kDSPI_MasterActiveAfterTransfer);
   \   00000048   0x68E8             LDR      R0,[R5, #+12]
   \   0000004A   0x.... 0x....      BL       ?Subroutine13
    602              lastCommand = DSPI_MasterGetFormattedCommand(&(commandStruct));
    603          
    604              /*Calculate the bitsPerFrame*/
    605              bitsPerFrame = ((base->CTAR[commandStruct.whichCtar] & SPI_CTAR_FMSZ_MASK) >> SPI_CTAR_FMSZ_SHIFT) + 1;
   \                     ??CrossCallReturnLabel_34: (+1)
   \   0000004E   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   00000052   0xEB04 0x0181      ADD      R1,R4,R1, LSL #+2
   \   00000056   0x68C9             LDR      R1,[R1, #+12]
    606          
    607              txData = transfer->txData;
    608              rxData = transfer->rxData;
   \   00000058   0x686A             LDR      R2,[R5, #+4]
   \   0000005A   0x0EC9             LSRS     R1,R1,#+27
   \   0000005C   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000060   0x1C4E             ADDS     R6,R1,#+1
   \   00000062   0x6829             LDR      R1,[R5, #+0]
    609              remainingSendByteCount = transfer->dataSize;
   \   00000064   0x68AB             LDR      R3,[R5, #+8]
    610              remainingReceiveByteCount = transfer->dataSize;
   \   00000066   0xF8D5 0xE008      LDR      LR,[R5, #+8]
    611          
    612              if ((base->MCR & SPI_MCR_DIS_RXF_MASK) || (base->MCR & SPI_MCR_DIS_TXF_MASK))
   \   0000006A   0x6825             LDR      R5,[R4, #+0]
   \   0000006C   0x04ED             LSLS     R5,R5,#+19
   \   0000006E   0xD40C             BMI.N    ??DSPI_MasterTransferBlocking_2
   \   00000070   0x6825             LDR      R5,[R4, #+0]
   \   00000072   0x04AD             LSLS     R5,R5,#+18
   \   00000074   0xD409             BMI.N    ??DSPI_MasterTransferBlocking_2
    613              {
    614                  fifoSize = 1;
    615              }
    616              else
    617              {
    618                  fifoSize = FSL_FEATURE_DSPI_FIFO_SIZEn(base);
   \   00000076   0x.... 0x....      LDR.W    R5,??DataTable25_11  ;; 0x4002c000
   \   0000007A   0x42AC             CMP      R4,R5
   \   0000007C   0xBF08             IT       EQ 
   \   0000007E   0x2504             MOVEQ    R5,#+4
   \   00000080   0xD007             BEQ.N    ??DSPI_MasterTransferBlocking_3
   \   00000082   0x.... 0x....      LDR.W    R5,??DataTable25_12  ;; 0x4002d000
   \   00000086   0x42AC             CMP      R4,R5
   \   00000088   0xD101             BNE.N    ??DSPI_MasterTransferBlocking_4
   \                     ??DSPI_MasterTransferBlocking_2: (+1)
   \   0000008A   0x2501             MOVS     R5,#+1
   \   0000008C   0xE001             B.N      ??DSPI_MasterTransferBlocking_3
   \                     ??DSPI_MasterTransferBlocking_4: (+1)
   \   0000008E   0xF04F 0x35FF      MOV      R5,#-1
    619              }
    620          
    621              DSPI_StartTransfer(base);
   \                     ??DSPI_MasterTransferBlocking_3: (+1)
   \   00000092   0x6827             LDR      R7,[R4, #+0]
   \   00000094   0x087F             LSRS     R7,R7,#+1
   \   00000096   0x007F             LSLS     R7,R7,#+1
   \   00000098   0x6027             STR      R7,[R4, #+0]
    622          
    623              if (bitsPerFrame <= 8)
   \   0000009A   0xB2F6             UXTB     R6,R6
   \   0000009C   0x2E09             CMP      R6,#+9
   \   0000009E   0xF04F 0x7700      MOV      R7,#+33554432
   \   000000A2   0xF44F 0x3C00      MOV      R12,#+131072
   \   000000A6   0xDA64             BGE.N    ??DSPI_MasterTransferBlocking_5
   \   000000A8   0xE003             B.N      ??DSPI_MasterTransferBlocking_6
    624              {
    625                  while (remainingSendByteCount > 0)
    626                  {
    627                      if (remainingSendByteCount == 1)
    628                      {
    629                          while ((remainingReceiveByteCount - remainingSendByteCount) >= fifoSize)
    630                          {
    631                              if (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
    632                              {
    633                                  if (rxData != NULL)
    634                                  {
    635                                      *(rxData) = DSPI_ReadData(base);
    636                                      rxData++;
    637                                  }
    638                                  else
    639                                  {
    640                                      DSPI_ReadData(base);
    641                                  }
    642                                  remainingReceiveByteCount--;
    643          
    644                                  DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
    645                              }
    646                          }
    647          
    648                          while (!(DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag))
    649                          {
    650                              DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
    651                          }
    652          
    653                          if (txData != NULL)
    654                          {
    655                              base->PUSHR = (*txData) | (lastCommand);
    656                              txData++;
    657                          }
    658                          else
    659                          {
    660                              base->PUSHR = (lastCommand) | (dummyData);
    661                          }
    662                          DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
    663                          remainingSendByteCount--;
    664          
    665                          while (remainingReceiveByteCount > 0)
    666                          {
    667                              if (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
    668                              {
    669                                  if (rxData != NULL)
    670                                  {
    671                                      /* Read data from POPR*/
    672                                      *(rxData) = DSPI_ReadData(base);
    673                                      rxData++;
    674                                  }
    675                                  else
    676                                  {
    677                                      DSPI_ReadData(base);
    678                                  }
    679                                  remainingReceiveByteCount--;
    680          
    681                                  DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
    682                              }
    683                          }
    684                      }
    685                      else
    686                      {
    687                          /*Wait until Tx Fifo is not full*/
    688                          while (!(DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag))
    689                          {
    690                              DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
    691                          }
    692                          if (txData != NULL)
    693                          {
    694                              base->PUSHR = command | (uint16_t)(*txData);
    695                              txData++;
    696                          }
    697                          else
    698                          {
    699                              base->PUSHR = command | dummyData;
    700                          }
    701                          remainingSendByteCount--;
    702          
    703                          DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
    704          
    705                          if (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
    706                          {
    707                              if (rxData != NULL)
    708                              {
    709                                  *(rxData) = DSPI_ReadData(base);
    710                                  rxData++;
    711                              }
    712                              else
    713                              {
    714                                  DSPI_ReadData(base);
    715                              }
    716                              remainingReceiveByteCount--;
   \                     ??DSPI_MasterTransferBlocking_7: (+1)
   \   000000AA   0xF1AE 0x0E01      SUB      LR,LR,#+1
    717          
    718                              DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
   \   000000AE   0xF8C4 0xC02C      STR      R12,[R4, #+44]
   \                     ??DSPI_MasterTransferBlocking_6: (+1)
   \   000000B2   0x2B00             CMP      R3,#+0
   \   000000B4   0xD05E             BEQ.N    ??DSPI_MasterTransferBlocking_8
   \   000000B6   0x1E5E             SUBS     R6,R3,#+1
   \   000000B8   0xD130             BNE.N    ??DSPI_MasterTransferBlocking_9
   \   000000BA   0xE003             B.N      ??DSPI_MasterTransferBlocking_10
   \                     ??DSPI_MasterTransferBlocking_11: (+1)
   \   000000BC   0xF1AE 0x0E01      SUB      LR,LR,#+1
   \   000000C0   0xF8C4 0xC02C      STR      R12,[R4, #+44]
   \                     ??DSPI_MasterTransferBlocking_10: (+1)
   \   000000C4   0xEBAE 0x0603      SUB      R6,LR,R3
   \   000000C8   0x42AE             CMP      R6,R5
   \   000000CA   0xD309             BCC.N    ??DSPI_MasterTransferBlocking_12
   \                     ??DSPI_MasterTransferBlocking_13: (+1)
   \   000000CC   0x6AE6             LDR      R6,[R4, #+44]
   \   000000CE   0x03B6             LSLS     R6,R6,#+14
   \   000000D0   0xD5FC             BPL.N    ??DSPI_MasterTransferBlocking_13
   \   000000D2   0x2A00             CMP      R2,#+0
   \   000000D4   0x6BA6             LDR      R6,[R4, #+56]
   \   000000D6   0xD0F1             BEQ.N    ??DSPI_MasterTransferBlocking_11
   \   000000D8   0xF802 0x6B01      STRB     R6,[R2], #+1
   \   000000DC   0xE7EE             B.N      ??DSPI_MasterTransferBlocking_11
   \                     ??DSPI_MasterTransferBlocking_14: (+1)
   \   000000DE   0x62E7             STR      R7,[R4, #+44]
   \                     ??DSPI_MasterTransferBlocking_12: (+1)
   \   000000E0   0x6AE3             LDR      R3,[R4, #+44]
   \   000000E2   0x019B             LSLS     R3,R3,#+6
   \   000000E4   0xD5FB             BPL.N    ??DSPI_MasterTransferBlocking_14
   \   000000E6   0x2900             CMP      R1,#+0
   \   000000E8   0xBF1D             ITTTE    NE 
   \   000000EA   0xF811 0x3B01      LDRBNE   R3,[R1], #+1
   \   000000EE   0x4303             ORRNE    R3,R0,R3
   \   000000F0   0x6363             STRNE    R3,[R4, #+52]
   \   000000F2   0x6360             STREQ    R0,[R4, #+52]
   \   000000F4   0x2300             MOVS     R3,#+0
   \   000000F6   0x62E7             STR      R7,[R4, #+44]
   \   000000F8   0xF1BE 0x0F00      CMP      LR,#+0
   \   000000FC   0xE003             B.N      ??DSPI_MasterTransferBlocking_15
   \                     ??DSPI_MasterTransferBlocking_16: (+1)
   \   000000FE   0xF1BE 0x0E01      SUBS     LR,LR,#+1
   \   00000102   0xF8C4 0xC02C      STR      R12,[R4, #+44]
   \                     ??DSPI_MasterTransferBlocking_15: (+1)
   \   00000106   0xD0D4             BEQ.N    ??DSPI_MasterTransferBlocking_6
   \                     ??DSPI_MasterTransferBlocking_17: (+1)
   \   00000108   0x6AE6             LDR      R6,[R4, #+44]
   \   0000010A   0x03B6             LSLS     R6,R6,#+14
   \   0000010C   0xD5FC             BPL.N    ??DSPI_MasterTransferBlocking_17
   \   0000010E   0x2A00             CMP      R2,#+0
   \   00000110   0x6BA6             LDR      R6,[R4, #+56]
   \   00000112   0xD0F4             BEQ.N    ??DSPI_MasterTransferBlocking_16
   \   00000114   0xF802 0x6B01      STRB     R6,[R2], #+1
   \   00000118   0xE7F1             B.N      ??DSPI_MasterTransferBlocking_16
   \                     ??DSPI_MasterTransferBlocking_18: (+1)
   \   0000011A   0x62E7             STR      R7,[R4, #+44]
   \                     ??DSPI_MasterTransferBlocking_9: (+1)
   \   0000011C   0x6AE3             LDR      R3,[R4, #+44]
   \   0000011E   0x019B             LSLS     R3,R3,#+6
   \   00000120   0xD5FB             BPL.N    ??DSPI_MasterTransferBlocking_18
   \   00000122   0x2900             CMP      R1,#+0
   \   00000124   0xBF1D             ITTTE    NE 
   \   00000126   0xF811 0x3B01      LDRBNE   R3,[R1], #+1
   \   0000012A   0xEA43 0x0308      ORRNE    R3,R3,R8
   \   0000012E   0x6363             STRNE    R3,[R4, #+52]
   \   00000130   0xF8C4 0x8034      STREQ    R8,[R4, #+52]
   \   00000134   0x4633             MOV      R3,R6
   \   00000136   0x62E7             STR      R7,[R4, #+44]
   \   00000138   0x6AE6             LDR      R6,[R4, #+44]
   \   0000013A   0x03B6             LSLS     R6,R6,#+14
   \   0000013C   0xD5B9             BPL.N    ??DSPI_MasterTransferBlocking_6
   \   0000013E   0x2A00             CMP      R2,#+0
   \   00000140   0x6BA6             LDR      R6,[R4, #+56]
   \   00000142   0xD0B2             BEQ.N    ??DSPI_MasterTransferBlocking_7
   \   00000144   0xF802 0x6B01      STRB     R6,[R2], #+1
   \   00000148   0xE7AF             B.N      ??DSPI_MasterTransferBlocking_7
    719                          }
    720                      }
    721                  }
    722              }
    723              else
    724              {
    725                  while (remainingSendByteCount > 0)
    726                  {
    727                      if (remainingSendByteCount <= 2)
    728                      {
    729                          while (((remainingReceiveByteCount - remainingSendByteCount) / 2) >= fifoSize)
    730                          {
    731                              if (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
    732                              {
    733                                  wordReceived = DSPI_ReadData(base);
    734          
    735                                  if (rxData != NULL)
    736                                  {
    737                                      *rxData = wordReceived;
    738                                      ++rxData;
    739                                      *rxData = wordReceived >> 8;
    740                                      ++rxData;
    741                                  }
    742                                  remainingReceiveByteCount -= 2;
    743          
    744                                  DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
    745                              }
    746                          }
    747          
    748                          while (!(DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag))
    749                          {
    750                              DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
    751                          }
    752          
    753                          if (txData != NULL)
    754                          {
    755                              wordToSend = *(txData);
    756                              ++txData;
    757          
    758                              if (remainingSendByteCount > 1)
    759                              {
    760                                  wordToSend |= (unsigned)(*(txData)) << 8U;
    761                                  ++txData;
    762                              }
    763                          }
    764                          else
    765                          {
    766                              wordToSend = dummyData;
    767                          }
    768          
    769                          base->PUSHR = lastCommand | wordToSend;
    770          
    771                          DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
    772                          remainingSendByteCount = 0;
    773          
    774                          while (remainingReceiveByteCount > 0)
    775                          {
    776                              if (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
    777                              {
    778                                  wordReceived = DSPI_ReadData(base);
    779          
    780                                  if (remainingReceiveByteCount != 1)
    781                                  {
    782                                      if (rxData != NULL)
    783                                      {
    784                                          *(rxData) = wordReceived;
    785                                          ++rxData;
    786                                          *(rxData) = wordReceived >> 8;
    787                                          ++rxData;
    788                                      }
    789                                      remainingReceiveByteCount -= 2;
    790                                  }
    791                                  else
    792                                  {
    793                                      if (rxData != NULL)
    794                                      {
    795                                          *(rxData) = wordReceived;
    796                                          ++rxData;
    797                                      }
    798                                      remainingReceiveByteCount--;
    799                                  }
    800                                  DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
    801                              }
    802                          }
    803                      }
    804                      else
    805                      {
    806                          /*Wait until Tx Fifo is not full*/
    807                          while (!(DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag))
    808                          {
    809                              DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
    810                          }
    811          
    812                          if (txData != NULL)
    813                          {
    814                              wordToSend = *(txData);
    815                              ++txData;
    816                              wordToSend |= (unsigned)(*(txData)) << 8U;
    817                              ++txData;
    818                          }
    819                          else
    820                          {
    821                              wordToSend = dummyData;
   \                     ??DSPI_MasterTransferBlocking_19: (+1)
   \   0000014A   0x2600             MOVS     R6,#+0
    822                          }
    823                          base->PUSHR = command | wordToSend;
   \                     ??DSPI_MasterTransferBlocking_20: (+1)
   \   0000014C   0xEA46 0x0608      ORR      R6,R6,R8
   \   00000150   0x6366             STR      R6,[R4, #+52]
    824                          remainingSendByteCount -= 2;
    825          
    826                          DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \   00000152   0x62E7             STR      R7,[R4, #+44]
   \   00000154   0x1E9B             SUBS     R3,R3,#+2
    827          
    828                          if (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
   \   00000156   0x6AE6             LDR      R6,[R4, #+44]
   \   00000158   0x03B6             LSLS     R6,R6,#+14
   \   0000015A   0xD50A             BPL.N    ??DSPI_MasterTransferBlocking_5
    829                          {
    830                              wordReceived = DSPI_ReadData(base);
   \   0000015C   0x6BA6             LDR      R6,[R4, #+56]
    831          
    832                              if (rxData != NULL)
   \   0000015E   0xB122             CBZ.N    R2,??DSPI_MasterTransferBlocking_21
    833                              {
    834                                  *rxData = wordReceived;
   \   00000160   0x7016             STRB     R6,[R2, #+0]
    835                                  ++rxData;
    836                                  *rxData = wordReceived >> 8;
   \   00000162   0x0436             LSLS     R6,R6,#+16
   \   00000164   0x0E36             LSRS     R6,R6,#+24
   \   00000166   0x7056             STRB     R6,[R2, #+1]
    837                                  ++rxData;
   \   00000168   0x1C92             ADDS     R2,R2,#+2
    838                              }
    839                              remainingReceiveByteCount -= 2;
   \                     ??DSPI_MasterTransferBlocking_21: (+1)
   \   0000016A   0xF1AE 0x0E02      SUB      LR,LR,#+2
    840          
    841                              DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
   \   0000016E   0xF8C4 0xC02C      STR      R12,[R4, #+44]
    842                          }
   \                     ??DSPI_MasterTransferBlocking_5: (+1)
   \   00000172   0x2B00             CMP      R3,#+0
   \                     ??DSPI_MasterTransferBlocking_8: (+1)
   \   00000174   0xD04E             BEQ.N    ??DSPI_MasterTransferBlocking_22
   \   00000176   0x2B03             CMP      R3,#+3
   \   00000178   0xD240             BCS.N    ??DSPI_MasterTransferBlocking_23
   \                     ??DSPI_MasterTransferBlocking_24: (+1)
   \   0000017A   0xEBAE 0x0603      SUB      R6,LR,R3
   \   0000017E   0x0876             LSRS     R6,R6,#+1
   \   00000180   0x42AE             CMP      R6,R5
   \   00000182   0xD30F             BCC.N    ??DSPI_MasterTransferBlocking_25
   \                     ??DSPI_MasterTransferBlocking_26: (+1)
   \   00000184   0x6AE6             LDR      R6,[R4, #+44]
   \   00000186   0x03B6             LSLS     R6,R6,#+14
   \   00000188   0xD5FC             BPL.N    ??DSPI_MasterTransferBlocking_26
   \   0000018A   0x6BA6             LDR      R6,[R4, #+56]
   \   0000018C   0xB122             CBZ.N    R2,??DSPI_MasterTransferBlocking_27
   \   0000018E   0x7016             STRB     R6,[R2, #+0]
   \   00000190   0x0436             LSLS     R6,R6,#+16
   \   00000192   0x0E36             LSRS     R6,R6,#+24
   \   00000194   0x7056             STRB     R6,[R2, #+1]
   \   00000196   0x1C92             ADDS     R2,R2,#+2
   \                     ??DSPI_MasterTransferBlocking_27: (+1)
   \   00000198   0xF1AE 0x0E02      SUB      LR,LR,#+2
   \   0000019C   0xF8C4 0xC02C      STR      R12,[R4, #+44]
   \   000001A0   0xE7EB             B.N      ??DSPI_MasterTransferBlocking_24
   \                     ??DSPI_MasterTransferBlocking_28: (+1)
   \   000001A2   0x62E7             STR      R7,[R4, #+44]
   \                     ??DSPI_MasterTransferBlocking_25: (+1)
   \   000001A4   0x6AE5             LDR      R5,[R4, #+44]
   \   000001A6   0x01AD             LSLS     R5,R5,#+6
   \   000001A8   0xD5FB             BPL.N    ??DSPI_MasterTransferBlocking_28
   \   000001AA   0xB139             CBZ.N    R1,??DSPI_MasterTransferBlocking_29
   \   000001AC   0xF811 0x6B01      LDRB     R6,[R1], #+1
   \   000001B0   0x2B02             CMP      R3,#+2
   \   000001B2   0xD304             BCC.N    ??DSPI_MasterTransferBlocking_30
   \   000001B4   0x7809             LDRB     R1,[R1, #+0]
   \   000001B6   0xEA46 0x2601      ORR      R6,R6,R1, LSL #+8
   \   000001BA   0xE000             B.N      ??DSPI_MasterTransferBlocking_30
   \                     ??DSPI_MasterTransferBlocking_29: (+1)
   \   000001BC   0x2600             MOVS     R6,#+0
   \                     ??DSPI_MasterTransferBlocking_30: (+1)
   \   000001BE   0x4330             ORRS     R0,R6,R0
   \   000001C0   0x6360             STR      R0,[R4, #+52]
   \   000001C2   0x62E7             STR      R7,[R4, #+44]
   \   000001C4   0xE006             B.N      ??DSPI_MasterTransferBlocking_31
   \                     ??DSPI_MasterTransferBlocking_32: (+1)
   \   000001C6   0xB10A             CBZ.N    R2,??DSPI_MasterTransferBlocking_33
   \   000001C8   0xF802 0x0B01      STRB     R0,[R2], #+1
   \                     ??DSPI_MasterTransferBlocking_33: (+1)
   \   000001CC   0xF04F 0x0E00      MOV      LR,#+0
   \                     ??DSPI_MasterTransferBlocking_34: (+1)
   \   000001D0   0xF8C4 0xC02C      STR      R12,[R4, #+44]
   \                     ??DSPI_MasterTransferBlocking_31: (+1)
   \   000001D4   0xF1BE 0x0F00      CMP      LR,#+0
   \   000001D8   0xD01C             BEQ.N    ??DSPI_MasterTransferBlocking_22
   \                     ??DSPI_MasterTransferBlocking_35: (+1)
   \   000001DA   0x6AE0             LDR      R0,[R4, #+44]
   \   000001DC   0x0380             LSLS     R0,R0,#+14
   \   000001DE   0xD5FC             BPL.N    ??DSPI_MasterTransferBlocking_35
   \   000001E0   0x6BA0             LDR      R0,[R4, #+56]
   \   000001E2   0xF1BE 0x0F01      CMP      LR,#+1
   \   000001E6   0xD0EE             BEQ.N    ??DSPI_MasterTransferBlocking_32
   \   000001E8   0xB122             CBZ.N    R2,??DSPI_MasterTransferBlocking_36
   \   000001EA   0x7010             STRB     R0,[R2, #+0]
   \   000001EC   0x0400             LSLS     R0,R0,#+16
   \   000001EE   0x0E00             LSRS     R0,R0,#+24
   \   000001F0   0x7050             STRB     R0,[R2, #+1]
   \   000001F2   0x1C92             ADDS     R2,R2,#+2
   \                     ??DSPI_MasterTransferBlocking_36: (+1)
   \   000001F4   0xF1AE 0x0E02      SUB      LR,LR,#+2
   \   000001F8   0xE7EA             B.N      ??DSPI_MasterTransferBlocking_34
   \                     ??DSPI_MasterTransferBlocking_37: (+1)
   \   000001FA   0x62E7             STR      R7,[R4, #+44]
   \                     ??DSPI_MasterTransferBlocking_23: (+1)
   \   000001FC   0x6AE6             LDR      R6,[R4, #+44]
   \   000001FE   0x01B6             LSLS     R6,R6,#+6
   \   00000200   0xD5FB             BPL.N    ??DSPI_MasterTransferBlocking_37
   \   00000202   0x2900             CMP      R1,#+0
   \   00000204   0xD0A1             BEQ.N    ??DSPI_MasterTransferBlocking_19
   \   00000206   0x780E             LDRB     R6,[R1, #+0]
   \   00000208   0xF891 0x9001      LDRB     R9,[R1, #+1]
   \   0000020C   0xEA46 0x2609      ORR      R6,R6,R9, LSL #+8
   \   00000210   0x1C89             ADDS     R1,R1,#+2
   \   00000212   0xE79B             B.N      ??DSPI_MasterTransferBlocking_20
    843                      }
    844                  }
    845              }
    846          
    847              return kStatus_Success;
   \                     ??DSPI_MasterTransferBlocking_22: (+1)
   \   00000214   0x2000             MOVS     R0,#+0
   \                     ??DSPI_MasterTransferBlocking_1: (+1)
   \   00000216   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
    848          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \                     ??Subroutine12_0: (+1)
   \   00000002   0x4620             MOV      R0,R4
   \   00000004   0x....             B.N      DSPI_FlushFifo

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \   00000000   0x0D40             LSRS     R0,R0,#+21
   \   00000002   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x....             B.N      DSPI_MasterGetFormattedCommand

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \   00000000   0x0D00             LSRS     R0,R0,#+20
   \   00000002   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x....             B.N      DSPI_MasterGetFormattedCommand

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \   00000000   0xF3C1 0x1103      UBFX     R1,R1,#+4,#+4
   \   00000004   0x4088             LSLS     R0,R0,R1
   \   00000006   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   00000010   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   00000014   0x4770             BX       LR
    849          

   \                                 In section .text, align 2, keep-with-next
    850          static void DSPI_MasterPrepareTransfer(SPI_Type *base, dspi_master_handle_t *handle, dspi_transfer_t *transfer)
    851          {
   \                     DSPI_MasterPrepareTransfer: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    852              dspi_command_data_config_t commandStruct;
    853          
    854              DSPI_StopTransfer(base);
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       ??Subroutine3_0
   \                     ??CrossCallReturnLabel_4: (+1)
   \   0000000C   0x4616             MOV      R6,R2
    855              DSPI_FlushFifo(base, true, true);
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x.... 0x....      BL       ?Subroutine12
    856              DSPI_ClearStatusFlags(base, kDSPI_AllStatusFlag);
   \                     ??CrossCallReturnLabel_31: (+1)
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable25_10  ;; 0xda0a0000
   \   00000018   0x62E0             STR      R0,[R4, #+44]
    857          
    858              commandStruct.whichPcs =
    859                  (dspi_which_pcs_t)(1U << ((transfer->configFlags & DSPI_MASTER_PCS_MASK) >> DSPI_MASTER_PCS_SHIFT));
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x68F1             LDR      R1,[R6, #+12]
   \   0000001E   0x.... 0x....      BL       ?Subroutine10
    860              commandStruct.isEndOfQueue = false;
    861              commandStruct.clearTransferCount = false;
    862              commandStruct.whichCtar =
    863                  (dspi_ctar_selection_t)((transfer->configFlags & DSPI_MASTER_CTAR_MASK) >> DSPI_MASTER_CTAR_SHIFT);
   \                     ??CrossCallReturnLabel_27: (+1)
   \   00000022   0x7B30             LDRB     R0,[R6, #+12]
   \   00000024   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000028   0xF88D 0x0001      STRB     R0,[SP, #+1]
    864              commandStruct.isPcsContinuous = (bool)(transfer->configFlags & kDSPI_MasterPcsContinuous);
   \   0000002C   0x68F0             LDR      R0,[R6, #+12]
   \   0000002E   0x.... 0x....      BL       ?Subroutine11
    865              handle->command = DSPI_MasterGetFormattedCommand(&(commandStruct));
   \                     ??CrossCallReturnLabel_28: (+1)
   \   00000032   0x6068             STR      R0,[R5, #+4]
    866          
    867              commandStruct.isPcsContinuous = (bool)(transfer->configFlags & kDSPI_MasterActiveAfterTransfer);
   \   00000034   0x68F0             LDR      R0,[R6, #+12]
   \   00000036   0x.... 0x....      BL       ?Subroutine13
    868              handle->lastCommand = DSPI_MasterGetFormattedCommand(&(commandStruct));
   \                     ??CrossCallReturnLabel_33: (+1)
   \   0000003A   0x60A8             STR      R0,[R5, #+8]
    869          
    870              handle->bitsPerFrame = ((base->CTAR[commandStruct.whichCtar] & SPI_CTAR_FMSZ_MASK) >> SPI_CTAR_FMSZ_SHIFT) + 1;
   \   0000003C   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000040   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000044   0x68C0             LDR      R0,[R0, #+12]
   \   00000046   0xF3C0 0x60C3      UBFX     R0,R0,#+27,#+4
   \   0000004A   0x1C40             ADDS     R0,R0,#+1
   \   0000004C   0x6028             STR      R0,[R5, #+0]
    871          
    872              if ((base->MCR & SPI_MCR_DIS_RXF_MASK) || (base->MCR & SPI_MCR_DIS_TXF_MASK))
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x04C0             LSLS     R0,R0,#+19
   \   00000052   0xD402             BMI.N    ??DSPI_MasterPrepareTransfer_0
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x0480             LSLS     R0,R0,#+18
   \   00000058   0xD501             BPL.N    ??DSPI_MasterPrepareTransfer_1
    873              {
    874                  handle->fifoSize = 1;
   \                     ??DSPI_MasterPrepareTransfer_0: (+1)
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0xE00B             B.N      ??DSPI_MasterPrepareTransfer_2
    875              }
    876              else
    877              {
    878                  handle->fifoSize = FSL_FEATURE_DSPI_FIFO_SIZEn(base);
   \                     ??DSPI_MasterPrepareTransfer_1: (+1)
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable25_11  ;; 0x4002c000
   \   00000062   0x4284             CMP      R4,R0
   \   00000064   0xBF08             IT       EQ 
   \   00000066   0x2004             MOVEQ    R0,#+4
   \   00000068   0xD005             BEQ.N    ??DSPI_MasterPrepareTransfer_2
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable25_12  ;; 0x4002d000
   \   0000006E   0x4284             CMP      R4,R0
   \   00000070   0xBF0C             ITE      EQ 
   \   00000072   0x2001             MOVEQ    R0,#+1
   \   00000074   0x20FF             MOVNE    R0,#+255
   \                     ??DSPI_MasterPrepareTransfer_2: (+1)
   \   00000076   0x7328             STRB     R0,[R5, #+12]
    879              }
    880              handle->txData = transfer->txData;
   \   00000078   0x6830             LDR      R0,[R6, #+0]
   \   0000007A   0x6128             STR      R0,[R5, #+16]
    881              handle->rxData = transfer->rxData;
   \   0000007C   0x6870             LDR      R0,[R6, #+4]
   \   0000007E   0x6168             STR      R0,[R5, #+20]
    882              handle->remainingSendByteCount = transfer->dataSize;
   \   00000080   0x68B0             LDR      R0,[R6, #+8]
   \   00000082   0x61A8             STR      R0,[R5, #+24]
    883              handle->remainingReceiveByteCount = transfer->dataSize;
   \   00000084   0x68B0             LDR      R0,[R6, #+8]
   \   00000086   0x61E8             STR      R0,[R5, #+28]
    884              handle->totalByteCount = transfer->dataSize;
   \   00000088   0x68B0             LDR      R0,[R6, #+8]
   \   0000008A   0x6228             STR      R0,[R5, #+32]
    885          }
   \   0000008C   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    886          

   \                                 In section .text, align 2, keep-with-next
    887          status_t DSPI_MasterTransferNonBlocking(SPI_Type *base, dspi_master_handle_t *handle, dspi_transfer_t *transfer)
    888          {
   \                     DSPI_MasterTransferNonBlocking: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    889              assert(handle && transfer);
    890          
    891              /* If the transfer count is zero, then return immediately.*/
    892              if (transfer->dataSize == 0)
   \   00000004   0x6890             LDR      R0,[R2, #+8]
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0xB908             CBNZ.N   R0,??DSPI_MasterTransferNonBlocking_0
    893              {
    894                  return kStatus_InvalidArgument;
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
    895              }
    896          
    897              /* Check that we're not busy.*/
    898              if (handle->state == kDSPI_Busy)
   \                     ??DSPI_MasterTransferNonBlocking_0: (+1)
   \   0000000E   0xF895 0x0024      LDRB     R0,[R5, #+36]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD102             BNE.N    ??DSPI_MasterTransferNonBlocking_1
    899              {
    900                  return kStatus_DSPI_Busy;
   \   00000016   0xF44F 0x7016      MOV      R0,#+600
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}
    901              }
    902          
    903              handle->state = kDSPI_Busy;
   \                     ??DSPI_MasterTransferNonBlocking_1: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xF885 0x0024      STRB     R0,[R5, #+36]
    904          
    905              DSPI_MasterPrepareTransfer(base, handle, transfer);
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       DSPI_MasterPrepareTransfer
    906              DSPI_StartTransfer(base);
   \   00000028   0x.... 0x....      BL       ?Subroutine6
    907          
    908              /* Enable the NVIC for DSPI peripheral. */
    909              EnableIRQ(s_dspiIRQ[DSPI_GetInstance(base)]);
   \                     ??CrossCallReturnLabel_15: (+1)
   \   0000002C   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_10: (+1)
   \   00000030   0x.... 0x....      BL       ?Subroutine14
    910          
    911              DSPI_MasterFillUpTxFifo(base, handle);
   \                     ??CrossCallReturnLabel_36: (+1)
   \   00000034   0x4629             MOV      R1,R5
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       DSPI_MasterFillUpTxFifo
    912          
    913              /* RX FIFO Drain request: RFDF_RE to enable RFDF interrupt
    914              * Since SPI is a synchronous interface, we only need to enable the RX interrupt.
    915              * The IRQ handler will get the status of RX and TX interrupt flags.
    916              */
    917              s_dspiMasterIsr = DSPI_MasterTransferHandleIRQ;
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable25_13
   \   00000040   0x.... 0x....      ADR.W    R0,DSPI_MasterTransferHandleIRQ
   \   00000044   0x6008             STR      R0,[R1, #+0]
    918          
    919              DSPI_EnableInterrupts(base, kDSPI_RxFifoDrainRequestInterruptEnable);
   \   00000046   0x.... 0x....      BL       ?Subroutine7
    920          
    921              return kStatus_Success;
   \                     ??CrossCallReturnLabel_20: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    922          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0xF44F 0x3100      MOV      R1,#+131072
   \                     ??Subroutine7_0: (+1)
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x....             B.N      DSPI_EnableInterrupts

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \   00000000   0x.... 0x....      ADR.W    R1,s_dspiIRQ
   \   00000004   0x5608             LDRSB    R0,[R1, R0]
   \   00000006   0x.... 0x....      B.W      EnableIRQ
    923          

   \                                 In section .text, align 2, keep-with-next
    924          status_t DSPI_MasterTransferGetCount(SPI_Type *base, dspi_master_handle_t *handle, size_t *count)
    925          {
    926              assert(handle);
    927          
    928              if (!count)
   \                     DSPI_MasterTransferGetCount: (+1)
   \   00000000   0xB90A             CBNZ.N   R2,??DSPI_MasterTransferGetCount_0
    929              {
    930                  return kStatus_InvalidArgument;
   \   00000002   0x2004             MOVS     R0,#+4
   \   00000004   0x4770             BX       LR
    931              }
    932          
    933              /* Catch when there is not an active transfer. */
    934              if (handle->state != kDSPI_Busy)
   \                     ??DSPI_MasterTransferGetCount_0: (+1)
   \   00000006   0xF101 0x001C      ADD      R0,R1,#+28
   \   0000000A   0x7A01             LDRB     R1,[R0, #+8]
   \   0000000C   0x2901             CMP      R1,#+1
   \   0000000E   0xD000             BEQ.N    ??DSPI_MasterTransferGetCount_1
    935              {
    936                  *count = 0;
   \   00000010   0x....             B.N      ?Subroutine1
    937                  return kStatus_NoTransferInProgress;
    938              }
    939          
    940              *count = handle->totalByteCount - handle->remainingReceiveByteCount;
   \                     ??DSPI_MasterTransferGetCount_1: (+1)
   \   00000012   0x6841             LDR      R1,[R0, #+4]
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x1A08             SUBS     R0,R1,R0
   \   00000018   0x....             B.N      ?Subroutine2
    941              return kStatus_Success;
    942          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x6010             STR      R0,[R2, #+0]
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x6010             STR      R0,[R2, #+0]
   \   00000004   0x2006             MOVS     R0,#+6
   \   00000006   0x4770             BX       LR
    943          
    944          static void DSPI_MasterCompleteTransfer(SPI_Type *base, dspi_master_handle_t *handle)
    945          {
    946              /* Disable interrupt requests*/
    947              DSPI_DisableInterrupts(base, kDSPI_RxFifoDrainRequestInterruptEnable | kDSPI_TxFifoFillRequestInterruptEnable);
    948          
    949              status_t status = 0;
    950              if (handle->state == kDSPI_Error)
    951              {
    952                  status = kStatus_DSPI_Error;
    953              }
    954              else
    955              {
    956                  status = kStatus_Success;
    957              }
    958          
    959              if (handle->callback)
    960              {
    961                  handle->callback(base, handle, status, handle->userData);
    962              }
    963          
    964              /* The transfer is complete.*/
    965              handle->state = kDSPI_Idle;
    966          }
    967          

   \                                 In section .text, align 2, keep-with-next
    968          static void DSPI_MasterFillUpTxFifo(SPI_Type *base, dspi_master_handle_t *handle)
    969          {
   \                     DSPI_MasterFillUpTxFifo: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    970              uint16_t wordToSend = 0;
    971              uint8_t dummyData = DSPI_MASTER_DUMMY_DATA;
    972          
    973              /* If bits/frame is greater than one byte */
    974              if (handle->bitsPerFrame > 8)
   \   00000002   0x680B             LDR      R3,[R1, #+0]
   \   00000004   0x2B09             CMP      R3,#+9
   \   00000006   0xF04F 0x7200      MOV      R2,#+33554432
   \   0000000A   0xD32C             BCC.N    ??DSPI_MasterFillUpTxFifo_0
    975              {
    976                  /* Fill the fifo until it is full or until the send word count is 0 or until the difference
    977                  * between the remainingReceiveByteCount and remainingSendByteCount equals the FIFO depth.
    978                  * The reason for checking the difference is to ensure we only send as much as the
    979                  * RX FIFO can receive.
    980                  * For this case where bitsPerFrame > 8, each entry in the FIFO contains 2 bytes of the
    981                  * send data, hence the difference between the remainingReceiveByteCount and
    982                  * remainingSendByteCount must be divided by 2 to convert this difference into a
    983                  * 16-bit (2 byte) value.
    984                  */
    985                  while ((DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag) &&
    986                         ((handle->remainingReceiveByteCount - handle->remainingSendByteCount) / 2 < handle->fifoSize))
   \                     ??DSPI_MasterFillUpTxFifo_1: (+1)
   \   0000000C   0x6AC3             LDR      R3,[R0, #+44]
   \   0000000E   0x019B             LSLS     R3,R3,#+6
   \   00000010   0xD547             BPL.N    ??DSPI_MasterFillUpTxFifo_2
   \   00000012   0x69CB             LDR      R3,[R1, #+28]
   \   00000014   0x698C             LDR      R4,[R1, #+24]
   \   00000016   0x1B1B             SUBS     R3,R3,R4
   \   00000018   0x7B0C             LDRB     R4,[R1, #+12]
   \   0000001A   0x085B             LSRS     R3,R3,#+1
   \   0000001C   0x42A3             CMP      R3,R4
   \   0000001E   0xD240             BCS.N    ??DSPI_MasterFillUpTxFifo_2
    987                  {
    988                      if (handle->remainingSendByteCount <= 2)
   \   00000020   0x698B             LDR      R3,[R1, #+24]
   \   00000022   0x2B03             CMP      R3,#+3
   \   00000024   0x690B             LDR      R3,[R1, #+16]
   \   00000026   0xD20B             BCS.N    ??DSPI_MasterFillUpTxFifo_3
    989                      {
    990                          if (handle->txData)
   \   00000028   0xB133             CBZ.N    R3,??CrossCallReturnLabel_37
    991                          {
    992                              if (handle->remainingSendByteCount == 1)
   \   0000002A   0x698B             LDR      R3,[R1, #+24]
   \   0000002C   0x2B01             CMP      R3,#+1
   \   0000002E   0x690B             LDR      R3,[R1, #+16]
   \   00000030   0x781B             LDRB     R3,[R3, #+0]
   \   00000032   0xD001             BEQ.N    ??CrossCallReturnLabel_37
    993                              {
    994                                  wordToSend = *(handle->txData);
    995                              }
    996                              else
    997                              {
    998                                  wordToSend = *(handle->txData);
    999                                  ++handle->txData; /* increment to next data byte */
   \   00000034   0x.... 0x....      BL       ?Subroutine15
   1000                                  wordToSend |= (unsigned)(*(handle->txData)) << 8U;
   1001                              }
   1002                          }
   1003                          else
   1004                          {
   1005                              wordToSend = dummyData;
   1006                          }
   1007                          handle->remainingSendByteCount = 0;
   \                     ??CrossCallReturnLabel_37: (+1)
   \   00000038   0x2400             MOVS     R4,#+0
   \   0000003A   0x618C             STR      R4,[R1, #+24]
   1008                          base->PUSHR = handle->lastCommand | wordToSend;
   \   0000003C   0x688C             LDR      R4,[R1, #+8]
   \   0000003E   0xE00B             B.N      ??DSPI_MasterFillUpTxFifo_4
   1009                      }
   1010                      /* For all words except the last word */
   1011                      else
   1012                      {
   1013                          if (handle->txData)
   \                     ??DSPI_MasterFillUpTxFifo_3: (+1)
   \   00000040   0xB133             CBZ.N    R3,??DSPI_MasterFillUpTxFifo_5
   1014                          {
   1015                              wordToSend = *(handle->txData);
   \   00000042   0x690B             LDR      R3,[R1, #+16]
   \   00000044   0x781B             LDRB     R3,[R3, #+0]
   1016                              ++handle->txData; /* increment to next data byte */
   \   00000046   0x.... 0x....      BL       ?Subroutine15
   1017                              wordToSend |= (unsigned)(*(handle->txData)) << 8U;
   1018                              ++handle->txData; /* increment to next data byte */
   \                     ??CrossCallReturnLabel_38: (+1)
   \   0000004A   0x690C             LDR      R4,[R1, #+16]
   \   0000004C   0x1C64             ADDS     R4,R4,#+1
   \   0000004E   0x610C             STR      R4,[R1, #+16]
   1019                          }
   1020                          else
   1021                          {
   1022                              wordToSend = dummyData;
   1023                          }
   1024                          handle->remainingSendByteCount -= 2; /* decrement remainingSendByteCount by 2 */
   \                     ??DSPI_MasterFillUpTxFifo_5: (+1)
   \   00000050   0x698C             LDR      R4,[R1, #+24]
   \   00000052   0x1EA4             SUBS     R4,R4,#+2
   \   00000054   0x618C             STR      R4,[R1, #+24]
   1025                          base->PUSHR = handle->command | wordToSend;
   \   00000056   0x684C             LDR      R4,[R1, #+4]
   \                     ??DSPI_MasterFillUpTxFifo_4: (+1)
   \   00000058   0x4323             ORRS     R3,R3,R4
   \   0000005A   0x6343             STR      R3,[R0, #+52]
   1026                      }
   1027          
   1028                      /* Try to clear the TFFF; if the TX FIFO is full this will clear */
   1029                      DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \   0000005C   0x62C2             STR      R2,[R0, #+44]
   1030          
   1031                      /* exit loop if send count is zero, else update local variables for next loop */
   1032                      if (handle->remainingSendByteCount == 0)
   \   0000005E   0x698B             LDR      R3,[R1, #+24]
   \   00000060   0x2B00             CMP      R3,#+0
   \   00000062   0xD1D3             BNE.N    ??DSPI_MasterFillUpTxFifo_1
   \   00000064   0xBD10             POP      {R4,PC}
   1033                      {
   1034                          break;
   1035                      }
   1036                  } /* End of TX FIFO fill while loop */
   1037              }
   1038              /* Optimized for bits/frame less than or equal to one byte. */
   1039              else
   1040              {
   1041                  /* Fill the fifo until it is full or until the send word count is 0 or until the difference
   1042                  * between the remainingReceiveByteCount and remainingSendByteCount equals the FIFO depth.
   1043                  * The reason for checking the difference is to ensure we only send as much as the
   1044                  * RX FIFO can receive.
   1045                  */
   1046                  while ((DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag) &&
   1047                         ((handle->remainingReceiveByteCount - handle->remainingSendByteCount) < handle->fifoSize))
   \                     ??DSPI_MasterFillUpTxFifo_0: (+1)
   \   00000066   0x6AC3             LDR      R3,[R0, #+44]
   \   00000068   0x019B             LSLS     R3,R3,#+6
   \   0000006A   0xD51A             BPL.N    ??DSPI_MasterFillUpTxFifo_2
   \   0000006C   0x69CB             LDR      R3,[R1, #+28]
   \   0000006E   0x698C             LDR      R4,[R1, #+24]
   \   00000070   0x1B1B             SUBS     R3,R3,R4
   \   00000072   0x7B0C             LDRB     R4,[R1, #+12]
   \   00000074   0x42A3             CMP      R3,R4
   \   00000076   0xD214             BCS.N    ??DSPI_MasterFillUpTxFifo_2
   1048                  {
   1049                      if (handle->txData)
   \   00000078   0x690B             LDR      R3,[R1, #+16]
   \   0000007A   0xB123             CBZ.N    R3,??DSPI_MasterFillUpTxFifo_6
   1050                      {
   1051                          wordToSend = *(handle->txData);
   \   0000007C   0x690B             LDR      R3,[R1, #+16]
   \   0000007E   0x781B             LDRB     R3,[R3, #+0]
   1052                          ++handle->txData;
   \   00000080   0x690C             LDR      R4,[R1, #+16]
   \   00000082   0x1C64             ADDS     R4,R4,#+1
   \   00000084   0x610C             STR      R4,[R1, #+16]
   1053                      }
   1054                      else
   1055                      {
   1056                          wordToSend = dummyData;
   1057                      }
   1058          
   1059                      if (handle->remainingSendByteCount == 1)
   \                     ??DSPI_MasterFillUpTxFifo_6: (+1)
   \   00000086   0x698C             LDR      R4,[R1, #+24]
   \   00000088   0x2C01             CMP      R4,#+1
   \   0000008A   0xBF0C             ITE      EQ 
   \   0000008C   0x688C             LDREQ    R4,[R1, #+8]
   \   0000008E   0x684C             LDRNE    R4,[R1, #+4]
   1060                      {
   1061                          base->PUSHR = handle->lastCommand | wordToSend;
   1062                      }
   1063                      else
   1064                      {
   1065                          base->PUSHR = handle->command | wordToSend;
   \   00000090   0x4323             ORRS     R3,R3,R4
   \   00000092   0x6343             STR      R3,[R0, #+52]
   1066                      }
   1067          
   1068                      /* Try to clear the TFFF; if the TX FIFO is full this will clear */
   1069                      DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \   00000094   0x62C2             STR      R2,[R0, #+44]
   1070          
   1071                      --handle->remainingSendByteCount;
   \   00000096   0x698B             LDR      R3,[R1, #+24]
   \   00000098   0x1E5B             SUBS     R3,R3,#+1
   \   0000009A   0x618B             STR      R3,[R1, #+24]
   1072          
   1073                      /* exit loop if send count is zero, else update local variables for next loop */
   1074                      if (handle->remainingSendByteCount == 0)
   \   0000009C   0x698B             LDR      R3,[R1, #+24]
   \   0000009E   0x2B00             CMP      R3,#+0
   \   000000A0   0xD1E1             BNE.N    ??DSPI_MasterFillUpTxFifo_0
   1075                      {
   1076                          break;
   1077                      }
   1078                  }
   1079              }
   1080          }
   \                     ??DSPI_MasterFillUpTxFifo_2: (+1)
   \   000000A2   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15: (+1)
   \   00000000   0x690C             LDR      R4,[R1, #+16]
   \   00000002   0x1C64             ADDS     R4,R4,#+1
   \   00000004   0x610C             STR      R4,[R1, #+16]
   \   00000006   0x690C             LDR      R4,[R1, #+16]
   \   00000008   0x7824             LDRB     R4,[R4, #+0]
   \   0000000A   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   0000000E   0x4770             BX       LR
   1081          

   \                                 In section .text, align 2, keep-with-next
   1082          void DSPI_MasterTransferAbort(SPI_Type *base, dspi_master_handle_t *handle)
   1083          {
   1084              DSPI_StopTransfer(base);
   \                     DSPI_MasterTransferAbort: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   1085          
   1086              /* Disable interrupt requests*/
   1087              DSPI_DisableInterrupts(base, kDSPI_RxFifoDrainRequestInterruptEnable | kDSPI_TxFifoFillRequestInterruptEnable);
   \   00000002   0x.... 0x....      LDR.W    R3,??DataTable25_14  ;; 0xfdfdffff
   \   00000006   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000000A   0x6002             STR      R2,[R0, #+0]
   \   0000000C   0x6B02             LDR      R2,[R0, #+48]
   \   0000000E   0x401A             ANDS     R2,R3,R2
   \   00000010   0x6302             STR      R2,[R0, #+48]
   1088          
   1089              handle->state = kDSPI_Idle;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF881 0x0024      STRB     R0,[R1, #+36]
   1090          }
   \   00000018   0x4770             BX       LR               ;; return
   1091          

   \                                 In section .text, align 4, keep-with-next
   1092          void DSPI_MasterTransferHandleIRQ(SPI_Type *base, dspi_master_handle_t *handle)
   1093          {
   \                     DSPI_MasterTransferHandleIRQ: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4604             MOV      R4,R0
   1094              /* RECEIVE IRQ handler: Check read buffer only if there are remaining bytes to read. */
   1095              if (handle->remainingReceiveByteCount)
   \   00000006   0x69E8             LDR      R0,[R5, #+28]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD03D             BEQ.N    ??DSPI_MasterTransferHandleIRQ_0
   1096              {
   1097                  /* Check read buffer.*/
   1098                  uint16_t wordReceived; /* Maximum supported data bit length in master mode is 16-bits */
   1099          
   1100                  /* If bits/frame is greater than one byte */
   1101                  if (handle->bitsPerFrame > 8)
   \   0000000C   0x6829             LDR      R1,[R5, #+0]
   \   0000000E   0x2909             CMP      R1,#+9
   \   00000010   0xF44F 0x3000      MOV      R0,#+131072
   \   00000014   0xD326             BCC.N    ??DSPI_MasterTransferHandleIRQ_1
   1102                  {
   1103                      while (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
   \                     ??DSPI_MasterTransferHandleIRQ_2: (+1)
   \   00000016   0x6AE1             LDR      R1,[R4, #+44]
   \   00000018   0x0389             LSLS     R1,R1,#+14
   \   0000001A   0xD535             BPL.N    ??DSPI_MasterTransferHandleIRQ_0
   1104                      {
   1105                          wordReceived = DSPI_ReadData(base);
   \   0000001C   0x6BA1             LDR      R1,[R4, #+56]
   1106                          /* clear the rx fifo drain request, needed for non-DMA applications as this flag
   1107                          * will remain set even if the rx fifo is empty. By manually clearing this flag, it
   1108                          * either remain clear if no more data is in the fifo, or it will set if there is
   1109                          * more data in the fifo.
   1110                          */
   1111                          DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
   \   0000001E   0x62E0             STR      R0,[R4, #+44]
   1112          
   1113                          /* Store read bytes into rx buffer only if a buffer pointer was provided */
   1114                          if (handle->rxData)
   \   00000020   0x696A             LDR      R2,[R5, #+20]
   \   00000022   0xB19A             CBZ.N    R2,??DSPI_MasterTransferHandleIRQ_3
   1115                          {
   1116                              /* For the last word received, if there is an extra byte due to the odd transfer
   1117                              * byte count, only save the the last byte and discard the upper byte
   1118                              */
   1119                              if (handle->remainingReceiveByteCount == 1)
   \   00000024   0x69EA             LDR      R2,[R5, #+28]
   \   00000026   0x2A01             CMP      R2,#+1
   \   00000028   0x696A             LDR      R2,[R5, #+20]
   \   0000002A   0x7011             STRB     R1,[R2, #+0]
   \   0000002C   0xD102             BNE.N    ??DSPI_MasterTransferHandleIRQ_4
   1120                              {
   1121                                  *handle->rxData = wordReceived; /* Write first data byte */
   1122                                  --handle->remainingReceiveByteCount;
   \   0000002E   0x69E9             LDR      R1,[R5, #+28]
   \   00000030   0x1E49             SUBS     R1,R1,#+1
   \   00000032   0xE012             B.N      ??DSPI_MasterTransferHandleIRQ_5
   1123                              }
   1124                              else
   1125                              {
   1126                                  *handle->rxData = wordReceived;      /* Write first data byte */
   1127                                  ++handle->rxData;                    /* increment to next data byte */
   \                     ??DSPI_MasterTransferHandleIRQ_4: (+1)
   \   00000034   0x696A             LDR      R2,[R5, #+20]
   \   00000036   0x1C52             ADDS     R2,R2,#+1
   \   00000038   0x616A             STR      R2,[R5, #+20]
   1128                                  *handle->rxData = wordReceived >> 8; /* Write second data byte */
   \   0000003A   0x0409             LSLS     R1,R1,#+16
   \   0000003C   0x696A             LDR      R2,[R5, #+20]
   \   0000003E   0x0E09             LSRS     R1,R1,#+24
   \   00000040   0x7011             STRB     R1,[R2, #+0]
   1129                                  ++handle->rxData;                    /* increment to next data byte */
   \   00000042   0x6969             LDR      R1,[R5, #+20]
   \   00000044   0x1C49             ADDS     R1,R1,#+1
   \   00000046   0x6169             STR      R1,[R5, #+20]
   1130                                  handle->remainingReceiveByteCount -= 2;
   \   00000048   0x69E9             LDR      R1,[R5, #+28]
   \   0000004A   0xE005             B.N      ??DSPI_MasterTransferHandleIRQ_6
   1131                              }
   1132                          }
   1133                          else
   1134                          {
   1135                              if (handle->remainingReceiveByteCount == 1)
   \                     ??DSPI_MasterTransferHandleIRQ_3: (+1)
   \   0000004C   0x69E9             LDR      R1,[R5, #+28]
   \   0000004E   0x2901             CMP      R1,#+1
   \   00000050   0x69E9             LDR      R1,[R5, #+28]
   \   00000052   0xBF08             IT       EQ 
   \   00000054   0x1E49             SUBEQ    R1,R1,#+1
   1136                              {
   1137                                  --handle->remainingReceiveByteCount;
   \   00000056   0xD000             BEQ.N    ??DSPI_MasterTransferHandleIRQ_5
   1138                              }
   1139                              else
   1140                              {
   1141                                  handle->remainingReceiveByteCount -= 2;
   \                     ??DSPI_MasterTransferHandleIRQ_6: (+1)
   \   00000058   0x1E89             SUBS     R1,R1,#+2
   \                     ??DSPI_MasterTransferHandleIRQ_5: (+1)
   \   0000005A   0x61E9             STR      R1,[R5, #+28]
   1142                              }
   1143                          }
   1144                          if (handle->remainingReceiveByteCount == 0)
   \   0000005C   0x69E9             LDR      R1,[R5, #+28]
   \   0000005E   0x2900             CMP      R1,#+0
   \   00000060   0xD1D9             BNE.N    ??DSPI_MasterTransferHandleIRQ_2
   \   00000062   0xE011             B.N      ??DSPI_MasterTransferHandleIRQ_0
   1145                          {
   1146                              break;
   1147                          }
   1148                      } /* End of RX FIFO drain while loop */
   1149                  }
   1150                  /* Optimized for bits/frame less than or equal to one byte. */
   1151                  else
   1152                  {
   1153                      while (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
   \                     ??DSPI_MasterTransferHandleIRQ_1: (+1)
   \   00000064   0x6AE1             LDR      R1,[R4, #+44]
   \   00000066   0x0389             LSLS     R1,R1,#+14
   \   00000068   0xD50E             BPL.N    ??DSPI_MasterTransferHandleIRQ_0
   1154                      {
   1155                          wordReceived = DSPI_ReadData(base);
   \   0000006A   0x6BA1             LDR      R1,[R4, #+56]
   1156                          /* clear the rx fifo drain request, needed for non-DMA applications as this flag
   1157                          * will remain set even if the rx fifo is empty. By manually clearing this flag, it
   1158                          * either remain clear if no more data is in the fifo, or it will set if there is
   1159                          * more data in the fifo.
   1160                          */
   1161                          DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
   \   0000006C   0x62E0             STR      R0,[R4, #+44]
   1162          
   1163                          /* Store read bytes into rx buffer only if a buffer pointer was provided */
   1164                          if (handle->rxData)
   \   0000006E   0x696A             LDR      R2,[R5, #+20]
   \   00000070   0xB122             CBZ.N    R2,??DSPI_MasterTransferHandleIRQ_7
   1165                          {
   1166                              *handle->rxData = wordReceived;
   \   00000072   0x696A             LDR      R2,[R5, #+20]
   \   00000074   0x7011             STRB     R1,[R2, #+0]
   1167                              ++handle->rxData;
   \   00000076   0x6969             LDR      R1,[R5, #+20]
   \   00000078   0x1C49             ADDS     R1,R1,#+1
   \   0000007A   0x6169             STR      R1,[R5, #+20]
   1168                          }
   1169          
   1170                          --handle->remainingReceiveByteCount;
   \                     ??DSPI_MasterTransferHandleIRQ_7: (+1)
   \   0000007C   0x69E9             LDR      R1,[R5, #+28]
   \   0000007E   0x1E49             SUBS     R1,R1,#+1
   \   00000080   0x61E9             STR      R1,[R5, #+28]
   1171          
   1172                          if (handle->remainingReceiveByteCount == 0)
   \   00000082   0x69E9             LDR      R1,[R5, #+28]
   \   00000084   0x2900             CMP      R1,#+0
   \   00000086   0xD1ED             BNE.N    ??DSPI_MasterTransferHandleIRQ_1
   1173                          {
   1174                              break;
   1175                          }
   1176                      } /* End of RX FIFO drain while loop */
   1177                  }
   1178              }
   1179          
   1180              /* Check write buffer. We always have to send a word in order to keep the transfer
   1181              * moving. So if the caller didn't provide a send buffer, we just send a zero.
   1182              */
   1183              if (handle->remainingSendByteCount)
   \                     ??DSPI_MasterTransferHandleIRQ_0: (+1)
   \   00000088   0x69A8             LDR      R0,[R5, #+24]
   \   0000008A   0xB118             CBZ.N    R0,??DSPI_MasterTransferHandleIRQ_8
   1184              {
   1185                  DSPI_MasterFillUpTxFifo(base, handle);
   \   0000008C   0x4629             MOV      R1,R5
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       DSPI_MasterFillUpTxFifo
   1186              }
   1187          
   1188              /* Check if we're done with this transfer.*/
   1189              if ((handle->remainingSendByteCount == 0) && (handle->remainingReceiveByteCount == 0))
   \                     ??DSPI_MasterTransferHandleIRQ_8: (+1)
   \   00000094   0x69A8             LDR      R0,[R5, #+24]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xBF04             ITT      EQ 
   \   0000009A   0x69E8             LDREQ    R0,[R5, #+28]
   \   0000009C   0x2800             CMPEQ    R0,#+0
   \   0000009E   0xD115             BNE.N    ??DSPI_MasterTransferHandleIRQ_9
   1190              {
   1191                  /* Complete the transfer and disable the interrupts */
   1192                  DSPI_MasterCompleteTransfer(base, handle);
   \   000000A0   0x6B20             LDR      R0,[R4, #+48]
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable25_14  ;; 0xfdfdffff
   \   000000A6   0x4008             ANDS     R0,R1,R0
   \   000000A8   0x6320             STR      R0,[R4, #+48]
   \   000000AA   0xF105 0x0624      ADD      R6,R5,#+36
   \   000000AE   0x2200             MOVS     R2,#+0
   \   000000B0   0x7830             LDRB     R0,[R6, #+0]
   \   000000B2   0x6877             LDR      R7,[R6, #+4]
   \   000000B4   0x2802             CMP      R0,#+2
   \   000000B6   0xBF08             IT       EQ 
   \   000000B8   0xF240 0x2259      MOVWEQ   R2,#+601
   \   000000BC   0x0038             MOVS     R0,R7
   \   000000BE   0xD003             BEQ.N    ??DSPI_MasterTransferHandleIRQ_10
   \   000000C0   0x68B3             LDR      R3,[R6, #+8]
   \   000000C2   0x4629             MOV      R1,R5
   \   000000C4   0x4620             MOV      R0,R4
   \   000000C6   0x47B8             BLX      R7
   \                     ??DSPI_MasterTransferHandleIRQ_10: (+1)
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x7030             STRB     R0,[R6, #+0]
   1193              }
   1194          }
   \                     ??DSPI_MasterTransferHandleIRQ_9: (+1)
   \   000000CC   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1195          
   1196          /*Transactional APIs -- Slave*/

   \                                 In section .text, align 2, keep-with-next
   1197          void DSPI_SlaveTransferCreateHandle(SPI_Type *base,
   1198                                              dspi_slave_handle_t *handle,
   1199                                              dspi_slave_transfer_callback_t callback,
   1200                                              void *userData)
   1201          {
   \                     DSPI_SlaveTransferCreateHandle: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
   1202              assert(handle);
   1203          
   1204              /* Zero the handle. */
   1205              memset(handle, 0, sizeof(*handle));
   \   0000000A   0x212C             MOVS     R1,#+44
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0x.... 0x....      BL       __aeabi_memclr4
   1206          
   1207              g_dspiHandle[DSPI_GetInstance(base)] = handle;
   \   00000012   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000016   0x....             LDR.N    R1,??DataTable25_8
   \   00000018   0xF841 0x5020      STR      R5,[R1, R0, LSL #+2]
   1208          
   1209              handle->callback = callback;
   \   0000001C   0x626E             STR      R6,[R5, #+36]
   1210              handle->userData = userData;
   \   0000001E   0x62AF             STR      R7,[R5, #+40]
   1211          }
   \   00000020   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1212          

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x0840             LSRS     R0,R0,#+1
   \   00000004   0x0040             LSLS     R0,R0,#+1
   \   00000006   0x6020             STR      R0,[R4, #+0]
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   1213          status_t DSPI_SlaveTransferNonBlocking(SPI_Type *base, dspi_slave_handle_t *handle, dspi_transfer_t *transfer)
   1214          {
   \                     DSPI_SlaveTransferNonBlocking: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4616             MOV      R6,R2
   \   00000004   0x4604             MOV      R4,R0
   1215              assert(handle && transfer);
   1216          
   1217              /* If receive length is zero */
   1218              if (transfer->dataSize == 0)
   \   00000006   0x68B0             LDR      R0,[R6, #+8]
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0xB128             CBZ.N    R0,??DSPI_SlaveTransferNonBlocking_0
   1219              {
   1220                  return kStatus_InvalidArgument;
   1221              }
   1222          
   1223              /* If both send buffer and receive buffer is null */
   1224              if ((!(transfer->txData)) && (!(transfer->rxData)))
   \   0000000C   0x6830             LDR      R0,[R6, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xBF04             ITT      EQ 
   \   00000012   0x6870             LDREQ    R0,[R6, #+4]
   \   00000014   0x2800             CMPEQ    R0,#+0
   \   00000016   0xD101             BNE.N    ??DSPI_SlaveTransferNonBlocking_1
   1225              {
   1226                  return kStatus_InvalidArgument;
   \                     ??DSPI_SlaveTransferNonBlocking_0: (+1)
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0xBD70             POP      {R4-R6,PC}
   1227              }
   1228          
   1229              /* Check that we're not busy.*/
   1230              if (handle->state == kDSPI_Busy)
   \                     ??DSPI_SlaveTransferNonBlocking_1: (+1)
   \   0000001C   0x7F28             LDRB     R0,[R5, #+28]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD102             BNE.N    ??DSPI_SlaveTransferNonBlocking_2
   1231              {
   1232                  return kStatus_DSPI_Busy;
   \   00000022   0xF44F 0x7016      MOV      R0,#+600
   \   00000026   0xBD70             POP      {R4-R6,PC}
   1233              }
   1234              handle->state = kDSPI_Busy;
   \                     ??DSPI_SlaveTransferNonBlocking_2: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x7728             STRB     R0,[R5, #+28]
   1235          
   1236              /* Enable the NVIC for DSPI peripheral. */
   1237              EnableIRQ(s_dspiIRQ[DSPI_GetInstance(base)]);
   \   0000002C   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_8: (+1)
   \   00000030   0x.... 0x....      BL       ?Subroutine14
   1238          
   1239              /* Store transfer information */
   1240              handle->txData = transfer->txData;
   \                     ??CrossCallReturnLabel_35: (+1)
   \   00000034   0x6830             LDR      R0,[R6, #+0]
   \   00000036   0x60A8             STR      R0,[R5, #+8]
   1241              handle->rxData = transfer->rxData;
   1242              handle->remainingSendByteCount = transfer->dataSize;
   1243              handle->remainingReceiveByteCount = transfer->dataSize;
   1244              handle->totalByteCount = transfer->dataSize;
   1245          
   1246              handle->errorCount = 0;
   1247          
   1248              uint8_t whichCtar = (transfer->configFlags & DSPI_SLAVE_CTAR_MASK) >> DSPI_SLAVE_CTAR_SHIFT;
   1249              handle->bitsPerFrame =
   1250                  (((base->CTAR_SLAVE[whichCtar]) & SPI_CTAR_SLAVE_FMSZ_MASK) >> SPI_CTAR_SLAVE_FMSZ_SHIFT) + 1;
   1251          
   1252              DSPI_StopTransfer(base);
   1253          
   1254              DSPI_FlushFifo(base, true, true);
   \   00000038   0x2201             MOVS     R2,#+1
   \   0000003A   0x6870             LDR      R0,[R6, #+4]
   \   0000003C   0x60E8             STR      R0,[R5, #+12]
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0x68B0             LDR      R0,[R6, #+8]
   \   00000042   0x6128             STR      R0,[R5, #+16]
   \   00000044   0x68B0             LDR      R0,[R6, #+8]
   \   00000046   0x6168             STR      R0,[R5, #+20]
   \   00000048   0x68B0             LDR      R0,[R6, #+8]
   \   0000004A   0x61A8             STR      R0,[R5, #+24]
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x6228             STR      R0,[R5, #+32]
   \   00000050   0x7B30             LDRB     R0,[R6, #+12]
   \   00000052   0xF000 0x0007      AND      R0,R0,#0x7
   \   00000056   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   0000005A   0x68C0             LDR      R0,[R0, #+12]
   \   0000005C   0x0EC0             LSRS     R0,R0,#+27
   \   0000005E   0x1C40             ADDS     R0,R0,#+1
   \   00000060   0x6028             STR      R0,[R5, #+0]
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x.... 0x....      BL       ??Subroutine3_0
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000068   0x.... 0x....      BL       ??Subroutine12_0
   1255              DSPI_ClearStatusFlags(base, kDSPI_AllStatusFlag);
   \                     ??CrossCallReturnLabel_30: (+1)
   \   0000006C   0x....             LDR.N    R0,??DataTable25_10  ;; 0xda0a0000
   \   0000006E   0x62E0             STR      R0,[R4, #+44]
   1256          
   1257              DSPI_StartTransfer(base);
   1258          
   1259              /* Prepare data to transmit */
   1260              DSPI_SlaveFillUpTxFifo(base, handle);
   \   00000070   0x4629             MOV      R1,R5
   \   00000072   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_16: (+1)
   \   00000076   0x4620             MOV      R0,R4
   \   00000078   0x.... 0x....      BL       DSPI_SlaveFillUpTxFifo
   1261          
   1262              s_dspiSlaveIsr = DSPI_SlaveTransferHandleIRQ;
   \   0000007C   0x....             LDR.N    R1,??DataTable25_13
   \   0000007E   0x.... 0x....      ADR.W    R0,DSPI_SlaveTransferHandleIRQ
   \   00000082   0x6048             STR      R0,[R1, #+4]
   1263          
   1264              /* Enable RX FIFO drain request, the slave only use this interrupt */
   1265              DSPI_EnableInterrupts(base, kDSPI_RxFifoDrainRequestInterruptEnable);
   \   00000084   0x.... 0x....      BL       ?Subroutine7
   1266          
   1267              if (handle->rxData)
   \                     ??CrossCallReturnLabel_19: (+1)
   \   00000088   0x68E8             LDR      R0,[R5, #+12]
   \   0000008A   0xB118             CBZ.N    R0,??CrossCallReturnLabel_18
   1268              {
   1269                  /* RX FIFO overflow request enable */
   1270                  DSPI_EnableInterrupts(base, kDSPI_RxFifoOverflowInterruptEnable);
   \   0000008C   0xF44F 0x2100      MOV      R1,#+524288
   \   00000090   0x.... 0x....      BL       ??Subroutine7_0
   1271              }
   1272              if (handle->txData)
   \                     ??CrossCallReturnLabel_18: (+1)
   \   00000094   0x68A8             LDR      R0,[R5, #+8]
   \   00000096   0xB118             CBZ.N    R0,??CrossCallReturnLabel_17
   1273              {
   1274                  /* TX FIFO underflow request enable */
   1275                  DSPI_EnableInterrupts(base, kDSPI_TxFifoUnderflowInterruptEnable);
   \   00000098   0xF04F 0x6100      MOV      R1,#+134217728
   \   0000009C   0x.... 0x....      BL       ??Subroutine7_0
   1276              }
   1277          
   1278              return kStatus_Success;
   \                     ??CrossCallReturnLabel_17: (+1)
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xBD70             POP      {R4-R6,PC}       ;; return
   1279          }
   1280          

   \                                 In section .text, align 2, keep-with-next
   1281          status_t DSPI_SlaveTransferGetCount(SPI_Type *base, dspi_slave_handle_t *handle, size_t *count)
   1282          {
   1283              assert(handle);
   1284          
   1285              if (!count)
   \                     DSPI_SlaveTransferGetCount: (+1)
   \   00000000   0xB90A             CBNZ.N   R2,??DSPI_SlaveTransferGetCount_0
   1286              {
   1287                  return kStatus_InvalidArgument;
   \   00000002   0x2004             MOVS     R0,#+4
   \   00000004   0x4770             BX       LR
   1288              }
   1289          
   1290              /* Catch when there is not an active transfer. */
   1291              if (handle->state != kDSPI_Busy)
   \                     ??DSPI_SlaveTransferGetCount_0: (+1)
   \   00000006   0x7F08             LDRB     R0,[R1, #+28]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD000             BEQ.N    ??DSPI_SlaveTransferGetCount_1
   1292              {
   1293                  *count = 0;
   \   0000000C   0x....             B.N      ?Subroutine1
   1294                  return kStatus_NoTransferInProgress;
   1295              }
   1296          
   1297              *count = handle->totalByteCount - handle->remainingReceiveByteCount;
   \                     ??DSPI_SlaveTransferGetCount_1: (+1)
   \   0000000E   0x6988             LDR      R0,[R1, #+24]
   \   00000010   0x6949             LDR      R1,[R1, #+20]
   \   00000012   0x1A40             SUBS     R0,R0,R1
   \   00000014                      REQUIRE ?Subroutine2
   \   00000014                      ;; // Fall through to label ?Subroutine2
   1298              return kStatus_Success;
   1299          }
   1300          

   \                                 In section .text, align 2, keep-with-next
   1301          static void DSPI_SlaveFillUpTxFifo(SPI_Type *base, dspi_slave_handle_t *handle)
   1302          {
   1303              uint16_t transmitData = 0;
   1304              uint8_t dummyPattern = DSPI_SLAVE_DUMMY_DATA;
   \                     DSPI_SlaveFillUpTxFifo: (+1)
   \   00000000   0xE005             B.N      ??DSPI_SlaveFillUpTxFifo_0
   1305          
   1306              /* Service the transmitter, if transmit buffer provided, transmit the data,
   1307              * else transmit dummy pattern
   1308              */
   1309              while (DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag)
   1310              {
   1311                  /* Transmit data */
   1312                  if (handle->remainingSendByteCount > 0)
   1313                  {
   1314                      /* Have data to transmit, update the transmit data and push to FIFO */
   1315                      if (handle->bitsPerFrame <= 8)
   1316                      {
   1317                          /* bits/frame is 1 byte */
   1318                          if (handle->txData)
   1319                          {
   1320                              /* Update transmit data and transmit pointer */
   1321                              transmitData = *handle->txData;
   1322                              handle->txData++;
   1323                          }
   1324                          else
   1325                          {
   1326                              transmitData = dummyPattern;
   1327                          }
   1328          
   1329                          /* Decrease remaining dataSize */
   1330                          --handle->remainingSendByteCount;
   1331                      }
   1332                      /* bits/frame is 2 bytes */
   1333                      else
   1334                      {
   1335                          /* With multibytes per frame transmission, the transmit frame contains data from
   1336                          * transmit buffer until sent dataSize matches user request. Other bytes will set to
   1337                          * dummy pattern value.
   1338                          */
   1339                          if (handle->txData)
   1340                          {
   1341                              /* Update first byte of transmit data and transmit pointer */
   1342                              transmitData = *handle->txData;
   1343                              handle->txData++;
   1344          
   1345                              if (handle->remainingSendByteCount == 1)
   1346                              {
   1347                                  /* Decrease remaining dataSize */
   1348                                  --handle->remainingSendByteCount;
   1349                                  /* Update second byte of transmit data to second byte of dummy pattern */
   1350                                  transmitData = transmitData | (uint16_t)(((uint16_t)dummyPattern) << 8);
   1351                              }
   1352                              else
   1353                              {
   1354                                  /* Update second byte of transmit data and transmit pointer */
   1355                                  transmitData = transmitData | (uint16_t)((uint16_t)(*handle->txData) << 8);
   1356                                  handle->txData++;
   1357                                  handle->remainingSendByteCount -= 2;
   1358                              }
   1359                          }
   1360                          else
   1361                          {
   1362                              if (handle->remainingSendByteCount == 1)
   1363                              {
   1364                                  --handle->remainingSendByteCount;
   1365                              }
   1366                              else
   1367                              {
   1368                                  handle->remainingSendByteCount -= 2;
   \                     ??DSPI_SlaveFillUpTxFifo_1: (+1)
   \   00000002   0x610A             STR      R2,[R1, #+16]
   1369                              }
   1370                              transmitData = (uint16_t)((uint16_t)(dummyPattern) << 8) | dummyPattern;
   \   00000004   0x2200             MOVS     R2,#+0
   1371                          }
   1372                      }
   1373                  }
   1374                  else
   1375                  {
   1376                      break;
   1377                  }
   1378          
   1379                  /* Write the data to the DSPI data register */
   1380                  base->PUSHR_SLAVE = transmitData;
   \                     ??DSPI_SlaveFillUpTxFifo_2: (+1)
   \   00000006   0x6342             STR      R2,[R0, #+52]
   1381          
   1382                  /* Try to clear TFFF by writing a one to it; it will not clear if TX FIFO not full */
   1383                  DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \   00000008   0xF04F 0x7200      MOV      R2,#+33554432
   \   0000000C   0x62C2             STR      R2,[R0, #+44]
   \                     ??DSPI_SlaveFillUpTxFifo_0: (+1)
   \   0000000E   0x6AC2             LDR      R2,[R0, #+44]
   \   00000010   0x0192             LSLS     R2,R2,#+6
   \   00000012   0xD529             BPL.N    ??DSPI_SlaveFillUpTxFifo_3
   \   00000014   0x690A             LDR      R2,[R1, #+16]
   \   00000016   0xB33A             CBZ.N    R2,??DSPI_SlaveFillUpTxFifo_3
   \   00000018   0x680A             LDR      R2,[R1, #+0]
   \   0000001A   0x2A09             CMP      R2,#+9
   \   0000001C   0x688A             LDR      R2,[R1, #+8]
   \   0000001E   0xD209             BCS.N    ??DSPI_SlaveFillUpTxFifo_4
   \   00000020   0xB122             CBZ.N    R2,??DSPI_SlaveFillUpTxFifo_5
   \   00000022   0x688A             LDR      R2,[R1, #+8]
   \   00000024   0x7812             LDRB     R2,[R2, #+0]
   \   00000026   0x688B             LDR      R3,[R1, #+8]
   \   00000028   0x1C5B             ADDS     R3,R3,#+1
   \   0000002A   0x608B             STR      R3,[R1, #+8]
   \                     ??DSPI_SlaveFillUpTxFifo_5: (+1)
   \   0000002C   0x690B             LDR      R3,[R1, #+16]
   \   0000002E   0x1E5B             SUBS     R3,R3,#+1
   \                     ??DSPI_SlaveFillUpTxFifo_6: (+1)
   \   00000030   0x610B             STR      R3,[R1, #+16]
   \   00000032   0xE7E8             B.N      ??DSPI_SlaveFillUpTxFifo_2
   \                     ??DSPI_SlaveFillUpTxFifo_4: (+1)
   \   00000034   0xB18A             CBZ.N    R2,??DSPI_SlaveFillUpTxFifo_7
   \   00000036   0x688A             LDR      R2,[R1, #+8]
   \   00000038   0x7812             LDRB     R2,[R2, #+0]
   \   0000003A   0x688B             LDR      R3,[R1, #+8]
   \   0000003C   0x1C5B             ADDS     R3,R3,#+1
   \   0000003E   0x608B             STR      R3,[R1, #+8]
   \   00000040   0x690B             LDR      R3,[R1, #+16]
   \   00000042   0x2B01             CMP      R3,#+1
   \   00000044   0xD0F2             BEQ.N    ??DSPI_SlaveFillUpTxFifo_5
   \   00000046   0x688B             LDR      R3,[R1, #+8]
   \   00000048   0x781B             LDRB     R3,[R3, #+0]
   \   0000004A   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   0000004E   0x688B             LDR      R3,[R1, #+8]
   \   00000050   0x1C5B             ADDS     R3,R3,#+1
   \   00000052   0x608B             STR      R3,[R1, #+8]
   \   00000054   0x690B             LDR      R3,[R1, #+16]
   \   00000056   0x1E9B             SUBS     R3,R3,#+2
   \   00000058   0xE7EA             B.N      ??DSPI_SlaveFillUpTxFifo_6
   \                     ??DSPI_SlaveFillUpTxFifo_7: (+1)
   \   0000005A   0x690A             LDR      R2,[R1, #+16]
   \   0000005C   0x2A01             CMP      R2,#+1
   \   0000005E   0x690A             LDR      R2,[R1, #+16]
   \   00000060   0xBF0C             ITE      EQ 
   \   00000062   0x1E52             SUBEQ    R2,R2,#+1
   \   00000064   0x1E92             SUBNE    R2,R2,#+2
   \   00000066   0xE7CC             B.N      ??DSPI_SlaveFillUpTxFifo_1
   1384              }
   1385          }
   \                     ??DSPI_SlaveFillUpTxFifo_3: (+1)
   \   00000068   0x4770             BX       LR               ;; return
   1386          
   1387          static void DSPI_SlaveCompleteTransfer(SPI_Type *base, dspi_slave_handle_t *handle)
   1388          {
   1389              /* Disable interrupt requests */
   1390              DSPI_DisableInterrupts(base, kDSPI_TxFifoUnderflowInterruptEnable | kDSPI_TxFifoFillRequestInterruptEnable |
   1391                                               kDSPI_RxFifoOverflowInterruptEnable | kDSPI_RxFifoDrainRequestInterruptEnable);
   1392          
   1393              /* The transfer is complete. */
   1394              handle->txData = NULL;
   1395              handle->rxData = NULL;
   1396              handle->remainingReceiveByteCount = 0;
   1397              handle->remainingSendByteCount = 0;
   1398          
   1399              status_t status = 0;
   1400              if (handle->state == kDSPI_Error)
   1401              {
   1402                  status = kStatus_DSPI_Error;
   1403              }
   1404              else
   1405              {
   1406                  status = kStatus_Success;
   1407              }
   1408          
   1409              if (handle->callback)
   1410              {
   1411                  handle->callback(base, handle, status, handle->userData);
   1412              }
   1413          
   1414              handle->state = kDSPI_Idle;
   1415          }
   1416          

   \                                 In section .text, align 2, keep-with-next
   1417          void DSPI_SlaveTransferAbort(SPI_Type *base, dspi_slave_handle_t *handle)
   1418          {
   1419              DSPI_StopTransfer(base);
   \                     DSPI_SlaveTransferAbort: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   1420          
   1421              /* Disable interrupt requests */
   1422              DSPI_DisableInterrupts(base, kDSPI_TxFifoUnderflowInterruptEnable | kDSPI_TxFifoFillRequestInterruptEnable |
   1423                                               kDSPI_RxFifoOverflowInterruptEnable | kDSPI_RxFifoDrainRequestInterruptEnable);
   \   00000002   0x....             LDR.N    R3,??DataTable25_16  ;; 0xf5f5ffff
   \   00000004   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000008   0x6002             STR      R2,[R0, #+0]
   \   0000000A   0x6B02             LDR      R2,[R0, #+48]
   \   0000000C   0x401A             ANDS     R2,R3,R2
   \   0000000E   0x6302             STR      R2,[R0, #+48]
   1424          
   1425              handle->state = kDSPI_Idle;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x7708             STRB     R0,[R1, #+28]
   1426              handle->remainingSendByteCount = 0;
   \   00000014   0x6108             STR      R0,[R1, #+16]
   1427              handle->remainingReceiveByteCount = 0;
   \   00000016   0x6148             STR      R0,[R1, #+20]
   1428          }
   \   00000018   0x4770             BX       LR               ;; return
   1429          

   \                                 In section .text, align 4, keep-with-next
   1430          void DSPI_SlaveTransferHandleIRQ(SPI_Type *base, dspi_slave_handle_t *handle)
   1431          {
   \                     DSPI_SlaveTransferHandleIRQ: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
   1432              uint8_t dummyPattern = DSPI_SLAVE_DUMMY_DATA;
   1433              uint32_t dataReceived;
   1434              uint32_t dataSend = 0;
   1435          
   1436              /* Because SPI protocol is synchronous, the number of bytes that that slave received from the
   1437              * master is the actual number of bytes that the slave transmitted to the master. So we only
   1438              * monitor the received dataSize to know when the transfer is complete.
   1439              */
   1440              if (handle->remainingReceiveByteCount > 0)
   \   00000004   0x6961             LDR      R1,[R4, #+20]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD05F             BEQ.N    ??DSPI_SlaveTransferHandleIRQ_0
   1441              {
   1442                  while (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
   \                     ??DSPI_SlaveTransferHandleIRQ_1: (+1)
   \   0000000A   0x6AC1             LDR      R1,[R0, #+44]
   \   0000000C   0x0389             LSLS     R1,R1,#+14
   \   0000000E   0xD55C             BPL.N    ??DSPI_SlaveTransferHandleIRQ_0
   1443                  {
   1444                      /* Have received data in the buffer. */
   1445                      dataReceived = base->POPR;
   \   00000010   0x6B81             LDR      R1,[R0, #+56]
   1446                      /*Clear the rx fifo drain request, needed for non-DMA applications as this flag
   1447                      * will remain set even if the rx fifo is empty. By manually clearing this flag, it
   1448                      * either remain clear if no more data is in the fifo, or it will set if there is
   1449                      * more data in the fifo.
   1450                      */
   1451                      DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
   \   00000012   0xF44F 0x3200      MOV      R2,#+131072
   \   00000016   0x62C2             STR      R2,[R0, #+44]
   1452          
   1453                      /* If bits/frame is one byte */
   1454                      if (handle->bitsPerFrame <= 8)
   \   00000018   0x6822             LDR      R2,[R4, #+0]
   \   0000001A   0x2A09             CMP      R2,#+9
   \   0000001C   0x68E2             LDR      R2,[R4, #+12]
   \   0000001E   0xD212             BCS.N    ??DSPI_SlaveTransferHandleIRQ_2
   1455                      {
   1456                          if (handle->rxData)
   \   00000020   0xB122             CBZ.N    R2,??DSPI_SlaveTransferHandleIRQ_3
   1457                          {
   1458                              /* Receive buffer is not null, store data into it */
   1459                              *handle->rxData = dataReceived;
   \   00000022   0x68E2             LDR      R2,[R4, #+12]
   \   00000024   0x7011             STRB     R1,[R2, #+0]
   1460                              ++handle->rxData;
   \   00000026   0x68E1             LDR      R1,[R4, #+12]
   \   00000028   0x1C49             ADDS     R1,R1,#+1
   \   0000002A   0x60E1             STR      R1,[R4, #+12]
   1461                          }
   1462                          /* Descrease remaining receive byte count */
   1463                          --handle->remainingReceiveByteCount;
   \                     ??DSPI_SlaveTransferHandleIRQ_3: (+1)
   \   0000002C   0x6961             LDR      R1,[R4, #+20]
   \   0000002E   0x1E49             SUBS     R1,R1,#+1
   \   00000030   0x6161             STR      R1,[R4, #+20]
   1464          
   1465                          if (handle->remainingSendByteCount > 0)
   \   00000032   0x6921             LDR      R1,[R4, #+16]
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xD042             BEQ.N    ??DSPI_SlaveTransferHandleIRQ_4
   1466                          {
   1467                              if (handle->txData)
   \   00000038   0x68A1             LDR      R1,[R4, #+8]
   \   0000003A   0xB109             CBZ.N    R1,??CrossCallReturnLabel_39
   1468                              {
   1469                                  dataSend = *handle->txData;
   \   0000003C   0x.... 0x....      BL       ?Subroutine16
   1470                                  ++handle->txData;
   1471                              }
   1472                              else
   1473                              {
   1474                                  dataSend = dummyPattern;
   1475                              }
   1476          
   1477                              --handle->remainingSendByteCount;
   \                     ??CrossCallReturnLabel_39: (+1)
   \   00000040   0x6922             LDR      R2,[R4, #+16]
   \   00000042   0x1E52             SUBS     R2,R2,#+1
   \   00000044   0xE030             B.N      ??DSPI_SlaveTransferHandleIRQ_5
   1478                              /* Write the data to the DSPI data register */
   1479                              base->PUSHR_SLAVE = dataSend;
   1480                          }
   1481                      }
   1482                      else /* If bits/frame is 2 bytes */
   1483                      {
   1484                          /* With multibytes frame receiving, we only receive till the received dataSize
   1485                          * matches user request. Other bytes will be ignored.
   1486                          */
   1487                          if (handle->rxData)
   \                     ??DSPI_SlaveTransferHandleIRQ_2: (+1)
   \   00000046   0xB192             CBZ.N    R2,??DSPI_SlaveTransferHandleIRQ_6
   1488                          {
   1489                              /* Receive buffer is not null, store first byte into it */
   1490                              *handle->rxData = dataReceived;
   \   00000048   0x68E2             LDR      R2,[R4, #+12]
   \   0000004A   0x7011             STRB     R1,[R2, #+0]
   1491                              ++handle->rxData;
   \   0000004C   0x68E2             LDR      R2,[R4, #+12]
   \   0000004E   0x1C52             ADDS     R2,R2,#+1
   \   00000050   0x60E2             STR      R2,[R4, #+12]
   1492          
   1493                              if (handle->remainingReceiveByteCount == 1)
   \   00000052   0x6962             LDR      R2,[R4, #+20]
   \   00000054   0x2A01             CMP      R2,#+1
   \   00000056   0xD102             BNE.N    ??DSPI_SlaveTransferHandleIRQ_7
   1494                              {
   1495                                  /* Decrease remaining receive byte count */
   1496                                  --handle->remainingReceiveByteCount;
   \   00000058   0x6961             LDR      R1,[R4, #+20]
   \   0000005A   0x1E49             SUBS     R1,R1,#+1
   \   0000005C   0xE00E             B.N      ??DSPI_SlaveTransferHandleIRQ_8
   1497                              }
   1498                              else
   1499                              {
   1500                                  /* Receive buffer is not null, store second byte into it */
   1501                                  *handle->rxData = dataReceived >> 8;
   \                     ??DSPI_SlaveTransferHandleIRQ_7: (+1)
   \   0000005E   0x68E2             LDR      R2,[R4, #+12]
   \   00000060   0x0A09             LSRS     R1,R1,#+8
   \   00000062   0x7011             STRB     R1,[R2, #+0]
   1502                                  ++handle->rxData;
   \   00000064   0x68E1             LDR      R1,[R4, #+12]
   \   00000066   0x1C49             ADDS     R1,R1,#+1
   \   00000068   0x60E1             STR      R1,[R4, #+12]
   1503                                  handle->remainingReceiveByteCount -= 2;
   \   0000006A   0x6961             LDR      R1,[R4, #+20]
   \   0000006C   0xE005             B.N      ??DSPI_SlaveTransferHandleIRQ_9
   1504                              }
   1505                          }
   1506                          /* If no handle->rxData*/
   1507                          else
   1508                          {
   1509                              if (handle->remainingReceiveByteCount == 1)
   \                     ??DSPI_SlaveTransferHandleIRQ_6: (+1)
   \   0000006E   0x6961             LDR      R1,[R4, #+20]
   \   00000070   0x2901             CMP      R1,#+1
   \   00000072   0x6961             LDR      R1,[R4, #+20]
   \   00000074   0xBF08             IT       EQ 
   \   00000076   0x1E49             SUBEQ    R1,R1,#+1
   1510                              {
   1511                                  /* Decrease remaining receive byte count */
   1512                                  --handle->remainingReceiveByteCount;
   \   00000078   0xD000             BEQ.N    ??DSPI_SlaveTransferHandleIRQ_8
   1513                              }
   1514                              else
   1515                              {
   1516                                  handle->remainingReceiveByteCount -= 2;
   \                     ??DSPI_SlaveTransferHandleIRQ_9: (+1)
   \   0000007A   0x1E89             SUBS     R1,R1,#+2
   \                     ??DSPI_SlaveTransferHandleIRQ_8: (+1)
   \   0000007C   0x6161             STR      R1,[R4, #+20]
   1517                              }
   1518                          }
   1519          
   1520                          if (handle->remainingSendByteCount > 0)
   \   0000007E   0x6921             LDR      R1,[R4, #+16]
   \   00000080   0xB1E9             CBZ.N    R1,??DSPI_SlaveTransferHandleIRQ_4
   1521                          {
   1522                              if (handle->txData)
   \   00000082   0x68A1             LDR      R1,[R4, #+8]
   \   00000084   0xB191             CBZ.N    R1,??DSPI_SlaveTransferHandleIRQ_10
   1523                              {
   1524                                  dataSend = *handle->txData;
   \   00000086   0x.... 0x....      BL       ?Subroutine16
   1525                                  ++handle->txData;
   1526          
   1527                                  if (handle->remainingSendByteCount == 1)
   \                     ??CrossCallReturnLabel_40: (+1)
   \   0000008A   0x6922             LDR      R2,[R4, #+16]
   \   0000008C   0x2A01             CMP      R2,#+1
   \   0000008E   0xD102             BNE.N    ??DSPI_SlaveTransferHandleIRQ_11
   1528                                  {
   1529                                      --handle->remainingSendByteCount;
   \   00000090   0x6922             LDR      R2,[R4, #+16]
   \   00000092   0x1E52             SUBS     R2,R2,#+1
   \   00000094   0xE008             B.N      ??DSPI_SlaveTransferHandleIRQ_5
   1530                                      dataSend |= (uint16_t)((uint16_t)(dummyPattern) << 8);
   1531                                  }
   1532                                  else
   1533                                  {
   1534                                      dataSend |= (uint32_t)(*handle->txData) << 8;
   \                     ??DSPI_SlaveTransferHandleIRQ_11: (+1)
   \   00000096   0x68A2             LDR      R2,[R4, #+8]
   \   00000098   0x7812             LDRB     R2,[R2, #+0]
   \   0000009A   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   1535                                      ++handle->txData;
   \   0000009E   0x68A2             LDR      R2,[R4, #+8]
   \   000000A0   0x1C52             ADDS     R2,R2,#+1
   \   000000A2   0x60A2             STR      R2,[R4, #+8]
   1536                                      handle->remainingSendByteCount -= 2;
   \   000000A4   0x6922             LDR      R2,[R4, #+16]
   \   000000A6   0x1E92             SUBS     R2,R2,#+2
   \                     ??DSPI_SlaveTransferHandleIRQ_5: (+1)
   \   000000A8   0x6122             STR      R2,[R4, #+16]
   \   000000AA   0xE007             B.N      ??DSPI_SlaveTransferHandleIRQ_12
   1537                                  }
   1538                              }
   1539                              /* If no handle->txData*/
   1540                              else
   1541                              {
   1542                                  if (handle->remainingSendByteCount == 1)
   \                     ??DSPI_SlaveTransferHandleIRQ_10: (+1)
   \   000000AC   0x6921             LDR      R1,[R4, #+16]
   \   000000AE   0x2901             CMP      R1,#+1
   \   000000B0   0x6921             LDR      R1,[R4, #+16]
   \   000000B2   0xBF0C             ITE      EQ 
   \   000000B4   0x1E49             SUBEQ    R1,R1,#+1
   \   000000B6   0x1E89             SUBNE    R1,R1,#+2
   1543                                  {
   1544                                      --handle->remainingSendByteCount;
   1545                                  }
   1546                                  else
   1547                                  {
   1548                                      handle->remainingSendByteCount -= 2;
   \   000000B8   0x6121             STR      R1,[R4, #+16]
   1549                                  }
   1550                                  dataSend = (uint16_t)((uint16_t)(dummyPattern) << 8) | dummyPattern;
   \   000000BA   0x2100             MOVS     R1,#+0
   1551                              }
   1552                              /* Write the data to the DSPI data register */
   1553                              base->PUSHR_SLAVE = dataSend;
   \                     ??DSPI_SlaveTransferHandleIRQ_12: (+1)
   \   000000BC   0x6341             STR      R1,[R0, #+52]
   1554                          }
   1555                      }
   1556                      /* Try to clear TFFF by writing a one to it; it will not clear if TX FIFO not full */
   1557                      DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \                     ??DSPI_SlaveTransferHandleIRQ_4: (+1)
   \   000000BE   0xF04F 0x7100      MOV      R1,#+33554432
   \   000000C2   0x62C1             STR      R1,[R0, #+44]
   1558          
   1559                      if (handle->remainingReceiveByteCount == 0)
   \   000000C4   0x6961             LDR      R1,[R4, #+20]
   \   000000C6   0x2900             CMP      R1,#+0
   \   000000C8   0xD19F             BNE.N    ??DSPI_SlaveTransferHandleIRQ_1
   1560                      {
   1561                          break;
   1562                      }
   1563                  }
   1564              }
   1565              /* Check if remaining receive byte count matches user request */
   1566              if ((handle->remainingReceiveByteCount == 0) || (handle->state == kDSPI_Error))
   \                     ??DSPI_SlaveTransferHandleIRQ_0: (+1)
   \   000000CA   0x6961             LDR      R1,[R4, #+20]
   \   000000CC   0x2900             CMP      R1,#+0
   \   000000CE   0xBF1C             ITT      NE 
   \   000000D0   0x7F21             LDRBNE   R1,[R4, #+28]
   \   000000D2   0x2902             CMPNE    R1,#+2
   \   000000D4   0xD117             BNE.N    ??DSPI_SlaveTransferHandleIRQ_13
   1567              {
   1568                  /* Other cases, stop the transfer. */
   1569                  DSPI_SlaveCompleteTransfer(base, handle);
   \   000000D6   0x6B01             LDR      R1,[R0, #+48]
   \   000000D8   0x....             LDR.N    R2,??DataTable25_16  ;; 0xf5f5ffff
   \   000000DA   0x4011             ANDS     R1,R2,R1
   \   000000DC   0x6301             STR      R1,[R0, #+48]
   \   000000DE   0x2200             MOVS     R2,#+0
   \   000000E0   0x2100             MOVS     R1,#+0
   \   000000E2   0x60A1             STR      R1,[R4, #+8]
   \   000000E4   0x60E1             STR      R1,[R4, #+12]
   \   000000E6   0x6161             STR      R1,[R4, #+20]
   \   000000E8   0x6121             STR      R1,[R4, #+16]
   \   000000EA   0x7F21             LDRB     R1,[R4, #+28]
   \   000000EC   0x6A65             LDR      R5,[R4, #+36]
   \   000000EE   0x2902             CMP      R1,#+2
   \   000000F0   0xBF08             IT       EQ 
   \   000000F2   0xF240 0x2259      MOVWEQ   R2,#+601
   \   000000F6   0x0029             MOVS     R1,R5
   \   000000F8   0xD002             BEQ.N    ??DSPI_SlaveTransferHandleIRQ_14
   \   000000FA   0x6AA3             LDR      R3,[R4, #+40]
   \   000000FC   0x4621             MOV      R1,R4
   \   000000FE   0x47A8             BLX      R5
   \                     ??DSPI_SlaveTransferHandleIRQ_14: (+1)
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x7720             STRB     R0,[R4, #+28]
   1570                  return;
   \   00000104   0xBD31             POP      {R0,R4,R5,PC}
   1571              }
   1572          
   1573              /* Catch tx fifo underflow conditions, service only if tx under flow interrupt enabled */
   1574              if ((DSPI_GetStatusFlags(base) & kDSPI_TxFifoUnderflowFlag) && (base->RSER & SPI_RSER_TFUF_RE_MASK))
   \                     ??DSPI_SlaveTransferHandleIRQ_13: (+1)
   \   00000106   0x6AC1             LDR      R1,[R0, #+44]
   \   00000108   0x0109             LSLS     R1,R1,#+4
   \   0000010A   0xD50C             BPL.N    ??DSPI_SlaveTransferHandleIRQ_15
   \   0000010C   0x6B01             LDR      R1,[R0, #+48]
   \   0000010E   0x0109             LSLS     R1,R1,#+4
   \   00000110   0xD509             BPL.N    ??DSPI_SlaveTransferHandleIRQ_15
   1575              {
   1576                  DSPI_ClearStatusFlags(base, kDSPI_TxFifoUnderflowFlag);
   \   00000112   0xF04F 0x6100      MOV      R1,#+134217728
   \   00000116   0x62C1             STR      R1,[R0, #+44]
   1577                  /* Change state to error and clear flag */
   1578                  if (handle->txData)
   \   00000118   0x68A1             LDR      R1,[R4, #+8]
   \   0000011A   0xB109             CBZ.N    R1,??DSPI_SlaveTransferHandleIRQ_16
   1579                  {
   1580                      handle->state = kDSPI_Error;
   \   0000011C   0x2102             MOVS     R1,#+2
   \   0000011E   0x7721             STRB     R1,[R4, #+28]
   1581                  }
   1582                  handle->errorCount++;
   \                     ??DSPI_SlaveTransferHandleIRQ_16: (+1)
   \   00000120   0x6A21             LDR      R1,[R4, #+32]
   \   00000122   0x1C49             ADDS     R1,R1,#+1
   \   00000124   0x6221             STR      R1,[R4, #+32]
   1583              }
   1584              /* Catch rx fifo overflow conditions, service only if rx over flow interrupt enabled */
   1585              if ((DSPI_GetStatusFlags(base) & kDSPI_RxFifoOverflowFlag) && (base->RSER & SPI_RSER_RFOF_RE_MASK))
   \                     ??DSPI_SlaveTransferHandleIRQ_15: (+1)
   \   00000126   0x6AC1             LDR      R1,[R0, #+44]
   \   00000128   0x0309             LSLS     R1,R1,#+12
   \   0000012A   0xD50C             BPL.N    ??DSPI_SlaveTransferHandleIRQ_17
   \   0000012C   0x6B01             LDR      R1,[R0, #+48]
   \   0000012E   0x0309             LSLS     R1,R1,#+12
   \   00000130   0xD509             BPL.N    ??DSPI_SlaveTransferHandleIRQ_17
   1586              {
   1587                  DSPI_ClearStatusFlags(base, kDSPI_RxFifoOverflowFlag);
   \   00000132   0xF44F 0x2100      MOV      R1,#+524288
   \   00000136   0x62C1             STR      R1,[R0, #+44]
   1588                  /* Change state to error and clear flag */
   1589                  if (handle->txData)
   \   00000138   0x68A0             LDR      R0,[R4, #+8]
   \   0000013A   0xB108             CBZ.N    R0,??DSPI_SlaveTransferHandleIRQ_18
   1590                  {
   1591                      handle->state = kDSPI_Error;
   \   0000013C   0x2002             MOVS     R0,#+2
   \   0000013E   0x7720             STRB     R0,[R4, #+28]
   1592                  }
   1593                  handle->errorCount++;
   \                     ??DSPI_SlaveTransferHandleIRQ_18: (+1)
   \   00000140   0x6A20             LDR      R0,[R4, #+32]
   \   00000142   0x1C40             ADDS     R0,R0,#+1
   \   00000144   0x6220             STR      R0,[R4, #+32]
   1594              }
   1595          }
   \                     ??DSPI_SlaveTransferHandleIRQ_17: (+1)
   \   00000146   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine16: (+1)
   \   00000000   0x68A1             LDR      R1,[R4, #+8]
   \   00000002   0x7809             LDRB     R1,[R1, #+0]
   \   00000004   0x68A2             LDR      R2,[R4, #+8]
   \   00000006   0x1C52             ADDS     R2,R2,#+1
   \   00000008   0x60A2             STR      R2,[R4, #+8]
   \   0000000A   0x4770             BX       LR
   1596          

   \                                 In section .text, align 2, keep-with-next
   1597          static void DSPI_CommonIRQHandler(SPI_Type *base, void *param)
   1598          {
   1599              if (DSPI_IsMaster(base))
   \                     DSPI_CommonIRQHandler: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x....             LDR.N    R3,??DataTable25_13
   \   00000004   0x0FD2             LSRS     R2,R2,#+31
   \   00000006   0xBF1C             ITT      NE 
   1600              {
   1601                  s_dspiMasterIsr(base, (dspi_master_handle_t *)param);
   \   00000008   0x681A             LDRNE    R2,[R3, #+0]
   \   0000000A   0x4710             BXNE     R2
   1602              }
   1603              else
   1604              {
   1605                  s_dspiSlaveIsr(base, (dspi_slave_handle_t *)param);
   \   0000000C   0x685A             LDR      R2,[R3, #+4]
   \   0000000E   0x4710             BX       R2
   1606              }
   1607          }
   1608          
   1609          #if defined(SPI0)

   \                                 In section .text, align 2, keep-with-next
   1610          void SPI0_DriverIRQHandler(void)
   1611          {
   1612              assert(g_dspiHandle[0]);
   1613              DSPI_CommonIRQHandler(SPI0, g_dspiHandle[0]);
   \                     SPI0_DriverIRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable25_8
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x....             LDR.N    R0,??DataTable25_11  ;; 0x4002c000
   \   00000006   0x....             B.N      DSPI_CommonIRQHandler
   1614          }
   1615          #endif
   1616          
   1617          #if defined(SPI1)

   \                                 In section .text, align 2, keep-with-next
   1618          void SPI1_DriverIRQHandler(void)
   1619          {
   1620              assert(g_dspiHandle[1]);
   1621              DSPI_CommonIRQHandler(SPI1, g_dspiHandle[1]);
   \                     SPI1_DriverIRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable25_8
   \   00000002   0x6841             LDR      R1,[R0, #+4]
   \   00000004   0x....             LDR.N    R0,??DataTable25_12  ;; 0x4002d000
   \   00000006   0x....             B.N      DSPI_CommonIRQHandler
   1622          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \   00000000   0x0007A120         DC32     0x7a120

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \   00000000   0x7FFCFFF0         DC32     0x7ffcfff0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_3:
   \   00000000   0xFF3F0FFF         DC32     0xff3f0fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_4:
   \   00000000   0xFFCFF0FF         DC32     0xffcff0ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_5:
   \   00000000   0xFFF3FF0F         DC32     0xfff3ff0f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_6:
   \   00000000   0xEE6B2800         DC32     0xee6b2800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_7:
   \   00000000   0x3B9ACA00         DC32     0x3b9aca00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_8:
   \   00000000   0x........         DC32     g_dspiHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_9:
   \   00000000   0x65F5FFFF         DC32     0x65f5ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_10:
   \   00000000   0xDA0A0000         DC32     0xda0a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_11:
   \   00000000   0x4002C000         DC32     0x4002c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_12:
   \   00000000   0x4002D000         DC32     0x4002d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_13:
   \   00000000   0x........         DC32     s_dspiMasterIsr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_14:
   \   00000000   0xFDFDFFFF         DC32     0xfdfdffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_15:
   \   00000000   0xBAFFCCFF         DC32     0xbaffccff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_16:
   \   00000000   0xF5F5FFFF         DC32     0xf5f5ffff
   1623          #endif
   1624          
   1625          #if defined(SPI2)
   1626          void SPI2_DriverIRQHandler(void)
   1627          {
   1628              assert(g_dspiHandle[2]);
   1629              DSPI_CommonIRQHandler(SPI2, g_dspiHandle[2]);
   1630          }
   1631          #endif
   1632          
   1633          #if defined(SPI3)
   1634          void SPI3_DriverIRQHandler(void)
   1635          {
   1636              assert(g_dspiHandle[3]);
   1637              DSPI_CommonIRQHandler(SPI3, g_dspiHandle[3]);
   1638          }
   1639          #endif
   1640          
   1641          #if defined(SPI4)
   1642          void SPI4_DriverIRQHandler(void)
   1643          {
   1644              assert(g_dspiHandle[4]);
   1645              DSPI_CommonIRQHandler(SPI4, g_dspiHandle[4]);
   1646          }
   1647          #endif
   1648          
   1649          #if defined(SPI5)
   1650          void SPI5_DriverIRQHandler(void)
   1651          {
   1652              assert(g_dspiHandle[5]);
   1653              DSPI_CommonIRQHandler(SPI5, g_dspiHandle[5]);
   1654          }
   1655          #endif
   1656          
   1657          #if (FSL_FEATURE_SOC_DSPI_COUNT > 6)
   1658          #error "Should write the SPIx_DriverIRQHandler function that instance greater than 5 !"
   1659          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CLOCK_EnableClock
       0   DSPI_CommonIRQHandler
         0   -- Indirect call
       8   DSPI_Deinit
         8   -> DSPI_Enable
         8   -> DSPI_GetInstance
       0   DSPI_Enable
       0   DSPI_EnableInterrupts
       0   DSPI_FlushFifo
       0   DSPI_GetDefaultDataCommandConfig
       0   DSPI_GetInstance
       8   DSPI_MasterFillUpTxFifo
       0   DSPI_MasterGetDefaultConfig
       0   DSPI_MasterGetFormattedCommand
      24   DSPI_MasterInit
        24   -> CLOCK_EnableClock
        24   -> DSPI_Enable
        24   -> DSPI_GetInstance
        24   -> DSPI_MasterSetBaudRate
        24   -> DSPI_MasterSetDelayTimes
        24   -> DSPI_SetOnePcsPolarity
      24   DSPI_MasterPrepareTransfer
        24   -> DSPI_FlushFifo
        24   -> DSPI_MasterGetFormattedCommand
      48   DSPI_MasterSetBaudRate
       8   DSPI_MasterSetDelayScaler
      48   DSPI_MasterSetDelayTimes
        48   -> DSPI_MasterSetDelayScaler
       0   DSPI_MasterTransferAbort
      40   DSPI_MasterTransferBlocking
        40   -> DSPI_FlushFifo
        40   -> DSPI_MasterGetFormattedCommand
      24   DSPI_MasterTransferCreateHandle
        24   -> DSPI_GetInstance
        24   -> __aeabi_memclr4
       0   DSPI_MasterTransferGetCount
      24   DSPI_MasterTransferHandleIRQ
        24   -- Indirect call
        24   -> DSPI_MasterFillUpTxFifo
      16   DSPI_MasterTransferNonBlocking
        16   -> DSPI_EnableInterrupts
        16   -> DSPI_GetInstance
        16   -> DSPI_MasterFillUpTxFifo
        16   -> DSPI_MasterPrepareTransfer
        16   -> EnableIRQ
       0   DSPI_MasterWriteCommandDataBlocking
      12   DSPI_MasterWriteDataBlocking
       0   DSPI_SetOnePcsPolarity
       0   DSPI_SlaveFillUpTxFifo
       0   DSPI_SlaveGetDefaultConfig
      16   DSPI_SlaveInit
        16   -> CLOCK_EnableClock
        16   -> DSPI_Enable
        16   -> DSPI_GetInstance
        16   -> DSPI_SetOnePcsPolarity
       0   DSPI_SlaveTransferAbort
      24   DSPI_SlaveTransferCreateHandle
        24   -> DSPI_GetInstance
        24   -> __aeabi_memclr4
       0   DSPI_SlaveTransferGetCount
      16   DSPI_SlaveTransferHandleIRQ
        16   -- Indirect call
      16   DSPI_SlaveTransferNonBlocking
        16   -> DSPI_EnableInterrupts
        16   -> DSPI_FlushFifo
        16   -> DSPI_GetInstance
        16   -> DSPI_SlaveFillUpTxFifo
        16   -> EnableIRQ
       0   DSPI_SlaveWriteDataBlocking
       0   EnableIRQ
       0   SPI0_DriverIRQHandler
         0   -> DSPI_CommonIRQHandler
       0   SPI1_DriverIRQHandler
         0   -> DSPI_CommonIRQHandler


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_10
       4  ??DataTable25_11
       4  ??DataTable25_12
       4  ??DataTable25_13
       4  ??DataTable25_14
       4  ??DataTable25_15
       4  ??DataTable25_16
       4  ??DataTable25_2
       4  ??DataTable25_3
       4  ??DataTable25_4
       4  ??DataTable25_5
       4  ??DataTable25_6
       4  ??DataTable25_7
       4  ??DataTable25_8
       4  ??DataTable25_9
      32  ?Subroutine0
       8  ?Subroutine1
      22  ?Subroutine10
      14  ?Subroutine11
       6  ?Subroutine12
      14  ?Subroutine13
      10  ?Subroutine14
      16  ?Subroutine15
      12  ?Subroutine16
       6  ?Subroutine2
      12  ?Subroutine3
      10  ?Subroutine4
       4  ?Subroutine5
      10  ?Subroutine6
       8  ?Subroutine7
       6  ?Subroutine8
      12  ?Subroutine9
      24  CLOCK_EnableClock
      16  DSPI_CommonIRQHandler
      54  DSPI_Deinit
      18  DSPI_Enable
      32  DSPI_EnableInterrupts
      18  DSPI_FlushFifo
      18  DSPI_GetDefaultDataCommandConfig
      24  DSPI_GetInstance
     164  DSPI_MasterFillUpTxFifo
      54  DSPI_MasterGetDefaultConfig
      38  DSPI_MasterGetFormattedCommand
     198  DSPI_MasterInit
     142  DSPI_MasterPrepareTransfer
     158  DSPI_MasterSetBaudRate
     104  DSPI_MasterSetDelayScaler
     170  DSPI_MasterSetDelayTimes
      26  DSPI_MasterTransferAbort
     538  DSPI_MasterTransferBlocking
      36  DSPI_MasterTransferCreateHandle
      26  DSPI_MasterTransferGetCount
     206  DSPI_MasterTransferHandleIRQ
      78  DSPI_MasterTransferNonBlocking
       2  DSPI_MasterWriteCommandDataBlocking
      72  DSPI_MasterWriteDataBlocking
      22  DSPI_SetOnePcsPolarity
     106  DSPI_SlaveFillUpTxFifo
      24  DSPI_SlaveGetDefaultConfig
     116  DSPI_SlaveInit
      26  DSPI_SlaveTransferAbort
      34  DSPI_SlaveTransferCreateHandle
      20  DSPI_SlaveTransferGetCount
     328  DSPI_SlaveTransferHandleIRQ
     164  DSPI_SlaveTransferNonBlocking
       2  DSPI_SlaveWriteDataBlocking
      20  EnableIRQ
       8  SPI0_DriverIRQHandler
       8  SPI1_DriverIRQHandler
       8  g_dspiHandle
      16  s_baudratePrescaler
      64  s_baudrateScaler
      16  s_delayPrescaler
      64  s_delayScaler
       8  s_dspiBases
       8  s_dspiClock
       2  s_dspiIRQ
       8  s_dspiMasterIsr
          s_dspiSlaveIsr

 
    16 bytes in section .bss
 3 542 bytes in section .text
 
 3 542 bytes of CODE memory
    16 bytes of DATA memory

Errors: none
Warnings: none
