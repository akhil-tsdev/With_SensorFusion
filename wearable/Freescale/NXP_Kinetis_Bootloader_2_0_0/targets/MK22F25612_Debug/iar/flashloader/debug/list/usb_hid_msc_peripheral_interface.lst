###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Aug/2016  13:16:03
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\usb_hid_msc_peripheral_interface.c
#    Command line =  
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\usb_hid_msc_peripheral_interface.c"
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN256VDC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D BL_TARGET_RAM -lC
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj"
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices/MK22F25612\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/autobaud\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/osa\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device/class\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/bm_usb\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/CMSIS/Include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers/common\"
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list\usb_hid_msc_peripheral_interface.lst
#    Object file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj\usb_hid_msc_peripheral_interface.o
#
###############################################################################

C:\Users\cwati\Documents\My Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\usb_hid_msc_peripheral_interface.c
      1          /*
      2           * Copyright (c) 2013, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "bootloader/bl_context.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void debug_printf(char const *, ...)
   \                     debug_printf: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB500             PUSH     {LR}
   \   00000004   0xA901             ADD      R1,SP,#+4
   \   00000006   0x.... 0x....      BL       vprintf
   \   0000000A   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
     32          #include "bootloader/bootloader.h"
     33          #include "bootloader_common.h"
     34          #include "fsl_device_registers.h"
     35          #include "bootloader_core.h"
     36          #include "sbloader/sbloader.h"
     37          #include "sbloader/sb_file_format.h"
     38          #include "bootloader_hid_report_ids.h"
     39          #include "utilities/fsl_rtos_abstraction.h"
     40          #include <string.h>
     41          #include "property/property.h"
     42          #include "usb_descriptor.h"
     43          
     44          #include "usb_device_config.h"
     45          #include "usb.h"
     46          #include "usb_device.h"
     47          
     48          #include "usb_device_class.h"
     49          #include "usb_device_msc.h"
     50          #include "usb_device_hid.h"
     51          #include "usb_device_ch9.h"
     52          #include "usb_descriptor.h"
     53          
     54          #include "composite.h"
     55          
     56          #include <stdio.h>
     57          #include <stdlib.h>
     58          
     59          #if defined(K65F18_SERIES)
     60          #include "MK65F18_INV.h"
     61          #endif
     62          
     63          #if (BL_CONFIG_USB_HID || BL_CONFIG_HS_USB_HID || BL_CONFIG_USB_MSC || BL_CONFIG_HS_USB_MSC)
     64          
     65          //! @addtogroup usb_hid_peripheral
     66          //! @{
     67          
     68          ////////////////////////////////////////////////////////////////////////////////
     69          // Definitions
     70          ////////////////////////////////////////////////////////////////////////////////
     71          #define REQ_DATA_SIZE (1)
     72          
     73          #define USB_HID_INDEX (0)
     74          #define USB_MSC_INDEX (1)
     75          
     76          ////////////////////////////////////////////////////////////////////////////////
     77          // Prototypes
     78          ////////////////////////////////////////////////////////////////////////////////
     79          
     80          static bool usb_hid_poll_for_activity(const peripheral_descriptor_t *self);
     81          static status_t usb_device_full_init(const peripheral_descriptor_t *self, serial_byte_receive_func_t function);
     82          static void usb_device_full_shutdown(const peripheral_descriptor_t *self);
     83          static void usb_msc_pump(const peripheral_descriptor_t *self);
     84          
     85          static status_t usb_hid_packet_init(const peripheral_descriptor_t *self);
     86          static status_t usb_hid_packet_read(const peripheral_descriptor_t *self,
     87                                              uint8_t **packet,
     88                                              uint32_t *packetLength,
     89                                              packet_type_t packetType);
     90          static status_t usb_hid_packet_write(const peripheral_descriptor_t *self,
     91                                               const uint8_t *packet,
     92                                               uint32_t byteCount,
     93                                               packet_type_t packetType);
     94          static void usb_hid_packet_abort_data_phase(const peripheral_descriptor_t *self);
     95          static status_t usb_hid_packet_finalize(const peripheral_descriptor_t *self);
     96          static uint32_t usb_hid_packet_get_max_packet_size(const peripheral_descriptor_t *self);
     97          
     98          // static bool s_dHidMscActivity[USB_COMPOSITE_INTERFACE_COUNT] = {false};

   \                                 In section .bss, align 2
     99          static bool s_dHidMscActivity[2] = { false };
   \                     s_dHidMscActivity:
   \   00000000                      DS8 2
    100          
    101          ////////////////////////////////////////////////////////////////////////////////
    102          // Variables
    103          ////////////////////////////////////////////////////////////////////////////////
    104          

   \                                 In section .rodata, align 4, keep-with-next
    105          const peripheral_control_interface_t g_usbHidControlInterface = {.pollForActivity = usb_hid_poll_for_activity,
   \                     g_usbHidControlInterface:
   \   00000000   0x........         DC32 usb_hid_poll_for_activity, usb_device_full_init
   \              0x........   
   \   00000008   0x........         DC32 usb_device_full_shutdown, usb_msc_pump
   \              0x........   
    106                                                                           .init = usb_device_full_init,
    107                                                                           .shutdown = usb_device_full_shutdown,
    108                                                                           .pump = usb_msc_pump };
    109          

   \                                 In section .rodata, align 4, keep-with-next
    110          const peripheral_packet_interface_t g_usbHidPacketInterface = {.init = usb_hid_packet_init,
   \                     g_usbHidPacketInterface:
   \   00000000   0x........         DC32 usb_hid_packet_init, usb_hid_packet_read, usb_hid_packet_write
   \              0x........   
   \              0x........   
   \   0000000C   0x........         DC32 usb_hid_packet_abort_data_phase, usb_hid_packet_finalize
   \              0x........   
   \   00000014   0x........         DC32 usb_hid_packet_get_max_packet_size, 0H
   \              0x00000000   
    111                                                                         .readPacket = usb_hid_packet_read,
    112                                                                         .writePacket = usb_hid_packet_write,
    113                                                                         .abortDataPhase = usb_hid_packet_abort_data_phase,
    114                                                                         .finalize = usb_hid_packet_finalize,
    115                                                                         .getMaxPacketSize = usb_hid_packet_get_max_packet_size,
    116                                                                         .byteReceivedCallback = 0 };
    117          

   \                                 In section .bss, align 4
    118          static usb_device_composite_struct_t g_device_composite;
   \                     g_device_composite:
   \   00000000                      DS8 1152
    119          
    120          usb_status_t usb_device_callback(usb_device_handle handle, uint32_t event, void *param);
    121          
    122          extern usb_status_t usb_device_msc_callback(class_handle_t handle, uint32_t event, void *param);
    123          
    124          ////////////////////////////////////////////////////////////////////////////////
    125          // Code
    126          ////////////////////////////////////////////////////////////////////////////////
    127          

   \                                 In section .text, align 2, keep-with-next
    128          bool usb_hid_poll_for_activity(const peripheral_descriptor_t *self)
    129          {
    130              //    uint32_t hidInfoIndex = self->instance / 2;
    131              bool hid_active = false;
    132              bool msc_active = false;
    133          #if USB_DEVICE_CONFIG_HID
    134              hid_active = g_device_composite.hid_generic.hid_packet.didReceiveFirstReport;
   \                     usb_hid_poll_for_activity: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000004   0x7B0A             LDRB     R2,[R1, #+12]
    135          #endif //  USB_DEVICE_CONFIG_HID
    136          #if USB_DEVICE_CONFIG_MSC
    137              msc_active = g_device_composite.msc_disk.msc_state.isActive;
   \   00000006   0xF201 0x415A      ADDW     R1,R1,#+1114
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x780B             LDRB     R3,[R1, #+0]
   \   0000000E   0xB103             CBZ.N    R3,??usb_hid_poll_for_activity_0
   \   00000010   0x2001             MOVS     R0,#+1
    138          #endif //  USB_DEVICE_CONFIG_HID
    139          
    140              s_dHidMscActivity[0] = hid_active;
   \                     ??usb_hid_poll_for_activity_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R3,??DataTable14_1
   \   00000016   0x701A             STRB     R2,[R3, #+0]
    141              s_dHidMscActivity[1] = msc_active;
   \   00000018   0x7058             STRB     R0,[R3, #+1]
    142              return (g_device_composite.attach && (hid_active || msc_active));
   \   0000001A   0x7FC9             LDRB     R1,[R1, #+31]
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xBF14             ITE      NE 
   \   00000020   0x4310             ORRNE    R0,R0,R2
   \   00000022   0x2000             MOVEQ    R0,#+0
   \   00000024   0x4770             BX       LR
    143          }
    144          

   \                                 In section .text, align 4, keep-with-next
    145          usb_status_t usb_device_callback(usb_device_handle handle, uint32_t event, void *param)
    146          {
   \                     usb_device_callback: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    147              usb_status_t error = kStatus_USB_Success;
   \   00000002   0x2400             MOVS     R4,#+0
    148              uint16_t *temp16 = (uint16_t *)param;
    149              uint8_t *temp8 = (uint8_t *)param;
    150          
    151              switch (event)
   \   00000004   0x1E49             SUBS     R1,R1,#+1
   \   00000006   0x4615             MOV      R5,R2
   \   00000008   0x.... 0x....      LDR.W    R3,??DataTable14
   \   0000000C   0x2911             CMP      R1,#+17
   \   0000000E   0xF103 0x0608      ADD      R6,R3,#+8
   \   00000012   0xF203 0x4279      ADDW     R2,R3,#+1145
   \   00000016   0xD85C             BHI.N    ??usb_device_callback_1
   \   00000018   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??usb_device_callback_0:
   \   0000001C   0x09 0x5B          DC8      0x9,0x5B,0x5B,0x5B
   \              0x5B 0x5B    
   \   00000020   0x5B 0x5B          DC8      0x5B,0x5B,0xB,0x1A
   \              0x0B 0x1A    
   \   00000024   0x3D 0x42          DC8      0x3D,0x42,0x47,0x4C
   \              0x47 0x4C    
   \   00000028   0x51 0x56          DC8      0x51,0x56,0x5B,0x5B
   \              0x5B 0x5B    
   \   0000002C   0x29 0x2E          DC8      0x29,0x2E
    152              {
    153                  case kUSB_DeviceEventBusReset:
    154                  {
    155                      g_device_composite.attach = 0;
   \                     ??usb_device_callback_2: (+1)
   \   0000002E   0x7014             STRB     R4,[R2, #+0]
    156          #if defined(USB_DEVICE_CONFIG_EHCI) && (USB_DEVICE_CONFIG_EHCI > 0)
    157                      if (kStatus_USB_Success == USB_DeviceClassGetSpeed(CONTROLLER_ID, &g_device_composite.speed))
    158                      {
    159                          usb_device_set_speed(handle, g_device_composite.speed);
    160                      }
    161          #endif
    162                  }
    163                  break;
   \   00000030   0xE04F             B.N      ??usb_device_callback_1
    164                  case kUSB_DeviceEventSetConfiguration:
    165                      if (param)
   \                     ??usb_device_callback_3: (+1)
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD04D             BEQ.N    ??usb_device_callback_1
    166                      {
    167                          g_device_composite.attach = 1;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x7010             STRB     R0,[R2, #+0]
    168                          g_device_composite.current_configuration = *temp8;
   \   0000003A   0x7828             LDRB     R0,[R5, #+0]
   \   0000003C   0x7050             STRB     R0,[R2, #+1]
    169          #if USB_DEVICE_CONFIG_HID
    170                          error = usb_device_hid_generic_set_configure(g_device_composite.hid_generic.hid_handle, *temp8);
   \   0000003E   0x7829             LDRB     R1,[R5, #+0]
   \   00000040   0x6830             LDR      R0,[R6, #+0]
   \   00000042   0x.... 0x....      BL       usb_device_hid_generic_set_configure
    171          #endif // USB_DEVICE_CONFIG_HID
    172          #if USB_DEVICE_CONFIG_MSC
    173                          usb_device_msc_disk_set_configure(g_device_composite.msc_disk.msc_handle, *temp8);
   \   00000046   0x7829             LDRB     R1,[R5, #+0]
   \   00000048   0x6CB0             LDR      R0,[R6, #+72]
   \   0000004A   0x.... 0x....      BL       usb_device_msc_disk_set_configure
    174          #endif // USB_DEVICE_CONFIG_MSC
    175                          error = kStatus_USB_Success;
   \   0000004E   0xE040             B.N      ??usb_device_callback_1
    176                      }
    177                      break;
    178                  case kUSB_DeviceEventSetInterface:
    179                      if (g_device_composite.attach)
   \                     ??usb_device_callback_4: (+1)
   \   00000050   0x7810             LDRB     R0,[R2, #+0]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD03D             BEQ.N    ??usb_device_callback_1
    180                      {
    181                          uint8_t interface = (uint8_t)((*temp16 & 0xFF00U) >> 0x08U);
   \   00000056   0x882A             LDRH     R2,[R5, #+0]
   \   00000058   0x0A11             LSRS     R1,R2,#+8
    182                          uint8_t alternate_setting = (uint8_t)(*temp16 & 0x00FFU);
    183                          if (interface < USB_COMPOSITE_INTERFACE_COUNT)
   \   0000005A   0x2902             CMP      R1,#+2
   \   0000005C   0xDA39             BGE.N    ??usb_device_callback_1
    184                          {
    185                              g_device_composite.current_interface_alternate_setting[interface] = alternate_setting;
   \   0000005E   0x1858             ADDS     R0,R3,R1
   \   00000060   0xF880 0x247B      STRB     R2,[R0, #+1147]
    186          #if USB_DEVICE_CONFIG_HID
    187                              usb_device_hid_generic_set_interface(g_device_composite.hid_generic.hid_handle, interface,
    188                                                                   alternate_setting);
   \   00000064   0xB2D2             UXTB     R2,R2
   \   00000066   0x6830             LDR      R0,[R6, #+0]
   \   00000068   0x.... 0x....      BL       usb_device_hid_generic_set_interface
    189          #endif
    190                              error = kStatus_USB_Success;
   \   0000006C   0xE031             B.N      ??usb_device_callback_1
    191                          }
    192                      }
    193                      break;
    194                  case kUSB_DeviceEventGetConfiguration:
    195                      if (param)
   \                     ??usb_device_callback_5: (+1)
   \   0000006E   0x2D00             CMP      R5,#+0
   \   00000070   0xD02F             BEQ.N    ??usb_device_callback_1
    196                      {
    197                          *temp8 = g_device_composite.current_configuration;
   \   00000072   0x7850             LDRB     R0,[R2, #+1]
   \   00000074   0x7028             STRB     R0,[R5, #+0]
    198                          error = kStatus_USB_Success;
   \   00000076   0xE02C             B.N      ??usb_device_callback_1
    199                      }
    200                      break;
    201                  case kUSB_DeviceEventGetInterface:
    202                      if (param)
   \                     ??usb_device_callback_6: (+1)
   \   00000078   0xB35D             CBZ.N    R5,??usb_device_callback_1
    203                      {
    204                          uint8_t interface = (uint8_t)((*temp16 & 0xFF00) >> 0x08);
   \   0000007A   0x882A             LDRH     R2,[R5, #+0]
   \   0000007C   0x0A10             LSRS     R0,R2,#+8
    205                          if (interface < USB_COMPOSITE_INTERFACE_COUNT)
   \   0000007E   0x2802             CMP      R0,#+2
   \   00000080   0xDA07             BGE.N    ??usb_device_callback_7
    206                          {
    207                              *temp16 = (*temp16 & 0xFF00) | g_device_composite.current_interface_alternate_setting[interface];
   \   00000082   0x4418             ADD      R0,R3,R0
   \   00000084   0xF402 0x417F      AND      R1,R2,#0xFF00
   \   00000088   0xF890 0x047B      LDRB     R0,[R0, #+1147]
   \   0000008C   0x4308             ORRS     R0,R0,R1
   \   0000008E   0x8028             STRH     R0,[R5, #+0]
    208                              error = kStatus_USB_Success;
   \   00000090   0xE01F             B.N      ??usb_device_callback_1
    209                          }
    210                          else
    211                          {
    212                              error = kStatus_USB_InvalidRequest;
   \                     ??usb_device_callback_7: (+1)
   \   00000092   0x2405             MOVS     R4,#+5
   \   00000094   0xE01D             B.N      ??usb_device_callback_1
    213                          }
    214                      }
    215                      break;
    216                  case kUSB_DeviceEventGetDeviceDescriptor:
    217                      if (param)
   \                     ??usb_device_callback_8: (+1)
   \   00000096   0xB1E5             CBZ.N    R5,??usb_device_callback_1
    218                      {
    219                          error = usb_device_get_device_descriptor(handle, (usb_device_get_device_descriptor_struct_t *)param);
   \   00000098   0x4629             MOV      R1,R5
   \   0000009A   0x.... 0x....      BL       usb_device_get_device_descriptor
   \   0000009E   0xE017             B.N      ??usb_device_callback_9
    220                      }
    221                      break;
    222                  case kUSB_DeviceEventGetConfigurationDescriptor:
    223                      if (param)
   \                     ??usb_device_callback_10: (+1)
   \   000000A0   0xB1BD             CBZ.N    R5,??usb_device_callback_1
    224                      {
    225                          error = usb_device_get_configuration_descriptor(
    226                              handle, (usb_device_get_configuration_descriptor_struct_t *)param);
   \   000000A2   0x4629             MOV      R1,R5
   \   000000A4   0x.... 0x....      BL       usb_device_get_configuration_descriptor
   \   000000A8   0xE012             B.N      ??usb_device_callback_9
    227                      }
    228                      break;
    229                  case kUSB_DeviceEventGetStringDescriptor:
    230                      if (param)
   \                     ??usb_device_callback_11: (+1)
   \   000000AA   0xB195             CBZ.N    R5,??usb_device_callback_1
    231                      {
    232                          error = usb_device_get_string_descriptor(handle, (usb_device_get_string_descriptor_struct_t *)param);
   \   000000AC   0x4629             MOV      R1,R5
   \   000000AE   0x.... 0x....      BL       usb_device_get_string_descriptor
   \   000000B2   0xE00D             B.N      ??usb_device_callback_9
    233                      }
    234                      break;
    235                  case kUSB_DeviceEventGetHidDescriptor:
    236                      if (param)
   \                     ??usb_device_callback_12: (+1)
   \   000000B4   0xB16D             CBZ.N    R5,??usb_device_callback_1
    237                      {
    238                          error = usb_device_get_hid_descriptor(handle, (usb_device_get_hid_descriptor_struct_t *)param);
   \   000000B6   0x4629             MOV      R1,R5
   \   000000B8   0x.... 0x....      BL       usb_device_get_hid_descriptor
   \   000000BC   0xE008             B.N      ??usb_device_callback_9
    239                      }
    240                      break;
    241                  case kUSB_DeviceEventGetHidReportDescriptor:
    242                      if (param)
   \                     ??usb_device_callback_13: (+1)
   \   000000BE   0xB145             CBZ.N    R5,??usb_device_callback_1
    243                      {
    244                          error = usb_device_get_hid_report_descriptor(handle,
    245                                                                       (usb_device_get_hid_report_descriptor_struct_t *)param);
   \   000000C0   0x4629             MOV      R1,R5
   \   000000C2   0x.... 0x....      BL       usb_device_get_hid_report_descriptor
   \   000000C6   0xE003             B.N      ??usb_device_callback_9
    246                      }
    247                      break;
    248                  case kUSB_DeviceEventGetHidPhysicalDescriptor:
    249                      if (param)
   \                     ??usb_device_callback_14: (+1)
   \   000000C8   0xB11D             CBZ.N    R5,??usb_device_callback_1
    250                      {
    251                          error = usb_device_get_hid_physical_descriptor(
    252                              handle, (usb_device_get_hid_physical_descriptor_struct_t *)param);
   \   000000CA   0x4629             MOV      R1,R5
   \   000000CC   0x.... 0x....      BL       usb_device_get_hid_physical_descriptor
   \                     ??usb_device_callback_9: (+1)
   \   000000D0   0x4604             MOV      R4,R0
    253                      }
    254                      break;
    255              }
    256          
    257              return error;
   \                     ??usb_device_callback_1: (+1)
   \   000000D2   0x4620             MOV      R0,R4
   \   000000D4   0xBD70             POP      {R4-R6,PC}       ;; return
    258          }
    259          

   \                                 In section .text, align 2, keep-with-next
    260          status_t usb_device_full_init(const peripheral_descriptor_t *self, serial_byte_receive_func_t function)
    261          {
   \                     usb_device_full_init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    262              // Not used for USB
    263              (void)function;
    264          
    265              uint8_t irqNumber;
    266          #if defined(USB_DEVICE_CONFIG_EHCI) && (USB_DEVICE_CONFIG_EHCI > 0U)
    267              uint8_t usbDeviceEhciIrq[] = USBHS_IRQS;
    268              irqNumber = usbDeviceEhciIrq[CONTROLLER_ID - kUSB_ControllerEhci0];
    269          #endif
    270          #if defined(USB_DEVICE_CONFIG_KHCI) && (USB_DEVICE_CONFIG_KHCI > 0U)
    271              uint8_t usbDeviceKhciIrq[] = USB_IRQS;
   \   00000002   0x.... 0x....      ADR.W    R0,?_0
    272              irqNumber = usbDeviceKhciIrq[CONTROLLER_ID - kUSB_ControllerKhci0];
    273          #endif
    274          
    275              // Init the state info.
    276              memset(&g_device_composite, 0, sizeof(g_device_composite));
   \   00000006   0x....             LDR.N    R4,??DataTable14
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
    277          
    278              // Init the usb clock, if usb clock cannot be enabled, clear corresponding bit even it is enabled by user.
    279              if (!usb_clock_init())
   \   0000000A   0x....             LDR.N    R6,??DataTable14_2
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000010   0x4605             MOV      R5,R0
   \   00000012   0xF44F 0x6190      MOV      R1,#+1152
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       __aeabi_memclr4
   \   0000001C   0x.... 0x....      BL       usb_clock_init
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0x68B0             LDR      R0,[R6, #+8]
   \   00000024   0x6900             LDR      R0,[R0, #+16]
   \   00000026   0xD10D             BNE.N    ??usb_device_full_init_0
   \   00000028   0xF890 0x1078      LDRB     R1,[R0, #+120]
   \   0000002C   0xF001 0x01EF      AND      R1,R1,#0xEF
   \   00000030   0xF880 0x1078      STRB     R1,[R0, #+120]
   \   00000034   0xF06F 0x0210      MVN      R2,#+16
   \   00000038   0x68B0             LDR      R0,[R6, #+8]
   \   0000003A   0x6900             LDR      R0,[R0, #+16]
   \   0000003C   0x68C1             LDR      R1,[R0, #+12]
   \   0000003E   0x4011             ANDS     R1,R2,R1
   \   00000040   0x60C1             STR      R1,[R0, #+12]
    280              {
    281                  g_bootloaderContext.propertyInterface->store->configurationData.enabledPeripherals &= ~kPeripheralType_USB_HID;
    282                  g_bootloaderContext.propertyInterface->store->availablePeripherals &= ~kPeripheralType_USB_HID;
    283                  return kStatus_Fail;
   \   00000042   0xE02E             B.N      ??usb_device_full_init_1
    284              }
    285          
    286              property_store_t *propertyStore = g_bootloaderContext.propertyInterface->store;
    287          
    288              if ((propertyStore->configurationData.usbPid != (uint16_t)0xFFFF) ||
    289                  (propertyStore->configurationData.usbVid != (uint16_t)0xFFFF))
   \                     ??usb_device_full_init_0: (+1)
   \   00000044   0xF100 0x067C      ADD      R6,R0,#+124
   \   00000048   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000004C   0x8872             LDRH     R2,[R6, #+2]
   \   0000004E   0x8830             LDRH     R0,[R6, #+0]
   \   00000050   0x428A             CMP      R2,R1
   \   00000052   0xBF08             IT       EQ 
   \   00000054   0x4288             CMPEQ    R0,R1
   \   00000056   0xD009             BEQ.N    ??usb_device_full_init_2
    290              {
    291                  g_device_descriptor[kUsbDescriptorIndex_VidLow] = ((propertyStore->configurationData.usbVid) & 0xFF);
   \   00000058   0x....             LDR.N    R1,??DataTable14_3
   \   0000005A   0x7208             STRB     R0,[R1, #+8]
    292                  g_device_descriptor[kUsbDescriptorIndex_VidHigh] = ((propertyStore->configurationData.usbVid) & 0xFF00) >> 8;
   \   0000005C   0x8830             LDRH     R0,[R6, #+0]
   \   0000005E   0x0A00             LSRS     R0,R0,#+8
   \   00000060   0x7248             STRB     R0,[R1, #+9]
    293                  g_device_descriptor[kUsbDescriptorIndex_PidLow] = ((propertyStore->configurationData.usbPid) & 0xFF);
   \   00000062   0x8870             LDRH     R0,[R6, #+2]
   \   00000064   0x7288             STRB     R0,[R1, #+10]
    294                  g_device_descriptor[kUsbDescriptorIndex_PidHigh] = ((propertyStore->configurationData.usbPid) & 0xFF00) >> 8;
   \   00000066   0x8870             LDRH     R0,[R6, #+2]
   \   00000068   0x0A00             LSRS     R0,R0,#+8
   \   0000006A   0x72C8             STRB     R0,[R1, #+11]
    295              }
    296          
    297              if (propertyStore->configurationData.usbStringsPointer != 0xFFFFFFFF)
   \                     ??usb_device_full_init_2: (+1)
   \   0000006C   0x6870             LDR      R0,[R6, #+4]
   \   0000006E   0x....             LDR.N    R7,??DataTable14_4
   \   00000070   0xF110 0x0F01      CMN      R0,#+1
   \   00000074   0xD004             BEQ.N    ??usb_device_full_init_3
    298              {
    299          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    300                  // Make sure the usb string isn't in execute-only region.
    301                  if (is_in_execute_only_region(propertyStore->configurationData.usbStringsPointer, sizeof(usb_language_list_t)))
   \   00000076   0x2110             MOVS     R1,#+16
   \   00000078   0x.... 0x....      BL       is_in_execute_only_region
   \   0000007C   0xB900             CBNZ.N   R0,??usb_device_full_init_3
    302                  {
    303                      g_language_ptr = &g_language_list;
    304                  }
    305                  else
    306          #endif // #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    307                  {
    308                      g_language_ptr = (usb_language_list_t *)propertyStore->configurationData.usbStringsPointer;
   \   0000007E   0x6877             LDR      R7,[R6, #+4]
    309                  }
    310              }
    311              else
    312              {
    313                  g_language_ptr = &g_language_list;
   \                     ??usb_device_full_init_3: (+1)
   \   00000080   0x....             LDR.N    R0,??DataTable14_5
    314              }
    315          
    316              g_device_composite.speed = USB_SPEED_FULL;
    317              g_device_composite.attach = 0;
    318          #if USB_DEVICE_CONFIG_HID
    319              g_device_composite.hid_generic.hid_handle = (class_handle_t)NULL;
    320          #endif // USB_DEVICE_CONFIG_HID
    321          #if USB_DEVICE_CONFIG_MSC
    322              g_device_composite.msc_disk.msc_handle = (class_handle_t)NULL;
    323          #endif // USB_DEVICE_CONFIG_MSC
    324              g_device_composite.device_handle = NULL;
    325          
    326              if (kStatus_USB_Success !=
    327                  USB_DeviceClassInit(CONTROLLER_ID, &g_composite_device_config_list, &g_device_composite.device_handle))
   \   00000082   0x....             LDR.N    R6,??DataTable14_6
   \   00000084   0x6007             STR      R7,[R0, #+0]
   \   00000086   0xF44F 0x608F      MOV      R0,#+1144
   \   0000008A   0x4420             ADD      R0,R4,R0
   \   0000008C   0x2100             MOVS     R1,#+0
   \   0000008E   0x8001             STRH     R1,[R0, #+0]
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x60A0             STR      R0,[R4, #+8]
   \   00000094   0x6520             STR      R0,[R4, #+80]
   \   00000096   0x6020             STR      R0,[R4, #+0]
   \   00000098   0x4622             MOV      R2,R4
   \   0000009A   0x4631             MOV      R1,R6
   \   0000009C   0x.... 0x....      BL       USB_DeviceClassInit
   \   000000A0   0xB108             CBZ.N    R0,??usb_device_full_init_4
    328              {
    329                  return kStatus_Fail;
   \                     ??usb_device_full_init_1: (+1)
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0xBDF2             POP      {R1,R4-R7,PC}
    330              }
    331              else
    332              {
    333          #if ((USB_DEVICE_CONFIG_HID == 1) && (USB_DEVICE_CONFIG_MSC == 1))
    334                  g_device_composite.msc_disk.msc_handle = g_composite_device_config_list.config[1].classHandle;
   \                     ??usb_device_full_init_4: (+1)
   \   000000A6   0x6830             LDR      R0,[R6, #+0]
   \   000000A8   0x6900             LDR      R0,[R0, #+16]
   \   000000AA   0x6520             STR      R0,[R4, #+80]
    335                  usb_device_msc_disk_init(&g_device_composite);
   \   000000AC   0x4620             MOV      R0,R4
   \   000000AE   0x.... 0x....      BL       usb_device_msc_disk_init
    336                  g_device_composite.hid_generic.hid_handle = g_composite_device_config_list.config[0].classHandle;
   \   000000B2   0x6830             LDR      R0,[R6, #+0]
   \   000000B4   0x6840             LDR      R0,[R0, #+4]
   \   000000B6   0x60A0             STR      R0,[R4, #+8]
    337                  usb_device_hid_generic_init(&g_device_composite);
   \   000000B8   0x4620             MOV      R0,R4
   \   000000BA   0x.... 0x....      BL       usb_device_hid_generic_init
    338          #endif
    339          #if ((USB_DEVICE_CONFIG_MSC == 1) && (USB_DEVICE_CONFIG_HID == 0))
    340                  g_device_composite.msc_disk.msc_handle = g_composite_device_config_list.config[0].classHandle;
    341                  usb_device_msc_disk_init(&g_device_composite);
    342          #endif // USB_DEVICE_CONFIG_MSC
    343          #if ((USB_DEVICE_CONFIG_HID == 1) && (USB_DEVICE_CONFIG_MSC == 0))
    344                  g_device_composite.hid_generic.hid_handle = g_composite_device_config_list.config[0].classHandle;
    345                  usb_device_hid_generic_init(&g_device_composite);
    346          #endif // USB_DEVICE_CONFIG_HID
    347              }
    348          
    349              /* Install isr, set priority, and enable IRQ. */
    350              NVIC_SetPriority((IRQn_Type)irqNumber, USB_DEVICE_INTERRUPT_PRIORITY);
   \   000000BE   0xB268             SXTB     R0,R5
   \   000000C0   0x0001             MOVS     R1,R0
   \   000000C2   0xD507             BPL.N    ??usb_device_full_init_5
   \   000000C4   0x....             LDR.N    R3,??DataTable14_7  ;; 0xe000ed18
   \   000000C6   0xF000 0x000F      AND      R0,R0,#0xF
   \   000000CA   0x4418             ADD      R0,R3,R0
   \   000000CC   0x2240             MOVS     R2,#+64
   \   000000CE   0xF800 0x2C04      STRB     R2,[R0, #-4]
   \   000000D2   0xE002             B.N      ??usb_device_full_init_6
   \                     ??usb_device_full_init_5: (+1)
   \   000000D4   0x....             LDR.N    R2,??DataTable14_8  ;; 0xe000e400
   \   000000D6   0x2040             MOVS     R0,#+64
   \   000000D8   0x5450             STRB     R0,[R2, R1]
    351              NVIC_EnableIRQ((IRQn_Type)irqNumber);
   \                     ??usb_device_full_init_6: (+1)
   \   000000DA   0x2001             MOVS     R0,#+1
   \   000000DC   0xF005 0x021F      AND      R2,R5,#0x1F
   \   000000E0   0x4090             LSLS     R0,R0,R2
   \   000000E2   0x....             LDR.N    R2,??DataTable14_9  ;; 0xe000e100
   \   000000E4   0x0949             LSRS     R1,R1,#+5
   \   000000E6   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
    352          
    353              USB_DeviceRun(g_device_composite.device_handle);
   \   000000EA   0x6820             LDR      R0,[R4, #+0]
   \   000000EC   0x.... 0x....      BL       USB_DeviceRun
    354          
    355              return kStatus_Success;
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    356          }
    357          

   \                                 In section .text, align 2, keep-with-next
    358          void usb_device_full_shutdown(const peripheral_descriptor_t *self)
    359          {
   \                     usb_device_full_shutdown: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    360              if (kStatus_USB_Success != USB_DeviceClassDeinit(CONTROLLER_ID))
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       USB_DeviceClassDeinit
   \   00000008   0xB9A0             CBNZ.N   R0,??usb_device_full_shutdown_0
    361              {
    362                  return;
    363              }
    364              else
    365              {
    366          // Shutdown class driver
    367          #if USB_DEVICE_CONFIG_MSC
    368                  usb_device_msc_disk_deinit(&g_device_composite);
   \   0000000A   0x....             LDR.N    R4,??DataTable14
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       usb_device_msc_disk_deinit
    369          #endif // USB_DEVICE_CONFIG_MSC
    370          #if USB_DEVICE_CONFIG_HID
    371                  usb_device_hid_generic_deinit(&g_device_composite);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       usb_device_hid_generic_deinit
    372          #endif // USB_DEVICE_CONFIG_MSC
    373              }
    374          
    375          // Make sure we are clocking to the peripheral to ensure there
    376          // are no bus errors
    377          #if defined(PCC_BASE_ADDRS)
    378              if ((self->instance == kUSB_ControllerEhci0) && ((*(volatile uint32_t *)kCLOCK_Usbfs0) & PCC_CLKCFG_CGC_MASK))
    379              {
    380                  // Disable the USB interrupt
    381                  NVIC_DisableIRQ(USB0_IRQn);
    382          
    383                  // Clear any pending interrupts on USB
    384                  NVIC_ClearPendingIRQ(USB0_IRQn);
    385          
    386                  // Turn off clocking to USB
    387                  CLOCK_DisableClock(kCLOCK_Usbfs0);
    388              }
    389          #else
    390              if ((CONTROLLER_ID == kUSB_ControllerKhci0) && (SIM->SCGC4 & SIM_SCGC4_USBOTG_MASK))
   \   00000018   0x....             LDR.N    R0,??DataTable14_10  ;; 0x40048034
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0x0349             LSLS     R1,R1,#+13
   \   0000001E   0xD509             BPL.N    ??usb_device_full_shutdown_0
    391              {
    392                  // Disable the USB interrupt
    393                  NVIC_DisableIRQ(USB0_IRQn);
   \   00000020   0x....             LDR.N    R2,??DataTable14_11  ;; 0xe000e184
   \   00000022   0xF44F 0x1100      MOV      R1,#+2097152
   \   00000026   0x6011             STR      R1,[R2, #+0]
    394          
    395                  // Clear any pending interrupts on USB
    396                  NVIC_ClearPendingIRQ(USB0_IRQn);
   \   00000028   0x....             LDR.N    R2,??DataTable14_12  ;; 0xe000e284
   \   0000002A   0x6011             STR      R1,[R2, #+0]
    397          
    398                  // Turn off clocking to USB
    399                  SIM->SCGC4 &= ~SIM_SCGC4_USBOTG_MASK;
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0xF421 0x2180      BIC      R1,R1,#0x40000
   \   00000032   0x6001             STR      R1,[R0, #+0]
    400              }
    401          #endif // defined(PCC_BASE_ADDRS)
    402          #if USB_DEVICE_CONFIG_EHCI
    403              else if ((CONTROLLER_ID == kUSB_ControllerEhci0) && (SIM->SCGC3 & SIM_SCGC3_USBHS_MASK))
    404              {
    405                  // Disable the USB interrupt
    406                  NVIC_DisableIRQ(USBHS_IRQn);
    407          
    408                  // Clear any pending interrupts on USB
    409                  NVIC_ClearPendingIRQ(USBHS_IRQn);
    410          
    411                  // Turn off HS USB PHY clock gate
    412                  SIM->SCGC3 &= ~(SIM_SCGC3_USBHS_MASK | SIM_SCGC3_USBHSPHY_MASK);
    413              }
    414          #endif
    415          }
   \                     ??usb_device_full_shutdown_0: (+1)
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    416          
    417          //! @brief Run the sbloader state machine.
    418          //!
    419          //! This function is called repeatedly by the main application loop. We use it
    420          //! to run the sbloader state machine from non-interrupt context.

   \                                 In section .text, align 2, keep-with-next
    421          void usb_msc_pump(const peripheral_descriptor_t *self)
    422          {
   \                     usb_msc_pump: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    423              s_dHidMscActivity[USB_HID_INDEX] = false;
   \   00000002   0x....             LDR.N    R4,??DataTable14_1
    424              s_dHidMscActivity[USB_MSC_INDEX] = true;
   \   00000004   0x....             LDR.N    R5,??DataTable14_13
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x7020             STRB     R0,[R4, #+0]
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x7060             STRB     R0,[R4, #+1]
    425          
    426          //#if (USB_DEVICE_CONFIG_MSC)
    427          #if (BL_CONFIG_USB_MSC || BL_CONFIG_HS_USB_MSC)
    428              lock_acquire();
   \   0000000E   0x.... 0x....      BL       lock_acquire
    429              usb_device_msc_disk_pump();
   \   00000012   0x.... 0x....      BL       usb_device_msc_disk_pump
    430          
    431              if (g_device_composite.msc_disk.msc_state.sbLoaderStatus == kSbLoaderFinal)
   \   00000016   0x78A8             LDRB     R0,[R5, #+2]
   \   00000018   0x2803             CMP      R0,#+3
   \   0000001A   0xD103             BNE.N    ??usb_msc_pump_0
    432              {
    433                  g_device_composite.msc_disk.msc_state.sbLoaderStatus = kSbLoaderFree;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x70A8             STRB     R0,[R5, #+2]
    434                  sbloader_finalize();
   \   00000020   0x.... 0x....      BL       sbloader_finalize
    435              }
    436              lock_release();
   \                     ??usb_msc_pump_0: (+1)
   \   00000024   0x.... 0x....      BL       lock_release
    437          
    438              s_dHidMscActivity[USB_MSC_INDEX] = g_device_composite.msc_disk.msc_state.isActive;
   \   00000028   0x7828             LDRB     R0,[R5, #+0]
   \   0000002A   0xB100             CBZ.N    R0,??usb_msc_pump_1
   \   0000002C   0x2001             MOVS     R0,#+1
   \                     ??usb_msc_pump_1: (+1)
   \   0000002E   0x7060             STRB     R0,[R4, #+1]
    439          #endif // BL_CONFIG_USB_MSC
    440          
    441              s_dHidMscActivity[USB_HID_INDEX] = true;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x7020             STRB     R0,[R4, #+0]
    442          }
   \   00000034   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    443          

   \                                 In section .text, align 2, keep-with-next
    444          static status_t usb_hid_packet_init(const peripheral_descriptor_t *self)
    445          {
   \                     usb_hid_packet_init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    446          #if USB_DEVICE_CONFIG_HID
    447              sync_init(&g_device_composite.hid_generic.hid_packet.receiveSync, false);
   \   00000002   0x....             LDR.N    R4,??DataTable14
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0xF104 0x0014      ADD      R0,R4,#+20
   \   0000000A   0x.... 0x....      BL       sync_init
    448              sync_init(&g_device_composite.hid_generic.hid_packet.sendSync, false);
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0xF104 0x0018      ADD      R0,R4,#+24
   \   00000014   0x.... 0x....      BL       sync_init
    449          
    450              // Check for any received data that may be pending
    451              sync_signal(&g_device_composite.hid_generic.hid_packet.receiveSync);
   \   00000018   0xF104 0x0014      ADD      R0,R4,#+20
   \   0000001C   0x.... 0x....      BL       sync_signal
    452          #endif
    453              return kStatus_Success;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    454          }
    455          

   \                                 In section .text, align 2, keep-with-next
    456          static status_t usb_hid_packet_read(const peripheral_descriptor_t *self,
    457                                              uint8_t **packet,
    458                                              uint32_t *packetLength,
    459                                              packet_type_t packetType)
    460          {
   \                     usb_hid_packet_read: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x4615             MOV      R5,R2
    461              if (!packet || !packetLength)
   \   00000008   0xBF14             ITE      NE 
   \   0000000A   0x2D00             CMPNE    R5,#+0
   \   0000000C   0x2004             MOVEQ    R0,#+4
    462              {
    463                  //        debug_printf("Error: invalid packet\r\n");
    464                  return kStatus_InvalidArgument;
   \   0000000E   0xD039             BEQ.N    ??usb_hid_packet_read_0
    465              }
    466              *packetLength = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x6028             STR      R0,[R5, #+0]
    467          
    468              // Determine report ID based on packet type.
    469              uint8_t reportID;
    470              switch (packetType)
   \   00000014   0xB113             CBZ.N    R3,??usb_hid_packet_read_1
   \   00000016   0x2B01             CMP      R3,#+1
   \   00000018   0xD002             BEQ.N    ??usb_hid_packet_read_2
   \   0000001A   0xE02C             B.N      ??usb_hid_packet_read_3
    471              {
    472                  case kPacketType_Command:
    473                      reportID = kBootloaderReportID_CommandOut;
   \                     ??usb_hid_packet_read_1: (+1)
   \   0000001C   0x2601             MOVS     R6,#+1
    474                      break;
   \   0000001E   0xE000             B.N      ??usb_hid_packet_read_4
    475                  case kPacketType_Data:
    476                      reportID = kBootloaderReportID_DataOut;
   \                     ??usb_hid_packet_read_2: (+1)
   \   00000020   0x2602             MOVS     R6,#+2
    477                      break;
    478                  default:
    479                      //            debug_printf("usbhid: unsupported packet type %d\r\n", (int)packetType);
    480                      return kStatus_Fail;
    481              };
    482          #if USB_DEVICE_CONFIG_HID
    483              if (s_dHidMscActivity[USB_HID_INDEX])
   \                     ??usb_hid_packet_read_4: (+1)
   \   00000022   0x....             LDR.N    R0,??DataTable14_1
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0xB360             CBZ.N    R0,??usb_hid_packet_read_5
    484              {
    485                  // The first receive data request was initiated after enumeration.
    486                  // After that we wait until we are ready to read data before
    487                  // we request more. This mechanism prevents data loss
    488                  // by allowing the USB controller to hold off the host with NAKs
    489                  // on the interrupt out pipe until we are ready.
    490                  if (g_device_composite.hid_generic.hid_packet.isReceiveDataRequestRequired)
   \   00000028   0x.... 0x....      LDR.W    R8,??DataTable14
   \   0000002C   0xF108 0x0708      ADD      R7,R8,#+8
   \   00000030   0x79B8             LDRB     R0,[R7, #+6]
   \   00000032   0xB130             CBZ.N    R0,??usb_hid_packet_read_6
    491                  {
    492                      // Initiate receive on interrupt out pipe.
    493                      USB_DeviceHidRecv(g_device_composite.hid_generic.hid_handle, USB_HID_GENERIC_ENDPOINT_OUT,
    494                                        (uint8_t *)&g_device_composite.hid_generic.hid_packet.report.header,
    495                                        sizeof(g_device_composite.hid_generic.hid_packet.report));
   \   00000034   0x6838             LDR      R0,[R7, #+0]
   \   00000036   0x2324             MOVS     R3,#+36
   \   00000038   0xF108 0x0220      ADD      R2,R8,#+32
   \   0000003C   0x2102             MOVS     R1,#+2
   \   0000003E   0x.... 0x....      BL       USB_DeviceHidRecv
    496                  }
    497          
    498                  g_device_composite.hid_generic.hid_packet.isReceiveDataRequestRequired = true;
   \                     ??usb_hid_packet_read_6: (+1)
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x71B8             STRB     R0,[R7, #+6]
    499          
    500                  // Wait until we have received a report.
    501          
    502                  sync_wait(&g_device_composite.hid_generic.hid_packet.receiveSync, kSyncWaitForever);
   \   00000046   0xF04F 0x31FF      MOV      R1,#-1
   \   0000004A   0xF108 0x0014      ADD      R0,R8,#+20
   \   0000004E   0x.... 0x....      BL       sync_wait
    503          
    504                  // Check the report ID, the first byte of the report buffer.
    505                  if (g_device_composite.hid_generic.hid_packet.report.header.reportID != reportID)
   \   00000052   0x7E38             LDRB     R0,[R7, #+24]
   \   00000054   0x42B0             CMP      R0,R6
   \   00000056   0xD006             BEQ.N    ??usb_hid_packet_read_7
    506                  {
    507                      // If waiting for a command but get data, this is a flush after a data abort.
    508                      if ((reportID == kBootloaderReportID_CommandOut) &&
    509                          (g_device_composite.hid_generic.hid_packet.report.header.reportID == kBootloaderReportID_DataOut))
   \   00000058   0x2E01             CMP      R6,#+1
   \   0000005A   0xBF08             IT       EQ 
   \   0000005C   0x2802             CMPEQ    R0,#+2
   \   0000005E   0xD10A             BNE.N    ??usb_hid_packet_read_3
    510                      {
    511                          return kStatus_AbortDataPhase;
   \   00000060   0xF242 0x7012      MOVW     R0,#+10002
   \   00000064   0xE00E             B.N      ??usb_hid_packet_read_0
    512                      }
    513                      //        debug_printf("usbhid: received unexpected report=%x\r\n",
    514                      //        g_device_composite.hid_generic.hid_packet.report.header.reportID);
    515                      return kStatus_Fail;
    516                  }
    517          
    518                  // Extract the packet length encoded as bytes 1 and 2 of the report. The packet length
    519                  // is transferred in little endian byte order.
    520                  uint16_t lengthOfPacket = g_device_composite.hid_generic.hid_packet.report.header.packetLengthLsb |
    521                                            (g_device_composite.hid_generic.hid_packet.report.header.packetLengthMsb << 8);
   \                     ??usb_hid_packet_read_7: (+1)
   \   00000066   0x7EB8             LDRB     R0,[R7, #+26]
   \   00000068   0x7EF9             LDRB     R1,[R7, #+27]
   \   0000006A   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
    522          
    523                  // Make sure we got all of the packet. Some hosts (Windows) may send up to the maximum
    524                  // report size, so there may be extra trailing bytes.
    525                  if ((g_device_composite.hid_generic.hid_packet.reportSize -
    526                       sizeof(g_device_composite.hid_generic.hid_packet.report.header)) < lengthOfPacket)
   \   0000006E   0x6979             LDR      R1,[R7, #+20]
   \   00000070   0x1F09             SUBS     R1,R1,#+4
   \   00000072   0x4281             CMP      R1,R0
   \   00000074   0xD201             BCS.N    ??usb_hid_packet_read_8
    527                  {
    528                      //        debug_printf("usbhid: received only %d bytes of packet with length %d\r\n",
    529                      //        s_hidInfo[hidInfoIndex].reportSize - 3, lengthOfPacket);
    530                      return kStatus_Fail;
   \                     ??usb_hid_packet_read_3: (+1)
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0xE004             B.N      ??usb_hid_packet_read_0
    531                  }
    532          
    533                  // Return packet to caller.
    534                  *packet = g_device_composite.hid_generic.hid_packet.report.packet;
   \                     ??usb_hid_packet_read_8: (+1)
   \   0000007A   0xF108 0x0124      ADD      R1,R8,#+36
   \   0000007E   0x6021             STR      R1,[R4, #+0]
    535                  *packetLength = lengthOfPacket;
   \   00000080   0x6028             STR      R0,[R5, #+0]
    536              }
    537          #endif // USB_DEVICE_CONFIG_HID
    538              return kStatus_Success;
   \                     ??usb_hid_packet_read_5: (+1)
   \   00000082   0x2000             MOVS     R0,#+0
   \                     ??usb_hid_packet_read_0: (+1)
   \   00000084   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    539          }
    540          

   \                                 In section .text, align 2, keep-with-next
    541          static status_t usb_hid_packet_write(const peripheral_descriptor_t *self,
    542                                               const uint8_t *packet,
    543                                               uint32_t byteCount,
    544                                               packet_type_t packetType)
    545          {
   \                     usb_hid_packet_write: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    546          #if USB_DEVICE_CONFIG_HID
    547              if (s_dHidMscActivity[USB_HID_INDEX])
   \   00000004   0x....             LDR.N    R0,??DataTable14_1
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x460C             MOV      R4,R1
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0x4615             MOV      R5,R2
   \   0000000E   0x4619             MOV      R1,R3
   \   00000010   0xD047             BEQ.N    ??usb_hid_packet_write_0
    548              {
    549                  if (byteCount > kMinPacketBufferSize)
   \   00000012   0x2D21             CMP      R5,#+33
   \   00000014   0xD306             BCC.N    ??usb_hid_packet_write_1
    550                  {
    551                      debug_printf("Error: invalid packet size %d\r\n", byteCount);
   \   00000016   0x4629             MOV      R1,R5
   \   00000018   0x.... 0x....      ADR.W    R0,?_1
   \   0000001C   0x.... 0x....      BL       debug_printf
    552                      return kStatus_InvalidArgument;
   \   00000020   0x2004             MOVS     R0,#+4
   \   00000022   0xE03F             B.N      ??usb_hid_packet_write_2
    553                  }
    554          
    555                  // Determine report ID based on packet type.
    556                  uint8_t reportID;
    557                  switch (packetType)
   \                     ??usb_hid_packet_write_1: (+1)
   \   00000024   0xB111             CBZ.N    R1,??usb_hid_packet_write_3
   \   00000026   0x2901             CMP      R1,#+1
   \   00000028   0xD010             BEQ.N    ??usb_hid_packet_write_4
   \   0000002A   0xE011             B.N      ??usb_hid_packet_write_5
    558                  {
    559                      case kPacketType_Command:
    560                          reportID = kBootloaderReportID_CommandIn;
   \                     ??usb_hid_packet_write_3: (+1)
   \   0000002C   0x2703             MOVS     R7,#+3
    561                          break;
   \                     ??usb_hid_packet_write_6: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R8,??DataTable14
    562                      case kPacketType_Data:
    563                          reportID = kBootloaderReportID_DataIn;
    564                          break;
    565                      default:
    566                          debug_printf("usbhid: unsupported packet type %d\r\n", (int)packetType);
    567                          return kStatus_Fail;
    568                  };
    569          
    570                  // Check for data phase aborted by receiver.
    571                  lock_acquire();
   \   00000032   0x.... 0x....      BL       lock_acquire
    572                  if (g_device_composite.hid_generic.hid_packet.didReceiveDataPhaseAbort)
   \   00000036   0xF108 0x0608      ADD      R6,R8,#+8
   \   0000003A   0x7970             LDRB     R0,[R6, #+5]
   \   0000003C   0xB170             CBZ.N    R0,??usb_hid_packet_write_7
    573                  {
    574                      g_device_composite.hid_generic.hid_packet.didReceiveDataPhaseAbort = false;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7170             STRB     R0,[R6, #+5]
    575                      lock_release();
   \   00000042   0x.... 0x....      BL       lock_release
    576                      return kStatus_AbortDataPhase;
   \   00000046   0xF242 0x7012      MOVW     R0,#+10002
   \   0000004A   0xE02B             B.N      ??usb_hid_packet_write_2
    577                  }
   \                     ??usb_hid_packet_write_4: (+1)
   \   0000004C   0x2704             MOVS     R7,#+4
   \   0000004E   0xE7EE             B.N      ??usb_hid_packet_write_6
   \                     ??usb_hid_packet_write_5: (+1)
   \   00000050   0x.... 0x....      ADR.W    R0,?_2
   \   00000054   0x.... 0x....      BL       debug_printf
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0xE023             B.N      ??usb_hid_packet_write_2
    578                  lock_release();
   \                     ??usb_hid_packet_write_7: (+1)
   \   0000005C   0x.... 0x....      BL       lock_release
    579          
    580                  // Construct report contents.
    581                  g_device_composite.hid_generic.hid_packet.report.header.reportID = reportID;
   \   00000060   0x7637             STRB     R7,[R6, #+24]
    582                  g_device_composite.hid_generic.hid_packet.report.header._padding = 0;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x7670             STRB     R0,[R6, #+25]
    583                  g_device_composite.hid_generic.hid_packet.report.header.packetLengthLsb = byteCount & 0xff;
   \   00000066   0x76B5             STRB     R5,[R6, #+26]
    584                  g_device_composite.hid_generic.hid_packet.report.header.packetLengthMsb = (byteCount >> 8) & 0xff;
   \   00000068   0x0A28             LSRS     R0,R5,#+8
    585                  if (packet && byteCount > 0)
   \   0000006A   0x2C00             CMP      R4,#+0
   \   0000006C   0xBF18             IT       NE 
   \   0000006E   0x2D00             CMPNE    R5,#+0
   \   00000070   0x76F0             STRB     R0,[R6, #+27]
   \   00000072   0xD005             BEQ.N    ??usb_hid_packet_write_8
    586                  {
    587                      memcpy(&g_device_composite.hid_generic.hid_packet.report.packet, packet, byteCount);
   \   00000074   0x462A             MOV      R2,R5
   \   00000076   0x4621             MOV      R1,R4
   \   00000078   0xF108 0x0024      ADD      R0,R8,#+36
   \   0000007C   0x.... 0x....      BL       __aeabi_memcpy
    588                  }
    589                  if (g_device_composite.hid_generic.attach == 1)
   \                     ??usb_hid_packet_write_8: (+1)
   \   00000080   0xF898 0x0046      LDRB     R0,[R8, #+70]
   \   00000084   0x2801             CMP      R0,#+1
   \   00000086   0xD10C             BNE.N    ??usb_hid_packet_write_0
    590                  {
    591                      // Send the maximum report size since that's what the host expects.
    592                      // There may be extra trailing bytes.
    593                      USB_DeviceHidSend(g_device_composite.hid_generic.hid_handle, USB_HID_GENERIC_ENDPOINT_IN,
    594                                        (uint8_t *)&g_device_composite.hid_generic.hid_packet.report.header,
    595                                        sizeof(g_device_composite.hid_generic.hid_packet.report));
   \   00000088   0x6830             LDR      R0,[R6, #+0]
   \   0000008A   0x2324             MOVS     R3,#+36
   \   0000008C   0xF108 0x0220      ADD      R2,R8,#+32
   \   00000090   0x2101             MOVS     R1,#+1
   \   00000092   0x.... 0x....      BL       USB_DeviceHidSend
    596                      sync_wait(&g_device_composite.hid_generic.hid_packet.sendSync, kSyncWaitForever);
   \   00000096   0xF04F 0x31FF      MOV      R1,#-1
   \   0000009A   0xF108 0x0018      ADD      R0,R8,#+24
   \   0000009E   0x.... 0x....      BL       sync_wait
    597                  }
    598              }
    599          #endif // USB_DEVICE_CONFIG_HID
    600              return kStatus_Success;
   \                     ??usb_hid_packet_write_0: (+1)
   \   000000A2   0x2000             MOVS     R0,#+0
   \                     ??usb_hid_packet_write_2: (+1)
   \   000000A4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    601          }
    602          

   \                                 In section .text, align 2, keep-with-next
    603          static void usb_hid_packet_abort_data_phase(const peripheral_descriptor_t *self)
    604          {
   \                     usb_hid_packet_abort_data_phase: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    605              status_t status = self->packetInterface->writePacket(self, NULL, 0, kPacketType_Command);
   \   00000002   0x6944             LDR      R4,[R0, #+20]
   \   00000004   0x68A4             LDR      R4,[R4, #+8]
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x47A0             BLX      R4
    606              if (status != kStatus_Success)
   \   0000000E   0xB128             CBZ.N    R0,??usb_hid_packet_abort_data_phase_0
    607              {
    608                  debug_printf("Error: usb_hid_packet_abort write packet returned status 0x%x\r\n", status);
   \   00000010   0xE8BD 0x4010      POP      {R4,LR}
   \   00000014   0x4601             MOV      R1,R0
   \   00000016   0x.... 0x....      ADR.W    R0,?_3
   \   0000001A   0x....             B.N      debug_printf
    609                  return;
    610              }
    611          }
   \                     ??usb_hid_packet_abort_data_phase_0: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    612          

   \                                 In section .text, align 2, keep-with-next
    613          static status_t usb_hid_packet_finalize(const peripheral_descriptor_t *self)
    614          {
    615              return kStatus_Success;
   \                     usb_hid_packet_finalize: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    616          }
    617          

   \                                 In section .text, align 2, keep-with-next
    618          static uint32_t usb_hid_packet_get_max_packet_size(const peripheral_descriptor_t *self)
    619          {
    620              return kMinPacketBufferSize;
   \                     usb_hid_packet_get_max_packet_size: (+1)
   \   00000000   0x2020             MOVS     R0,#+32
   \   00000002   0x4770             BX       LR               ;; return
    621          }
    622          
    623          #if defined(USB_DEVICE_CONFIG_EHCI) && (USB_DEVICE_CONFIG_EHCI > 0)
    624          void USBHS_IRQHandler(void)
    625          {
    626          #if USB_DEVICE_CONFIG_MSC
    627              if ((g_device_composite.msc_disk.msc_state.sbLoaderStatus == kSbLoaderLoading) ||
    628                  (g_device_composite.msc_disk.msc_state.sbLoaderStatus == kSbLoaderFinal))
    629              {
    630          #if USB_DEVICE_CONFIG_HID
    631                  sync_reset(&g_device_composite.hid_generic.hid_packet.receiveSync);
    632                  sync_reset(&g_device_composite.hid_generic.hid_packet.sendSync);
    633          #endif //#if USB_DEVICE_CONFIG_HID
    634              }
    635          #endif // USB_DEVICE_CONFIG_MSC
    636              USB_DeviceEhciIsrFunction(g_device_composite.device_handle);
    637          }
    638          #endif
    639          
    640          #if defined(USB_DEVICE_CONFIG_KHCI) && (USB_DEVICE_CONFIG_KHCI > 0)

   \                                 In section .text, align 2, keep-with-next
    641          void USB0_IRQHandler(void)
    642          {
   \                     USB0_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    643          #if USB_DEVICE_CONFIG_MSC
    644              if ((g_device_composite.msc_disk.msc_state.sbLoaderStatus == kSbLoaderLoading) ||
    645                  (g_device_composite.msc_disk.msc_state.sbLoaderStatus == kSbLoaderFinal))
   \   00000002   0x....             LDR.N    R4,??DataTable14
   \   00000004   0xF894 0x045C      LDRB     R0,[R4, #+1116]
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xBF18             IT       NE 
   \   0000000C   0x2803             CMPNE    R0,#+3
   \   0000000E   0xD107             BNE.N    ??USB0_IRQHandler_0
    646              {
    647          #if USB_DEVICE_CONFIG_HID
    648                  sync_reset(&g_device_composite.hid_generic.hid_packet.receiveSync);
   \   00000010   0xF104 0x0014      ADD      R0,R4,#+20
   \   00000014   0x.... 0x....      BL       sync_reset
    649                  sync_reset(&g_device_composite.hid_generic.hid_packet.sendSync);
   \   00000018   0xF104 0x0018      ADD      R0,R4,#+24
   \   0000001C   0x.... 0x....      BL       sync_reset
    650          #endif //#if USB_DEVICE_CONFIG_HID
    651              }
    652          #endif // USB_DEVICE_CONFIG_MSC
    653              USB_DeviceKhciIsrFunction(g_device_composite.device_handle);
   \                     ??USB0_IRQHandler_0: (+1)
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0xE8BD 0x4010      POP      {R4,LR}
   \   00000026   0x.... 0x....      B.W      USB_DeviceKhciIsrFunction
    654          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     g_device_composite

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     s_dHidMscActivity

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     g_bootloaderContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x........         DC32     g_device_descriptor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x........         DC32     g_language_list

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x........         DC32     g_language_ptr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x........         DC32     g_composite_device_config_list

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0xE000ED18         DC32     0xe000ed18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0xE000E400         DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \   00000000   0xE000E184         DC32     0xe000e184

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_12:
   \   00000000   0xE000E284         DC32     0xe000e284

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_13:
   \   00000000   0x........         DC32     g_device_composite+0x45A

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x35               DC8 53

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x45 0x72          DC8 "Error: invalid packet size %d\015\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x69    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x70    
   \              0x61 0x63    
   \              0x6B 0x65    
   \              0x74 0x20    
   \              0x73 0x69    
   \              0x7A 0x65    
   \              0x20 0x25    
   \              0x64 0x0D    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x75 0x73          DC8 "usbhid: unsupported packet type %d\015\012"
   \              0x62 0x68    
   \              0x69 0x64    
   \              0x3A 0x20    
   \              0x75 0x6E    
   \              0x73 0x75    
   \              0x70 0x70    
   \              0x6F 0x72    
   \              0x74 0x65    
   \              0x64 0x20    
   \              0x70 0x61    
   \              0x63 0x6B    
   \              0x65 0x74    
   \              0x20 0x74    
   \              0x79 0x70    
   \              0x65 0x20    
   \              0x25 0x64    
   \              0x0D 0x0A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x45 0x72          DC8 45H, 72H, 72H, 6FH, 72H, 3AH, 20H, 75H
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x75    
   \   00000008   0x73 0x62          DC8 73H, 62H, 5FH, 68H, 69H, 64H, 5FH, 70H
   \              0x5F 0x68    
   \              0x69 0x64    
   \              0x5F 0x70    
   \   00000010   0x61 0x63          DC8 61H, 63H, 6BH, 65H, 74H, 5FH, 61H, 62H
   \              0x6B 0x65    
   \              0x74 0x5F    
   \              0x61 0x62    
   \   00000018   0x6F 0x72          DC8 6FH, 72H, 74H, 20H, 77H, 72H, 69H, 74H
   \              0x74 0x20    
   \              0x77 0x72    
   \              0x69 0x74    
   \   00000020   0x65 0x20          DC8 65H, 20H, 70H, 61H, 63H, 6BH, 65H, 74H
   \              0x70 0x61    
   \              0x63 0x6B    
   \              0x65 0x74    
   \   00000028   0x20 0x72          DC8 20H, 72H, 65H, 74H, 75H, 72H, 6EH, 65H
   \              0x65 0x74    
   \              0x75 0x72    
   \              0x6E 0x65    
   \   00000030   0x64 0x20          DC8 64H, 20H, 73H, 74H, 61H, 74H, 75H, 73H
   \              0x73 0x74    
   \              0x61 0x74    
   \              0x75 0x73    
   \   00000038   0x20 0x30          DC8 20H, 30H, 78H, 25H, 78H, 0DH, 0AH, 0
   \              0x78 0x25    
   \              0x78 0x0D    
   \              0x0A 0x00    
    655          #endif
    656          
    657          //! @}
    658          
    659          #endif // (BL_CONFIG_USB_HID || BL_CONFIG_HS_USB_HID || BL_CONFIG_USB_MSC || BL_CONFIG_HS_USB_MSC)
    660          
    661          ////////////////////////////////////////////////////////////////////////////////
    662          // EOF
    663          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   USB0_IRQHandler
         0   -> USB_DeviceKhciIsrFunction
         8   -> sync_reset
      16   debug_printf
        16   -> vprintf
      16   usb_device_callback
        16   -> usb_device_get_configuration_descriptor
        16   -> usb_device_get_device_descriptor
        16   -> usb_device_get_hid_descriptor
        16   -> usb_device_get_hid_physical_descriptor
        16   -> usb_device_get_hid_report_descriptor
        16   -> usb_device_get_string_descriptor
        16   -> usb_device_hid_generic_set_configure
        16   -> usb_device_hid_generic_set_interface
        16   -> usb_device_msc_disk_set_configure
      24   usb_device_full_init
        24   -> USB_DeviceClassInit
        24   -> USB_DeviceRun
        24   -> __aeabi_memclr4
        24   -> is_in_execute_only_region
        24   -> usb_clock_init
        24   -> usb_device_hid_generic_init
        24   -> usb_device_msc_disk_init
       8   usb_device_full_shutdown
         8   -> USB_DeviceClassDeinit
         8   -> usb_device_hid_generic_deinit
         8   -> usb_device_msc_disk_deinit
       8   usb_hid_packet_abort_data_phase
         8   -- Indirect call
         0   -> debug_printf
       0   usb_hid_packet_finalize
       0   usb_hid_packet_get_max_packet_size
       8   usb_hid_packet_init
         8   -> sync_init
         8   -> sync_signal
      24   usb_hid_packet_read
        24   -> USB_DeviceHidRecv
        24   -> sync_wait
      24   usb_hid_packet_write
        24   -> USB_DeviceHidSend
        24   -> __aeabi_memcpy
        24   -> debug_printf
        24   -> lock_acquire
        24   -> lock_release
        24   -> sync_wait
       0   usb_hid_poll_for_activity
      16   usb_msc_pump
        16   -> lock_acquire
        16   -> lock_release
        16   -> sbloader_finalize
        16   -> usb_device_msc_disk_pump


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_13
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
       1  ?_0
      32  ?_1
      40  ?_2
      64  ?_3
      42  USB0_IRQHandler
      14  debug_printf
    1152  g_device_composite
      16  g_usbHidControlInterface
      28  g_usbHidPacketInterface
       2  s_dHidMscActivity
     214  usb_device_callback
     244  usb_device_full_init
      54  usb_device_full_shutdown
      30  usb_hid_packet_abort_data_phase
       4  usb_hid_packet_finalize
       4  usb_hid_packet_get_max_packet_size
      36  usb_hid_packet_init
     136  usb_hid_packet_read
     168  usb_hid_packet_write
      38  usb_hid_poll_for_activity
      54  usb_msc_pump

 
 1 154 bytes in section .bss
    44 bytes in section .rodata
 1 231 bytes in section .text
 
 1 231 bytes of CODE  memory
    44 bytes of CONST memory
 1 154 bytes of DATA  memory

Errors: none
Warnings: none
