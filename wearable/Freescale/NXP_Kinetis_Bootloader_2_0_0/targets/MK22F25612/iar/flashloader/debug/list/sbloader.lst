###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Aug/2016  13:15:59
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\sbloader\src\sbloader.c
#    Command line =  
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\sbloader\src\sbloader.c"
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN256VDC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D BL_TARGET_RAM -lC
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj"
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices/MK22F25612\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/autobaud\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/osa\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device/class\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/bm_usb\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/CMSIS/Include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers/common\"
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list\sbloader.lst
#    Object file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj\sbloader.o
#
###############################################################################

C:\Users\cwati\Documents\My Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\sbloader\src\sbloader.c
      1          /*
      2           * Copyright (c) 2013, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include <stdint.h>
     32          #include <stdio.h>
     33          #include <string.h>
     34          #include "sbloader/sbloader.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void debug_printf(char const *, ...)
   \                     debug_printf: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB500             PUSH     {LR}
   \   00000004   0xA901             ADD      R1,SP,#+4
   \   00000006   0x.... 0x....      BL       vprintf
   \   0000000A   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
     35          #include "bootloader/bl_context.h"
     36          #include "bootloader/bootloader.h"
     37          #include "bootloader/bl_shutdown_cleanup.h"
     38          #if BL_FEATURE_ENCRYPTION
     39          #include "security/aes_security.h"
     40          #include "security/cbc_mac.h"
     41          #endif // BL_FEATURE_ENCRYPTION
     42          #include "utilities/fsl_assert.h"
     43          #include "utilities/fsl_rtos_abstraction.h"
     44          
     45          #if DEBUG
     46          #include "property/property.h"
     47          #endif
     48          
     49          #if BL_FEATURE_QSPI_MODULE
     50          #include "qspi/qspi.h"
     51          #endif
     52          #if BL_FEATURE_OTFAD_MODULE
     53          #include "otfad/fsl_otfad_driver.h"
     54          #endif
     55          
     56          #ifdef BOOTLOADER_HOST
     57          #error BOOTLOADER_HOST is deprecated
     58          #endif
     59          
     60          //! @addtogroup sbloader
     61          //! @{
     62          
     63          ////////////////////////////////////////////////////////////////////////////////
     64          // Definitions
     65          ////////////////////////////////////////////////////////////////////////////////
     66          
     67          #define SB_KEY_RDONCE_INDEX 0x30
     68          
     69          ////////////////////////////////////////////////////////////////////////////////
     70          // Prototypes
     71          ////////////////////////////////////////////////////////////////////////////////
     72          typedef struct _ldr_buf ldr_buf_t;
     73          
     74          struct _ldr_buf
     75          {
     76              chunk_t data;
     77              uint32_t fillPosition;
     78          };
     79          
     80          //! Loader utilities.
     81          status_t ldr_GoToNextSection(ldr_Context_t *);
     82          status_t sbloader_handle_chunk(void);
     83          
     84          //! Loader action (context.Action) functions for header processing.
     85          status_t ldr_DoHeader(ldr_Context_t *);
     86          status_t ldr_DoHeader1(ldr_Context_t *);
     87          status_t ldr_DoHeader2(ldr_Context_t *);
     88          status_t ldr_DoHeaderMac(ldr_Context_t *);
     89          status_t ldr_DoKeyTest(ldr_Context_t *);
     90          status_t ldr_DoGetDek(ldr_Context_t *);
     91          
     92          //! Loader action (context.Action) functions for command processing.
     93          status_t ldr_DoInit(ldr_Context_t *);
     94          status_t ldr_DoCommand(ldr_Context_t *);
     95          status_t ldr_DoLoadBytes(ldr_Context_t *);
     96          status_t ldr_DoLoadChunks(ldr_Context_t *);
     97          status_t ldr_DoLoadCmd(ldr_Context_t *);
     98          status_t ldr_DoFillCmd(ldr_Context_t *);
     99          status_t ldr_DoJumpCmd(ldr_Context_t *);
    100          status_t ldr_DoCallCmd(ldr_Context_t *);
    101          status_t ldr_DoTagCmd(ldr_Context_t *);
    102          status_t ldr_DoEraseCmd(ldr_Context_t *);
    103          status_t ldr_DoResetCmd(ldr_Context_t *);
    104          status_t ldr_DoMemEnableCmd(ldr_Context_t *);
    105          status_t ldr_DoProgramCmd(ldr_Context_t *);
    106          
    107          ////////////////////////////////////////////////////////////////////////////////
    108          // Data
    109          ////////////////////////////////////////////////////////////////////////////////
    110          
    111          //! static loader context data.
    112          static ldr_Context_t s_loaderContext;
    113          
    114          //! static buffer queueing up a chunk worth of data
    115          static ldr_buf_t s_loaderBuf;
    116          
    117          #if AES_SECURITY_SUPPORTED
    118          //! Pointer for the aes which will for now be a null pointer unless in debug mode
    119          //! we will try to read from the config area
    120          static uint32_t s_aesKey[AES_128_KEY_SIZE_WORDS];
    121          #endif
    122          
    123          ////////////////////////////////////////////////////////////////////////////////
    124          //! \brief  Skip ahead to the next "tag" command
    125          //!
    126          //! \This function will set up the skipCount to skip over the remainder of any section
    127          //! \that you are currently in. If encryption is enabled it will also re-init the encryption
    128          //! \process to begin on the new section it arrives at.
    129          //!
    130          //! \retval kStatus_Success
    131          //! \retval kStatusRomLdrEOFReached if the end of the image file is reached.
    132          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    133          status_t ldr_GoToNextSection(ldr_Context_t *context)
    134          {
    135              // If we are not in the last section of the image file, setup to get a
    136              // "tag" command then skip the remaining chunks in the section. Otherwise,
    137              // return an error.
    138              if (context->fileChunks > context->sectChunks)
   \                     ldr_GoToNextSection: (+1)
   \   00000000   0x6841             LDR      R1,[R0, #+4]
   \   00000002   0x6882             LDR      R2,[R0, #+8]
   \   00000004   0x428A             CMP      R2,R1
   \   00000006   0xD209             BCS.N    ??ldr_GoToNextSection_0
    139              {
    140                  // Skip over any remaining chunks in section, making sure to adjust
    141                  // the file chunk count.
    142                  context->fileChunks -= context->sectChunks;
   \   00000008   0x1A89             SUBS     R1,R1,R2
   \   0000000A   0x6041             STR      R1,[R0, #+4]
    143                  context->skipCount = context->sectChunks;
   \   0000000C   0x6682             STR      R2,[R0, #+104]
    144          
    145                  // Setup the loader context to get the next command
    146                  context->Action = ldr_DoCommand;
   \   0000000E   0x.... 0x....      ADR.W    R1,ldr_DoCommand
   \   00000012   0x6001             STR      R1,[R0, #+0]
    147          
    148          // Reinit the encryption for the start of a new section
    149          #if AES_SECURITY_SUPPORTED
    150                  if (context->keyCount)
    151                  {
    152                      cbc_mac_init(context->dek, context->initVector);
    153                  }
    154          #endif
    155          
    156                  // Assume for now the new section has at least one chunk
    157                  context->sectChunks = 1;
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x6081             STR      R1,[R0, #+8]
    158          
    159                  return kStatus_Success;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR
    160              }
    161          
    162              // No where to skip to, so return an error
    163              return kStatusRomLdrEOFReached;
   \                     ??ldr_GoToNextSection_0: (+1)
   \   0000001C   0xF242 0x7078      MOVW     R0,#+10104
   \   00000020   0x4770             BX       LR               ;; return
    164          }
    165          
    166          ////////////////////////////////////////////////////////////////////////////////
    167          //! \brief  Loader action function processes the first header chunk
    168          //!
    169          //! Processes the first header chunk of the boot image file, which
    170          //! saves the SHA-1 to the context initVector field, the CBC-MAC process is
    171          //! started here to handle the DEK if one is found
    172          //!
    173          //! \param[in]  context    Pointer to a loader context structure.
    174          //!
    175          //! \pre    context->src points at the current header chunk.
    176          //!
    177          //! \post   context->Action is set to process the next header chunk.
    178          //!
    179          //! \retval SUCCESS
    180          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    181          status_t ldr_DoHeader(ldr_Context_t *context)
    182          {
    183          #if AES_SECURITY_SUPPORTED
    184              // Start the cbc-mac decode process which we may not need but won't know until we get
    185              // to the keyCount variable in the header
    186              cbc_mac_init((uint8_t *)&s_aesKey, 0);
    187          
    188              // The contents of header chunk[0] are used as the initialization vector
    189              // for the CBC decryption process. Save this value in the loader context.
    190              memcpy(context->initVector, context->src, sizeof(chunk_t));
    191          
    192              // Feed the cbc mac the received data, and store the data in the DEK
    193              cbc_mac_encrypt(context->src, sizeof(chunk_t), context->dek);
    194          #endif
    195          
    196              // Setup to process the next header chunk
    197              context->Action = ldr_DoHeader1;
   \                     ldr_DoHeader: (+1)
   \   00000000   0x.... 0x....      ADR.W    R1,ldr_DoHeader1
   \   00000004   0x....             B.N      ?Subroutine0
    198          
    199              return kStatus_Success;
    200          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
    201          
    202          ////////////////////////////////////////////////////////////////////////////////
    203          //! \brief  Loader action function processes header chunk 1
    204          //!
    205          //! Processes the second header chunk of the boot image file, which contains
    206          //! the file signature, version, flags and chunk count.
    207          //!
    208          //! \param[in]  context    Pointer to a loader context structure.
    209          //!
    210          //! \pre    context->src points at the current header chunk.
    211          //!
    212          //! \post   context->Action is set to process the next header chunk.
    213          //! \post   context->fileChunks and fileFlags are set to the header values.
    214          //!
    215          //! \retval kStatus_Success
    216          //! \retval kStatusRomLdrSignature if the signature or version are incorrect.
    217          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 4, keep-with-next
    218          status_t ldr_DoHeader1(ldr_Context_t *context)
    219          {
    220              boot_hdr1_t *pHdr1 = (boot_hdr1_t *)context->src;
   \                     ldr_DoHeader1: (+1)
   \   00000000   0x6A41             LDR      R1,[R0, #+36]
    221          
    222              // Copy the file flags and chunk count
    223              context->fileFlags = pHdr1->fileFlags;
    224              context->fileChunks = pHdr1->fileChunks - 2;
    225          
    226              // Check the file signature and version
    227              if ((pHdr1->signature != BOOT_SIGNATURE) || (pHdr1->major > SB_FILE_MAJOR_VERSION))
   \   00000002   0x.... 0x....      LDR.W    R3,??DataTable12  ;; 0x504d5453
   \   00000006   0x894A             LDRH     R2,[R1, #+10]
   \   00000008   0x8282             STRH     R2,[R0, #+20]
   \   0000000A   0x68CA             LDR      R2,[R1, #+12]
   \   0000000C   0x1E92             SUBS     R2,R2,#+2
   \   0000000E   0x6042             STR      R2,[R0, #+4]
   \   00000010   0x684A             LDR      R2,[R1, #+4]
   \   00000012   0x429A             CMP      R2,R3
   \   00000014   0xD102             BNE.N    ??ldr_DoHeader1_0
   \   00000016   0x7A09             LDRB     R1,[R1, #+8]
   \   00000018   0x2902             CMP      R1,#+2
   \   0000001A   0xDB02             BLT.N    ??ldr_DoHeader1_1
    228              {
    229                  return kStatusRomLdrSignature;
   \                     ??ldr_DoHeader1_0: (+1)
   \   0000001C   0xF242 0x7075      MOVW     R0,#+10101
   \   00000020   0x4770             BX       LR
    230              }
    231              else
    232              {
    233          #if AES_SECURITY_SUPPORTED
    234                  // Feed the cbc mac the received data
    235                  cbc_mac_encrypt(context->src, sizeof(chunk_t), context->dek);
    236          #endif
    237          
    238                  // Setup to process the next header chunk
    239                  context->Action = ldr_DoHeader2;
   \                     ??ldr_DoHeader1_1: (+1)
   \   00000022   0x.... 0x....      ADR.W    R1,ldr_DoHeader2
   \   00000026   0xBF00             Nop      
   \   00000028                      REQUIRE ?Subroutine0
   \   00000028                      ;; // Fall through to label ?Subroutine0
    240          
    241                  return kStatus_Success;
    242              }
    243          }
    244          
    245          ////////////////////////////////////////////////////////////////////////////////
    246          //! \brief  Loader action function processes header chunk 2
    247          //!
    248          //! Processes the third header chunk of the boot image file, which contains
    249          //! parameters for the first boot section and the key dictionary.
    250          //!
    251          //! \param[in]  context    Pointer to a loader context structure.
    252          //!
    253          //! \pre    context->src points at the current header chunk.
    254          //!
    255          //! \post   context->Action is set to process the next header chunk.
    256          //! \post   context->sectChunks, objectID and keyCount are set to the header values.
    257          //!
    258          //! \retval kStatus_Success
    259          //! \retval kStatusRomLdrSectionLength if the bootOffset is out of range.
    260          //! \retval kStatusRomLdrUnencryptedOnly if the unencrypted image is disabled.
    261          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 4, keep-with-next
    262          status_t ldr_DoHeader2(ldr_Context_t *context)
    263          {
   \                     ldr_DoHeader2: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB082             SUB      SP,SP,#+8
    264              boot_hdr2_t *pHdr2 = (boot_hdr2_t *)context->src;
   \   00000006   0x6A60             LDR      R0,[R4, #+36]
    265          
    266              // Save first boot section parameters
    267              context->objectID = pHdr2->bootSectID;
   \   00000008   0x6841             LDR      R1,[R0, #+4]
    268              // Set up our first sectChunks value since we can determine it now
    269              context->sectChunks = pHdr2->bootOffset - 3;
    270          
    271              // Sanity check the section chunk count
    272              if (context->sectChunks >= context->fileChunks)
   \   0000000A   0x6862             LDR      R2,[R4, #+4]
   \   0000000C   0x61A1             STR      R1,[R4, #+24]
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0x1EC9             SUBS     R1,R1,#+3
   \   00000012   0x4291             CMP      R1,R2
   \   00000014   0x60A1             STR      R1,[R4, #+8]
   \   00000016   0xD302             BCC.N    ??ldr_DoHeader2_0
    273              {
    274                  return kStatusRomLdrSectionLength;
   \   00000018   0xF242 0x7076      MOVW     R0,#+10102
   \   0000001C   0xBD16             POP      {R1,R2,R4,PC}
    275              }
    276          
    277              // Check whether the image is encrypted
    278              if (pHdr2->keyCount != 0)
   \                     ??ldr_DoHeader2_0: (+1)
   \   0000001E   0x8900             LDRH     R0,[R0, #+8]
   \   00000020   0xB130             CBZ.N    R0,??ldr_DoHeader2_1
    279              {
    280          #if AES_SECURITY_SUPPORTED
    281                  // Save the key count for the dictionary search
    282                  context->keyCount = pHdr2->keyCount;
    283          
    284                  // Use bootCmd.count as temporary storage to hold the number of chunks
    285                  // remaining in the plaintext header
    286                  context->bootCmd.count = pHdr2->keyOffset - 3;
    287          
    288                  // Set action to finish calculation of CBC MAC over the header
    289                  context->Action = ldr_DoHeaderMac;
    290          
    291                  // Feed the cbc mac the received data
    292                  cbc_mac_encrypt(context->src, sizeof(chunk_t), context->dek);
    293          
    294                  return kStatus_Success;
    295          #else
    296                  debug_printf("Error: image is encrypted\r\n");
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       debug_printf
    297                  return kStatusRomLdrUnencryptedOnly;
   \   0000002A   0xF242 0x7077      MOVW     R0,#+10103
   \   0000002E   0xBD16             POP      {R1,R2,R4,PC}
    298          #endif
    299              }
    300              else
    301              {
    302                  flash_security_state_t securityState = kFLASH_SecurityStateNotSecure;
   \                     ??ldr_DoHeader2_1: (+1)
   \   00000030   0xF88D 0x0000      STRB     R0,[SP, #+0]
    303                  // If the image is not encrypted and we have flash security enabled
    304                  // abort the transfer
    305                  g_bootloaderContext.flashDriverInterface->flash_get_security_state(&g_bootloaderContext.flashState,
    306                                                                                     &securityState);
   \   00000034   0x4669             MOV      R1,SP
   \   00000036   0x.... 0x....      LDR.W    R2,??DataTable12_1
   \   0000003A   0xF102 0x0020      ADD      R0,R2,#+32
   \   0000003E   0x6912             LDR      R2,[R2, #+16]
   \   00000040   0x6992             LDR      R2,[R2, #+24]
   \   00000042   0x4790             BLX      R2
    307          
    308                  if (securityState != kFLASH_SecurityStateNotSecure)
   \   00000044   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000048   0xB110             CBZ.N    R0,??ldr_DoHeader2_2
    309                  {
    310                      return kStatusRomLdrSecureOnly;
   \   0000004A   0xF242 0x7081      MOVW     R0,#+10113
   \   0000004E   0xBD16             POP      {R1,R2,R4,PC}
    311                  }
    312          
    313                  // Skip the rest of the header
    314                  return ldr_GoToNextSection(context);
   \                     ??ldr_DoHeader2_2: (+1)
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       ldr_GoToNextSection
   \   00000056   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    315              }
    316          }
    317          
    318          ////////////////////////////////////////////////////////////////////////////////
    319          //! \brief  Loader action function finishes CBC-MAC over final header chunks
    320          //!
    321          //! Completes the CBC-MAC calculation over the remaining plaintext header.
    322          //! This function will only get called if CBC_MAC is supported
    323          //!
    324          //! \param[in]  context    Pointer to a loader context structure.
    325          //!
    326          //! \pre    context->src points at the current header chunk.
    327          //! \pre    context->bootCmd.count = number of chunks left in plaintext header.
    328          //!
    329          //! \post   context->scratchPad contains the computed CBC-MAC.
    330          //! \post   context->bootCmd.count is updated.
    331          //!
    332          //! \retval SUCCESS
    333          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    334          status_t ldr_DoHeaderMac(ldr_Context_t *context)
    335          {
    336              // Continue to compute the CBC-MAC over the remaining plaintext header
    337              // one chunk at a time.
    338              --context->sectChunks;
   \                     ldr_DoHeaderMac: (+1)
   \   00000000   0x6881             LDR      R1,[R0, #+8]
   \   00000002   0x1E49             SUBS     R1,R1,#+1
   \   00000004   0x6081             STR      R1,[R0, #+8]
    339          
    340          #if AES_SECURITY_SUPPORTED
    341              // Feed the cbc mac the received data
    342              cbc_mac_encrypt(context->src, sizeof(chunk_t), context->dek);
    343          #endif
    344          
    345              if (--(context->bootCmd.count) == 0)
   \   00000006   0x6E01             LDR      R1,[R0, #+96]
   \   00000008   0x1E49             SUBS     R1,R1,#+1
   \   0000000A   0x6601             STR      R1,[R0, #+96]
   \   0000000C   0xBF04             ITT      EQ 
   \   0000000E   0x.... 0x....      ADREQ.W  R1,ldr_DoKeyTest
   \   00000012   0x6001             STREQ    R1,[R0, #+0]
    346              {
    347                  context->Action = ldr_DoKeyTest;
    348              }
    349          
    350              return kStatus_Success;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR               ;; return
    351          }
    352          
    353          ////////////////////////////////////////////////////////////////////////////////
    354          //! \brief  Loader action function processes a key dictionary match
    355          //!
    356          //! This loader action function is one of three functions used to parse the
    357          //! key dictionary. It is called after a match of the CBC-MAC is found and the
    358          //! session key (DEK) is decrypted. It saves the DEK in the boot context and
    359          //! then skips to the first boot command in the image.
    360          //! This function will only get called if CBC_MAC is supported
    361          //!
    362          //! \param[in]  context    Pointer to a loader context structure.
    363          //!
    364          //! \pre    context->src points to the the encrypted session key.
    365          //! \pre    context->initVector contains the SHA-1 chunk from the header
    366          //!
    367          //! \post   *context is setup to decrypt the first boot command.
    368          //! \post   The session key is decrypted and stored in the context dek field
    369          //!
    370          //! \return Return value from ldr_GoToNextSection().
    371          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    372          status_t ldr_DoGetDek(ldr_Context_t *context)
    373          {
    374              --context->sectChunks;
   \                     ldr_DoGetDek: (+1)
   \   00000000   0x6881             LDR      R1,[R0, #+8]
   \   00000002   0x1E49             SUBS     R1,R1,#+1
   \   00000004   0x6081             STR      R1,[R0, #+8]
    375          
    376          #if AES_SECURITY_SUPPORTED
    377              // Use the OTP key and the init vector from the header
    378              cbc_mac_init((uint8_t *)&s_aesKey, context->initVector);
    379          
    380              // decrypt the dek
    381              cbc_mac_decrypt(context->src, sizeof(chunk_t), context->dek);
    382          #endif
    383          
    384              // Skip ahead to the next section
    385              return ldr_GoToNextSection(context);
   \   00000006   0x....             B.N      ldr_GoToNextSection
    386          }
    387          
    388          ////////////////////////////////////////////////////////////////////////////////
    389          //! \brief  Loader action function tests for a key dictionary match
    390          //!
    391          //! This loader action function is one of three functions used to parse the
    392          //! key dictionary. It is called after a CBC-MAC entry from the dictionary
    393          //! has been read. If the value read is equal to the computed CBC-MAC, then
    394          //! the next encrypted chunk holds the session key (DEK), and the next action
    395          //! function will decrypt the key. Otherwise if there are remaining entries
    396          //! in the dictionary, the next action will get the next CBC-MAC to test.
    397          //!
    398          //! \param[in]  context    Pointer to a loader context structure.
    399          //!
    400          //! \pre    context->dek holds the CBC-MAC computed over the header.
    401          //! \pre    context->src holds a CBC-MAC value from the dictionary.
    402          //!
    403          //! \post   if CBC-MAC matches we transition to decrypt the DEK
    404          //! \post   context->keyCount is updated to the remaining number of keys to test.
    405          //!
    406          //! \retval SUCCESS
    407          //! \retval ERROR_ROM_LDR_KEY_NOT_FOUND if there are no more entries in the
    408          //!             dictionary and a CBC-MAC match was not found.
    409          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 4, keep-with-next
    410          status_t ldr_DoKeyTest(ldr_Context_t *context)
    411          {
   \                     ldr_DoKeyTest: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
    412              status_t rc = kStatus_Success;
    413          
    414              --context->sectChunks;
    415          
    416              // See if the computed CBC-MAC and the dictionary entry match
    417              if (memcmp(context->dek, context->src, sizeof(chunk_t)) == 0)
   \   00000004   0x2210             MOVS     R2,#+16
   \   00000006   0x68A8             LDR      R0,[R5, #+8]
   \   00000008   0x6A69             LDR      R1,[R5, #+36]
   \   0000000A   0x1E46             SUBS     R6,R0,#+1
   \   0000000C   0x60AE             STR      R6,[R5, #+8]
   \   0000000E   0xF105 0x0038      ADD      R0,R5,#+56
   \   00000012   0x.... 0x....      BL       memcmp
   \   00000016   0x2400             MOVS     R4,#+0
   \   00000018   0xB918             CBNZ.N   R0,??ldr_DoKeyTest_0
    418              {
    419                  // Yes, the next chunk holds the session key. The next action will
    420                  // load the key and terminate the key search.
    421                  context->Action = ldr_DoGetDek;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   0000001E   0x6028             STR      R0,[R5, #+0]
   \   00000020   0xE00B             B.N      ??ldr_DoKeyTest_1
    422              }
    423              else if (--(context->keyCount) > 0)
   \                     ??ldr_DoKeyTest_0: (+1)
   \   00000022   0x8AE8             LDRH     R0,[R5, #+22]
   \   00000024   0x1E40             SUBS     R0,R0,#+1
   \   00000026   0x82E8             STRH     R0,[R5, #+22]
   \   00000028   0xB280             UXTH     R0,R0
   \   0000002A   0xB120             CBZ.N    R0,??ldr_DoKeyTest_2
    424              {
    425                  // No, but there are more entries in the dictionary, so go get the
    426                  // next one to test. Skip over the next chunk which is the unmatching DEK
    427                  --context->sectChunks;
   \   0000002C   0x1E70             SUBS     R0,R6,#+1
   \   0000002E   0x60A8             STR      R0,[R5, #+8]
    428                  context->skipCount = 1;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x66A8             STR      R0,[R5, #+104]
   \   00000034   0xE001             B.N      ??ldr_DoKeyTest_1
    429              }
    430              else
    431              {
    432                  // No, and there are no more entries in the dictionary.
    433                  rc = kStatusRomLdrKeyNotFound;
   \                     ??ldr_DoKeyTest_2: (+1)
   \   00000036   0xF44F 0x541E      MOV      R4,#+10112
    434              }
    435          
    436              return rc;
   \                     ??ldr_DoKeyTest_1: (+1)
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
    437          }
    438          
    439          ////////////////////////////////////////////////////////////////////////////////
    440          //! \brief  Loader action function loads the trailing "ragged edge bytes"
    441          //!
    442          //! Implements the second of two action functions for the boot "load" command.
    443          //! The last move sequence for the load command moves the final
    444          //! payload chunk. This function checks the payload
    445          //! CRC, then copies the final load bytes to the load
    446          //! destination.
    447          //!
    448          //! \param[in]  context    Pointer to a loader context structure.
    449          //!
    450          //! \pre    context->bootCmd contains the boot command.
    451          //! \pre    context->src contains the final decrypted payload chunk.
    452          //! \pre    context->crc32 holds the CRC calculated over the entire payload.
    453          //!
    454          //! \post   *context is setup to get the next boot command.
    455          //!
    456          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    457          status_t ldr_DoLoadBytes(ldr_Context_t *context)
    458          {
   \                     ldr_DoLoadBytes: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    459              uint32_t crc32Result;
    460          
    461          // Copy the trailing edge payload bytes to the load destination.
    462          #if AES_SECURITY_SUPPORTED
    463              if (context->keyCount)
    464              {
    465                  // decrypt the block in place
    466                  cbc_mac_decrypt(context->src, sizeof(chunk_t), context->src);
    467              }
    468          #endif
    469          
    470              status_t status =
    471                  g_bootloaderContext.memoryInterface->write(context->bootCmd.address, context->bootCmd.count, context->src);
   \   00000002   0x.... 0x....      LDR.W    R5,??DataTable12_1
   \   00000006   0x682B             LDR      R3,[R5, #+0]
   \   00000008   0x689B             LDR      R3,[R3, #+8]
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0x6A62             LDR      R2,[R4, #+36]
   \   0000000E   0x6E21             LDR      R1,[R4, #+96]
   \   00000010   0x6DE0             LDR      R0,[R4, #+92]
   \   00000012   0x4798             BLX      R3
    472          
    473              if (status != kStatus_Success)
   \   00000014   0xB9A8             CBNZ.N   R0,??ldr_DoLoadBytes_0
    474              {
    475                  return status;
    476              }
    477          
    478              if (context->receivedChunks >= (context->sectChunks - 1))
   \   00000016   0x68A1             LDR      R1,[R4, #+8]
   \   00000018   0x6920             LDR      R0,[R4, #+16]
   \   0000001A   0x1E49             SUBS     R1,R1,#+1
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD303             BCC.N    ??ldr_DoLoadBytes_1
    479              {
    480                  // Force to write buffered data to target memory if it is last data
    481                  // chunks without reset/call/jump command at the end
    482                  assert(g_bootloaderContext.memoryInterface->flush);
    483                  status = g_bootloaderContext.memoryInterface->flush();
   \   00000020   0x6828             LDR      R0,[R5, #+0]
   \   00000022   0x6900             LDR      R0,[R0, #+16]
   \   00000024   0x4780             BLX      R0
    484                  if (status != kStatus_Success)
   \   00000026   0xB960             CBNZ.N   R0,??ldr_DoLoadBytes_0
    485                  {
    486                      return status;
    487                  }
    488              }
    489          
    490              // update the crc running value then finalize
    491              crc32_update(&context->crc32, context->src, sizeof(chunk_t));
   \                     ??ldr_DoLoadBytes_1: (+1)
   \   00000028   0x.... 0x....      BL       ?Subroutine4
    492          
    493              crc32_finalize(&context->crc32, &crc32Result);
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000002C   0x.... 0x....      BL       ?Subroutine5
    494          
    495              if (crc32Result != context->bootCmd.data)
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000030   0x9800             LDR      R0,[SP, #+0]
   \   00000032   0x6E61             LDR      R1,[R4, #+100]
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD000             BEQ.N    ??ldr_DoLoadBytes_2
    496              {
    497                  return kStatusRomLdrCrc32Error;
   \   00000038   0x....             B.N      ?Subroutine2
    498              }
    499          
    500              // Setup to get the next boot command.
    501              context->Action = ldr_DoCommand;
   \                     ??ldr_DoLoadBytes_2: (+1)
   \   0000003A   0x.... 0x....      ADR.W    R0,ldr_DoCommand
   \   0000003E   0x6020             STR      R0,[R4, #+0]
    502          
    503              return kStatus_Success;
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??ldr_DoLoadBytes_0: (+1)
   \   00000042   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    504          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x4669             MOV      R1,SP
   \   00000002   0xF104 0x001C      ADD      R0,R4,#+28
   \   00000006   0x.... 0x....      B.W      crc32_finalize

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x6A61             LDR      R1,[R4, #+36]
   \   00000002   0x2210             MOVS     R2,#+16
   \   00000004   0xF104 0x001C      ADD      R0,R4,#+28
   \   00000008   0x.... 0x....      B.W      crc32_update

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xF242 0x707A      MOVW     R0,#+10106
   \   00000004   0xBD32             POP      {R1,R4,R5,PC}
    505          
    506          ////////////////////////////////////////////////////////////////////////////////
    507          //! \brief  Loader action function loads data chunks
    508          //!
    509          //! Implements the first of two action functions for the boot "load" command.
    510          //! Loads one or more complete "chunk size" blocks of data.
    511          //!
    512          //! If the amount of data remaining to load is one chunk or less, it sets the
    513          //! state sequence to move the next chunk. The
    514          //! action function is changed to \ref ldr_DoLoadBytes, which will check the
    515          //! payload CRC and copy to the correct location.
    516          //!
    517          //! \param[in]  context    Pointer to a loader context structure.
    518          //!
    519          //! \pre    context->bootCmd contains the boot command.
    520          //!
    521          //! \post   context->bootCmd is adjusted to reflect the previous move.
    522          //! \post   context->Action is set to move the next received payload.
    523          //!
    524          //! \retval kStatus_Success
    525          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    526          status_t ldr_DoLoadChunks(ldr_Context_t *context)
    527          {
   \                     ldr_DoLoadChunks: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    528              uint32_t crc32Result;
    529          
    530          #if AES_SECURITY_SUPPORTED
    531              if (context->keyCount)
    532              {
    533                  // decrypt the block in place
    534                  cbc_mac_decrypt(context->src, sizeof(chunk_t), context->src);
    535              }
    536          #endif
    537          
    538              // update the crc running value
    539              crc32_update(&context->crc32, context->src, sizeof(chunk_t));
   \   00000004   0x....             LDR.N    R5,??DataTable12_1
   \   00000006   0x.... 0x....      BL       ?Subroutine4
    540          
    541              status_t status =
    542                  g_bootloaderContext.memoryInterface->write(context->bootCmd.address, sizeof(chunk_t), context->src);
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000000A   0x682B             LDR      R3,[R5, #+0]
   \   0000000C   0x6A62             LDR      R2,[R4, #+36]
   \   0000000E   0x6DE0             LDR      R0,[R4, #+92]
   \   00000010   0x689B             LDR      R3,[R3, #+8]
   \   00000012   0x2110             MOVS     R1,#+16
   \   00000014   0x4798             BLX      R3
    543              if (status != kStatus_Success)
   \   00000016   0xB9D8             CBNZ.N   R0,??ldr_DoLoadChunks_0
    544              {
    545                  return status;
    546              }
    547          
    548              // Adjust the boot command parameters to reflect the last move
    549              context->bootCmd.address += sizeof(chunk_t);
   \   00000018   0x6DE0             LDR      R0,[R4, #+92]
   \   0000001A   0x3010             ADDS     R0,R0,#+16
   \   0000001C   0x65E0             STR      R0,[R4, #+92]
    550              context->bootCmd.count -= sizeof(chunk_t);
   \   0000001E   0x6E20             LDR      R0,[R4, #+96]
   \   00000020   0x3810             SUBS     R0,R0,#+16
   \   00000022   0x6620             STR      R0,[R4, #+96]
    551              if (context->bootCmd.count > sizeof(chunk_t))
   \   00000024   0x2811             CMP      R0,#+17
   \   00000026   0xBF28             IT       CS 
   \   00000028   0x....             LDRCS.N  R0,??DataTable12_3
    552              {
    553                  context->Action = ldr_DoLoadChunks;
   \   0000002A   0xD20F             BCS.N    ??ldr_DoLoadChunks_1
    554              }
    555              else if (context->bootCmd.count)
   \   0000002C   0xB108             CBZ.N    R0,??ldr_DoLoadChunks_2
    556              {
    557                  context->Action = ldr_DoLoadBytes;
   \   0000002E   0x....             LDR.N    R0,??DataTable12_4
   \   00000030   0xE00C             B.N      ??ldr_DoLoadChunks_1
    558              }
    559              else
    560              {
    561                  // Force to write buffered data to target memory
    562                  assert(g_bootloaderContext.memoryInterface->flush);
    563                  status = g_bootloaderContext.memoryInterface->flush();
   \                     ??ldr_DoLoadChunks_2: (+1)
   \   00000032   0x6828             LDR      R0,[R5, #+0]
   \   00000034   0x6900             LDR      R0,[R0, #+16]
   \   00000036   0x4780             BLX      R0
    564                  if (status != kStatus_Success)
   \   00000038   0xB950             CBNZ.N   R0,??ldr_DoLoadChunks_0
    565                  {
    566                      return status;
    567                  }
    568          
    569                  // The last amount of data we received was a full chunk so get our crc result
    570                  crc32_finalize(&context->crc32, &crc32Result);
   \   0000003A   0x.... 0x....      BL       ?Subroutine5
    571          
    572                  if (crc32Result != context->bootCmd.data)
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000003E   0x9800             LDR      R0,[SP, #+0]
   \   00000040   0x6E61             LDR      R1,[R4, #+100]
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xD000             BEQ.N    ??ldr_DoLoadChunks_3
    573                  {
    574                      return kStatusRomLdrCrc32Error;
   \   00000046   0x....             B.N      ?Subroutine2
    575                  }
    576          
    577                  context->Action = ldr_DoCommand;
   \                     ??ldr_DoLoadChunks_3: (+1)
   \   00000048   0x.... 0x....      ADR.W    R0,ldr_DoCommand
   \                     ??ldr_DoLoadChunks_1: (+1)
   \   0000004C   0x6020             STR      R0,[R4, #+0]
    578              }
    579          
    580              return kStatus_Success;
   \   0000004E   0x2000             MOVS     R0,#+0
   \                     ??ldr_DoLoadChunks_0: (+1)
   \   00000050   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    581          }
    582          
    583          ////////////////////////////////////////////////////////////////////////////////
    584          //! \brief  Loader "load" command handler
    585          //!
    586          //! Implements the first command handler called for the boot "load" command.
    587          //! The load action is split into two functions:
    588          //! - \ref ldr_DoLoadChunks, loads chunks
    589          //! - \ref ldr_DoLoadBytes, loads the trailing "ragged edge bytes"
    590          //! This function initializes the context before calling load action.
    591          //!
    592          //! \param[in]  context    Pointer to a loader context structure.
    593          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    594          status_t ldr_DoLoadCmd(ldr_Context_t *context)
    595          {
   \                     ldr_DoLoadCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    596              // initialize crc32
    597              crc32_init(&context->crc32);
   \   00000004   0xF104 0x001C      ADD      R0,R4,#+28
   \   00000008   0x.... 0x....      BL       crc32_init
    598          
    599              // Next chunk will be the first chunk to load, if its a full chunk do load chunks
    600              if (context->bootCmd.count > sizeof(chunk_t))
   \   0000000C   0x6E20             LDR      R0,[R4, #+96]
   \   0000000E   0x2811             CMP      R0,#+17
   \   00000010   0xBF2C             ITE      CS 
   \   00000012   0x....             LDRCS.N  R0,??DataTable12_3
   \   00000014   0x....             LDRCC.N  R0,??DataTable12_4
    601              {
    602                  context->Action = ldr_DoLoadChunks;
    603              }
    604              else
    605              {
    606                  context->Action = ldr_DoLoadBytes;
   \   00000016   0x....             B.N      ?Subroutine3
    607              }
    608          
    609              return kStatus_Success;
    610          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x6020             STR      R0,[R4, #+0]
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xBD10             POP      {R4,PC}          ;; return
    611          
    612          ////////////////////////////////////////////////////////////////////////////////
    613          //! \brief  Loader "fill" command handler
    614          //!
    615          //! Implements the action function for the boot "fill" command.
    616          //!
    617          //! \param[in]  context    Pointer to a loader context structure.
    618          //!
    619          //! \pre    context->bootCmd contains the boot command.
    620          //!
    621          //! \post   *context is left setup to get the next boot command.
    622          //!
    623          //! \retval kStatus_Success
    624          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    625          status_t ldr_DoFillCmd(ldr_Context_t *context)
    626          {
    627              status_t status = g_bootloaderContext.memoryInterface->fill(context->bootCmd.address, context->bootCmd.count,
    628                                                                          context->bootCmd.data);
   \                     ldr_DoFillCmd: (+1)
   \   00000000   0x....             LDR.N    R3,??DataTable12_1
   \   00000002   0x681B             LDR      R3,[R3, #+0]
   \   00000004   0x6E42             LDR      R2,[R0, #+100]
   \   00000006   0x6E01             LDR      R1,[R0, #+96]
   \   00000008   0x6DC0             LDR      R0,[R0, #+92]
   \   0000000A   0x68DB             LDR      R3,[R3, #+12]
   \   0000000C   0x4718             BX       R3
    629              if (status != kStatus_Success)
    630              {
    631                  return status;
    632              }
    633          
    634              // Context is already setup to get the next boot command
    635              return kStatus_Success;
    636          }
    637          
    638          ////////////////////////////////////////////////////////////////////////////////
    639          //! \brief  Loader "program" command handler
    640          //!
    641          //! Implements the action function for the boot "program" command.
    642          //!
    643          //! \param[in]  context    Pointer to a loader context structure.
    644          //!
    645          //! \pre    context->bootCmd contains the boot command.
    646          //!
    647          //! \post   *context is left setup to get the next boot command.
    648          //!
    649          //! \retval kStatus_Success
    650          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    651          status_t ldr_DoProgramCmd(ldr_Context_t *context)
    652          {
   \                     ldr_DoProgramCmd: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    653              status_t status;
    654              uint32_t space = (context->bootCmd.flags >> ROM_MEM_SPACE_SHIFT) & ROM_MEM_SPACE_MASK;
   \   00000004   0xF8B4 0x005A      LDRH     R0,[R4, #+90]
    655              bool isEightByte = (context->bootCmd.flags & ROM_PROG_8BYTE_MASK) != 0;
    656              uint32_t byteCount = (isEightByte ? 8 : 4);
    657              uint32_t index = context->bootCmd.address;
   \   00000008   0x6DE6             LDR      R6,[R4, #+92]
   \   0000000A   0xF3C0 0x2103      UBFX     R1,R0,#+8,#+4
   \   0000000E   0x07C0             LSLS     R0,R0,#+31
   \   00000010   0xBF4C             ITE      MI 
   \   00000012   0x2508             MOVMI    R5,#+8
   \   00000014   0x2504             MOVPL    R5,#+4
    658              uint32_t *data =
    659                  &context->bootCmd.count; // First 4 bytes are in count field, second 4 bytes are in following data field
    660          
    661              if (space != kLdrMemorySpace_IFR0)
   \   00000016   0x2904             CMP      R1,#+4
   \   00000018   0xD001             BEQ.N    ??ldr_DoProgramCmd_0
    662              {
    663                  return kStatus_InvalidArgument;
   \   0000001A   0x2004             MOVS     R0,#+4
   \   0000001C   0xBDF2             POP      {R1,R4-R7,PC}
    664              }
    665          
    666              lock_acquire();
   \                     ??ldr_DoProgramCmd_0: (+1)
   \   0000001E   0x.... 0x....      BL       lock_acquire
    667              status = g_bootloaderContext.flashDriverInterface->flash_program_once(&g_bootloaderContext.flashState, index, data,
    668                                                                                    byteCount);
   \   00000022   0xF104 0x0260      ADD      R2,R4,#+96
   \   00000026   0x....             LDR.N    R7,??DataTable12_1
   \   00000028   0x693C             LDR      R4,[R7, #+16]
   \   0000002A   0x6B64             LDR      R4,[R4, #+52]
   \   0000002C   0x462B             MOV      R3,R5
   \   0000002E   0x4631             MOV      R1,R6
   \   00000030   0xF107 0x0020      ADD      R0,R7,#+32
   \   00000034   0x47A0             BLX      R4
   \   00000036   0x4604             MOV      R4,R0
    669              lock_release();
   \   00000038   0x.... 0x....      BL       lock_release
    670              if (status != kStatus_Success)
   \   0000003C   0x2C00             CMP      R4,#+0
   \   0000003E   0xBF14             ITE      NE 
   \   00000040   0x4620             MOVNE    R0,R4
   \   00000042   0x2000             MOVEQ    R0,#+0
    671              {
    672                  return status;
    673              }
    674          
    675              // Context is already setup to get the next boot command
    676              return kStatus_Success;
   \   00000044   0xBDF2             POP      {R1,R4-R7,PC}
    677          }
    678          
    679          ////////////////////////////////////////////////////////////////////////////////
    680          //! \brief  Loader "jump" command handler
    681          //!
    682          //! Implements the action function for the boot "jump" command.
    683          //!
    684          //! \param[in]  context    Pointer to a loader context structure.
    685          //!
    686          //! \pre    context->bootCmd contains the boot command.
    687          //!
    688          //! \retval kStatusRomLdrJumpReturned if the plugin returns
    689          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    690          status_t ldr_DoJumpCmd(ldr_Context_t *context)
    691          {
    692              // Actual jump is implemented in sbloader_finalize().
    693              return kStatus_AbortDataPhase;
   \                     ldr_DoJumpCmd: (+1)
   \   00000000   0x....             B.N      ?Subroutine1
    694          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xF242 0x7012      MOVW     R0,#+10002
   \   00000004   0x4770             BX       LR               ;; return
    695          
    696          ////////////////////////////////////////////////////////////////////////////////
    697          //! \brief  Loader "call" command handler
    698          //!
    699          //! Implements the action function for the boot "call" command.
    700          //!
    701          //! \param[in]  context    Pointer to a loader context structure.
    702          //!
    703          //! \pre    context->bootCmd contains the boot command.
    704          //!
    705          //! \post   *context is setup to get the next boot command.
    706          //! \post   context->objectID is set to the next boot section or image ID.
    707          //!
    708          //! \return Return code from plugin or ldr_GoToNextSection.
    709          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    710          status_t ldr_DoCallCmd(ldr_Context_t *context)
    711          {
   \                     ldr_DoCallCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    712              pCallFnc_t entry_fun = (pCallFnc_t)context->bootCmd.address;
    713              status_t rc = kStatusRomLdrCallFailed;
   \   00000004   0xF242 0x767F      MOVW     R6,#+10111
   \   00000008   0x6DE5             LDR      R5,[R4, #+92]
    714          
    715              // todo: need common impl with bootloader call cmd
    716          
    717              // Call the plugin entry point with the specified parameter. The plugin
    718              // can start a new section or image by returning the appropriate code and
    719              // updating the object id pointed to by the second parameter.
    720              if (is_valid_application_location((uint32_t)entry_fun))
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x.... 0x....      BL       is_valid_application_location
   \   00000010   0xB180             CBZ.N    R0,??ldr_DoCallCmd_0
    721              {
    722                  rc = entry_fun(context->bootCmd.data, &context->objectID);
   \   00000012   0x6E60             LDR      R0,[R4, #+100]
   \   00000014   0xF104 0x0118      ADD      R1,R4,#+24
   \   00000018   0x47A8             BLX      R5
   \   0000001A   0x4606             MOV      R6,R0
    723              }
    724          
    725              if (rc == ROM_BOOT_SECTION_ID)
   \   0000001C   0x2E01             CMP      R6,#+1
   \   0000001E   0xD103             BNE.N    ??ldr_DoCallCmd_1
    726              {
    727                  // The plugin returned a section ID, skip ahead to the next section
    728                  return ldr_GoToNextSection(context);
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000026   0x....             B.N      ldr_GoToNextSection
    729              }
    730              else if (rc == ROM_BOOT_IMAGE_ID)
   \                     ??ldr_DoCallCmd_1: (+1)
   \   00000028   0x2E02             CMP      R6,#+2
   \   0000002A   0xD103             BNE.N    ??ldr_DoCallCmd_0
    731              {
    732                  // The plugin returned an image ID, restart the loader state machine
    733                  sbloader_init();
   \   0000002C   0x.... 0x....      BL       sbloader_init
    734                  return kStatus_Success;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD70             POP      {R4-R6,PC}
    735              }
    736              else
    737              {
    738                  // Otherwise, just pass on the plugin return code. Context is already
    739                  // setup to get the next boot command.
    740                  return rc;
   \                     ??ldr_DoCallCmd_0: (+1)
   \   00000034   0x4630             MOV      R0,R6
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return
    741              }
    742          }
    743          
    744          ////////////////////////////////////////////////////////////////////////////////
    745          //! \brief  Loader "tag" command handler
    746          //!
    747          //! Implements the action function for the boot "tag" command.
    748          //!
    749          //! \param[in]  context    Pointer to a loader context structure.
    750          //!
    751          //! \pre    context->bootCmd contains the boot command.
    752          //!
    753          //! \post   *context is setup to get the next boot command.
    754          //! \post   context->sectChunks is updated to the next section.
    755          //!
    756          //! \retval kStatusRomLdrSectionLength if new section count is out of range.
    757          //! \retval kStatusRomLdrIdNotFound if no match and no more sections.
    758          //! \retval Return code from ldr_GoToNextSection.
    759          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    760          status_t ldr_DoTagCmd(ldr_Context_t *context)
    761          {
   \                     ldr_DoTagCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    762              // Get the section chunk count from the boot command
    763              context->sectChunks = context->bootCmd.count;
   \   00000002   0xF100 0x015C      ADD      R1,R0,#+92
   \   00000006   0x1D03             ADDS     R3,R0,#+4
    764          
    765              // Sanity check the new section count
    766              if (context->sectChunks > context->fileChunks)
   \   00000008   0x681C             LDR      R4,[R3, #+0]
   \   0000000A   0x684A             LDR      R2,[R1, #+4]
   \   0000000C   0x605A             STR      R2,[R3, #+4]
   \   0000000E   0x4294             CMP      R4,R2
   \   00000010   0xD202             BCS.N    ??ldr_DoTagCmd_0
    767              {
    768                  return kStatusRomLdrSectionLength;
   \   00000012   0xF242 0x7076      MOVW     R0,#+10102
   \   00000016   0xBD10             POP      {R4,PC}
    769              }
    770          
    771              if ((context->bootCmd.data & SFLG_SECTION_BOOTABLE) && (context->bootCmd.address == context->objectID) &&
    772                  (context->bootCmd.count != 0))
   \                     ??ldr_DoTagCmd_0: (+1)
   \   00000018   0x7A0C             LDRB     R4,[R1, #+8]
   \   0000001A   0x07E4             LSLS     R4,R4,#+31
   \   0000001C   0xD507             BPL.N    ??ldr_DoTagCmd_1
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x695C             LDR      R4,[R3, #+20]
   \   00000022   0x42A1             CMP      R1,R4
   \   00000024   0xD103             BNE.N    ??ldr_DoTagCmd_1
   \   00000026   0xB112             CBZ.N    R2,??ldr_DoTagCmd_1
    773              {
    774                  // This section is bootable and matches the ID we are looking for, so
    775                  // just continue getting commands from this point
    776                  // Reinitialize the decryption for the rest of the boot commands and the section
    777          
    778                  context->bootSectChunks = context->bootCmd.count;
   \   00000028   0x609A             STR      R2,[R3, #+8]
    779          
    780          #if AES_SECURITY_SUPPORTED
    781                  if (context->keyCount)
    782                  {
    783                      cbc_mac_init(context->dek, context->initVector);
    784                  }
    785          #endif
    786                  return kStatus_Success;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD10             POP      {R4,PC}
    787              }
    788              else if (context->bootCmd.flags & CFLG_LAST_TAG)
   \                     ??ldr_DoTagCmd_1: (+1)
   \   0000002E   0xF890 0x105A      LDRB     R1,[R0, #+90]
   \   00000032   0x07C9             LSLS     R1,R1,#+31
   \   00000034   0xBF5C             ITT      PL 
    789              {
    790                  // This isn't the right boot section and it's the last one, so return
    791                  // an error
    792                  return kStatusRomLdrIdNotFound;
    793              }
    794              else
    795              {
    796                  // This isn't the boot section we are looking for and there are more, so
    797                  // skip to the next one
    798                  return ldr_GoToNextSection(context);
   \   00000036   0xE8BD 0x4010      POPPL    {R4,LR}
   \   0000003A   0x.... 0x....      BPL.W    ldr_GoToNextSection
    799              }
   \   0000003E   0xF242 0x707C      MOVW     R0,#+10108
   \   00000042   0xBD10             POP      {R4,PC}
    800          }
    801          
    802          ////////////////////////////////////////////////////////////////////////////////
    803          //! \brief  Loader "erase" command handler
    804          //!
    805          //! Implements the action function for the boot "erase" command.
    806          //!
    807          //! \param[in]  context    Pointer to a loader context structure.
    808          //!
    809          //! \pre    context->bootCmd contains the boot command.
    810          //!
    811          //! \post   *context is setup to get the next boot command.
    812          //! \post   context->sectChunks is updated to the next section.
    813          //!
    814          //! \retval kStatus_Success
    815          //! \retval kStatus_InvalidArgument
    816          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    817          status_t ldr_DoEraseCmd(ldr_Context_t *context)
    818          {
    819              status_t status = kStatus_Success;
    820          
    821              if (context->bootCmd.flags & ROM_ERASE_ALL_UNSECURE_MASK)
   \                     ldr_DoEraseCmd: (+1)
   \   00000000   0xF8B0 0x105A      LDRH     R1,[R0, #+90]
   \   00000004   0x078A             LSLS     R2,R1,#+30
   \   00000006   0xD407             BMI.N    ??ldr_DoEraseCmd_0
    822              {
    823          #if BL_FEATURE_ERASEALL_UNSECURE
    824                  status = flash_mem_erase_all_unsecure();
    825          #else
    826                  status = kStatus_InvalidArgument;
    827          #endif // BL_FEATURE_ERASEALL_UNSECURE
    828              }
    829              else if (context->bootCmd.flags & ROM_ERASE_ALL_MASK)
   \   00000008   0x07CA             LSLS     R2,R1,#+31
   \   0000000A   0xD507             BPL.N    ??ldr_DoEraseCmd_1
    830              {
    831                  uint32_t memCtrl = (context->bootCmd.flags >> ROM_MEM_CTRL_SHIFT) & ROM_MEM_CTRL_MASK;
    832          
    833                  if (memCtrl == kLdrMemoryCtrl_InternalFlash)
   \   0000000C   0xF3C1 0x2003      UBFX     R0,R1,#+8,#+4
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xBF08             IT       EQ 
    834                  {
    835          #if BL_FEATURE_FAC_ERASE
    836                      status = flash_mem_erase_all(kFlashEraseAllOption_Blocks);
    837          #else
    838                      status = flash_mem_erase_all();
   \   00000014   0x.... 0x....      BEQ.W    flash_mem_erase_all
    839          #endif
    840                  }
    841          #if BL_FEATURE_QSPI_MODULE
    842                  else if (memCtrl == kLdrMemoryCtrl_QSPI0)
    843                  {
    844                      status = qspi_mem_erase_all();
    845                  }
    846          #endif // BL_FEATURE_QSPI_MODULE
    847                  else
    848                  {
    849                      status = kStatus_InvalidArgument;
   \                     ??ldr_DoEraseCmd_0: (+1)
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0x4770             BX       LR
    850                  }
    851              }
    852              else
    853              {
    854                  status = g_bootloaderContext.memoryInterface->erase(context->bootCmd.address, context->bootCmd.count);
   \                     ??ldr_DoEraseCmd_1: (+1)
   \   0000001C   0x....             LDR.N    R2,??DataTable12_1
   \   0000001E   0x6812             LDR      R2,[R2, #+0]
   \   00000020   0x6952             LDR      R2,[R2, #+20]
   \   00000022   0x305C             ADDS     R0,R0,#+92
   \   00000024   0x6841             LDR      R1,[R0, #+4]
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x4710             BX       R2
    855              }
    856          
    857              return status;
    858          }
    859          
    860          ///////////////////////////////////////////////////////////////////////////////
    861          //! \brief  Loader "reset" command handler
    862          //!
    863          //! Implements the action function for the boot "reset" command.
    864          //!
    865          //! \param[in]  context    Pointer to a loader context structure.
    866          //!
    867          //! \pre    context->bootCmd contains the boot command.
    868          //!
    869          //! \post   *context is setup to get the next boot command.
    870          //! \post   context->sectChunks is updated to the next section.
    871          //!
    872          //! \retval kStatus_Success
    873          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    874          status_t ldr_DoResetCmd(ldr_Context_t *context)
   \                     ldr_DoResetCmd: (+1)
   \   00000000   0xBF00             Nop      
    875          {
    876              // Actual reset is implemented in sbloader_finalize().
    877              return kStatus_AbortDataPhase;
   \   00000002                      REQUIRE ?Subroutine1
   \   00000002                      ;; // Fall through to label ?Subroutine1
    878          }
    879          
    880          ///////////////////////////////////////////////////////////////////////////////
    881          //! \brief  Loader "memory enable" command handler
    882          //!
    883          //! Implements the action function for the boot "memory enable" command.
    884          //!
    885          //! \param[in]  context    Pointer to a loader context structure.
    886          //!
    887          //! \pre    context->bootCmd contains the boot command.
    888          //!
    889          //! \post   *context is setup to get the next boot command.
    890          //! \post   context->sectChunks is updated to the next section.
    891          //!
    892          //! \retval kStatus_Success
    893          //! \retval kStatus_InvalidArgument
    894          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    895          status_t ldr_DoMemEnableCmd(ldr_Context_t *context)
    896          {
    897          #if BL_FEATURE_QSPI_MODULE
    898              uint32_t memCtrl = (context->bootCmd.flags >> ROM_MEM_CTRL_SHIFT) & ROM_MEM_CTRL_MASK;
    899              uint32_t startAddr = context->bootCmd.address; // RAM address of previously written config block
    900              uint32_t endAddr = startAddr + sizeof(qspi_config_t) - 1;
    901          
    902              // Validate parameters.
    903              // Note: we don't validate bootCmd.count. This matches how the configure-quadspi command behaves.
    904              if ((memCtrl != kLdrMemoryCtrl_QSPI0) || (!is_valid_application_location(startAddr)) ||
    905                  (!is_valid_application_location(endAddr)))
    906              {
    907                  return kStatus_InvalidArgument;
    908              }
    909          
    910              status_t status = quadspi_init((void *)startAddr);
    911              if (status == kStatus_Success)
    912              {
    913                  // Re-init memory interface to intialize qspi memory interface
    914                  g_bootloaderContext.memoryInterface->init();
    915              }
    916              g_bootloaderContext.propertyInterface->store->qspiInitStatus = status;
    917          
    918              return status;
    919          #else
    920              return kStatus_InvalidArgument;
   \                     ldr_DoMemEnableCmd: (+1)
   \   00000000   0x2004             MOVS     R0,#+4
   \   00000002   0x4770             BX       LR               ;; return
    921          #endif // BL_FEATURE_QSPI_MODULE
    922          }
    923          
    924          ////////////////////////////////////////////////////////////////////////////////
    925          //! \brief  Loader boot command parsing function
    926          //!
    927          //! Implements the action function for parsing a boot command. Performs generic
    928          //! integrity tests and flag handling, then calls the appropriate command
    929          //! handler function based on the command tag.
    930          //!
    931          //! \param[in]  context    Pointer to a loader context structure.
    932          //!
    933          //! \pre    context->bootCmd contains the boot command.
    934          //!
    935          //! \retval kStatusRomLdrChecksum if command checksum failed.
    936          //! \retval kStatusRomLdrUnknownCommand if command tag is not recognized.
    937          //! \retval Return code from the boot command handler function.
    938          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 4, keep-with-next
    939          status_t ldr_DoCommand(ldr_Context_t *context)
    940          {
   \                     ldr_DoCommand: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    941              boot_cmd_t *pCmd = &context->bootCmd;
    942              uint32_t i, sum = 0x5a;
    943          
    944          #if AES_SECURITY_SUPPORTED
    945              // Decrypt this boot command block if enabled
    946              if (context->keyCount)
    947              {
    948                  cbc_mac_decrypt(context->src, sizeof(chunk_t), context->src);
    949              }
    950          #endif
    951          
    952              // Save the boot commmand.
    953              context->bootCmd = *((boot_cmd_t *)context->src);
   \   00000004   0xF104 0x0658      ADD      R6,R4,#+88
   \   00000008   0x6A61             LDR      R1,[R4, #+36]
   \   0000000A   0x4630             MOV      R0,R6
   \   0000000C   0x2210             MOVS     R2,#+16
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000012   0x255A             MOVS     R5,#+90
    954          
    955              // Compute and test the boot command checksum
    956              for (i = 1; i < sizeof(boot_cmd_t); i++)
   \   00000014   0x2001             MOVS     R0,#+1
    957              {
    958                  sum += ((uint8_t *)pCmd)[i];
   \                     ??ldr_DoCommand_1: (+1)
   \   00000016   0x1821             ADDS     R1,R4,R0
    959              }
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \   0000001A   0xF891 0x1058      LDRB     R1,[R1, #+88]
   \   0000001E   0x186D             ADDS     R5,R5,R1
   \   00000020   0x2810             CMP      R0,#+16
   \   00000022   0xD3F8             BCC.N    ??ldr_DoCommand_1
    960              if (((uint8_t *)pCmd)[0] != (sum & 0xFF))
   \   00000024   0x7830             LDRB     R0,[R6, #+0]
   \   00000026   0xF005 0x01FF      AND      R1,R5,#0xFF
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD006             BEQ.N    ??ldr_DoCommand_2
    961              {
    962                  debug_printf("Error: invalid boot command checksum\r\n");
   \   0000002E   0x.... 0x....      ADR.W    R0,?_1
   \   00000032   0x.... 0x....      BL       debug_printf
    963                  return kStatusRomLdrChecksum;
   \   00000036   0xF242 0x7079      MOVW     R0,#+10105
   \   0000003A   0xBD70             POP      {R4-R6,PC}
    964              }
    965          
    966              // Switch to the appropriate command handler function
    967              switch (pCmd->tag)
   \                     ??ldr_DoCommand_2: (+1)
   \   0000003C   0x7871             LDRB     R1,[R6, #+1]
   \   0000003E   0x290A             CMP      R1,#+10
   \   00000040   0xF242 0x7012      MOVW     R0,#+10002
   \   00000044   0xD823             BHI.N    ??ldr_DoCommand_3
   \   00000046   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??ldr_DoCommand_0:
   \   0000004A   0x1A 0x06          DC8      0x1A,0x6,0xA,0xE
   \              0x0A 0x0E    
   \   0000004E   0x24 0x12          DC8      0x24,0x12,0x1A,0x16
   \              0x1A 0x16    
   \   00000052   0x24 0x1C          DC8      0x24,0x1C,0x1E,0x0
   \              0x1E 0x00    
    968              {
    969                  case ROM_NOP_CMD:
    970                      return kStatus_Success;
    971                  case ROM_TAG_CMD:
    972                      return ldr_DoTagCmd(context);
   \                     ??ldr_DoCommand_4: (+1)
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000005C   0x....             B.N      ldr_DoTagCmd
    973                  case ROM_LOAD_CMD:
    974                      return ldr_DoLoadCmd(context);
   \                     ??ldr_DoCommand_5: (+1)
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000064   0x....             B.N      ldr_DoLoadCmd
    975                  case ROM_FILL_CMD:
    976                      return ldr_DoFillCmd(context);
   \                     ??ldr_DoCommand_6: (+1)
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000006C   0x....             B.N      ldr_DoFillCmd
    977                  case ROM_JUMP_CMD:
    978                      return ldr_DoJumpCmd(context);
    979                  case ROM_CALL_CMD:
    980                      return ldr_DoCallCmd(context);
   \                     ??ldr_DoCommand_7: (+1)
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000074   0x....             B.N      ldr_DoCallCmd
    981                  case ROM_ERASE_CMD:
    982                      return ldr_DoEraseCmd(context);
   \                     ??ldr_DoCommand_8: (+1)
   \   00000076   0x4620             MOV      R0,R4
   \   00000078   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000007C   0x....             B.N      ldr_DoEraseCmd
    983                  case ROM_MODE_CMD:
    984                      return kStatus_Success; // ignored for Kinetis
   \                     ??ldr_DoCommand_9: (+1)
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xBD70             POP      {R4-R6,PC}
    985                  case ROM_RESET_CMD:
    986                      return ldr_DoResetCmd(context);
    987                  case ROM_MEM_ENABLE_CMD:
    988                      return ldr_DoMemEnableCmd(context);
   \                     ??ldr_DoCommand_10: (+1)
   \   00000082   0x2004             MOVS     R0,#+4
   \   00000084   0xBD70             POP      {R4-R6,PC}
    989                  case ROM_PROG_CMD:
    990                      return ldr_DoProgramCmd(context);
   \                     ??ldr_DoCommand_11: (+1)
   \   00000086   0x4620             MOV      R0,R4
   \   00000088   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000008C   0x....             B.N      ldr_DoProgramCmd
    991              }
    992              return kStatusRomLdrUnknownCommand;
   \                     ??ldr_DoCommand_3: (+1)
   \   0000008E   0xF242 0x707B      MOVW     R0,#+10107
   \                     ??ldr_DoCommand_12: (+1)
   \   00000092   0xBD70             POP      {R4-R6,PC}       ;; return
    993          }
    994          
    995          ////////////////////////////////////////////////////////////////////////////////
    996          //! @brief Initialize the loader state machine.
    997          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    998          status_t sbloader_init(void)
    999          {
   \                     sbloader_init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1000              // Initialize the context
   1001              memset(&s_loaderContext, 0, sizeof(ldr_Context_t));
   \   00000002   0x....             LDR.N    R4,??DataTable12_5
   \   00000004   0x2170             MOVS     R1,#+112
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       __aeabi_memclr4
   1002          
   1003              // Process the first chunk of the image header
   1004              s_loaderContext.Action = ldr_DoHeader;
   \   0000000C   0x....             LDR.N    R0,??DataTable12_6
   \   0000000E                      REQUIRE ?Subroutine3
   \   0000000E                      ;; // Fall through to label ?Subroutine3
   1005          
   1006          #if AES_SECURITY_SUPPORTED
   1007          #ifndef BL_FEATURE_ENCRYPTION_KEY_ADDRESS
   1008              // Ensure the process of read key cannot be interrupted by other IRQs.
   1009              lock_acquire();
   1010              g_bootloaderContext.flashDriverInterface->flash_read_once(&g_bootloaderContext.flashState, SB_KEY_RDONCE_INDEX + 0,
   1011                                                                        &s_aesKey[0], sizeof(s_aesKey[0]));
   1012              g_bootloaderContext.flashDriverInterface->flash_read_once(&g_bootloaderContext.flashState, SB_KEY_RDONCE_INDEX + 1,
   1013                                                                        &s_aesKey[1], sizeof(s_aesKey[1]));
   1014              g_bootloaderContext.flashDriverInterface->flash_read_once(&g_bootloaderContext.flashState, SB_KEY_RDONCE_INDEX + 2,
   1015                                                                        &s_aesKey[2], sizeof(s_aesKey[2]));
   1016              g_bootloaderContext.flashDriverInterface->flash_read_once(&g_bootloaderContext.flashState, SB_KEY_RDONCE_INDEX + 3,
   1017                                                                        &s_aesKey[3], sizeof(s_aesKey[3]));
   1018              lock_release();
   1019          #else
   1020              const uint32_t *kekTable = (const uint32_t *)BL_FEATURE_ENCRYPTION_KEY_ADDRESS;
   1021              s_aesKey[0] = kekTable[0];
   1022              s_aesKey[1] = kekTable[1];
   1023              s_aesKey[2] = kekTable[2];
   1024              s_aesKey[3] = kekTable[3];
   1025          #endif
   1026          
   1027              uint32_t i;
   1028              // Test to see if the key is non blank
   1029              for (i = 0; i < AES_128_KEY_SIZE_WORDS; i++)
   1030              {
   1031                  if (s_aesKey[i] != ~0)
   1032                  {
   1033                      break;
   1034                  }
   1035              }
   1036          
   1037              // If i went all the way through the loop the key is blank so default to a blank key
   1038              if (i == AES_128_KEY_SIZE_WORDS)
   1039              {
   1040                  memset(s_aesKey, 0, sizeof(s_aesKey));
   1041              }
   1042          #endif
   1043          
   1044              return kStatus_Success;
   1045          }
   1046          
   1047          ////////////////////////////////////////////////////////////////////////////////
   1048          //! @brief Pump the loader state machine.
   1049          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
   1050          status_t sbloader_pump(uint8_t *data, uint32_t length)
   1051          {
   \                     sbloader_pump: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1052              status_t status = kStatus_Success;
   \   00000006   0x2000             MOVS     R0,#+0
   1053              uint32_t required;
   1054              uint32_t available;
   1055              uint32_t readPosition = 0;
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0x....             LDR.N    R7,??DataTable12_7
   1056          
   1057              while (readPosition != length)
   \                     ??sbloader_pump_0: (+1)
   \   0000000C   0x42AE             CMP      R6,R5
   \   0000000E   0xD017             BEQ.N    ??sbloader_pump_1
   1058              {
   1059                  required = sizeof(s_loaderBuf.data) - s_loaderBuf.fillPosition;
   \   00000010   0x6938             LDR      R0,[R7, #+16]
   \   00000012   0xF1C0 0x0010      RSB      R0,R0,#+16
   1060                  available = length - readPosition;
   \   00000016   0x1BA9             SUBS     R1,R5,R6
   \   00000018   0xE009             B.N      ??sbloader_pump_2
   1061          
   1062                  // copy what we need to complete a full chunk into the chunk buffer
   1063                  while ((required > 0) && (available > 0))
   \                     ??sbloader_pump_3: (+1)
   \   0000001A   0xB179             CBZ.N    R1,??sbloader_pump_4
   1064                  {
   1065                      s_loaderBuf.data[s_loaderBuf.fillPosition++] = data[readPosition++];
   \   0000001C   0x693B             LDR      R3,[R7, #+16]
   \   0000001E   0x5DA2             LDRB     R2,[R4, R6]
   \   00000020   0x54FA             STRB     R2,[R7, R3]
   \   00000022   0x1C76             ADDS     R6,R6,#+1
   \   00000024   0x693A             LDR      R2,[R7, #+16]
   \   00000026   0x1C52             ADDS     R2,R2,#+1
   \   00000028   0x613A             STR      R2,[R7, #+16]
   1066                      --required;
   \   0000002A   0x1E40             SUBS     R0,R0,#+1
   1067                      --available;
   \   0000002C   0x1E49             SUBS     R1,R1,#+1
   1068                  }
   \                     ??sbloader_pump_2: (+1)
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD1F3             BNE.N    ??sbloader_pump_3
   1069          
   1070                  if (required == 0)
   1071                  {
   1072                      // a full chunk was filled to process it
   1073                      s_loaderBuf.fillPosition = 0;
   \   00000032   0x6138             STR      R0,[R7, #+16]
   1074          
   1075                      status = sbloader_handle_chunk();
   \   00000034   0x.... 0x....      BL       sbloader_handle_chunk
   1076          
   1077                      if (status != kStatus_Success)
   \   00000038   0xB910             CBNZ.N   R0,??sbloader_pump_1
   \   0000003A   0xE7E7             B.N      ??sbloader_pump_0
   1078                      {
   1079                          break;
   1080                      }
   1081                  }
   1082                  else if (available == 0)
   1083                  {
   1084                      // otherwise we are just going to wait for more data
   1085                      status = kStatusRomLdrDataUnderrun;
   \                     ??sbloader_pump_4: (+1)
   \   0000003C   0xF242 0x707D      MOVW     R0,#+10109
   1086                      break;
   1087                  }
   1088              }
   1089          
   1090              return status;
   \                     ??sbloader_pump_1: (+1)
   \   00000040   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1091          }
   1092          
   1093          ////////////////////////////////////////////////////////////////////////////////
   1094          //! @brief Handles the chunk in the s_loaderBuf
   1095          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
   1096          status_t sbloader_handle_chunk(void)
   1097          {
   1098              status_t status = kStatus_Success;
   1099          
   1100              s_loaderContext.src = s_loaderBuf.data;
   \                     sbloader_handle_chunk: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable12_5
   \   00000002   0x....             LDR.N    R2,??DataTable12_7
   \   00000004   0x624A             STR      R2,[R1, #+36]
   \   00000006   0x2000             MOVS     R0,#+0
   1101          
   1102              // If we have found the boot section and are currently working on its commands
   1103              // Once we have received the number of chunks in the section we will be done
   1104              if (s_loaderContext.bootSectChunks)
   \   00000008   0x68CA             LDR      R2,[R1, #+12]
   \   0000000A   0xB12A             CBZ.N    R2,??sbloader_handle_chunk_0
   1105              {
   1106                  if (s_loaderContext.receivedChunks != s_loaderContext.bootSectChunks)
   \   0000000C   0x690B             LDR      R3,[R1, #+16]
   \   0000000E   0x4293             CMP      R3,R2
   \   00000010   0xD009             BEQ.N    ??sbloader_handle_chunk_1
   1107                  {
   1108                      s_loaderContext.receivedChunks++;
   \   00000012   0x1C58             ADDS     R0,R3,#+1
   \   00000014   0x6108             STR      R0,[R1, #+16]
   1109                      status = s_loaderContext.Action(&s_loaderContext);
   \   00000016   0xE001             B.N      ??sbloader_handle_chunk_2
   1110                  }
   1111              }
   1112              else
   1113              {
   1114                  // Otherwise this is header info or a non bootable section that might be skipped through
   1115                  if (!s_loaderContext.skipCount)
   \                     ??sbloader_handle_chunk_0: (+1)
   \   00000018   0x6E8A             LDR      R2,[R1, #+104]
   \   0000001A   0xB912             CBNZ.N   R2,??sbloader_handle_chunk_3
   1116                  {
   1117                      status = s_loaderContext.Action(&s_loaderContext);
   \                     ??sbloader_handle_chunk_2: (+1)
   \   0000001C   0x4608             MOV      R0,R1
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x4708             BX       R1
   1118                  }
   1119                  else
   1120                  {
   1121                      --s_loaderContext.skipCount;
   \                     ??sbloader_handle_chunk_3: (+1)
   \   00000022   0x1E52             SUBS     R2,R2,#+1
   \   00000024   0x668A             STR      R2,[R1, #+104]
   1122                  }
   1123              }
   1124          
   1125              return status;
   \                     ??sbloader_handle_chunk_1: (+1)
   \   00000026   0x4770             BX       LR               ;; return
   1126          }
   1127          
   1128          ////////////////////////////////////////////////////////////////////////////////
   1129          //! @brief Implement jump or reset command
   1130          ////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
   1131          status_t sbloader_finalize()
   1132          {
   \                     sbloader_finalize: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   1133              // Force to write buffered data to target memory if it is last data
   1134              // chunks with reset/call/jump command at the end
   1135              assert(g_bootloaderContext.memoryInterface->flush);
   1136              status_t status = g_bootloaderContext.memoryInterface->flush();
   \   00000002   0x....             LDR.N    R4,??DataTable12_1
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6900             LDR      R0,[R0, #+16]
   \   00000008   0x4780             BLX      R0
   1137              if (status != kStatus_Success)
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD13D             BNE.N    ??sbloader_finalize_0
   1138              {
   1139                  return status;
   1140              }
   1141          
   1142              if (s_loaderContext.bootCmd.tag == ROM_JUMP_CMD)
   \   0000000E   0x....             LDR.N    R7,??DataTable12_5
   \   00000010   0xF897 0x0059      LDRB     R0,[R7, #+89]
   \   00000014   0x2804             CMP      R0,#+4
   \   00000016   0xD124             BNE.N    ??sbloader_finalize_1
   1143              {
   1144                  pJumpFnc_t entry_fun = (pJumpFnc_t)s_loaderContext.bootCmd.address;
   \   00000018   0xF107 0x055C      ADD      R5,R7,#+92
   \   0000001C   0x682E             LDR      R6,[R5, #+0]
   1145          
   1146                  // Jump to the entry point with the specified parameter
   1147                  bool isValid = is_valid_application_location((uint32_t)entry_fun);
   1148          #if BL_FEATURE_OTFAD_MODULE
   1149                  if (isValid && is_qspi_present())
   1150                  {
   1151                      quadspi_cache_clear();
   1152                      status_t status = otfad_init_as_needed();
   1153                      if (status != kStatus_Success)
   1154                      {
   1155                          isValid = false;
   1156                      }
   1157                      update_qspi_otfad_init_status(status);
   1158                  }
   1159                  if (!isValid)
   1160                  {
   1161                      return kStatus_OtfadInvalidKeyBlob;
   1162                  }
   1163          #endif
   1164                  if (isValid)
   \   0000001E   0x4630             MOV      R0,R6
   \   00000020   0x.... 0x....      BL       is_valid_application_location
   \   00000024   0xB1D0             CBZ.N    R0,??sbloader_finalize_2
   1165                  {
   1166                      // Clean up prior to calling user code.
   1167                      shutdown_cleanup(kShutdownType_Shutdown);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x.... 0x....      BL       shutdown_cleanup
   1168          
   1169                      // Set initial SP if requested in by flag
   1170                      if (s_loaderContext.bootCmd.flags & ROM_JUMP_SP_MASK)
   \   0000002C   0xF897 0x005A      LDRB     R0,[R7, #+90]
   \   00000030   0x0780             LSLS     R0,R0,#+30
   \   00000032   0xD511             BPL.N    ??sbloader_finalize_3
   1171                      {
   1172                          static uint32_t s_addr = 0;
   1173                          s_addr = s_loaderContext.bootCmd.count;
   \   00000034   0x6868             LDR      R0,[R5, #+4]
   \   00000036   0x6168             STR      R0,[R5, #+20]
   1174          
   1175                          // Get RAM address ranges
   1176                          const memory_map_entry_t *map = &g_bootloaderContext.memoryMap[kIndexSRAM];
   \   00000038   0x6861             LDR      R1,[R4, #+4]
   \   0000003A   0x3110             ADDS     R1,R1,#+16
   1177          
   1178                          // Validate stack pointer address. It must either be 0 or within the RAM range.
   1179                          if (!((s_addr == 0) || ((s_addr >= map->startAddress) && (s_addr <= map->endAddress + 1))))
   \   0000003C   0xB160             CBZ.N    R0,??sbloader_finalize_3
   \   0000003E   0x680A             LDR      R2,[R1, #+0]
   \   00000040   0x4290             CMP      R0,R2
   \   00000042   0xBF22             ITTT     CS 
   \   00000044   0x6849             LDRCS    R1,[R1, #+4]
   \   00000046   0x1C49             ADDCS    R1,R1,#+1
   \   00000048   0x4281             CMPCS    R1,R0
   \   0000004A   0xD201             BCS.N    ??sbloader_finalize_4
   1180                          {
   1181                              // Invalid stack pointer value, respond with kStatus_InvalidArgument.
   1182                              return kStatus_InvalidArgument;
   \   0000004C   0x2004             MOVS     R0,#+4
   \   0000004E   0xBDF2             POP      {R1,R4-R7,PC}
   1183                          }
   1184          
   1185                          if (s_addr)
   1186                          {
   1187                              // Set main stack pointer and process stack pointer
   1188                              __set_MSP(s_addr);
   \                     ??sbloader_finalize_4: (+1)
   \   00000050   0xF380 0x8808      MSR      MSP,R0
   1189                              __set_PSP(s_addr);
   \   00000054   0xF380 0x8809      MSR      PSP,R0
   1190                          }
   1191                      }
   1192          
   1193                      entry_fun(s_loaderContext.bootCmd.data);
   \                     ??sbloader_finalize_3: (+1)
   \   00000058   0x68A8             LDR      R0,[R5, #+8]
   \   0000005A   0x47B0             BLX      R6
   1194                  }
   1195          
   1196                  // We should never get here, so return an error if we do
   1197                  return kStatusRomLdrJumpReturned;
   \                     ??sbloader_finalize_2: (+1)
   \   0000005C   0xF242 0x707E      MOVW     R0,#+10110
   \   00000060   0xBDF2             POP      {R1,R4-R7,PC}
   1198              }
   1199              else if (s_loaderContext.bootCmd.tag == ROM_RESET_CMD)
   \                     ??sbloader_finalize_1: (+1)
   \   00000062   0x2808             CMP      R0,#+8
   \   00000064   0xD10F             BNE.N    ??sbloader_finalize_5
   1200              {
   1201                  // Prepare for shutdown.
   1202                  shutdown_cleanup(kShutdownType_Reset);
   \   00000066   0x2002             MOVS     R0,#+2
   \   00000068   0x.... 0x....      BL       shutdown_cleanup
   1203          
   1204                  NVIC_SystemReset();
   \   0000006C   0xF3BF 0x8F4F      DSB      
   \   00000070   0x....             LDR.N    R0,??DataTable12_8  ;; 0xe000ed0c
   \   00000072   0x....             LDR.N    R2,??DataTable12_9  ;; 0x5fa0004
   \   00000074   0x6801             LDR      R1,[R0, #+0]
   \   00000076   0xF401 0x61E0      AND      R1,R1,#0x700
   \   0000007A   0x4311             ORRS     R1,R2,R1
   \   0000007C   0x6001             STR      R1,[R0, #+0]
   \   0000007E   0xF3BF 0x8F4F      DSB      
   \                     ??sbloader_finalize_6: (+1)
   \   00000082   0xBF00             Nop      
   \   00000084   0xE7FD             B.N      ??sbloader_finalize_6
   1205                  // Does not get here.
   1206                  assert(0);
   1207          
   1208                  // We should never get here, so return an error if we do
   1209                  return kStatusRomLdrResetReturned;
   1210              }
   1211          
   1212              // We should never get here, so return an error if we do
   1213              return kStatusRomLdrUnknownCommand;
   \                     ??sbloader_finalize_5: (+1)
   \   00000086   0xF242 0x707B      MOVW     R0,#+10107
   \                     ??sbloader_finalize_0: (+1)
   \   0000008A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1214          }

   \                                 In section .bss, align 4
   \                     s_loaderContext:
   \   00000000                      DS8 112
   \   00000070                      DS8 4

   \                                 In section .bss, align 4
   \                     s_loaderBuf:
   \   00000000                      DS8 20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x504D5453         DC32     0x504d5453

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x........         DC32     g_bootloaderContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x........         DC32     ldr_DoGetDek

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x........         DC32     ldr_DoLoadChunks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x........         DC32     ldr_DoLoadBytes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x........         DC32     s_loaderContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x........         DC32     ldr_DoHeader

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \   00000000   0x........         DC32     s_loaderBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \   00000000   0xE000ED0C         DC32     0xe000ed0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \   00000000   0x05FA0004         DC32     0x5fa0004

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x45 0x72          DC8 "Error: image is encrypted\015\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x69    
   \              0x6D 0x61    
   \              0x67 0x65    
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x65 0x6E    
   \              0x63 0x72    
   \              0x79 0x70    
   \              0x74 0x65    
   \              0x64 0x0D    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x45 0x72          DC8 "Error: invalid boot command checksum\015\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x69    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x62    
   \              0x6F 0x6F    
   \              0x74 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x20    
   \              0x63 0x68    
   \              0x65 0x63    
   \              0x6B 0x73    
   \              0x75 0x6D    
   \              0x0D 0x0A    
   \              0x00         
   \   00000027   0x00               DC8 0
   1215          
   1216          //! @}
   1217          
   1218          ////////////////////////////////////////////////////////////////////////////////
   1219          // EOF
   1220          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   debug_printf
        16   -> vprintf
      16   ldr_DoCallCmd
        16   -- Indirect call
        16   -> is_valid_application_location
         0   -> ldr_GoToNextSection
        16   -> sbloader_init
      16   ldr_DoCommand
        16   -> __aeabi_memcpy4
        16   -> debug_printf
         0   -> ldr_DoCallCmd
         0   -> ldr_DoEraseCmd
         0   -> ldr_DoFillCmd
         0   -> ldr_DoLoadCmd
         0   -> ldr_DoProgramCmd
         0   -> ldr_DoTagCmd
       0   ldr_DoEraseCmd
         0   -- Indirect call
         0   -> flash_mem_erase_all
       0   ldr_DoFillCmd
         0   -- Indirect call
       0   ldr_DoGetDek
         0   -> ldr_GoToNextSection
       0   ldr_DoHeader
       0   ldr_DoHeader1
      16   ldr_DoHeader2
        16   -- Indirect call
        16   -> debug_printf
        16   -> ldr_GoToNextSection
       0   ldr_DoHeaderMac
       0   ldr_DoJumpCmd
      16   ldr_DoKeyTest
        16   -> memcmp
      16   ldr_DoLoadBytes
        16   -- Indirect call
        16   -> crc32_finalize
        16   -> crc32_update
      16   ldr_DoLoadChunks
        16   -- Indirect call
        16   -> crc32_finalize
        16   -> crc32_update
       8   ldr_DoLoadCmd
         8   -> crc32_init
       0   ldr_DoMemEnableCmd
      24   ldr_DoProgramCmd
        24   -- Indirect call
        24   -> lock_acquire
        24   -> lock_release
       0   ldr_DoResetCmd
       8   ldr_DoTagCmd
         8   -> ldr_GoToNextSection
       0   ldr_GoToNextSection
      24   sbloader_finalize
        24   -- Indirect call
        24   -> is_valid_application_location
        24   -> shutdown_cleanup
       0   sbloader_handle_chunk
         0   -- Indirect call
       8   sbloader_init
         8   -> __aeabi_memclr4
      24   sbloader_pump
        24   -> sbloader_handle_chunk


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
       6  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine2
       6  ?Subroutine3
      12  ?Subroutine4
      10  ?Subroutine5
      28  ?_0
      40  ?_1
      14  debug_printf
      56  ldr_DoCallCmd
     148  ldr_DoCommand
      42  ldr_DoEraseCmd
      14  ldr_DoFillCmd
       8  ldr_DoGetDek
       6  ldr_DoHeader
      40  ldr_DoHeader1
      88  ldr_DoHeader2
      24  ldr_DoHeaderMac
       2  ldr_DoJumpCmd
      62  ldr_DoKeyTest
      68  ldr_DoLoadBytes
      82  ldr_DoLoadChunks
      24  ldr_DoLoadCmd
       4  ldr_DoMemEnableCmd
      70  ldr_DoProgramCmd
       2  ldr_DoResetCmd
      68  ldr_DoTagCmd
      34  ldr_GoToNextSection
      20  s_loaderBuf
     116  s_loaderContext
          s_addr
     140  sbloader_finalize
      40  sbloader_handle_chunk
      14  sbloader_init
      66  sbloader_pump

 
   136 bytes in section .bss
 1 270 bytes in section .text
 
 1 270 bytes of CODE memory
   136 bytes of DATA memory

Errors: none
Warnings: none
