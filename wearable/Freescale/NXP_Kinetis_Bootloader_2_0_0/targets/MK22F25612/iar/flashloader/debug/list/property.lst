###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Aug/2016  13:15:58
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\property\src\property.c
#    Command line =  
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\property\src\property.c"
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN256VDC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D BL_TARGET_RAM -lC
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj"
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices/MK22F25612\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/autobaud\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/osa\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device/class\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/bm_usb\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/CMSIS/Include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers/common\"
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list\property.lst
#    Object file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj\property.o
#
###############################################################################

C:\Users\cwati\Documents\My Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\property\src\property.c
      1          /*
      2           * Copyright (c) 2013-2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "bootloader_common.h"
     32          #include "property/property.h"
     33          #include "memory/memory.h"
     34          #include "packet/command_packet.h"
     35          #include "packet/serial_packet.h"
     36          #include "bootloader/bl_peripheral.h"
     37          #include "bootloader/bl_context.h"
     38          #include "bootloader/bl_version.h"
     39          #include "utilities/fsl_assert.h"
     40          #include <string.h>
     41          #if !defined(BOOTLOADER_HOST)
     42          #include "flash/fsl_flash.h"
     43          #include "fsl_device_registers.h"
     44          #if BL_FEATURE_QSPI_MODULE
     45          #include "qspi/qspi.h"
     46          #endif // BL_FEATURE_QSPI_MODULE
     47          #if BL_FEATURE_CRC_CHECK
     48          #include "bootloader/bl_app_crc_check.h"
     49          #endif // BL_FEATURE_CRC_CHECK
     50          #endif //! BOOTLOADER_HOST
     51          
     52          ////////////////////////////////////////////////////////////////////////////////
     53          // Declarations
     54          ////////////////////////////////////////////////////////////////////////////////
     55          
     56          #if (defined(__ICCARM__)) // IAR
     57          #pragma section = ".intvec"
     58          #pragma section = "ApplicationFlash"
     59          #pragma section = "ApplicationRam"
     60          #if defined(BL_TARGET_RAM)
     61          #define __RAM_START ((uint32_t)__section_begin(".intvec"))
     62          #else
     63          #define __RAM_START ((uint32_t)__section_begin("ApplicationRam"))
     64          #endif // #if defined(BL_TARGET_RAM)
     65          #define __RAM_END ((uint32_t)__section_end("ApplicationRam") - 1)
     66          #define __ROM_START ((uint32_t)__section_begin(".intvec"))
     67          #define __ROM_END ((uint32_t)__section_end("ApplicationFlash"))
     68          #elif(defined(__CC_ARM)) // MDK
     69          extern uint32_t Image$$VECTOR_ROM$$Base[];
     70          extern uint32_t Image$$ER_m_text$$Limit[];
     71          extern char Image$$VECTOR_RAM$$Base[];
     72          extern uint32_t Image$$ARM_LIB_STACK$$ZI$$Limit[];
     73          #define __RAM_START ((uint32_t)Image$$VECTOR_RAM$$Base)
     74          #define __RAM_END ((uint32_t)Image$$ARM_LIB_STACK$$ZI$$Limit - 1)
     75          #define __ROM_START ((uint32_t)Image$$VECTOR_ROM$$Base)
     76          #define __ROM_END ((uint32_t)Image$$ER_m_text$$Limit)
     77          #elif(defined(__GNUC__)) // GCC
     78          extern uint32_t __VECTOR_RAM[];
     79          extern uint32_t __VECTOR_TABLE[];
     80          extern char __DATA_END[];
     81          extern uint32_t __STACK_TOP[];
     82          #define __RAM_START ((uint32_t)__VECTOR_RAM)
     83          #define __RAM_END ((uint32_t)__STACK_TOP - 1)
     84          #define __ROM_START ((uint32_t)__VECTOR_TABLE)
     85          #define __ROM_END ((uint32_t)__DATA_END)
     86          #else
     87          #error Unknown toolchain!
     88          #endif // __ICCARM__
     89          
     90          ////////////////////////////////////////////////////////////////////////////////
     91          // Variables
     92          ////////////////////////////////////////////////////////////////////////////////
     93          
     94          //! @brief Storage for property values.

   \                                 In section .bss, align 4
     95          property_store_t g_propertyStore;
   \                     g_propertyStore:
   \   00000000                      DS8 184
     96          //! @brief Map for external memory property interface.
     97          extern const external_memory_property_interface_t g_externalMemPropertyInterfaceMap[];
     98          
     99          // See property.h for documentation on this data structure.

   \                                 In section .rodata, align 4, keep-with-next
    100          const property_interface_t g_propertyInterface = { bootloader_property_load_user_config, bootloader_property_init,
   \                     g_propertyInterface:
   \   00000000   0x........         DC32 bootloader_property_load_user_config, bootloader_property_init
   \              0x........   
   \   00000008   0x........         DC32 bootloader_property_get, bootloader_property_set_uint32
   \              0x........   
   \   00000010   0x........         DC32 g_propertyStore
    101                                                             bootloader_property_get, bootloader_property_set_uint32,
    102                                                             &g_propertyStore };
    103          
    104          //! @brief Storage for property values computed every time they are read.

   \                                 In section .bss, align 4
    105          static uint32_t s_propertyReturnValue;
   \                     s_propertyReturnValue:
   \   00000000                      DS8 4
    106          
    107          ////////////////////////////////////////////////////////////////////////////////
    108          // Prototypes
    109          ////////////////////////////////////////////////////////////////////////////////
    110          // !@brief Get external memoery proporties
    111          status_t bootloader_get_external_memory_properties(uint8_t memoryId, external_memory_property_store_t *store);
    112          
    113          ////////////////////////////////////////////////////////////////////////////////
    114          // Code
    115          ////////////////////////////////////////////////////////////////////////////////
    116          
    117          // See property.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    118          status_t bootloader_property_load_user_config(void)
    119          {
   \                     bootloader_property_load_user_config: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    120          #if !defined(BOOTLOADER_HOST)
    121          
    122              bootloader_configuration_data_t *config = &g_bootloaderContext.propertyInterface->store->configurationData;
   \   00000002   0x....             LDR.N    R0,??DataTable4
   \   00000004   0x6880             LDR      R0,[R0, #+8]
   \   00000006   0x6900             LDR      R0,[R0, #+16]
   \   00000008   0xF100 0x0468      ADD      R4,R0,#+104
    123          
    124          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    125              if (is_in_execute_only_region(kBootloaderConfigAreaAddress, sizeof(bootloader_configuration_data_t)))
   \   0000000C   0x2134             MOVS     R1,#+52
   \   0000000E   0xF44F 0x7070      MOV      R0,#+960
   \   00000012   0x.... 0x....      BL       is_in_execute_only_region
   \   00000016   0xB948             CBNZ.N   R0,??bootloader_property_load_user_config_0
    126              {
    127                  memset(config, 0xff, sizeof(bootloader_configuration_data_t));
    128              }
    129              else
    130          #endif // FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    131              {
    132                  // Copy bootloader configuration data from the flash into the property store.
    133                  memcpy(config, (const void *)kBootloaderConfigAreaAddress, sizeof(bootloader_configuration_data_t));
   \   00000018   0x2234             MOVS     R2,#+52
   \   0000001A   0xF44F 0x7170      MOV      R1,#+960
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       __aeabi_memcpy4
    134          
    135                  // Verify tag. If it is invalid, wipe the config data to all 0xff.
    136                  if (kPropertyStoreTag != config->tag)
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x....             LDR.N    R1,??DataTable4_1  ;; 0x6766636b
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xD004             BEQ.N    ??bootloader_property_load_user_config_1
    137                  {
    138                      memset(config, 0xff, sizeof(bootloader_configuration_data_t));
   \                     ??bootloader_property_load_user_config_0: (+1)
   \   0000002C   0x22FF             MOVS     R2,#+255
   \   0000002E   0x2134             MOVS     R1,#+52
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       __aeabi_memset4
    139                  }
    140              }
    141          
    142              // Update available peripherals based on specific chips
    143              update_available_peripherals();
   \                     ??bootloader_property_load_user_config_1: (+1)
   \   00000036   0x.... 0x....      BL       update_available_peripherals
    144          
    145          #endif // BOOTLOADER_HOST
    146          
    147              return kStatus_Success;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
    148          }
    149          
    150          // See property.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    151          status_t bootloader_property_init(void)
    152          {
   \                     bootloader_property_init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    153              property_store_t *propertyStore = g_bootloaderContext.propertyInterface->store;
   \   00000002   0x....             LDR.N    R5,??DataTable4
   \   00000004   0x68A8             LDR      R0,[R5, #+8]
   \   00000006   0x6904             LDR      R4,[R0, #+16]
    154          
    155              // Fill in default values.
    156              propertyStore->bootloaderVersion.name = kBootloader_Version_Name;
   \   00000008   0x204B             MOVS     R0,#+75
   \   0000000A   0x70E0             STRB     R0,[R4, #+3]
    157              propertyStore->bootloaderVersion.major = kBootloader_Version_Major;
    158              propertyStore->bootloaderVersion.minor = kBootloader_Version_Minor;
    159              propertyStore->bootloaderVersion.bugfix = kBootloader_Version_Bugfix;
    160          
    161              propertyStore->serialProtocolVersion.name = kSerialProtocol_Version_Name;
    162              propertyStore->serialProtocolVersion.major = kSerialProtocol_Version_Major;
    163              propertyStore->serialProtocolVersion.minor = kSerialProtocol_Version_Minor;
    164              propertyStore->serialProtocolVersion.bugfix = kSerialProtocol_Version_Bugfix;
    165          
    166          #if defined(BOOTLOADER_HOST)
    167              propertyStore->targetVersion.name = 'H';
    168              propertyStore->targetVersion.major = 1;
    169              propertyStore->targetVersion.minor = 0;
    170              propertyStore->targetVersion.bugfix = 0;
    171          #else
    172              propertyStore->targetVersion.name = kTarget_Version_Name;
    173              propertyStore->targetVersion.major = kTarget_Version_Major;
    174              propertyStore->targetVersion.minor = kTarget_Version_Minor;
    175              propertyStore->targetVersion.bugfix = kTarget_Version_Bugfix;
    176          #endif
    177              propertyStore->verifyWrites = true;
    178          
    179              propertyStore->availableCommands = kAvailableCommands;
    180          
    181          #if !defined(BOOTLOADER_HOST)
    182          
    183              /// Initialize flash properties.
    184              g_bootloaderContext.flashDriverInterface->flash_get_property(
    185                  &g_bootloaderContext.flashState, kFLASH_PropertyPflashBlockBaseAddr, &propertyStore->flashStartAddress);
   \   0000000C   0xF104 0x0210      ADD      R2,R4,#+16
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0x70A0             STRB     R0,[R4, #+2]
   \   00000014   0x2104             MOVS     R1,#+4
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x7060             STRB     R0,[R4, #+1]
   \   0000001A   0x7020             STRB     R0,[R4, #+0]
   \   0000001C   0x2050             MOVS     R0,#+80
   \   0000001E   0x71E0             STRB     R0,[R4, #+7]
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x71A0             STRB     R0,[R4, #+6]
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0x7160             STRB     R0,[R4, #+5]
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x7120             STRB     R0,[R4, #+4]
   \   0000002C   0x2054             MOVS     R0,#+84
   \   0000002E   0x72E0             STRB     R0,[R4, #+11]
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x72A0             STRB     R0,[R4, #+10]
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x7260             STRB     R0,[R4, #+9]
   \   00000038   0x7220             STRB     R0,[R4, #+8]
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x6320             STR      R0,[R4, #+48]
   \   0000003E   0xF64E 0x70DF      MOVW     R0,#+61407
   \   00000042   0x6360             STR      R0,[R4, #+52]
   \   00000044   0xF105 0x0020      ADD      R0,R5,#+32
   \   00000048   0x692B             LDR      R3,[R5, #+16]
   \   0000004A   0x6ADB             LDR      R3,[R3, #+44]
   \   0000004C   0x4798             BLX      R3
    186              g_bootloaderContext.flashDriverInterface->flash_get_property(
    187                  &g_bootloaderContext.flashState, kFLASH_PropertyPflashTotalSize, &propertyStore->flashSizeInBytes);
   \   0000004E   0x692B             LDR      R3,[R5, #+16]
   \   00000050   0x6ADB             LDR      R3,[R3, #+44]
   \   00000052   0xF104 0x0214      ADD      R2,R4,#+20
   \   00000056   0x2101             MOVS     R1,#+1
   \   00000058   0x.... 0x....      BL       ?Subroutine0
    188              g_bootloaderContext.flashDriverInterface->flash_get_property(
    189                  &g_bootloaderContext.flashState, kFLASH_PropertyPflashSectorSize, &propertyStore->flashSectorSize);
   \                     ??CrossCallReturnLabel_6: (+1)
   \   0000005C   0x692B             LDR      R3,[R5, #+16]
   \   0000005E   0x6ADB             LDR      R3,[R3, #+44]
   \   00000060   0xF104 0x0218      ADD      R2,R4,#+24
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0x.... 0x....      BL       ?Subroutine0
    190              g_bootloaderContext.flashDriverInterface->flash_get_property(
    191                  &g_bootloaderContext.flashState, kFLASH_PropertyPflashBlockSize, &propertyStore->flashBlockSize);
   \                     ??CrossCallReturnLabel_5: (+1)
   \   0000006A   0x692B             LDR      R3,[R5, #+16]
   \   0000006C   0x6ADB             LDR      R3,[R3, #+44]
   \   0000006E   0xF104 0x021C      ADD      R2,R4,#+28
   \   00000072   0x2102             MOVS     R1,#+2
   \   00000074   0x.... 0x....      BL       ?Subroutine0
    192              g_bootloaderContext.flashDriverInterface->flash_get_property(
    193                  &g_bootloaderContext.flashState, kFLASH_PropertyPflashBlockCount, &propertyStore->flashBlockCount);
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000078   0x692B             LDR      R3,[R5, #+16]
   \   0000007A   0x6ADB             LDR      R3,[R3, #+44]
   \   0000007C   0xF104 0x0220      ADD      R2,R4,#+32
   \   00000080   0x2103             MOVS     R1,#+3
   \   00000082   0x.... 0x....      BL       ?Subroutine0
    194              g_bootloaderContext.flashDriverInterface->flash_get_property(
    195                  &g_bootloaderContext.flashState, kFLASH_PropertyPflashFacSupport, &propertyStore->flashFacSupport);
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000086   0x692B             LDR      R3,[R5, #+16]
   \   00000088   0x6ADB             LDR      R3,[R3, #+44]
   \   0000008A   0xF104 0x0244      ADD      R2,R4,#+68
   \   0000008E   0x2105             MOVS     R1,#+5
   \   00000090   0x.... 0x....      BL       ?Subroutine0
    196              g_bootloaderContext.flashDriverInterface->flash_get_property(&g_bootloaderContext.flashState,
    197                                                                           kFLASH_PropertyPflashAccessSegmentSize,
    198                                                                           &propertyStore->flashAccessSegmentSize);
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000094   0x692B             LDR      R3,[R5, #+16]
   \   00000096   0x6ADB             LDR      R3,[R3, #+44]
   \   00000098   0xF104 0x0248      ADD      R2,R4,#+72
   \   0000009C   0x2106             MOVS     R1,#+6
   \   0000009E   0x.... 0x....      BL       ?Subroutine0
    199              g_bootloaderContext.flashDriverInterface->flash_get_property(&g_bootloaderContext.flashState,
    200                                                                           kFLASH_PropertyPflashAccessSegmentCount,
    201                                                                           &propertyStore->flashAccessSegmentCount);
   \                     ??CrossCallReturnLabel_1: (+1)
   \   000000A2   0x692B             LDR      R3,[R5, #+16]
   \   000000A4   0x6ADB             LDR      R3,[R3, #+44]
   \   000000A6   0xF104 0x024C      ADD      R2,R4,#+76
   \   000000AA   0x2107             MOVS     R1,#+7
   \   000000AC   0x.... 0x....      BL       ?Subroutine0
    202          
    203              // Fill in reserved regions.
    204              //! @todo Support other tool chain
    205          
    206              uint32_t flashStart = 0;
    207              uint32_t flashEnd = 0;
    208              uint32_t ramStart = 0;
    209              uint32_t ramEnd = 0;
    210          
    211          #if !BL_TARGET_FLASH
    212              flashStart = (&g_bootloaderContext.memoryMap[kIndexFlashArray])->startAddress;
    213              flashEnd = (&g_bootloaderContext.memoryMap[kIndexFlashArray])->startAddress;
   \                     ??CrossCallReturnLabel_0: (+1)
   \   000000B0   0x6868             LDR      R0,[R5, #+4]
   \   000000B2   0x6801             LDR      R1,[R0, #+0]
    214          #else
    215              flashStart = __ROM_START;
    216              flashEnd = __ROM_END;
    217              assert(flashEnd);
    218          
    219              // Force flash erase size alignment.
    220              flashStart = ALIGN_DOWN(flashStart, propertyStore->flashSectorSize);
    221              flashEnd = ALIGN_UP(flashEnd, propertyStore->flashSectorSize) - 1;
    222          #endif
    223              ramStart = __RAM_START;
    224              ramEnd = __RAM_END;
    225              assert(ramEnd);
    226          
    227              propertyStore->reservedRegions[kProperty_FlashReservedRegionIndex].startAddress = flashStart;
   \   000000B4   0x65A1             STR      R1,[R4, #+88]
    228              propertyStore->reservedRegions[kProperty_FlashReservedRegionIndex].endAddress = flashEnd;
   \   000000B6   0x65E1             STR      R1,[R4, #+92]
    229              propertyStore->reservedRegions[kProperty_RamReservedRegionIndex].startAddress = ramStart;
    230              propertyStore->reservedRegions[kProperty_RamReservedRegionIndex].endAddress = ramEnd;
    231          
    232              // Fill in available peripherals array.
    233              const peripheral_descriptor_t *peripherals = g_bootloaderContext.allPeripherals;
    234              propertyStore->availablePeripherals = 0;
   \   000000B8   0x2200             MOVS     R2,#+0
   \   000000BA   0x....             LDR.N    R1,??DataTable4_2
   \   000000BC   0x6621             STR      R1,[R4, #+96]
   \   000000BE   0x....             LDR.N    R1,??DataTable4_3
   \   000000C0   0x6661             STR      R1,[R4, #+100]
   \   000000C2   0x6969             LDR      R1,[R5, #+20]
   \   000000C4   0x60E2             STR      R2,[R4, #+12]
    235              for (uint32_t i = 0; peripherals[i].typeMask != 0; ++i)
   \   000000C6   0xE007             B.N      ??bootloader_property_init_0
    236              {
    237                  // Check that the peripheral is enabled in the user configuration data.
    238                  if (propertyStore->configurationData.enabledPeripherals & peripherals[i].typeMask)
   \                     ??bootloader_property_init_1: (+1)
   \   000000C8   0xF894 0x5078      LDRB     R5,[R4, #+120]
   \   000000CC   0x421D             TST      R5,R3
   \   000000CE   0xD002             BEQ.N    ??bootloader_property_init_2
    239                  {
    240                      propertyStore->availablePeripherals |= peripherals[i].typeMask;
   \   000000D0   0x68E5             LDR      R5,[R4, #+12]
   \   000000D2   0x432B             ORRS     R3,R3,R5
   \   000000D4   0x60E3             STR      R3,[R4, #+12]
    241                  }
    242              }
   \                     ??bootloader_property_init_2: (+1)
   \   000000D6   0x1C52             ADDS     R2,R2,#+1
   \                     ??bootloader_property_init_0: (+1)
   \   000000D8   0x2318             MOVS     R3,#+24
   \   000000DA   0x4353             MULS     R3,R3,R2
   \   000000DC   0x58CB             LDR      R3,[R1, R3]
   \   000000DE   0x2B00             CMP      R3,#+0
   \   000000E0   0xD1F2             BNE.N    ??bootloader_property_init_1
    243          
    244          // Fill in unique device id value.
    245          // Different series have different length of UID (K series=128 bits, KL series=80 bits)
    246          #if defined(SIM_UIDH)
    247              propertyStore->UniqueDeviceId.uidh = SIM_RD_UIDH(SIM);
    248          #endif
    249              propertyStore->UniqueDeviceId.uidmh = SIM->UIDMH;
   \   000000E2   0x....             LDR.N    R1,??DataTable4_4  ;; 0x40048058
   \   000000E4   0x680A             LDR      R2,[R1, #+0]
   \   000000E6   0x6422             STR      R2,[R4, #+64]
    250              propertyStore->UniqueDeviceId.uidml = SIM->UIDML;
   \   000000E8   0x684A             LDR      R2,[R1, #+4]
   \   000000EA   0x63E2             STR      R2,[R4, #+60]
    251              propertyStore->UniqueDeviceId.uidl = SIM->UIDL;
   \   000000EC   0x6889             LDR      R1,[R1, #+8]
   \   000000EE   0x63A1             STR      R1,[R4, #+56]
    252          
    253              // Set address range of RAM in property interface
    254              const memory_map_entry_t *map = (memory_map_entry_t *)&g_bootloaderContext.memoryMap[kIndexSRAM];
    255              propertyStore->ramStartAddress[kIndexSRAM - 1] = map->startAddress;
   \   000000F0   0xF850 0x1F10      LDR      R1,[R0, #+16]!
   \   000000F4   0x6261             STR      R1,[R4, #+36]
    256              propertyStore->ramSizeInBytes[kIndexSRAM - 1] = map->endAddress - map->startAddress + 1;
   \   000000F6   0x6841             LDR      R1,[R0, #+4]
   \   000000F8   0x6800             LDR      R0,[R0, #+0]
   \   000000FA   0x1A08             SUBS     R0,R1,R0
   \   000000FC   0x1C40             ADDS     R0,R0,#+1
   \   000000FE   0x62A0             STR      R0,[R4, #+40]
    257          #if CPU_IS_ARM_CORTEX_M7
    258              map = (memory_map_entry_t *)&g_bootloaderContext.memoryMap[kIndexDTCM];
    259              propertyStore->ramStartAddress[kIndexDTCM - 1] = map->startAddress;
    260              propertyStore->ramSizeInBytes[kIndexDTCM - 1] = map->endAddress - map->startAddress + 1;
    261              map = (memory_map_entry_t *)&g_bootloaderContext.memoryMap[kIndexOCRAM];
    262              propertyStore->ramStartAddress[kIndexOCRAM - 1] = map->startAddress;
    263              propertyStore->ramSizeInBytes[kIndexOCRAM - 1] = map->endAddress - map->startAddress + 1;
    264          
    265          #endif
    266          
    267          #if BL_FEATURE_CRC_CHECK
    268              // Initialize crc check status property based on BCA related fields.
    269              init_crc_check_status(propertyStore);
    270          #endif
    271          
    272              // Fill in default margin level.
    273              propertyStore->flashReadMargin = (uint32_t)kFLASH_MarginValueUser;
   \   00000100   0x2001             MOVS     R0,#+1
   \   00000102   0x6520             STR      R0,[R4, #+80]
    274          
    275          #if BL_FEATURE_QSPI_MODULE
    276              propertyStore->qspiInitStatus = get_qspi_otfad_init_status();
    277          #endif // BL_FEATURE_QSPI_MODULE
    278          
    279          #else
    280          
    281              const memory_map_entry_t *entry;
    282          
    283              // Initialize simulated flash properties.
    284              entry = &g_bootloaderContext.memoryMap[kIndexFlashArray];
    285          
    286              propertyStore->flashStartAddress = entry->startAddress;
    287              propertyStore->flashSizeInBytes = entry->endAddress - entry->startAddress + 1;
    288              propertyStore->flashSectorSize = 1024;
    289              propertyStore->flashBlockSize = propertyStore->flashSizeInBytes;
    290              propertyStore->flashBlockCount = 1;
    291          
    292              // Initialize simulated RAM properties.
    293              entry = &g_bootloaderContext.memoryMap[kIndexSRAM];
    294          
    295              propertyStore->ramStartAddress = entry->startAddress;
    296              propertyStore->ramSizeInBytes = entry->endAddress - entry->startAddress + 1;
    297          
    298          #endif // !BOOTLOADER_HOST
    299          
    300              return kStatus_Success;
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    301          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xF105 0x0020      ADD      R0,R5,#+32
   \   00000004   0x4718             BX       R3
    302          
    303          // See property.h for documentation on this function.

   \                                 In section .text, align 4, keep-with-next
    304          status_t bootloader_property_get(uint8_t tag, uint8_t id, const void **value, uint32_t *valueSize)
    305          {
   \                     bootloader_property_get: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4614             MOV      R4,R2
    306              property_store_t *propertyStore = g_bootloaderContext.propertyInterface->store;
   \   00000004   0x....             LDR.N    R2,??DataTable4
    307          
    308              // Set default value size, may be modified below.
    309              uint32_t returnSize = sizeof(uint32_t);
    310              const void *returnValue;
    311              switch (tag)
   \   00000006   0x....             LDR.N    R7,??DataTable4_5
   \   00000008   0x6891             LDR      R1,[R2, #+8]
   \   0000000A   0x2604             MOVS     R6,#+4
   \   0000000C   0x1E40             SUBS     R0,R0,#+1
   \   0000000E   0x6909             LDR      R1,[R1, #+16]
   \   00000010   0x2817             CMP      R0,#+23
   \   00000012   0x461D             MOV      R5,R3
   \   00000014   0xD84B             BHI.N    ??bootloader_property_get_1
   \   00000016   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??bootloader_property_get_0:
   \   0000001A   0x0C 0x12          DC8      0xC,0x12,0x14,0x16
   \              0x14 0x16    
   \   0000001E   0x18 0x1A          DC8      0x18,0x1A,0x20,0x4A
   \              0x20 0x4A    
   \   00000022   0x4A 0x22          DC8      0x4A,0x22,0x24,0x2B
   \              0x24 0x2B    
   \   00000026   0x4A 0x1C          DC8      0x4A,0x1C,0x1E,0x2E
   \              0x1E 0x2E    
   \   0000002A   0x31 0x3D          DC8      0x31,0x3D,0x40,0x42
   \              0x40 0x42    
   \   0000002E   0x44 0x46          DC8      0x44,0x46,0x4A,0x48
   \              0x4A 0x48    
    312              {
    313                  case kPropertyTag_BootloaderVersion:
    314                      returnValue = &propertyStore->bootloaderVersion.version;
    315                      break;
    316          
    317                  case kPropertyTag_AvailablePeripherals:
    318                      returnValue = &propertyStore->availablePeripherals;
    319                      break;
    320          
    321                  case kPropertyTag_FlashStartAddress:
    322                      returnValue = &propertyStore->flashStartAddress;
    323                      break;
    324          
    325                  case kPropertyTag_FlashSizeInBytes:
    326                      returnValue = &propertyStore->flashSizeInBytes;
    327                      break;
    328          
    329                  case kPropertyTag_FlashSectorSize:
    330                      returnValue = &propertyStore->flashSectorSize;
    331                      break;
    332          
    333                  case kPropertyTag_FlashBlockCount:
    334                      returnValue = &propertyStore->flashBlockCount;
    335                      break;
    336          
    337                  case kPropertyTag_RAMStartAddress:
    338                      returnValue = &propertyStore->ramStartAddress[0];
    339          
    340          #if CPU_IS_ARM_CORTEX_M7
    341                      returnValue = &propertyStore->ramStartAddress[id];
    342          #endif // CPU_IS_ARM_CORTEX_M7
    343          
    344                      break;
    345          
    346                  case kPropertyTag_RAMSizeInBytes:
    347                      returnValue = &propertyStore->ramSizeInBytes[0];
    348          
    349          #if CPU_IS_ARM_CORTEX_M7
    350                      returnValue = &propertyStore->ramSizeInBytes[id];
    351          #endif // CPU_IS_ARM_CORTEX_M7
    352          
    353                      break;
    354          
    355                  case kPropertyTag_AvailableCommands:
    356                      returnValue = &propertyStore->availableCommands;
    357                      break;
    358          
    359          #if BL_FEATURE_CRC_CHECK
    360                  case kPropertyTag_CrcCheckStatus:
    361                      returnValue = &propertyStore->crcCheckStatus;
    362                      break;
    363          #endif // else falls through to unknown
    364          
    365                  case kPropertyTag_VerifyWrites:
    366                      returnValue = &propertyStore->verifyWrites;
    367                      break;
    368          
    369                  case kPropertyTag_MaxPacketSize:
    370                      // Read the max packet size from the active peripheral.
    371                      s_propertyReturnValue = g_bootloaderContext.activePeripheral->packetInterface->getMaxPacketSize(
    372                          g_bootloaderContext.activePeripheral);
    373                      returnValue = &s_propertyReturnValue;
    374                      break;
    375          
    376                  case kPropertyTag_ReservedRegions:
    377                      returnSize = sizeof(propertyStore->reservedRegions);
    378                      returnValue = propertyStore->reservedRegions;
    379                      break;
    380          
    381                  case kPropertyTag_SystemDeviceId:
    382          // Get system device identification
    383          #if BOOTLOADER_HOST
    384                      s_propertyReturnValue = 0;
    385          #else
    386                      s_propertyReturnValue = SIM->SDID;
    387          #endif // BOOTLOADER_HOST
    388                      returnValue = &s_propertyReturnValue;
    389                      break;
    390          
    391                  case kPropertyTag_FlashSecurityState:
    392                  {
    393          #if BOOTLOADER_HOST
    394                      s_propertyReturnValue = 0;
    395          #else
    396                      flash_security_state_t securityState;
    397                      g_bootloaderContext.flashDriverInterface->flash_get_security_state(&g_bootloaderContext.flashState,
    398                                                                                         &securityState);
    399                      s_propertyReturnValue = (securityState != kFLASH_SecurityStateNotSecure);
    400          #endif // BOOTLOADER_HOST
    401                      returnValue = &s_propertyReturnValue;
    402                      break;
    403                  }
    404          
    405                  case kPropertyTag_UniqueDeviceId:
    406                      returnSize = sizeof(propertyStore->UniqueDeviceId);
    407                      returnValue = &propertyStore->UniqueDeviceId;
    408                      break;
    409          
    410                  case kPropertyTag_FacSupport:
    411                      returnSize = sizeof(propertyStore->flashFacSupport);
    412                      returnValue = &propertyStore->flashFacSupport;
    413                      break;
    414          
    415                  case kPropertyTag_FlashAccessSegmentSize:
    416                      returnSize = sizeof(propertyStore->flashAccessSegmentSize);
    417                      returnValue = &propertyStore->flashAccessSegmentSize;
    418                      break;
    419          
    420                  case kPropertyTag_FlashAccessSegmentCount:
    421                      returnSize = sizeof(propertyStore->flashAccessSegmentCount);
    422                      returnValue = &propertyStore->flashAccessSegmentCount;
    423                      break;
    424          
    425                  case kPropertyTag_FlashReadMargin:
    426                      returnSize = sizeof(propertyStore->flashReadMargin);
    427                      returnValue = &propertyStore->flashReadMargin;
    428                      break;
    429          
    430          #if BL_FEATURE_QSPI_MODULE
    431                  case kPropertyTag_QspiInitStatus:
    432                      returnValue = &propertyStore->qspiInitStatus;
    433                      break;
    434          #endif // else falls through to unknown
    435          
    436                  case kPropertyTag_TargetVersion:
    437                      returnValue = &propertyStore->targetVersion.version;
    438                      break;
    439          #if BL_FEATURE_EXTERNAL_MEMORY_PROPERTY
    440                  case kPropertyTag_ExternalMemoryAttributes:
    441                  {
    442                      status_t status =
    443                          bootloader_get_external_memory_properties(id, &propertyStore->externalMemoryPropertyStore);
    444                      if (status != kStatus_Success)
    445                      {
    446                          return status;
    447                      }
    448                  }
    449                      returnSize = sizeof(propertyStore->externalMemoryPropertyStore);
    450                      returnValue = &propertyStore->externalMemoryPropertyStore;
    451                      break;
    452          #endif // BL_FEATURE_EXTERNAL_MEMORY_PROPERTY
    453          
    454          #if BL_FEATURE_RELIABLE_UPDATE
    455                  case kPropertyTag_ReliableUpdateStatus:
    456                      returnValue = &propertyStore->reliableUpdateStatus;
    457                      break;
    458          #endif // BL_FEATURE_RELIABLE_UPDATE
    459          
    460                  default:
    461                      return kStatus_UnknownProperty;
    462              }
    463          
    464              // Set the return size.
    465              if (valueSize)
   \                     ??bootloader_property_get_2: (+1)
   \   00000032   0xB105             CBZ.N    R5,??bootloader_property_get_3
    466              {
    467                  *valueSize = returnSize;
   \   00000034   0x602E             STR      R6,[R5, #+0]
    468              }
    469          
    470              // Set the return value
    471              if (value)
   \                     ??bootloader_property_get_3: (+1)
   \   00000036   0xB104             CBZ.N    R4,??bootloader_property_get_4
    472              {
    473                  *value = returnValue;
   \   00000038   0x6021             STR      R1,[R4, #+0]
    474              }
    475          
    476              return kStatus_Success;
   \                     ??bootloader_property_get_4: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??bootloader_property_get_5: (+1)
   \   0000003E   0x310C             ADDS     R1,R1,#+12
   \   00000040   0xE7F7             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_6: (+1)
   \   00000042   0x3110             ADDS     R1,R1,#+16
   \   00000044   0xE7F5             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_7: (+1)
   \   00000046   0x3114             ADDS     R1,R1,#+20
   \   00000048   0xE7F3             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_8: (+1)
   \   0000004A   0x3118             ADDS     R1,R1,#+24
   \   0000004C   0xE7F1             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_9: (+1)
   \   0000004E   0x3120             ADDS     R1,R1,#+32
   \   00000050   0xE7EF             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_10: (+1)
   \   00000052   0x3124             ADDS     R1,R1,#+36
   \   00000054   0xE7ED             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_11: (+1)
   \   00000056   0x3128             ADDS     R1,R1,#+40
   \   00000058   0xE7EB             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_12: (+1)
   \   0000005A   0x3134             ADDS     R1,R1,#+52
   \   0000005C   0xE7E9             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_13: (+1)
   \   0000005E   0x3130             ADDS     R1,R1,#+48
   \   00000060   0xE7E7             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_14: (+1)
   \   00000062   0x69D0             LDR      R0,[R2, #+28]
   \   00000064   0x6941             LDR      R1,[R0, #+20]
   \   00000066   0x6949             LDR      R1,[R1, #+20]
   \   00000068   0x4788             BLX      R1
   \                     ??bootloader_property_get_15: (+1)
   \   0000006A   0x6038             STR      R0,[R7, #+0]
   \   0000006C   0x4639             MOV      R1,R7
   \   0000006E   0xE7E0             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_16: (+1)
   \   00000070   0x2610             MOVS     R6,#+16
   \   00000072   0x3158             ADDS     R1,R1,#+88
   \   00000074   0xE7DD             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_17: (+1)
   \   00000076   0x....             LDR.N    R0,??DataTable4_6  ;; 0x40048024
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0xE7F6             B.N      ??bootloader_property_get_15
   \                     ??bootloader_property_get_18: (+1)
   \   0000007C   0xF102 0x0020      ADD      R0,R2,#+32
   \   00000080   0x6912             LDR      R2,[R2, #+16]
   \   00000082   0x6992             LDR      R2,[R2, #+24]
   \   00000084   0x4669             MOV      R1,SP
   \   00000086   0x4790             BLX      R2
   \   00000088   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD0EC             BEQ.N    ??bootloader_property_get_15
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0xE7EA             B.N      ??bootloader_property_get_15
   \                     ??bootloader_property_get_19: (+1)
   \   00000094   0x260C             MOVS     R6,#+12
   \   00000096   0x3138             ADDS     R1,R1,#+56
   \   00000098   0xE7CB             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_20: (+1)
   \   0000009A   0x3144             ADDS     R1,R1,#+68
   \   0000009C   0xE7C9             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_21: (+1)
   \   0000009E   0x3148             ADDS     R1,R1,#+72
   \   000000A0   0xE7C7             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_22: (+1)
   \   000000A2   0x314C             ADDS     R1,R1,#+76
   \   000000A4   0xE7C5             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_23: (+1)
   \   000000A6   0x3150             ADDS     R1,R1,#+80
   \   000000A8   0xE7C3             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_24: (+1)
   \   000000AA   0x3108             ADDS     R1,R1,#+8
   \   000000AC   0xE7C1             B.N      ??bootloader_property_get_2
   \                     ??bootloader_property_get_1: (+1)
   \   000000AE   0xF642 0x003C      MOVW     R0,#+10300
   \   000000B2   0xBDF2             POP      {R1,R4-R7,PC}
    477          }
    478          
    479          // See property.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    480          status_t bootloader_property_set_uint32(uint8_t tag, uint32_t value)
    481          {
    482              property_store_t *propertyStore = g_bootloaderContext.propertyInterface->store;
   \                     bootloader_property_set_uint32: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable4
   \   00000002   0x6892             LDR      R2,[R2, #+8]
   \   00000004   0x6913             LDR      R3,[R2, #+16]
    483          
    484              switch (tag)
   \   00000006   0x1E40             SUBS     R0,R0,#+1
   \   00000008   0x2806             CMP      R0,#+6
   \   0000000A   0xF642 0x023E      MOVW     R2,#+10302
   \   0000000E   0xD918             BLS.N    ??bootloader_property_set_uint32_0
   \   00000010   0x3809             SUBS     R0,R0,#+9
   \   00000012   0xD00A             BEQ.N    ??bootloader_property_set_uint32_1
   \   00000014   0x1E40             SUBS     R0,R0,#+1
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xBF84             ITT      HI 
   \   0000001A   0x1EC0             SUBHI    R0,R0,#+3
   \   0000001C   0x2803             CMPHI    R0,#+3
   \   0000001E   0xD910             BLS.N    ??bootloader_property_set_uint32_0
   \   00000020   0x3808             SUBS     R0,R0,#+8
   \   00000022   0xD008             BEQ.N    ??bootloader_property_set_uint32_2
   \   00000024   0x1E80             SUBS     R0,R0,#+2
   \   00000026   0xD00C             BEQ.N    ??bootloader_property_set_uint32_0
   \   00000028   0xE00E             B.N      ??bootloader_property_set_uint32_3
    485              {
    486                  case kPropertyTag_VerifyWrites:
    487                      if (value != 0 && value != 1)
   \                     ??bootloader_property_set_uint32_1: (+1)
   \   0000002A   0x2900             CMP      R1,#+0
   \   0000002C   0xBF18             IT       NE 
   \   0000002E   0x2901             CMPNE    R1,#+1
   \   00000030   0xD103             BNE.N    ??bootloader_property_set_uint32_4
    488                      {
    489                          return kStatus_InvalidPropertyValue;
    490                      }
    491                      propertyStore->verifyWrites = value;
   \   00000032   0x6319             STR      R1,[R3, #+48]
    492                      return kStatus_Success;
   \   00000034   0x4770             BX       LR
    493          
    494                  case kPropertyTag_FlashReadMargin:
    495          #if !defined(BOOTLOADER_HOST)
    496                      if (value >= kFLASH_MarginValueInvalid)
   \                     ??bootloader_property_set_uint32_2: (+1)
   \   00000036   0x2903             CMP      R1,#+3
   \   00000038   0xD301             BCC.N    ??bootloader_property_set_uint32_5
    497                      {
    498                          return kStatus_InvalidPropertyValue;
   \                     ??bootloader_property_set_uint32_4: (+1)
   \   0000003A   0x4610             MOV      R0,R2
   \   0000003C   0x4770             BX       LR
    499                      }
    500                      propertyStore->flashReadMargin = value;
   \                     ??bootloader_property_set_uint32_5: (+1)
   \   0000003E   0x6519             STR      R1,[R3, #+80]
    501          #endif // !BOOTLOADER_HOST
    502                      return kStatus_Success;
   \   00000040   0x4770             BX       LR
    503          
    504                  case kPropertyTag_BootloaderVersion:
    505                  case kPropertyTag_AvailablePeripherals:
    506                  case kPropertyTag_FlashStartAddress:
    507                  case kPropertyTag_FlashSizeInBytes:
    508                  case kPropertyTag_FlashSectorSize:
    509                  case kPropertyTag_FlashBlockCount:
    510                  case kPropertyTag_RAMStartAddress:
    511                  case kPropertyTag_RAMSizeInBytes:
    512                  case kPropertyTag_AvailableCommands:
    513          #if BL_FEATURE_CRC_CHECK
    514                  case kPropertyTag_CrcCheckStatus:
    515          #endif
    516          #if BL_FEATURE_QSPI_MODULE
    517                  case kPropertyTag_QspiInitStatus:
    518          #endif
    519          #if BL_FEATURE_EXTERNAL_MEMORY_PROPERTY
    520                  case kPropertyTag_ExternalMemoryAttributes:
    521          #endif // BL_FEATURE_EXTERNAL_MEMORY_PROPERTY
    522          #if BL_FEATURE_RELIABLE_UPDATE
    523                  case kPropertyTag_ReliableUpdateStatus:
    524          #endif // BL_FEATURE_RELIABLE_UPDATE
    525                  case kPropertyTag_MaxPacketSize:
    526                  case kPropertyTag_ReservedRegions:
    527                  case kPropertyTag_SystemDeviceId:
    528                  case kPropertyTag_FlashSecurityState:
    529                  case kPropertyTag_TargetVersion:
    530                      return kStatus_ReadOnlyProperty;
   \                     ??bootloader_property_set_uint32_0: (+1)
   \   00000042   0xF642 0x003D      MOVW     R0,#+10301
   \   00000046   0x4770             BX       LR
    531                  default:
    532                      return kStatus_UnknownProperty;
   \                     ??bootloader_property_set_uint32_3: (+1)
   \   00000048   0xF642 0x003C      MOVW     R0,#+10300
   \   0000004C   0x4770             BX       LR               ;; return
    533              }
    534          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     g_bootloaderContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x6766636B         DC32     0x6766636b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     SFB(`.intvec`)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     SFE(ApplicationRam)+0xFFFFFFFF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x40048058         DC32     0x40048058

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     s_propertyReturnValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x40048024         DC32     0x40048024
    535          
    536          #if BL_FEATURE_EXTERNAL_MEMORY_PROPERTY
    537          status_t bootloader_get_external_memory_properties(uint8_t memoryId, external_memory_property_store_t *store)
    538          {
    539              extern const external_memory_property_interface_t g_externalMemPropertyInterfaceMap[];
    540          
    541              // Find external memory property interface map.
    542              const external_memory_property_interface_t *map = &g_externalMemPropertyInterfaceMap[0];
    543              while (map && map->get)
    544              {
    545                  if (map->memoryId == memoryId)
    546                  {
    547                      break;
    548                  }
    549                  map++;
    550              }
    551          
    552              if (map->get == NULL)
    553              {
    554                  return kStatus_InvalidArgument;
    555              }
    556          
    557              external_memory_property_store_t propertyStore;
    558              uint32_t memoryInitStatus;
    559              map->get(kExternalMemoryPropertyTag_InitStatus, &memoryInitStatus);
    560              if (memoryInitStatus != kStatus_Success)
    561              {
    562                  return memoryInitStatus;
    563              }
    564          
    565              uint32_t *property = (uint32_t *)&propertyStore.startAddress;
    566              propertyStore.availableAttributesFlag = 0;
    567              for (uint32_t tag = kExternalMemoryPropertyTag_Start; tag <= kExternalMemoryPropertyTag_End; tag++)
    568              {
    569                  uint32_t tmp = 0;
    570                  status_t status = map->get(tag, &tmp);
    571                  if (status == kStatus_Success)
    572                  {
    573                      *property = tmp;
    574                      propertyStore.availableAttributesFlag |= 1 << (tag - 1);
    575                  }
    576                  else
    577                  {
    578                      *property = 0;
    579                  }
    580          
    581                  property++;
    582              }
    583          
    584              memcpy(store, &propertyStore, sizeof(propertyStore));
    585          
    586              return kStatus_Success;
    587          }
    588          #endif // BL_FEATURE_EXTERNAL_MEMORY_PROPERTY
    589          
    590          ////////////////////////////////////////////////////////////////////////////////
    591          // EOF
    592          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   bootloader_property_get
        24   -- Indirect call
      16   bootloader_property_init
        16   -- Indirect call
       8   bootloader_property_load_user_config
         8   -> __aeabi_memcpy4
         8   -> __aeabi_memset4
         8   -> is_in_execute_only_region
         8   -> update_available_peripherals
       0   bootloader_property_set_uint32


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       6  ?Subroutine0
     180  bootloader_property_get
     264  bootloader_property_init
      62  bootloader_property_load_user_config
      78  bootloader_property_set_uint32
      20  g_propertyInterface
     184  g_propertyStore
       4  s_propertyReturnValue

 
 188 bytes in section .bss
  20 bytes in section .rodata
 618 bytes in section .text
 
 618 bytes of CODE  memory
  20 bytes of CONST memory
 188 bytes of DATA  memory

Errors: none
Warnings: none
