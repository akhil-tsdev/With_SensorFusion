###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Aug/2016  13:16:03
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_msc_ufi.c
#    Command line =  
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_msc_ufi.c"
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN256VDC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D BL_TARGET_RAM -lC
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj"
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices/MK22F25612\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/autobaud\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/osa\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device/class\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/bm_usb\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/CMSIS/Include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers/common\"
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list\usb_device_msc_ufi.lst
#    Object file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj\usb_device_msc_ufi.o
#
###############################################################################

C:\Users\cwati\Documents\My Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_msc_ufi.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "usb_device_config.h"
     32          #include "usb.h"
     33          #include "usb_device.h"
     34          
     35          #include "usb_device_class.h"
     36          
     37          #if USB_DEVICE_CONFIG_MSC
     38          #include "usb_device_msc_ufi.h"
     39          #include "usb_device_msc.h"
     40          /*******************************************************************************
     41           * Definitions
     42           ******************************************************************************/
     43          
     44          /*******************************************************************************
     45           * Prototypes
     46           ******************************************************************************/
     47          /*******************************************************************************
     48           * Variables
     49           ******************************************************************************/
     50          /*******************************************************************************
     51           * Code
     52           ******************************************************************************/
     53          

   \                                 In section .text, align 4, keep-with-next
     54          const usb_device_inquiry_data_fromat_struct_t g_InquiryInfoConst = {
   \                     g_InquiryInfoConst:
   \   00000000   0x00 0x80          DC8 0, 128, 4, 2, 32, 0, 0, 0, 70, 83, 76, 32, 83, 69, 77, 73, 70, 83
   \              0x04 0x02    
   \              0x20 0x00    
   \              0x00 0x00    
   \              0x46 0x53    
   \              0x4C 0x20    
   \              0x53 0x45    
   \              0x4D 0x49    
   \              0x46 0x53    
   \   00000012   0x4C 0x20          DC8 76, 32, 77, 65, 83, 83, 32, 83, 84, 79, 82, 65, 71, 69, 48, 48, 48
   \              0x4D 0x41    
   \              0x53 0x53    
   \              0x20 0x53    
   \              0x54 0x4F    
   \              0x52 0x41    
   \              0x47 0x45    
   \              0x30 0x30    
   \              0x30         
   \   00000023   0x31               DC8 49
     55              (USB_DEVICE_MSC_UFI_PERIPHERAL_QUALIFIER << USB_DEVICE_MSC_UFI_PERIPHERAL_QUALIFIER_SHIFT) |
     56                  USB_DEVICE_MSC_UFI_PERIPHERAL_DEVICE_TYPE,
     57              (uint8_t)(USB_DEVICE_MSC_UFI_REMOVABLE_MEDIUM_BIT << USB_DEVICE_MSC_UFI_REMOVABLE_MEDIUM_BIT_SHIFT),
     58              USB_DEVICE_MSC_UFI_VERSIONS,
     59              0x02,
     60              USB_DEVICE_MSC_UFI_ADDITIONAL_LENGTH,
     61              {0x00, 0x00, 0x00},
     62              {'F', 'S', 'L', ' ', 'S', 'E', 'M', 'I'},
     63              {'F', 'S', 'L', ' ', 'M', 'A', 'S', 'S', ' ', 'S', 'T', 'O', 'R', 'A', 'G', 'E'},
     64              {'0', '0', '0', '1'}};

   \                                 In section .text, align 4, keep-with-next
     65          const usb_device_mode_parameters_header_struct_t g_ModeParametersHeaderConst = {
   \                     g_ModeParametersHeaderConst:
   \   00000000   0x0000             DC16 0
   \   00000002   0x00 0x00          DC8 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
     66              /*refer to ufi spec mode parameter header*/
     67              0x0000, /*!< Mode Data Length*/
     68              0x00,   /*!<Default medium type (current mounted medium type)*/
     69              0x00,   /*!MODE SENSE command, a Write Protected bit of zero indicates the medium is write enabled*/
     70              {0x00, 0x00, 0x00, 0x00} /*!<This bit should be set to zero*/
     71          };
     72          /*!
     73           * @brief Thirteen possiable case check.
     74           *
     75           * This function handle the the thirteen possible cases of host expectations and device intent in the absence of
     76           *overriding error conditions.
     77           *
     78           * @param handle          The device msc class hanlde.
     79           *
     80           *@return A USB error code or kStatus_USB_Success. more information about return value ,refer to
     81           *USB_DeviceMscLbaTransfer and USB_DeviceRecvRequest
     82           */
     83          

   \                                 In section .text, align 2, keep-with-next
     84          usb_status_t USB_DeviceMscUfiThirteenCasesCheck(usb_device_msc_struct_t *mscHandle)
     85          {
   \                     USB_DeviceMscUfiThirteenCasesCheck: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
     86              usb_status_t error = kStatus_USB_Success;
     87              usb_device_msc_ufi_struct_t *ufi;
     88              usb_device_msc_thirteen_case_struct_t *mscCheckEvent;
     89          
     90              mscCheckEvent = (usb_device_msc_thirteen_case_struct_t *)&mscHandle->mscUfi.thirteenCase;
     91              ufi = &mscHandle->mscUfi;
     92              /* The following code describe the thirteen possiable cases of host
     93                  exceptations and device intent in absence of overriding error conditions ,refer to bulk-only spec chapter 6.7
     94                 The Thirteen Cases*/
     95              if (mscCheckEvent->hostExpectedDataLength == 0)
   \   00000004   0xF104 0x0554      ADD      R5,R4,#+84
   \   00000008   0x69EB             LDR      R3,[R5, #+28]
   \   0000000A   0x69A9             LDR      R1,[R5, #+24]
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xB921             CBNZ.N   R1,??USB_DeviceMscUfiThirteenCasesCheck_0
     96              {
     97                  /*Host expects no data transfers*/
     98                  mscHandle->mscCsw.dataResidue = 0;
     99                  if (mscCheckEvent->deviceExpectedDataLength == 0)
   \   00000010   0x2B00             CMP      R3,#+0
   \   00000012   0x6521             STR      R1,[R4, #+80]
   \   00000014   0xD000             BEQ.N    ??USB_DeviceMscUfiThirteenCasesCheck_1
    100                  { /*case 1, Device intends to transfer no data*/
    101                      mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_PASSED;
    102                  }
    103                  else
    104                  { /*case 2 ,Device intends to send data to the host; */
    105                      /*case 3, Device intends to receive data from the host*/
    106                      /*set csw status to 02h*/
    107                      mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_PHASE_ERROR;
   \   00000016   0x2102             MOVS     R1,#+2
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_1: (+1)
   \   00000018   0xE099             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_2
    108                  }
    109              }
    110              else if (mscCheckEvent->hostExpectedDirection)
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_0: (+1)
   \   0000001A   0xF104 0x0680      ADD      R6,R4,#+128
   \   0000001E   0xF104 0x07EF      ADD      R7,R4,#+239
   \   00000022   0x7870             LDRB     R0,[R6, #+1]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD045             BEQ.N    ??USB_DeviceMscUfiThirteenCasesCheck_3
    111              {
    112                  /*Host expects to receive data from the device*/
    113                  if (mscCheckEvent->deviceExpectedDataLength == 0)
   \   00000028   0xB923             CBNZ.N   R3,??USB_DeviceMscUfiThirteenCasesCheck_4
    114                  {
    115                      /*case 4, Device intends to transfer no data*/
    116                      mscHandle->mscCsw.dataResidue =
    117                          mscCheckEvent->hostExpectedDataLength - mscCheckEvent->deviceExpectedDataLength;
   \   0000002A   0x6521             STR      R1,[R4, #+80]
    118                      error = USB_DeviceSendRequest(mscHandle->handle, mscHandle->bulkInEndpoint, mscCheckEvent->buffer,
    119                                                    mscCheckEvent->deviceExpectedDataLength);
    120          
    121                      if (kStatus_USB_Success == error)
   \   0000002C   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000030   0xB978             CBNZ.N   R0,??USB_DeviceMscUfiThirteenCasesCheck_5
    122                      {
    123                          mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_PASSED;
   \   00000032   0xE061             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_6
    124                      }
    125                      else
    126                      {
    127                          mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_FAILED;
    128                          ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_MEDIUM_ERROR;
    129                          ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_UNRECOVERED_READ_ERROR;
    130                      }
    131                      error = kStatus_USB_InvalidRequest;
    132                  }
    133                  else if (mscCheckEvent->deviceExpectedDirection)
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_4: (+1)
   \   00000034   0x78B0             LDRB     R0,[R6, #+2]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD033             BEQ.N    ??USB_DeviceMscUfiThirteenCasesCheck_7
    134                  {
    135                      if (mscCheckEvent->hostExpectedDataLength > mscCheckEvent->deviceExpectedDataLength)
   \   0000003A   0x428B             CMP      R3,R1
   \   0000003C   0xD20F             BCS.N    ??USB_DeviceMscUfiThirteenCasesCheck_8
    136                      {
    137                          /*case 5, device intends to send less data than the host indicated*/
    138                          mscHandle->mscCsw.dataResidue =
    139                              mscCheckEvent->hostExpectedDataLength - mscCheckEvent->deviceExpectedDataLength;
   \   0000003E   0x.... 0x....      BL       ?Subroutine5
    140          
    141                          if (ufi->thirteenCase.lbaSendRecvSelect == 1)
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000042   0xD102             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_9
    142                          {
    143                              error = USB_DeviceMscLbaTransfer(mscHandle, USB_IN, &mscCheckEvent->lbaInformation);
   \   00000044   0x.... 0x....      BL       ?Subroutine7
    144                          }
   \                     ??CrossCallReturnLabel_15: (+1)
   \   00000048   0xE001             B.N      ??CrossCallReturnLabel_2
    145                          else
    146                          {
    147                              error = USB_DeviceSendRequest(mscHandle->handle, mscHandle->bulkInEndpoint, mscCheckEvent->buffer,
    148                                                            mscCheckEvent->deviceExpectedDataLength);
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_9: (+1)
   \   0000004A   0x.... 0x....      BL       ?Subroutine3
    149                          }
    150          
    151                          if (kStatus_USB_Success == error)
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD052             BEQ.N    ??USB_DeviceMscUfiThirteenCasesCheck_6
    152                          {
    153                              mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_PASSED;
    154                          }
    155                          else
    156                          {
    157                              mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_FAILED;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_5: (+1)
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x7028             STRB     R0,[R5, #+0]
    158                              ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_MEDIUM_ERROR;
   \   00000056   0x2003             MOVS     R0,#+3
   \   00000058   0x71A8             STRB     R0,[R5, #+6]
    159                              ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_UNRECOVERED_READ_ERROR;
   \   0000005A   0x2011             MOVS     R0,#+17
   \   0000005C   0xE052             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_10
    160                          }
    161                          error = kStatus_USB_InvalidRequest;
    162                      }
    163                      else if (mscCheckEvent->hostExpectedDataLength == mscCheckEvent->deviceExpectedDataLength)
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_8: (+1)
   \   0000005E   0x4299             CMP      R1,R3
   \   00000060   0xD10B             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_11
    164                      { /*case 6*,device intends to send dCBWDataTransferLength excepted by the host*/
    165                          mscHandle->mscCsw.dataResidue = 0;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x.... 0x....      BL       ??Subroutine5_0
    166                          if (ufi->thirteenCase.lbaSendRecvSelect == 1)
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000068   0xD102             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_12
    167                          {
    168                              error = USB_DeviceMscLbaTransfer(mscHandle, USB_IN, &mscCheckEvent->lbaInformation);
   \   0000006A   0x.... 0x....      BL       ?Subroutine7
    169                          }
   \                     ??CrossCallReturnLabel_14: (+1)
   \   0000006E   0xE001             B.N      ??CrossCallReturnLabel_1
    170                          else
    171                          {
    172                              error = USB_DeviceSendRequest(mscHandle->handle, mscHandle->bulkInEndpoint, mscCheckEvent->buffer,
    173                                                            mscCheckEvent->deviceExpectedDataLength);
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_12: (+1)
   \   00000070   0x.... 0x....      BL       ?Subroutine3
    174                          }
    175          
    176                          if (kStatus_USB_Success == error)
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000074   0x0001             MOVS     R1,R0
   \   00000076   0xD10E             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_13
    177                          {
    178                              mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_PASSED;
   \   00000078   0xE068             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_14
    179                          }
    180                          else
    181                          {
    182                              mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_FAILED;
    183                              ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_MEDIUM_ERROR;
    184                              ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_UNRECOVERED_READ_ERROR;
    185                          }
    186                      }
    187                      else
    188                      { /*case 7, device intends to send more data than the host indicated*/
    189                          mscHandle->mscCsw.dataResidue = 0;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_11: (+1)
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x.... 0x....      BL       ??Subroutine5_0
    190          
    191                          if (ufi->thirteenCase.lbaSendRecvSelect == 1)
   \                     ??CrossCallReturnLabel_10: (+1)
   \   00000080   0xD104             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_15
    192                          {
    193                              mscCheckEvent->lbaInformation.transferNumber =
    194                                  mscCheckEvent->hostExpectedDataLength / mscHandle->lengthOfEachLba;
   \   00000082   0x.... 0x....      BL       ?Subroutine10
    195                              mscHandle->mscCsw.dataResidue =
    196                                  mscCheckEvent->hostExpectedDataLength -
    197                                  mscCheckEvent->lbaInformation.transferNumber * mscHandle->lengthOfEachLba;
    198                              error = USB_DeviceMscLbaTransfer(mscHandle, USB_IN, &mscCheckEvent->lbaInformation);
   \                     ??CrossCallReturnLabel_21: (+1)
   \   00000086   0x.... 0x....      BL       ?Subroutine7
    199                          }
   \                     ??CrossCallReturnLabel_13: (+1)
   \   0000008A   0xE002             B.N      ??CrossCallReturnLabel_0
    200                          else
    201                          {
    202                              error = USB_DeviceSendRequest(mscHandle->handle, mscHandle->bulkInEndpoint, mscCheckEvent->buffer,
    203                                                            mscCheckEvent->hostExpectedDataLength);
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_15: (+1)
   \   0000008C   0x460B             MOV      R3,R1
   \   0000008E   0x.... 0x....      BL       ?Subroutine3
    204                          }
    205          
    206                          if (kStatus_USB_Success == error)
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000092   0x0001             MOVS     R1,R0
   \   00000094   0xD055             BEQ.N    ??USB_DeviceMscUfiThirteenCasesCheck_16
    207                          {
    208                              if (ufi->thirteenCase.lbaSendRecvSelect == 1)
    209                              {
    210                                  mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_PHASE_ERROR;
    211                              }
    212                              else
    213                              {
    214                                  mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_PASSED;
    215                              }
    216                          }
    217                          else
    218                          {
    219                              mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_FAILED;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_13: (+1)
   \   00000096   0x2101             MOVS     R1,#+1
   \   00000098   0x7029             STRB     R1,[R5, #+0]
    220                              ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_MEDIUM_ERROR;
   \   0000009A   0x2103             MOVS     R1,#+3
   \   0000009C   0x71A9             STRB     R1,[R5, #+6]
    221                              ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_UNRECOVERED_READ_ERROR;
   \   0000009E   0x2111             MOVS     R1,#+17
   \   000000A0   0xE059             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_17
    222                          }
    223                      }
    224                  }
    225                  else
    226                  {
    227                      /*case 8, device intends to receive data from the host*/
    228                      mscHandle->mscCsw.dataResidue = mscCheckEvent->hostExpectedDataLength;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_7: (+1)
   \   000000A2   0x6521             STR      R1,[R4, #+80]
    229                      error = USB_DeviceSendRequest(mscHandle->handle, mscHandle->bulkInEndpoint, mscCheckEvent->buffer, 0);
   \   000000A4   0x6A2A             LDR      R2,[R5, #+32]
   \   000000A6   0x7AB9             LDRB     R1,[R7, #+10]
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x2300             MOVS     R3,#+0
   \   000000AC   0x.... 0x....      BL       USB_DeviceSendRequest
    230                      mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_PHASE_ERROR;
   \   000000B0   0x2002             MOVS     R0,#+2
   \   000000B2   0xE021             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_6
    231                      error = kStatus_USB_InvalidRequest;
    232                  }
    233              }
    234              else
    235              {
    236                  /*Host expects to send data to the device*/
    237                  if (0 == mscCheckEvent->deviceExpectedDataLength)
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_3: (+1)
   \   000000B4   0xB943             CBNZ.N   R3,??USB_DeviceMscUfiThirteenCasesCheck_18
    238                  { /*case 9,Device intends to transfer no data*/
    239                      USB_DeviceStallEndpoint(mscHandle->handle, mscHandle->bulkOutEndpoint);
   \   000000B6   0x7AF9             LDRB     R1,[R7, #+11]
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x.... 0x....      BL       USB_DeviceStallEndpoint
    240                      mscHandle->mscCsw.dataResidue = mscCheckEvent->hostExpectedDataLength;
   \   000000BE   0x69A8             LDR      R0,[R5, #+24]
   \   000000C0   0x6520             STR      R0,[R4, #+80]
    241                      mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_FAILED;
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0x7028             STRB     R0,[R5, #+0]
    242                      mscHandle->outEndpointStallFlag = 1;
   \   000000C6   0xE00A             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_19
    243                      error = kStatus_USB_InvalidRequest;
    244                  }
    245                  else if (mscCheckEvent->deviceExpectedDirection)
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_18: (+1)
   \   000000C8   0x78B0             LDRB     R0,[R6, #+2]
   \   000000CA   0xB150             CBZ.N    R0,??USB_DeviceMscUfiThirteenCasesCheck_20
    246                  { /*case 10,Device intends to send data to the host*/
    247                      USB_DeviceStallEndpoint(mscHandle->handle, mscHandle->bulkOutEndpoint);
   \   000000CC   0x7AF9             LDRB     R1,[R7, #+11]
   \   000000CE   0x6820             LDR      R0,[R4, #+0]
   \   000000D0   0x.... 0x....      BL       USB_DeviceStallEndpoint
    248                      mscHandle->mscCsw.dataResidue = mscCheckEvent->hostExpectedDataLength;
   \   000000D4   0x69A8             LDR      R0,[R5, #+24]
   \   000000D6   0x6520             STR      R0,[R4, #+80]
    249                      mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_PHASE_ERROR;
   \   000000D8   0x2002             MOVS     R0,#+2
   \   000000DA   0x7028             STRB     R0,[R5, #+0]
    250                      mscHandle->outEndpointStallFlag = 1;
   \   000000DC   0x2001             MOVS     R0,#+1
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_19: (+1)
   \   000000DE   0x7038             STRB     R0,[R7, #+0]
   \   000000E0   0xE011             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_21
    251                      error = kStatus_USB_InvalidRequest;
    252                  }
    253                  else
    254                  {
    255                      if (mscCheckEvent->hostExpectedDataLength > mscCheckEvent->deviceExpectedDataLength)
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_20: (+1)
   \   000000E2   0x428B             CMP      R3,R1
   \   000000E4   0xD211             BCS.N    ??USB_DeviceMscUfiThirteenCasesCheck_22
    256                      { /*case 11, device intends to process less than the amount of data that the host indicated*/
    257                          mscHandle->mscCsw.dataResidue =
    258                              mscCheckEvent->hostExpectedDataLength - mscCheckEvent->deviceExpectedDataLength;
   \   000000E6   0x.... 0x....      BL       ?Subroutine5
    259          
    260                          if (ufi->thirteenCase.lbaSendRecvSelect == 1)
   \                     ??CrossCallReturnLabel_8: (+1)
   \   000000EA   0xD102             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_23
    261                          {
    262                              error = USB_DeviceMscLbaTransfer(mscHandle, USB_OUT, &mscCheckEvent->lbaInformation);
   \   000000EC   0x.... 0x....      BL       ?Subroutine8
    263                          }
   \                     ??CrossCallReturnLabel_18: (+1)
   \   000000F0   0xE001             B.N      ??CrossCallReturnLabel_6
    264                          else
    265                          {
    266                              error = USB_DeviceRecvRequest(mscHandle->handle, mscHandle->bulkOutEndpoint, mscCheckEvent->buffer,
    267                                                            mscCheckEvent->deviceExpectedDataLength);
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_23: (+1)
   \   000000F2   0x.... 0x....      BL       ?Subroutine4
    268                          }
    269          
    270                          if (kStatus_USB_Success == error)
   \                     ??CrossCallReturnLabel_6: (+1)
   \   000000F6   0xB908             CBNZ.N   R0,??USB_DeviceMscUfiThirteenCasesCheck_24
    271                          {
    272                              mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_PASSED;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_6: (+1)
   \   000000F8   0x7028             STRB     R0,[R5, #+0]
   \   000000FA   0xE004             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_21
    273                          }
    274                          else
    275                          {
    276                              mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_FAILED;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_24: (+1)
   \   000000FC   0x2001             MOVS     R0,#+1
   \   000000FE   0x7028             STRB     R0,[R5, #+0]
    277                              ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_MEDIUM_ERROR;
   \   00000100   0x2003             MOVS     R0,#+3
   \   00000102   0x71A8             STRB     R0,[R5, #+6]
    278                              ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_WRITE_FAULT;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_10: (+1)
   \   00000104   0x7428             STRB     R0,[R5, #+16]
    279                          }
    280                          error = kStatus_USB_InvalidRequest;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_21: (+1)
   \   00000106   0x2005             MOVS     R0,#+5
   \   00000108   0xBDF2             POP      {R1,R4-R7,PC}
    281                      }
    282                      else if (mscCheckEvent->hostExpectedDataLength == mscCheckEvent->deviceExpectedDataLength)
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_22: (+1)
   \   0000010A   0x6520             STR      R0,[R4, #+80]
   \   0000010C   0x4299             CMP      R1,R3
   \   0000010E   0x7830             LDRB     R0,[R6, #+0]
   \   00000110   0xD10B             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_25
    283                      { /*case 12,device intends to processequal to the amount of data that the host indicated*/
    284                          mscHandle->mscCsw.dataResidue = 0;
    285                          if (ufi->thirteenCase.lbaSendRecvSelect == 1)
   \   00000112   0x2801             CMP      R0,#+1
   \   00000114   0xD102             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_26
    286                          {
    287                              error = USB_DeviceMscLbaTransfer(mscHandle, USB_OUT, &mscCheckEvent->lbaInformation);
   \   00000116   0x.... 0x....      BL       ?Subroutine8
    288                          }
   \                     ??CrossCallReturnLabel_17: (+1)
   \   0000011A   0xE001             B.N      ??CrossCallReturnLabel_5
    289                          else
    290                          {
    291                              error = USB_DeviceRecvRequest(mscHandle->handle, mscHandle->bulkOutEndpoint, mscCheckEvent->buffer,
    292                                                            mscCheckEvent->deviceExpectedDataLength);
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_26: (+1)
   \   0000011C   0x.... 0x....      BL       ?Subroutine4
    293                          }
    294                          if (kStatus_USB_Success == error)
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000120   0x0001             MOVS     R1,R0
   \   00000122   0xD013             BEQ.N    ??USB_DeviceMscUfiThirteenCasesCheck_14
    295                          {
    296                              mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_PASSED;
    297                          }
    298                          else
    299                          {
    300                              mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_FAILED;
   \   00000124   0x2101             MOVS     R1,#+1
   \   00000126   0x7029             STRB     R1,[R5, #+0]
    301                              ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_MEDIUM_ERROR;
   \   00000128   0xE013             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_27
    302                              ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_WRITE_FAULT;
    303                          }
    304                      }
    305                      else
    306                      { /*case 13,device  intends to process more data than the host indicated*/
    307                          mscHandle->mscCsw.dataResidue = 0;
    308                          if (ufi->thirteenCase.lbaSendRecvSelect == 1)
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_25: (+1)
   \   0000012A   0x2801             CMP      R0,#+1
   \   0000012C   0xD104             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_28
    309                          {
    310                              mscCheckEvent->lbaInformation.transferNumber =
    311                                  mscCheckEvent->hostExpectedDataLength / mscHandle->lengthOfEachLba;
   \   0000012E   0x.... 0x....      BL       ?Subroutine10
    312                              mscHandle->mscCsw.dataResidue =
    313                                  mscCheckEvent->hostExpectedDataLength -
    314                                  mscCheckEvent->lbaInformation.transferNumber * mscHandle->lengthOfEachLba;
    315                              error = USB_DeviceMscLbaTransfer(mscHandle, USB_OUT, &mscCheckEvent->lbaInformation);
   \                     ??CrossCallReturnLabel_22: (+1)
   \   00000132   0x.... 0x....      BL       ?Subroutine8
    316                          }
   \                     ??CrossCallReturnLabel_16: (+1)
   \   00000136   0xE002             B.N      ??CrossCallReturnLabel_4
    317                          else
    318                          {
    319                              error = USB_DeviceRecvRequest(mscHandle->handle, mscHandle->bulkOutEndpoint, mscCheckEvent->buffer,
    320                                                            mscCheckEvent->hostExpectedDataLength);
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_28: (+1)
   \   00000138   0x460B             MOV      R3,R1
   \   0000013A   0x.... 0x....      BL       ?Subroutine4
    321                          }
    322          
    323                          if (kStatus_USB_Success == error)
   \                     ??CrossCallReturnLabel_4: (+1)
   \   0000013E   0x0001             MOVS     R1,R0
   \   00000140   0xD107             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_27
    324                          {
    325                              if (ufi->thirteenCase.lbaSendRecvSelect == 1)
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_16: (+1)
   \   00000142   0x7831             LDRB     R1,[R6, #+0]
   \   00000144   0x2901             CMP      R1,#+1
   \   00000146   0xBF08             IT       EQ 
   \   00000148   0x2102             MOVEQ    R1,#+2
    326                              {
    327                                  mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_PHASE_ERROR;
   \   0000014A   0xD000             BEQ.N    ??USB_DeviceMscUfiThirteenCasesCheck_2
    328                              }
    329                              else
    330                              {
    331                                  mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_PASSED;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_14: (+1)
   \   0000014C   0x2100             MOVS     R1,#+0
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_2: (+1)
   \   0000014E   0x7029             STRB     R1,[R5, #+0]
   \   00000150   0xBDF2             POP      {R1,R4-R7,PC}
    332                              }
    333                          }
    334                          else
    335                          {
    336                              ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_MEDIUM_ERROR;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_27: (+1)
   \   00000152   0x2103             MOVS     R1,#+3
   \   00000154   0x71A9             STRB     R1,[R5, #+6]
    337                              ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_WRITE_FAULT;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_17: (+1)
   \   00000156   0x7429             STRB     R1,[R5, #+16]
    338                          }
    339                      }
    340                  }
    341              }
    342              return error;
   \   00000158   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    343          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \   00000000   0x69A0             LDR      R0,[R4, #+24]
   \   00000002   0xFBB1 0xF2F0      UDIV     R2,R1,R0
   \   00000006   0x62AA             STR      R2,[R5, #+40]
   \   00000008   0xFB00 0x1012      MLS      R0,R0,R2,R1
   \   0000000C   0x6520             STR      R0,[R4, #+80]
   \   0000000E   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \   00000000   0xF104 0x0278      ADD      R2,R4,#+120
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      B.W      USB_DeviceMscLbaTransfer

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0xF104 0x0278      ADD      R2,R4,#+120
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      B.W      USB_DeviceMscLbaTransfer

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x1AC8             SUBS     R0,R1,R3
   \                     ??Subroutine5_0: (+1)
   \   00000002   0x6520             STR      R0,[R4, #+80]
   \   00000004   0x7830             LDRB     R0,[R6, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x6A2A             LDR      R2,[R5, #+32]
   \   00000002   0x7AF9             LDRB     R1,[R7, #+11]
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x.... 0x....      B.W      USB_DeviceRecvRequest

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x6A2A             LDR      R2,[R5, #+32]
   \   00000002   0x7AB9             LDRB     R1,[R7, #+10]
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x.... 0x....      B.W      USB_DeviceSendRequest
    344          
    345          /*!
    346           * @brief request sense command.
    347           *
    348           * The REQUEST SENSE command instructs the UFI device to transfer sense data to the host for the specified  logical
    349           *unit.
    350           *
    351           * @param handle          The device msc class hanlde.
    352           *
    353           *@return A USB error code or kStatus_USB_Success.
    354           */

   \                                 In section .text, align 2, keep-with-next
    355          usb_status_t USB_DeviceMscUfiRequestSenseCommand(usb_device_msc_struct_t *mscHandle)
    356          {
    357              usb_device_msc_ufi_struct_t *ufi = NULL;
    358              usb_status_t error;
    359          
    360              ufi = &mscHandle->mscUfi;
    361              ufi->thirteenCase.deviceExpectedDataLength = USB_DEVICE_MSC_UFI_REQ_SENSE_DATA_LENGTH;
   \                     USB_DeviceMscUfiRequestSenseCommand: (+1)
   \   00000000   0xF100 0x0170      ADD      R1,R0,#+112
   \   00000004   0x2212             MOVS     R2,#+18
   \   00000006   0x600A             STR      R2,[R1, #+0]
    362              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0x748A             STRB     R2,[R1, #+18]
    363              ufi->thirteenCase.buffer = (uint8_t *)&ufi->requestSense;
   \   0000000C   0xF100 0x0258      ADD      R2,R0,#+88
   \   00000010   0x604A             STR      R2,[R1, #+4]
    364              ufi->thirteenCase.lbaSendRecvSelect = 0;
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x....             B.N      ??Subroutine13_0
    365              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
    366          
    367              return error;
    368          }

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine13_0: (+1)
   \   00000000   0x740A             STRB     R2,[R1, #+16]
   \   00000002   0x....             B.N      USB_DeviceMscUfiThirteenCasesCheck
    369          
    370          /*!
    371           * @brief inquiry command.
    372           *
    373           * The INQUIRY command requests that information regarding parameters of the UFI device itself be sent to the host.
    374           *
    375           * @param handle          The device msc class hanlde.
    376           *
    377           *@return A USB error code or kStatus_USB_Success.
    378          */

   \                                 In section .text, align 2, keep-with-next
    379          usb_status_t USB_DeviceMscUfiInquiryCommand(usb_device_msc_struct_t *mscHandle)
    380          {
   \                     USB_DeviceMscUfiInquiryCommand: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    381              usb_device_msc_ufi_struct_t *ufi = NULL;
    382              usb_status_t error;
    383              uint8_t i;
    384              uint32_t temp;
    385              
    386              ufi = &mscHandle->mscUfi;
    387          
    388              temp = (uint32_t)&g_InquiryInfoConst;
    389              uint8_t * ptr = (uint8_t *)temp;
    390              uint8_t * pointer = (uint8_t *)&ufi->InquiryInfo;
    391              for (i = 0; i < sizeof(usb_device_inquiry_data_fromat_struct_t); i++)
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      ADR.W    R2,g_InquiryInfoConst
    392              {
    393                  pointer[i] =  ptr[i];    
   \                     ??USB_DeviceMscUfiInquiryCommand_0: (+1)
   \   00000008   0x5C53             LDRB     R3,[R2, R1]
   \   0000000A   0x1844             ADDS     R4,R0,R1
    394          
    395              }
   \   0000000C   0x1C49             ADDS     R1,R1,#+1
   \   0000000E   0x2924             CMP      R1,#+36
   \   00000010   0xF884 0x3098      STRB     R3,[R4, #+152]
   \   00000014   0xD3F8             BCC.N    ??USB_DeviceMscUfiInquiryCommand_0
    396              ufi->thirteenCase.deviceExpectedDataLength = USB_DEVICE_MSC_UFI_INQUIRY_ALLOCATION_LENGTH;
   \   00000016   0xF100 0x0170      ADD      R1,R0,#+112
   \   0000001A   0x2224             MOVS     R2,#+36
   \   0000001C   0x600A             STR      R2,[R1, #+0]
    397              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x748A             STRB     R2,[R1, #+18]
    398              ufi->thirteenCase.buffer = (uint8_t *)&ufi->InquiryInfo;
   \   00000022   0xF100 0x0298      ADD      R2,R0,#+152
   \   00000026   0x....             B.N      ?Subroutine1
    399              ufi->thirteenCase.lbaSendRecvSelect = 0;
    400          
    401              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
    402              return error;
    403          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x604A             STR      R2,[R1, #+4]
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x740A             STRB     R2,[R1, #+16]
   \   00000006   0xE8BD 0x4010      POP      {R4,LR}
   \   0000000A   0x....             B.N      USB_DeviceMscUfiThirteenCasesCheck
    404          
    405          /*!
    406           * @brief read command.
    407           *
    408           * The READ(10),READ(12) command requests that the UFI device transfer data to the host.
    409           *
    410           * @param handle          The device msc class hanlde.
    411           *
    412           *@return A USB error code or kStatus_USB_Success.
    413          */

   \                                 In section .text, align 2, keep-with-next
    414          usb_status_t USB_DeviceMscUfiReadCommand(usb_device_msc_struct_t *mscHandle)
    415          {
    416              usb_device_msc_ufi_struct_t *ufi = NULL;
    417              usb_status_t error;
    418              uint32_t logicalBlockAddress = 0;
    419              uint32_t lbaTransferLength = 0;
    420          
    421              ufi = &mscHandle->mscUfi;
    422          
    423              logicalBlockAddress = ((uint32_t)mscHandle->mscCbw.cbwcb[2] << 24);
    424              logicalBlockAddress |= ((uint32_t)mscHandle->mscCbw.cbwcb[3] << 16);
    425              logicalBlockAddress |= ((uint32_t)mscHandle->mscCbw.cbwcb[4] << 8);
    426              logicalBlockAddress |= ((uint32_t)mscHandle->mscCbw.cbwcb[5]);
   \                     USB_DeviceMscUfiReadCommand: (+1)
   \   00000000   0xF100 0x0139      ADD      R1,R0,#+57
   \   00000004   0xB538             PUSH     {R3-R5,LR}
   \   00000006   0x.... 0x....      BL       ?Subroutine11
    427          
    428              if (mscHandle->mscCbw.cbwcb[0] == USB_DEVICE_MSC_READ_10_COMMAND)
   \                     ??CrossCallReturnLabel_23: (+1)
   \   0000000A   0x2D28             CMP      R5,#+40
   \   0000000C   0xD104             BNE.N    ??USB_DeviceMscUfiReadCommand_0
    429              {
    430                  lbaTransferLength = (uint16_t)((uint16_t)mscHandle->mscCbw.cbwcb[7] << 8);
    431                  lbaTransferLength |= (uint16_t)mscHandle->mscCbw.cbwcb[8];
   \   0000000E   0x794C             LDRB     R4,[R1, #+5]
   \   00000010   0x7989             LDRB     R1,[R1, #+6]
   \   00000012   0xEA41 0x2404      ORR      R4,R1,R4, LSL #+8
   \   00000016   0xE002             B.N      ??CrossCallReturnLabel_11
    432              }
    433              else if (mscHandle->mscCbw.cbwcb[0] == USB_DEVICE_MSC_READ_12_COMMAND)
   \                     ??USB_DeviceMscUfiReadCommand_0: (+1)
   \   00000018   0x2DA8             CMP      R5,#+168
   \   0000001A   0x.... 0x....      BL       ?Subroutine6
    434              {
    435                  lbaTransferLength = ((uint32_t)mscHandle->mscCbw.cbwcb[6] << 24);
    436                  lbaTransferLength |= ((uint32_t)mscHandle->mscCbw.cbwcb[7] << 16);
    437                  lbaTransferLength |= ((uint32_t)mscHandle->mscCbw.cbwcb[8] << 8);
    438                  lbaTransferLength |= ((uint32_t)mscHandle->mscCbw.cbwcb[9]);
    439              }
    440              else
    441              {
    442              
    443              }
    444          
    445              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
   \                     ??CrossCallReturnLabel_11: (+1)
   \   0000001E   0xF100 0x0170      ADD      R1,R0,#+112
   \   00000022   0x2501             MOVS     R5,#+1
   \   00000024   0x748D             STRB     R5,[R1, #+18]
    446              ufi->thirteenCase.deviceExpectedDataLength = mscHandle->lengthOfEachLba * lbaTransferLength;
   \   00000026   0x681B             LDR      R3,[R3, #+0]
    447              ufi->thirteenCase.buffer = NULL;
    448          
    449              ufi->thirteenCase.lbaSendRecvSelect = 1;
   \   00000028   0x740D             STRB     R5,[R1, #+16]
   \   0000002A   0x4363             MULS     R3,R4,R3
   \   0000002C   0x600B             STR      R3,[R1, #+0]
    450              ufi->thirteenCase.lbaInformation.startingLogicalBlockAddress = logicalBlockAddress;
    451              ufi->thirteenCase.lbaInformation.transferNumber = lbaTransferLength;
   \   0000002E   0x60CC             STR      R4,[R1, #+12]
   \   00000030   0x2300             MOVS     R3,#+0
   \   00000032   0x604B             STR      R3,[R1, #+4]
   \   00000034   0x....             B.N      ?Subroutine2
    452          
    453              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
    454              return error;
    455          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x608A             STR      R2,[R1, #+8]
   \   00000002   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000006   0x....             B.N      USB_DeviceMscUfiThirteenCasesCheck

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \   00000000   0x784B             LDRB     R3,[R1, #+1]
   \   00000002   0x780A             LDRB     R2,[R1, #+0]
   \   00000004   0x041B             LSLS     R3,R3,#+16
   \   00000006   0xEA43 0x6202      ORR      R2,R3,R2, LSL #+24
   \   0000000A   0x788B             LDRB     R3,[R1, #+2]
   \   0000000C   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   00000010   0x78CB             LDRB     R3,[R1, #+3]
   \   00000012   0x431A             ORRS     R2,R3,R2
   \   00000014   0xF100 0x0318      ADD      R3,R0,#+24
   \   00000018   0x2400             MOVS     R4,#+0
   \   0000001A   0x7FDD             LDRB     R5,[R3, #+31]
   \   0000001C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0xD109             BNE.N    ??Subroutine6_0
   \   00000002   0x794D             LDRB     R5,[R1, #+5]
   \   00000004   0x790C             LDRB     R4,[R1, #+4]
   \   00000006   0x042D             LSLS     R5,R5,#+16
   \   00000008   0xEA45 0x6404      ORR      R4,R5,R4, LSL #+24
   \   0000000C   0x798D             LDRB     R5,[R1, #+6]
   \   0000000E   0x79C9             LDRB     R1,[R1, #+7]
   \   00000010   0xEA44 0x2405      ORR      R4,R4,R5, LSL #+8
   \   00000014   0x430C             ORRS     R4,R1,R4
   \                     ??Subroutine6_0: (+1)
   \   00000016   0x4770             BX       LR
    456          
    457          /*!
    458           * @brief write command.
    459           *
    460           * The WRITE(10),WRITE(12) command requests that the UFI device write the data transferred by the host to the medium.
    461           *
    462           * @param handle          The device msc class hanlde.
    463           *
    464           *@return A USB error code or kStatus_USB_Success.
    465          */

   \                                 In section .text, align 2, keep-with-next
    466          usb_status_t USB_DeviceMscUfiWriteCommand(usb_device_msc_struct_t *mscHandle)
    467          {
    468              usb_device_msc_ufi_struct_t *ufi = NULL;
    469              usb_status_t error;
    470              uint32_t logicalBlockAddress = 0;
    471              uint32_t lbaTransferLength = 0;
    472          
    473              ufi = &mscHandle->mscUfi;
    474          
    475              logicalBlockAddress = ((uint32_t)mscHandle->mscCbw.cbwcb[2] << 24);
    476              logicalBlockAddress |= ((uint32_t)mscHandle->mscCbw.cbwcb[3] << 16);
    477              logicalBlockAddress |= ((uint32_t)mscHandle->mscCbw.cbwcb[4] << 8);
    478              logicalBlockAddress |= ((uint32_t)mscHandle->mscCbw.cbwcb[5]);
   \                     USB_DeviceMscUfiWriteCommand: (+1)
   \   00000000   0xF100 0x0139      ADD      R1,R0,#+57
   \   00000004   0xB538             PUSH     {R3-R5,LR}
   \   00000006   0x.... 0x....      BL       ?Subroutine11
    479          
    480              if (mscHandle->mscCbw.cbwcb[0] == USB_DEVICE_MSC_WRITE_10_COMMAND)
   \                     ??CrossCallReturnLabel_24: (+1)
   \   0000000A   0x2D2A             CMP      R5,#+42
   \   0000000C   0xD104             BNE.N    ??USB_DeviceMscUfiWriteCommand_0
    481              {
    482                  lbaTransferLength = (uint16_t)((uint16_t)mscHandle->mscCbw.cbwcb[7] << 8);
    483                  lbaTransferLength |= (uint16_t)mscHandle->mscCbw.cbwcb[8];
   \   0000000E   0x794C             LDRB     R4,[R1, #+5]
   \   00000010   0x7989             LDRB     R1,[R1, #+6]
   \   00000012   0xEA41 0x2404      ORR      R4,R1,R4, LSL #+8
   \   00000016   0xE002             B.N      ??CrossCallReturnLabel_12
    484              }
    485              else if (mscHandle->mscCbw.cbwcb[0] == USB_DEVICE_MSC_WRITE_12_COMMAND)
   \                     ??USB_DeviceMscUfiWriteCommand_0: (+1)
   \   00000018   0x2DAA             CMP      R5,#+170
   \   0000001A   0x.... 0x....      BL       ?Subroutine6
    486              {
    487                  lbaTransferLength = ((uint32_t)mscHandle->mscCbw.cbwcb[6] << 24);
    488                  lbaTransferLength |= ((uint32_t)mscHandle->mscCbw.cbwcb[7] << 16);
    489                  lbaTransferLength |= ((uint32_t)mscHandle->mscCbw.cbwcb[8] << 8);
    490                  lbaTransferLength |= ((uint32_t)mscHandle->mscCbw.cbwcb[9]);
    491              }
    492              else
    493              {
    494              }
    495              ufi->thirteenCase.deviceExpectedDirection = USB_OUT;
   \                     ??CrossCallReturnLabel_12: (+1)
   \   0000001E   0xF100 0x0170      ADD      R1,R0,#+112
   \   00000022   0x2500             MOVS     R5,#+0
   \   00000024   0x748D             STRB     R5,[R1, #+18]
    496              ufi->thirteenCase.deviceExpectedDataLength = mscHandle->lengthOfEachLba * lbaTransferLength;
   \   00000026   0x681B             LDR      R3,[R3, #+0]
    497              ufi->thirteenCase.buffer = NULL;
   \   00000028   0x604D             STR      R5,[R1, #+4]
   \   0000002A   0x4363             MULS     R3,R4,R3
   \   0000002C   0x600B             STR      R3,[R1, #+0]
    498          
    499              ufi->thirteenCase.lbaSendRecvSelect = 1;
    500              ufi->thirteenCase.lbaInformation.startingLogicalBlockAddress = logicalBlockAddress;
    501              ufi->thirteenCase.lbaInformation.transferNumber = lbaTransferLength;
   \   0000002E   0x60CC             STR      R4,[R1, #+12]
   \   00000030   0x2301             MOVS     R3,#+1
   \   00000032   0x740B             STRB     R3,[R1, #+16]
   \   00000034                      REQUIRE ?Subroutine2
   \   00000034                      ;; // Fall through to label ?Subroutine2
    502          
    503              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
    504              return error;
    505          }
    506          
    507          /*!
    508           * @brief test unit ready command.
    509           *
    510           * The TEST UNIT READY command provides a means to check if the UFI device is ready.
    511           *
    512           * @param handle          The device msc class hanlde.
    513           *
    514           *@return A USB error code or kStatus_USB_Success.
    515          */

   \                                 In section .text, align 2, keep-with-next
    516          usb_status_t USB_DeviceMscUfiTestUnitReadyCommand(usb_device_msc_struct_t *mscHandle)
    517          {
    518              usb_device_msc_ufi_struct_t *ufi = NULL;
    519              usb_status_t error;
    520          
    521              ufi = &mscHandle->mscUfi;
    522          
    523              ufi->thirteenCase.deviceExpectedDataLength = 0;
   \                     USB_DeviceMscUfiTestUnitReadyCommand: (+1)
   \   00000000   0x....             B.N      ?Subroutine0
    524              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
    525              ufi->thirteenCase.buffer = NULL;
    526              ufi->thirteenCase.lbaSendRecvSelect = 0;
    527          
    528              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
    529              return error;
    530          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xF100 0x0170      ADD      R1,R0,#+112
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x600A             STR      R2,[R1, #+0]
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0x748A             STRB     R2,[R1, #+18]
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x604A             STR      R2,[R1, #+4]
   \   00000010                      REQUIRE ??Subroutine13_0
   \   00000010                      ;; // Fall through to label ??Subroutine13_0
    531          
    532          /*!
    533           * @brief verify command.
    534           *
    535           * The VERIFY command requests that the UFI device verify the data on the medium.
    536           *
    537           * @param handle          The device msc class hanlde.
    538           *
    539           *@return A USB error code or kStatus_USB_Success.
    540          */

   \                                 In section .text, align 2, keep-with-next
    541          usb_status_t USB_DeviceMscUfiVerifyCommand(usb_device_msc_struct_t *mscHandle)
   \                     USB_DeviceMscUfiVerifyCommand: (+1)
   \   00000000   0xBF00             Nop      
    542          {
    543              usb_device_msc_ufi_struct_t *ufi = NULL;
    544              usb_status_t error;
    545          
    546              ufi = &mscHandle->mscUfi;
    547          
    548              ufi->thirteenCase.deviceExpectedDataLength = 0;
   \   00000002                      REQUIRE ?Subroutine0
   \   00000002                      ;; // Fall through to label ?Subroutine0
    549              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
    550              ufi->thirteenCase.buffer = NULL;
    551              ufi->thirteenCase.lbaSendRecvSelect = 0;
    552          
    553              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
    554              return error;
    555          }
    556          
    557          /*!
    558           * @brief mode sense command.
    559           *
    560           * The MODE SENSE command allows the UFI device to report medium or device parameters to the host.
    561           *
    562           * @param handle          The device msc class hanlde.
    563           *
    564           *@return A USB error code or kStatus_USB_Success.
    565          */

   \                                 In section .text, align 2, keep-with-next
    566          usb_status_t USB_DeviceMscUfiModeSenseCommand(usb_device_msc_struct_t *mscHandle)
    567          {
   \                     USB_DeviceMscUfiModeSenseCommand: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    568              usb_device_msc_ufi_struct_t *ufi = NULL;
    569              usb_status_t error;
    570              uint8_t i;
    571              uint32_t temp;
    572              
    573              ufi = &mscHandle->mscUfi;
    574          
    575              temp = (uint32_t)&g_ModeParametersHeaderConst;
    576              uint8_t * ptr = (uint8_t *)temp;
    577              uint8_t * pointer = (uint8_t *)&ufi->ModeParametersHeader;
    578              for (i = 0; i < sizeof(usb_device_mode_parameters_header_struct_t); i++)
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      ADR.W    R2,g_ModeParametersHeaderConst
    579              {
    580                  pointer[i] =  ptr[i];    
   \                     ??USB_DeviceMscUfiModeSenseCommand_0: (+1)
   \   00000008   0x5C53             LDRB     R3,[R2, R1]
   \   0000000A   0x1844             ADDS     R4,R0,R1
    581          
    582              }
   \   0000000C   0x1C49             ADDS     R1,R1,#+1
   \   0000000E   0x2908             CMP      R1,#+8
   \   00000010   0xF884 0x30BC      STRB     R3,[R4, #+188]
   \   00000014   0xD3F8             BCC.N    ??USB_DeviceMscUfiModeSenseCommand_0
    583              ufi->thirteenCase.deviceExpectedDataLength = sizeof(g_ModeParametersHeaderConst);
   \   00000016   0xF100 0x0170      ADD      R1,R0,#+112
   \   0000001A   0x2208             MOVS     R2,#+8
   \   0000001C   0x600A             STR      R2,[R1, #+0]
    584              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x748A             STRB     R2,[R1, #+18]
    585              ufi->thirteenCase.buffer = (uint8_t *)&ufi->ModeParametersHeader;
   \   00000022   0xF100 0x02BC      ADD      R2,R0,#+188
   \   00000026                      REQUIRE ?Subroutine1
   \   00000026                      ;; // Fall through to label ?Subroutine1
    586              ufi->thirteenCase.lbaSendRecvSelect = 0;
    587          
    588              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
    589              return error;
    590          }
    591          
    592          /*!
    593           * @brief mode select command.
    594           *
    595           * The MODE SELECT command allows the host to specify medium or device parameters to the UFI device.
    596           *
    597           * @param handle          The device msc class hanlde.
    598           *
    599           *@return A USB error code or kStatus_USB_Success.
    600          */

   \                                 In section .text, align 2, keep-with-next
    601          usb_status_t USB_DeviceMscUfiModeSelectCommand(usb_device_msc_struct_t *mscHandle)
    602          {
   \                     USB_DeviceMscUfiModeSelectCommand: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    603              usb_device_msc_ufi_struct_t *ufi = NULL;
    604              usb_status_t error = kStatus_USB_TransferFailed;
    605              uint8_t i;
    606              uint32_t temp;
    607              
    608              ufi = &mscHandle->mscUfi;
    609          
    610              temp = (uint32_t)&g_ModeParametersHeaderConst;
    611              uint8_t * ptr = (uint8_t *)temp;
    612              uint8_t * pointer = (uint8_t *)&ufi->ModeParametersHeader;
    613              for (i = 0; i < sizeof(usb_device_mode_parameters_header_struct_t); i++)
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      ADR.W    R1,g_ModeParametersHeaderConst
    614              {
    615                  pointer[i] =  ptr[i];    
   \                     ??USB_DeviceMscUfiModeSelectCommand_0: (+1)
   \   0000000A   0x5C0A             LDRB     R2,[R1, R0]
   \   0000000C   0x1823             ADDS     R3,R4,R0
    616          
    617              }
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xF883 0x20BC      STRB     R2,[R3, #+188]
   \   00000016   0xD3F8             BCC.N    ??USB_DeviceMscUfiModeSelectCommand_0
    618          
    619              ufi->thirteenCase.deviceExpectedDataLength = sizeof(g_ModeParametersHeaderConst);
   \   00000018   0xF104 0x0070      ADD      R0,R4,#+112
   \   0000001C   0x2108             MOVS     R1,#+8
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    620              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x7481             STRB     R1,[R0, #+18]
    621              ufi->thirteenCase.buffer = (uint8_t *)&ufi->ModeParametersHeader;
   \   00000024   0xF104 0x01BC      ADD      R1,R4,#+188
   \   00000028   0x6041             STR      R1,[R0, #+4]
    622              ufi->thirteenCase.lbaSendRecvSelect = 0;
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x7401             STRB     R1,[R0, #+16]
    623          
    624              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       USB_DeviceMscUfiThirteenCasesCheck
    625          
    626              if (mscHandle->mscCbw.cbwcb[1] & 0x01)
   \   00000034   0xF894 0x1038      LDRB     R1,[R4, #+56]
   \   00000038   0x07C9             LSLS     R1,R1,#+31
   \   0000003A   0xD501             BPL.N    ??CrossCallReturnLabel_25
    627              {
    628                  ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_ILLEGAL_REQUEST;
   \   0000003C   0x.... 0x....      BL       ?Subroutine12
    629                  ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_INVALID_FIELD_IN_COMMAND_PKT;
    630              }
    631              return error;
   \                     ??CrossCallReturnLabel_25: (+1)
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    632          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \   00000000   0xF104 0x015A      ADD      R1,R4,#+90
   \   00000004   0x2205             MOVS     R2,#+5
   \   00000006   0x700A             STRB     R2,[R1, #+0]
   \   00000008   0x2224             MOVS     R2,#+36
   \   0000000A   0x728A             STRB     R2,[R1, #+10]
   \   0000000C   0x4770             BX       LR
    633          
    634          /*!
    635           * @brief read capacity command.
    636           *
    637           * The READ CAPACITIY command allows the host to request capacities of the currently installed medium.
    638           *
    639           * @param handle          The device msc class hanlde.
    640           *
    641           *@return A USB error code or kStatus_USB_Success.
    642          */

   \                                 In section .text, align 2, keep-with-next
    643          usb_status_t USB_DeviceMscUfiReadCapacityCommand(usb_device_msc_struct_t *mscHandle)
    644          {
    645              usb_device_msc_ufi_struct_t *ufi = NULL;
    646              usb_status_t error = kStatus_USB_TransferFailed;
    647          
    648              ufi = &mscHandle->mscUfi;
    649          
    650              if (mscHandle->mscCbw.cbwcb[0] == USB_DEVICE_MSC_READ_CAPACITY_10_COMMAND)
   \                     USB_DeviceMscUfiReadCapacityCommand: (+1)
   \   00000000   0xF890 0x1037      LDRB     R1,[R0, #+55]
   \   00000004   0x2925             CMP      R1,#+37
    651              {
    652                  ufi->thirteenCase.deviceExpectedDataLength = USB_DEVICE_MSC_UFI_READ_CAPACITY_DATA_LENGTH;
    653                  ufi->thirteenCase.buffer = (uint8_t *)&(ufi->readCapacity);
    654              }
    655              else
    656              {
    657                  ufi->thirteenCase.deviceExpectedDataLength = USB_DEVICE_MSC_UFI_READ_CAPACITY16_DATA_LENGTH;
    658                  ufi->thirteenCase.buffer = (uint8_t *)&(ufi->readCapacity16);
   \   00000006   0xF100 0x0370      ADD      R3,R0,#+112
   \   0000000A   0xBF07             ITTEE    EQ 
   \   0000000C   0x2108             MOVEQ    R1,#+8
   \   0000000E   0xF100 0x0284      ADDEQ    R2,R0,#+132
   \   00000012   0x210C             MOVNE    R1,#+12
   \   00000014   0xF100 0x028C      ADDNE    R2,R0,#+140
   \   00000018   0x6019             STR      R1,[R3, #+0]
   \   0000001A   0x605A             STR      R2,[R3, #+4]
    659              }
    660              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x7499             STRB     R1,[R3, #+18]
    661              ufi->thirteenCase.lbaSendRecvSelect = 0;
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x7419             STRB     R1,[R3, #+16]
    662          
    663              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
    664              return error;
   \   00000024   0x....             B.N      USB_DeviceMscUfiThirteenCasesCheck
    665          }
    666          
    667          /*!
    668           * @brief read format capacity command.
    669           *
    670           * The READ FORMAT CAPACITIES command allows the host to request a list of the possible capacities that
    671          * can be formatted on the currently installed medium.
    672           *
    673           * @param handle          The device msc class hanlde.
    674           *
    675           *@return A USB error code or kStatus_USB_Success.
    676          */

   \                                 In section .text, align 2, keep-with-next
    677          usb_status_t USB_DeviceMscUfiReadFormatCapacityCommand(usb_device_msc_struct_t *mscHandle)
    678          {
   \                     USB_DeviceMscUfiReadFormatCapacityCommand: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    679              usb_device_msc_ufi_struct_t *ufi = NULL;
    680              usb_status_t error = kStatus_USB_TransferFailed;
    681              usb_device_current_max_capacity_descriptor_struct_t current_max_head;
    682              usb_device_formattable_capacity_descriptor_struct_t formattable_capacity_head;
    683              usb_device_capacity_list_header_struct_t capacityListHead = {{0x00, 0x00, 0x00}, 0x00};
   \   00000002   0x.... 0x....      ADR.W    R1,?_0
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0xB085             SUB      SP,SP,#+20
    684              uint32_t response_size;
    685              uint16_t allocation_length;
    686              uint8_t num_formattable_cap_desc;
    687              uint8_t descriptor_code;
    688              uint8_t count = 0;
    689              uint8_t i = 0;
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x9100             STR      R1,[SP, #+0]
    690              uint8_t j = 0;
    691              uint8_t *ptr;
    692          
    693              ufi = &mscHandle->mscUfi;
    694              allocation_length = (uint16_t)((uint8_t)(mscHandle->mscCbw.cbwcb[7] << 8) | mscHandle->mscCbw.cbwcb[8]);
   \   0000000E   0xF890 0x403F      LDRB     R4,[R0, #+63]
    695              /*referance ufi command spec table-33 Descriptor Code definition*/
    696              num_formattable_cap_desc = (uint8_t)(ufi->formattedDisk ? (mscHandle->implementingDiskDrive ? 0x02 : 0x03) : 0x00);
   \   00000012   0xF890 0x50C4      LDRB     R5,[R0, #+196]
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0xF100 0x0614      ADD      R6,R0,#+20
   \   0000001E   0xB125             CBZ.N    R5,??USB_DeviceMscUfiReadFormatCapacityCommand_0
   \   00000020   0x68B5             LDR      R5,[R6, #+8]
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xBF14             ITE      NE 
   \   00000026   0x2502             MOVNE    R5,#+2
   \   00000028   0x2503             MOVEQ    R5,#+3
    697          
    698              formattable_capacity_head.blockNumber = mscHandle->totalLogicalBlockNumber;
   \                     ??USB_DeviceMscUfiReadFormatCapacityCommand_0: (+1)
   \   0000002A   0x6837             LDR      R7,[R6, #+0]
   \   0000002C   0x9701             STR      R7,[SP, #+4]
    699              formattable_capacity_head.blockLength = mscHandle->lengthOfEachLba;
    700          
    701              descriptor_code =
    702                  (uint8_t)(ufi->formattedDisk ? USB_DEVICE_MSC_UFI_FORMATTED_MEDIA : USB_DEVICE_MSC_UFI_UNFORMATTED_MEDIA);
    703              capacityListHead.capacityListLength = num_formattable_cap_desc * 8;
   \   0000002E   0xEA4F 0x0EC5      LSL      LR,R5,#+3
   \   00000032   0x6876             LDR      R6,[R6, #+4]
   \   00000034   0x9602             STR      R6,[SP, #+8]
    704              current_max_head.blockNumber = mscHandle->totalLogicalBlockNumber;
    705              current_max_head.descriptorCodeBlockLength = (uint8_t)(descriptor_code << 24) | mscHandle->lengthOfEachLba;
   \   00000036   0x9604             STR      R6,[SP, #+16]
   \   00000038   0xF88D 0xE003      STRB     LR,[SP, #+3]
    706          
    707              response_size = sizeof(usb_device_capacity_list_header_struct_t) +
    708                              sizeof(usb_device_current_max_capacity_descriptor_struct_t) +
    709                              sizeof(usb_device_formattable_capacity_descriptor_struct_t) * num_formattable_cap_desc;
   \   0000003C   0x00EE             LSLS     R6,R5,#+3
   \   0000003E   0x360C             ADDS     R6,R6,#+12
    710          
    711              if (response_size > allocation_length)
   \   00000040   0x42B4             CMP      R4,R6
   \   00000042   0x9703             STR      R7,[SP, #+12]
   \   00000044   0xBF88             IT       HI 
   \   00000046   0x4634             MOVHI    R4,R6
    712              {
    713                  response_size = allocation_length;
    714              }
    715              if (sizeof(ufi->formatCapacityData) < response_size)
    716              {
    717          #if (defined(_DEBUG) && _DEBUG)
    718                  usb_echo("format_capacity_response_data buff size less than need\n");
    719          #endif
    720              }
    721          
    722              ptr = (uint8_t *)&capacityListHead;
    723              for (count = 0; count < sizeof(capacityListHead); count++)
    724              {
    725                  ufi->formatCapacityData[count] = ptr[i++];
   \                     ??USB_DeviceMscUfiReadFormatCapacityCommand_1: (+1)
   \   00000048   0xB2D2             UXTB     R2,R2
   \   0000004A   0x1847             ADDS     R7,R0,R1
   \   0000004C   0xF81D 0x6002      LDRB     R6,[SP, R2]
   \   00000050   0x1C52             ADDS     R2,R2,#+1
    726              }
   \   00000052   0x1C49             ADDS     R1,R1,#+1
   \   00000054   0x2904             CMP      R1,#+4
   \   00000056   0xF887 0x60C5      STRB     R6,[R7, #+197]
   \   0000005A   0xD3F5             BCC.N    ??USB_DeviceMscUfiReadFormatCapacityCommand_1
    727              ptr = (uint8_t *)&current_max_head;
    728              i = 0;
   \   0000005C   0x2200             MOVS     R2,#+0
    729              for (; i < sizeof(current_max_head); count++)
    730              {
    731                  ufi->formatCapacityData[count] = ptr[i++];
   \                     ??USB_DeviceMscUfiReadFormatCapacityCommand_2: (+1)
   \   0000005E   0xAE03             ADD      R6,SP,#+12
   \   00000060   0xB2C9             UXTB     R1,R1
   \   00000062   0x5CB6             LDRB     R6,[R6, R2]
   \   00000064   0x1847             ADDS     R7,R0,R1
   \   00000066   0x1C52             ADDS     R2,R2,#+1
    732              }
   \   00000068   0x1C49             ADDS     R1,R1,#+1
   \   0000006A   0x2A08             CMP      R2,#+8
   \   0000006C   0xF887 0x60C5      STRB     R6,[R7, #+197]
   \   00000070   0xD3F5             BCC.N    ??USB_DeviceMscUfiReadFormatCapacityCommand_2
    733          
    734              if (ufi->formattedDisk)
   \   00000072   0xF890 0x20C4      LDRB     R2,[R0, #+196]
   \   00000076   0xB182             CBZ.N    R2,??USB_DeviceMscUfiReadFormatCapacityCommand_3
    735              {
    736                  for (i = 0; i < num_formattable_cap_desc; i++)
   \   00000078   0x2200             MOVS     R2,#+0
   \   0000007A   0xE00B             B.N      ??USB_DeviceMscUfiReadFormatCapacityCommand_4
    737                  {
    738                      ptr = (uint8_t *)&formattable_capacity_head;
    739          
    740                      for (; count < sizeof(formattable_capacity_head); count++)
    741                      {
    742                          ufi->formatCapacityData[count] = ptr[j++];
   \                     ??USB_DeviceMscUfiReadFormatCapacityCommand_5: (+1)
   \   0000007C   0xAE01             ADD      R6,SP,#+4
   \   0000007E   0xB2DB             UXTB     R3,R3
   \   00000080   0x1847             ADDS     R7,R0,R1
   \   00000082   0x5CF6             LDRB     R6,[R6, R3]
   \   00000084   0xF887 0x60C5      STRB     R6,[R7, #+197]
   \   00000088   0x1C5B             ADDS     R3,R3,#+1
    743                      }
   \   0000008A   0x1C49             ADDS     R1,R1,#+1
   \                     ??USB_DeviceMscUfiReadFormatCapacityCommand_6: (+1)
   \   0000008C   0xB2C9             UXTB     R1,R1
   \   0000008E   0x2908             CMP      R1,#+8
   \   00000090   0xD3F4             BCC.N    ??USB_DeviceMscUfiReadFormatCapacityCommand_5
    744                  }
   \   00000092   0x1C52             ADDS     R2,R2,#+1
   \                     ??USB_DeviceMscUfiReadFormatCapacityCommand_4: (+1)
   \   00000094   0xB2D2             UXTB     R2,R2
   \   00000096   0x42AA             CMP      R2,R5
   \   00000098   0xDBF8             BLT.N    ??USB_DeviceMscUfiReadFormatCapacityCommand_6
    745              }
    746          
    747              ufi->thirteenCase.deviceExpectedDataLength = response_size;
    748              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
   \                     ??USB_DeviceMscUfiReadFormatCapacityCommand_3: (+1)
   \   0000009A   0x2201             MOVS     R2,#+1
   \   0000009C   0xF100 0x0170      ADD      R1,R0,#+112
   \   000000A0   0x748A             STRB     R2,[R1, #+18]
    749              ufi->thirteenCase.buffer = ufi->formatCapacityData;
   \   000000A2   0xF100 0x02C5      ADD      R2,R0,#+197
   \   000000A6   0x604A             STR      R2,[R1, #+4]
   \   000000A8   0x600C             STR      R4,[R1, #+0]
    750              ufi->thirteenCase.lbaSendRecvSelect = 0;
   \   000000AA   0x2200             MOVS     R2,#+0
   \   000000AC   0x740A             STRB     R2,[R1, #+16]
    751          
    752              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
    753          
    754              return error;
   \   000000AE   0xB005             ADD      SP,SP,#+20
   \   000000B0   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   000000B4   0x....             B.N      USB_DeviceMscUfiThirteenCasesCheck
    755          }
    756          
    757          /*!
    758           * @brief format unit command.
    759           *
    760           * The Host sends the FORMAT UNIT command to physically format one track of a diskette according to the selected
    761           *options.
    762           *
    763           * @param handle          The device msc class hanlde.
    764           *
    765           *@return A USB error code or kStatus_USB_Success.
    766          */

   \                                 In section .text, align 2, keep-with-next
    767          usb_status_t USB_DeviceMscUfiFormatUnitCommand(usb_device_msc_struct_t *mscHandle)
    768          {
   \                     USB_DeviceMscUfiFormatUnitCommand: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    769              usb_device_msc_ufi_struct_t *ufi = NULL;
    770              usb_status_t error;
    771          
    772              ufi = &mscHandle->mscUfi;
    773          
    774              ufi->thirteenCase.deviceExpectedDataLength = 0;
   \   00000004   0xF104 0x0070      ADD      R0,R4,#+112
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x.... 0x....      BL       ?Subroutine9
    775              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
    776              ufi->thirteenCase.buffer = NULL;
    777              ufi->thirteenCase.lbaSendRecvSelect = 0;
    778          
    779              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
    780          
    781              if (mscHandle->mscCsw.cswStatus != USB_DEVICE_MSC_PHASE_ERROR)
   \                     ??CrossCallReturnLabel_20: (+1)
   \   0000000E   0xF104 0x0138      ADD      R1,R4,#+56
   \   00000012   0x7F0A             LDRB     R2,[R1, #+28]
   \   00000014   0x2A02             CMP      R2,#+2
   \   00000016   0xD00B             BEQ.N    ??CrossCallReturnLabel_26
    782              {
    783                  if ((mscHandle->mscCbw.cbwcb[1] & 0x1f) == 0x17)
   \   00000018   0x780A             LDRB     R2,[R1, #+0]
   \   0000001A   0xF002 0x021F      AND      R2,R2,#0x1F
   \   0000001E   0x2A17             CMP      R2,#+23
   \   00000020   0xD102             BNE.N    ??USB_DeviceMscUfiFormatUnitCommand_0
    784                  {
    785                      mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_PASSED;
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x770A             STRB     R2,[R1, #+28]
   \   00000026   0xBD10             POP      {R4,PC}
    786                  }
    787                  else
    788                  {
    789                      mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_FAILED;
   \                     ??USB_DeviceMscUfiFormatUnitCommand_0: (+1)
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0x770A             STRB     R2,[R1, #+28]
    790                      ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_ILLEGAL_REQUEST;
   \   0000002C   0x.... 0x....      BL       ?Subroutine12
    791                      ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_INVALID_FIELD_IN_COMMAND_PKT;
    792                  }
    793              }
    794              return error;
   \                     ??CrossCallReturnLabel_26: (+1)
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    795          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x7481             STRB     R1,[R0, #+18]
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6041             STR      R1,[R0, #+4]
   \   0000000A   0x7401             STRB     R1,[R0, #+16]
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x....             B.N      USB_DeviceMscUfiThirteenCasesCheck
    796          
    797          /*!
    798           * @brief prevent allow medium command.
    799           *
    800           * This command tells the UFI device to enable or disable the removal of the medium in the logical unit.
    801           *
    802           * @param handle          The device msc class hanlde.
    803           *
    804           *@return A USB error code or kStatus_USB_Success.
    805          */

   \                                 In section .text, align 2, keep-with-next
    806          usb_status_t USB_DeviceMscUfiPreventAllowMediumCommand(usb_device_msc_struct_t *mscHandle)
    807          {
   \                     USB_DeviceMscUfiPreventAllowMediumCommand: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
    808              usb_device_msc_ufi_struct_t *ufi = NULL;
    809              usb_status_t error;
    810              uint8_t prevent;
    811          
    812              ufi = &mscHandle->mscUfi;
    813              prevent = mscHandle->mscCbw.cbwcb[4] & USB_DEVICE_MSC_UFI_PREVENT_ALLOW_REMOVAL_MASK;
   \   00000006   0xF104 0x053B      ADD      R5,R4,#+59
    814          
    815              ufi->thirteenCase.deviceExpectedDataLength = 0;
   \   0000000A   0xF104 0x0764      ADD      R7,R4,#+100
   \   0000000E   0x782E             LDRB     R6,[R5, #+0]
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x60F8             STR      R0,[R7, #+12]
    816              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x77B8             STRB     R0,[R7, #+30]
    817              ufi->thirteenCase.buffer = NULL;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6138             STR      R0,[R7, #+16]
    818              ufi->thirteenCase.lbaSendRecvSelect = 0;
   \   0000001C   0x7738             STRB     R0,[R7, #+28]
    819          
    820              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       USB_DeviceMscUfiThirteenCasesCheck
   \   00000024   0x4680             MOV      R8,R0
    821          
    822              if (mscHandle->mscCsw.cswStatus != USB_DEVICE_MSC_PHASE_ERROR)
   \   00000026   0x7E68             LDRB     R0,[R5, #+25]
   \   00000028   0x2802             CMP      R0,#+2
   \   0000002A   0xD007             BEQ.N    ??USB_DeviceMscUfiPreventAllowMediumCommand_0
    823              {
    824                  if ((!USB_DEVICE_CONFIG_MSC_SUPPORT_DISK_LOCKING_MECHANISM && prevent))
   \   0000002C   0x07F0             LSLS     R0,R6,#+31
   \   0000002E   0xD505             BPL.N    ??USB_DeviceMscUfiPreventAllowMediumCommand_0
    825                  {
    826                      mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_FAILED;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x7668             STRB     R0,[R5, #+25]
    827                      ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_ILLEGAL_REQUEST;
   \   00000034   0x2005             MOVS     R0,#+5
   \   00000036   0x77E8             STRB     R0,[R5, #+31]
    828                      ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_INVALID_FIELD_IN_COMMAND_PKT;
   \   00000038   0x2024             MOVS     R0,#+36
   \   0000003A   0x7038             STRB     R0,[R7, #+0]
    829                  }
    830              }
    831          
    832              if (mscHandle->configurationStruct->classCallback != NULL)
   \                     ??USB_DeviceMscUfiPreventAllowMediumCommand_0: (+1)
   \   0000003C   0x6860             LDR      R0,[R4, #+4]
   \   0000003E   0x6803             LDR      R3,[R0, #+0]
   \   00000040   0x0018             MOVS     R0,R3
   \   00000042   0xD003             BEQ.N    ??USB_DeviceMscUfiPreventAllowMediumCommand_1
    833              {
    834                  mscHandle->configurationStruct->classCallback((class_handle_t)mscHandle, kUSB_DeviceMscEventRemovalRequest,
    835                                                                NULL);
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x2107             MOVS     R1,#+7
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x4798             BLX      R3
    836              }
    837          
    838              return error;
   \                     ??USB_DeviceMscUfiPreventAllowMediumCommand_1: (+1)
   \   0000004C   0x4640             MOV      R0,R8
   \   0000004E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    839          }
    840          
    841          /*!
    842           * @brief send diagnostic command.
    843           *
    844           * The SEND DIAGNOSTIC command requests the UFI device to do a reset or perform a self-test.
    845           *
    846           * @param handle          The device msc class hanlde.
    847           *
    848           *@return A USB error code or kStatus_USB_Success.
    849          */

   \                                 In section .text, align 2, keep-with-next
    850          usb_status_t USB_DeviceMscUfiSendDiagnosticCommand(usb_device_msc_struct_t *mscHandle)
    851          {
    852              usb_device_msc_ufi_struct_t *ufi = NULL;
    853              usb_status_t error;
    854          
    855              ufi = &mscHandle->mscUfi;
    856          
    857              ufi->thirteenCase.deviceExpectedDataLength = 0;
   \                     USB_DeviceMscUfiSendDiagnosticCommand: (+1)
   \   00000000   0x....             B.N      ?Subroutine0
    858              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
    859              ufi->thirteenCase.buffer = NULL;
    860              ufi->thirteenCase.lbaSendRecvSelect = 0;
    861          
    862              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
    863              return error;
    864          }
    865          
    866          /*!
    867           * @brief start stop unit command.
    868           *
    869           * The START-STOP UNIT command instructs the UFI device to enable or disable media access operations.
    870           *
    871           * @param handle          The device msc class hanlde.
    872           *
    873           *@return A USB error code or kStatus_USB_Success.
    874          */

   \                                 In section .text, align 2, keep-with-next
    875          usb_status_t USB_DeviceMscUfiStartStopUnitCommand(usb_device_msc_struct_t *mscHandle)
    876          {
   \                     USB_DeviceMscUfiStartStopUnitCommand: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    877              usb_device_msc_ufi_struct_t *ufi = NULL;
    878              usb_status_t error;
    879              uint8_t loej_start;
    880          
    881              ufi = &mscHandle->mscUfi;
    882              loej_start = mscHandle->mscCbw.cbwcb[4] & USB_DEVICE_MSC_UFI_LOAD_EJECT_START_MASK;
   \   00000004   0xF104 0x053B      ADD      R5,R4,#+59
   \   00000008   0xB082             SUB      SP,SP,#+8
   \   0000000A   0x7828             LDRB     R0,[R5, #+0]
   \   0000000C   0xF000 0x0003      AND      R0,R0,#0x3
   \   00000010   0xF88D 0x0000      STRB     R0,[SP, #+0]
    883          
    884              ufi->thirteenCase.deviceExpectedDataLength = 0;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0xF104 0x0070      ADD      R0,R4,#+112
   \   0000001A   0x.... 0x....      BL       ?Subroutine9
    885              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
    886              ufi->thirteenCase.buffer = NULL;
    887              ufi->thirteenCase.lbaSendRecvSelect = 0;
    888          
    889              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
   \                     ??CrossCallReturnLabel_19: (+1)
   \   0000001E   0x4606             MOV      R6,R0
    890          
    891              if (mscHandle->mscCsw.cswStatus != USB_DEVICE_MSC_PHASE_ERROR)
   \   00000020   0x7E68             LDRB     R0,[R5, #+25]
   \   00000022   0x2802             CMP      R0,#+2
   \   00000024   0xD007             BEQ.N    ??USB_DeviceMscUfiStartStopUnitCommand_0
    892              {
    893                  if (mscHandle->configurationStruct->classCallback != NULL)
   \   00000026   0x6860             LDR      R0,[R4, #+4]
   \   00000028   0x6803             LDR      R3,[R0, #+0]
   \   0000002A   0x0018             MOVS     R0,R3
   \   0000002C   0xD003             BEQ.N    ??USB_DeviceMscUfiStartStopUnitCommand_0
    894                  {
    895                      mscHandle->configurationStruct->classCallback((class_handle_t)mscHandle, kUSB_DeviceMscEventStopEjectMedia,
    896                                                                    (void *)&loej_start);
   \   0000002E   0x466A             MOV      R2,SP
   \   00000030   0x2108             MOVS     R1,#+8
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x4798             BLX      R3
    897                  }
    898              }
    899          
    900              return error;
   \                     ??USB_DeviceMscUfiStartStopUnitCommand_0: (+1)
   \   00000036   0x4630             MOV      R0,R6
   \   00000038   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    901          }
    902          
    903          /*!
    904           * @brief  unsupport command.
    905           *
    906           * Handle unsupported command .
    907           *
    908           * @param handle          The device msc class hanlde.
    909           *
    910           *@return A USB error code or kStatus_USB_Success.
    911          */

   \                                 In section .text, align 2, keep-with-next
    912          usb_status_t USB_DeviceMscUfiUnsupportCommand(usb_device_msc_struct_t *mscHandle)
    913          {
    914              usb_device_msc_ufi_struct_t *ufi = NULL;
    915          
    916              ufi = &mscHandle->mscUfi;
    917          
    918              mscHandle->mscCsw.dataResidue = 0;
   \                     USB_DeviceMscUfiUnsupportCommand: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF840 0x1F50      STR      R1,[R0, #+80]!
    919              mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_FAILED;
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x7101             STRB     R1,[R0, #+4]
    920          
    921              ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_ILLEGAL_REQUEST;
   \   0000000A   0x2105             MOVS     R1,#+5
   \   0000000C   0x7281             STRB     R1,[R0, #+10]
    922              ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_INVALID_COMMAND_OPCODE;
   \   0000000E   0x2120             MOVS     R1,#+32
   \   00000010   0x7501             STRB     R1,[R0, #+20]
    923              ufi->requestSense.additionalSenseQualifer = USB_DEVICE_MSC_UFI_NO_SENSE;
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x7541             STRB     R1,[R0, #+21]
    924          
    925              return kStatus_USB_Success;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR               ;; return
    926          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    927          
    928          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   USB_DeviceMscUfiFormatUnitCommand
         8   -> USB_DeviceMscUfiThirteenCasesCheck
       8   USB_DeviceMscUfiInquiryCommand
         0   -> USB_DeviceMscUfiThirteenCasesCheck
       8   USB_DeviceMscUfiModeSelectCommand
         8   -> USB_DeviceMscUfiThirteenCasesCheck
       8   USB_DeviceMscUfiModeSenseCommand
         0   -> USB_DeviceMscUfiThirteenCasesCheck
      24   USB_DeviceMscUfiPreventAllowMediumCommand
        24   -- Indirect call
        24   -> USB_DeviceMscUfiThirteenCasesCheck
       0   USB_DeviceMscUfiReadCapacityCommand
         0   -> USB_DeviceMscUfiThirteenCasesCheck
      16   USB_DeviceMscUfiReadCommand
         0   -> USB_DeviceMscUfiThirteenCasesCheck
      40   USB_DeviceMscUfiReadFormatCapacityCommand
         0   -> USB_DeviceMscUfiThirteenCasesCheck
       0   USB_DeviceMscUfiRequestSenseCommand
         0   -> USB_DeviceMscUfiThirteenCasesCheck
       0   USB_DeviceMscUfiSendDiagnosticCommand
         0   -> USB_DeviceMscUfiThirteenCasesCheck
      24   USB_DeviceMscUfiStartStopUnitCommand
        24   -- Indirect call
        24   -> USB_DeviceMscUfiThirteenCasesCheck
       0   USB_DeviceMscUfiTestUnitReadyCommand
         0   -> USB_DeviceMscUfiThirteenCasesCheck
      24   USB_DeviceMscUfiThirteenCasesCheck
        24   -> USB_DeviceMscLbaTransfer
        24   -> USB_DeviceRecvRequest
        24   -> USB_DeviceSendRequest
        24   -> USB_DeviceStallEndpoint
       0   USB_DeviceMscUfiUnsupportCommand
       0   USB_DeviceMscUfiVerifyCommand
         0   -> USB_DeviceMscUfiThirteenCasesCheck
      16   USB_DeviceMscUfiWriteCommand
         0   -> USB_DeviceMscUfiThirteenCasesCheck


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??Subroutine13_0
      16  ?Subroutine0
      12  ?Subroutine1
      16  ?Subroutine10
      30  ?Subroutine11
      14  ?Subroutine12
       8  ?Subroutine2
      10  ?Subroutine3
      10  ?Subroutine4
      10  ?Subroutine5
      24  ?Subroutine6
      12  ?Subroutine7
      12  ?Subroutine8
      16  ?Subroutine9
       4  ?_0
      50  USB_DeviceMscUfiFormatUnitCommand
      40  USB_DeviceMscUfiInquiryCommand
      66  USB_DeviceMscUfiModeSelectCommand
      38  USB_DeviceMscUfiModeSenseCommand
      82  USB_DeviceMscUfiPreventAllowMediumCommand
      38  USB_DeviceMscUfiReadCapacityCommand
      54  USB_DeviceMscUfiReadCommand
     182  USB_DeviceMscUfiReadFormatCapacityCommand
      22  USB_DeviceMscUfiRequestSenseCommand
       2  USB_DeviceMscUfiSendDiagnosticCommand
      58  USB_DeviceMscUfiStartStopUnitCommand
       2  USB_DeviceMscUfiTestUnitReadyCommand
     346  USB_DeviceMscUfiThirteenCasesCheck
      26  USB_DeviceMscUfiUnsupportCommand
       2  USB_DeviceMscUfiVerifyCommand
      52  USB_DeviceMscUfiWriteCommand
      36  g_InquiryInfoConst
       8  g_ModeParametersHeaderConst

 
 1 302 bytes in section .text
 
 1 302 bytes of CODE memory

Errors: none
Warnings: none
