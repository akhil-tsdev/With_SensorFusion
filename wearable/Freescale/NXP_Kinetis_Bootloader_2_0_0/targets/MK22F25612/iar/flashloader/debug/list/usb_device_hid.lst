###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Aug/2016  13:16:01
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_hid.c
#    Command line =  
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_hid.c"
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN256VDC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D BL_TARGET_RAM -lC
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj"
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices/MK22F25612\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/autobaud\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/osa\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device/class\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/bm_usb\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/CMSIS/Include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers/common\"
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list\usb_device_hid.lst
#    Object file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj\usb_device_hid.o
#
###############################################################################

C:\Users\cwati\Documents\My Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_hid.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "usb_device_config.h"
     32          #include "usb.h"
     33          #include "usb_device.h"
     34          
     35          #include "usb_device_class.h"
     36          
     37          #if ((defined(USB_DEVICE_CONFIG_HID)) && (USB_DEVICE_CONFIG_HID > 0U))
     38          #include "usb_device_hid.h"
     39          
     40          /*******************************************************************************
     41           * Definitions
     42           ******************************************************************************/
     43          
     44          /*******************************************************************************
     45           * Prototypes
     46           ******************************************************************************/
     47          
     48          static usb_status_t USB_DeviceHidAllocateHandle(usb_device_hid_struct_t **handle);
     49          static usb_status_t USB_DeviceHidFreeHandle(usb_device_hid_struct_t *handle);
     50          static usb_status_t USB_DeviceHidInterruptIn(usb_device_handle handle,
     51                                                       usb_device_endpoint_callback_message_struct_t *message,
     52                                                       void *callbackParam);
     53          static usb_status_t USB_DeviceHidInterruptOut(usb_device_handle handle,
     54                                                        usb_device_endpoint_callback_message_struct_t *message,
     55                                                        void *callbackParam);
     56          static usb_status_t USB_DeviceHidEndpointsInit(usb_device_hid_struct_t *hidHandle);
     57          static usb_status_t USB_DeviceHidEndpointsDeinit(usb_device_hid_struct_t *hidHandle);
     58          
     59          /*******************************************************************************
     60           * Variables
     61           ******************************************************************************/
     62          

   \                                 In section m_usb_global, align 4
     63          USB_GLOBAL static usb_device_hid_struct_t s_UsbDeviceHidHandle[USB_DEVICE_CONFIG_HID];
   \                     s_UsbDeviceHidHandle:
   \   00000000                      DS8 20
     64          
     65          /*******************************************************************************
     66           * Code
     67           ******************************************************************************/
     68          
     69          /*!
     70           * @brief Allocate a device hid class handle.
     71           *
     72           * This function allocates a device hid class handle.
     73           *
     74           * @param handle          It is out parameter, is used to return pointer of the device hid class handle to the caller.
     75           *
     76           * @retval kStatus_USB_Success              Get a device hid class handle successfully.
     77           * @retval kStatus_USB_Busy                 Cannot allocate a device hid class handle.
     78           */
     79          static usb_status_t USB_DeviceHidAllocateHandle(usb_device_hid_struct_t **handle)
     80          {
     81              int32_t count;
     82              for (count = 0U; count < USB_DEVICE_CONFIG_HID; count++)
     83              {
     84                  if (NULL == s_UsbDeviceHidHandle[count].handle)
     85                  {
     86                      *handle = &s_UsbDeviceHidHandle[count];
     87                      return kStatus_USB_Success;
     88                  }
     89              }
     90          
     91              return kStatus_USB_Busy;
     92          }
     93          
     94          /*!
     95           * @brief Free a device hid class hanlde.
     96           *
     97           * This function frees a device hid class hanlde.
     98           *
     99           * @param handle          The device hid class hanlde.
    100           *
    101           * @retval kStatus_USB_Success              Free device hid class hanlde successfully.
    102           */
    103          static usb_status_t USB_DeviceHidFreeHandle(usb_device_hid_struct_t *handle)
    104          {
    105              handle->handle = NULL;
    106              handle->configStruct = (usb_device_class_config_struct_t *)NULL;
    107              handle->configuration = 0U;
    108              handle->alternate = 0U;
    109              return kStatus_USB_Success;
    110          }
    111          
    112          /*!
    113           * @brief Interrupt IN endpoint callback function.
    114           *
    115           * This callback function is used to notify uplayer the tranfser result of a transfer.
    116           * This callback pointer is passed when the interrupt IN pipe initialized.
    117           *
    118           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    119           * @param message         The result of the interrupt IN pipe transfer.
    120           * @param callbackParam  The paramter for this callback. It is same with
    121           * usb_device_endpoint_callback_struct_t::callbackParam. In the class, the value is the HID class handle.
    122           *
    123           * @return A USB error code or kStatus_USB_Success.
    124           */

   \                                 In section .text, align 2, keep-with-next
    125          static usb_status_t USB_DeviceHidInterruptIn(usb_device_handle handle,
    126                                                       usb_device_endpoint_callback_message_struct_t *message,
    127                                                       void *callbackParam)
    128          {
   \                     USB_DeviceHidInterruptIn: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4613             MOV      R3,R2
    129              usb_device_hid_struct_t *hidHandle;
    130              usb_status_t error = kStatus_USB_Error;
   \   00000004   0x2001             MOVS     R0,#+1
    131          
    132              /* Get the HID class handle */
    133              hidHandle = (usb_device_hid_struct_t *)callbackParam;
    134          
    135              if (!hidHandle)
   \   00000006   0xB90B             CBNZ.N   R3,??USB_DeviceHidInterruptIn_0
    136              {
    137                  return kStatus_USB_InvalidHandle;
   \   00000008   0x2003             MOVS     R0,#+3
   \   0000000A   0xBD10             POP      {R4,PC}
    138              }
    139              hidHandle->interruptInPipeBusy = 0U;
   \                     ??USB_DeviceHidInterruptIn_0: (+1)
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x745A             STRB     R2,[R3, #+17]
    140              if ((NULL != hidHandle->configStruct) && (hidHandle->configStruct->classCallback))
   \   00000010   0x685A             LDR      R2,[R3, #+4]
   \   00000012   0xB132             CBZ.N    R2,??USB_DeviceHidInterruptIn_1
   \   00000014   0x6814             LDR      R4,[R2, #+0]
   \   00000016   0x0022             MOVS     R2,R4
   \   00000018   0xD003             BEQ.N    ??USB_DeviceHidInterruptIn_1
    141              {
    142                  /* Notify the application data sent by calling the hid class callback. */
    143                  error =
    144                      hidHandle->configStruct->classCallback((class_handle_t)hidHandle, kUSB_DeviceHidEventSendResponse, message);
   \   0000001A   0x460A             MOV      R2,R1
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x4618             MOV      R0,R3
   \   00000020   0x47A0             BLX      R4
    145              }
    146          
    147              return error;
   \                     ??USB_DeviceHidInterruptIn_1: (+1)
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    148          }
    149          
    150          /*!
    151           * @brief Interrupt OUT endpoint callback function.
    152           *
    153           * This callback function is used to notify uplayer the tranfser result of a transfer.
    154           * This callback pointer is passed when the interrupt OUT pipe initialized.
    155           *
    156           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    157           * @param message         The result of the interrupt OUT pipe transfer.
    158           * @param callbackParam  The paramter for this callback. It is same with
    159           * usb_device_endpoint_callback_struct_t::callbackParam. In the class, the value is the HID class handle.
    160           *
    161           * @return A USB error code or kStatus_USB_Success.
    162           */

   \                                 In section .text, align 2, keep-with-next
    163          static usb_status_t USB_DeviceHidInterruptOut(usb_device_handle handle,
    164                                                        usb_device_endpoint_callback_message_struct_t *message,
    165                                                        void *callbackParam)
    166          {
   \                     USB_DeviceHidInterruptOut: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4613             MOV      R3,R2
    167              usb_device_hid_struct_t *hidHandle;
    168              usb_status_t error = kStatus_USB_Error;
   \   00000004   0x2001             MOVS     R0,#+1
    169          
    170              /* Get the HID class handle */
    171              hidHandle = (usb_device_hid_struct_t *)callbackParam;
    172          
    173              if (!hidHandle)
   \   00000006   0xB90B             CBNZ.N   R3,??USB_DeviceHidInterruptOut_0
    174              {
    175                  return kStatus_USB_InvalidHandle;
   \   00000008   0x2003             MOVS     R0,#+3
   \   0000000A   0xBD10             POP      {R4,PC}
    176              }
    177              hidHandle->interruptOutPipeBusy = 0U;
   \                     ??USB_DeviceHidInterruptOut_0: (+1)
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x749A             STRB     R2,[R3, #+18]
    178              if ((NULL != hidHandle->configStruct) && (hidHandle->configStruct->classCallback))
   \   00000010   0x685A             LDR      R2,[R3, #+4]
   \   00000012   0xB132             CBZ.N    R2,??USB_DeviceHidInterruptOut_1
   \   00000014   0x6814             LDR      R4,[R2, #+0]
   \   00000016   0x0022             MOVS     R2,R4
   \   00000018   0xD003             BEQ.N    ??USB_DeviceHidInterruptOut_1
    179              {
    180                  /* Notify the application data received by calling the hid class callback. */
    181                  error =
    182                      hidHandle->configStruct->classCallback((class_handle_t)hidHandle, kUSB_DeviceHidEventRecvResponse, message);
   \   0000001A   0x460A             MOV      R2,R1
   \   0000001C   0x2102             MOVS     R1,#+2
   \   0000001E   0x4618             MOV      R0,R3
   \   00000020   0x47A0             BLX      R4
    183              }
    184          
    185              return error;
   \                     ??USB_DeviceHidInterruptOut_1: (+1)
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    186          }
    187          
    188          /*!
    189           * @brief Initialize the endpoints of the hid class.
    190           *
    191           * This callback function is used to initialize the endpoints of the hid class.
    192           *
    193           * @param hidHandle          The device hid class handle. It equals the value returned from
    194           * usb_device_class_config_struct_t::classHandle.
    195           *
    196           * @return A USB error code or kStatus_USB_Success.
    197           */

   \                                 In section .text, align 2, keep-with-next
    198          static usb_status_t USB_DeviceHidEndpointsInit(usb_device_hid_struct_t *hidHandle)
    199          {
   \                     USB_DeviceHidEndpointsInit: (+1)
   \   00000000   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
    200              usb_device_interface_list_t *interfaceList;
    201              usb_device_interface_struct_t *interface = (usb_device_interface_struct_t *)NULL;
   \   00000006   0x2500             MOVS     R5,#+0
    202              usb_status_t error = kStatus_USB_Error;
   \   00000008   0x6861             LDR      R1,[R4, #+4]
   \   0000000A   0x6889             LDR      R1,[R1, #+8]
   \   0000000C   0x7B22             LDRB     R2,[R4, #+12]
   \   0000000E   0x794B             LDRB     R3,[R1, #+5]
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4293             CMP      R3,R2
   \   00000014   0xD34B             BCC.N    ??USB_DeviceHidEndpointsInit_0
    203          
    204              /* Check the configuration is valid or not. */
    205              if (hidHandle->configuration > hidHandle->configStruct->classInfomation->configurations)
    206              {
    207                  return error;
    208              }
    209          
    210              /* Get the interface list of the new configuration. */
    211              if (NULL == hidHandle->configStruct->classInfomation->interfaceList)
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD048             BEQ.N    ??USB_DeviceHidEndpointsInit_0
    212              {
    213                  return error;
    214              }
    215              interfaceList = &hidHandle->configStruct->classInfomation->interfaceList[hidHandle->configuration - 1U];
   \   0000001C   0xEB01 0x01C2      ADD      R1,R1,R2, LSL #+3
   \   00000020   0x3908             SUBS     R1,R1,#+8
    216          
    217              /* Find interface by using the alternate setting of the interface. */
    218              for (int count = 0U; count < interfaceList->count; count++)
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0xE000             B.N      ??USB_DeviceHidEndpointsInit_1
   \                     ??USB_DeviceHidEndpointsInit_2: (+1)
   \   00000026   0x1C52             ADDS     R2,R2,#+1
   \                     ??USB_DeviceHidEndpointsInit_1: (+1)
   \   00000028   0x780B             LDRB     R3,[R1, #+0]
   \   0000002A   0x429A             CMP      R2,R3
   \   0000002C   0xDA3F             BGE.N    ??USB_DeviceHidEndpointsInit_0
    219              {
    220                  if (USB_DEVICE_CONFIG_HID_CLASS_CODE == interfaceList->interfaces[count].classCode)
   \   0000002E   0x684B             LDR      R3,[R1, #+4]
   \   00000030   0x260C             MOVS     R6,#+12
   \   00000032   0x4356             MULS     R6,R6,R2
   \   00000034   0x4433             ADD      R3,R3,R6
   \   00000036   0x781E             LDRB     R6,[R3, #+0]
   \   00000038   0x2E03             CMP      R6,#+3
   \   0000003A   0xD1F4             BNE.N    ??USB_DeviceHidEndpointsInit_2
    221                  {
    222                      for (int index = 0U; index < interfaceList->interfaces[count].count; index++)
   \   0000003C   0xF894 0xC00E      LDRB     R12,[R4, #+14]
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0xE000             B.N      ??USB_DeviceHidEndpointsInit_3
   \                     ??USB_DeviceHidEndpointsInit_4: (+1)
   \   00000044   0x1C49             ADDS     R1,R1,#+1
   \                     ??USB_DeviceHidEndpointsInit_3: (+1)
   \   00000046   0x7A1A             LDRB     R2,[R3, #+8]
   \   00000048   0x4291             CMP      R1,R2
   \   0000004A   0xDA05             BGE.N    ??USB_DeviceHidEndpointsInit_5
    223                      {
    224                          if (interfaceList->interfaces[count].interface[index].alternateSetting == hidHandle->alternate)
   \   0000004C   0x685A             LDR      R2,[R3, #+4]
   \   0000004E   0x010E             LSLS     R6,R1,#+4
   \   00000050   0x5D97             LDRB     R7,[R2, R6]
   \   00000052   0x4567             CMP      R7,R12
   \   00000054   0xD1F6             BNE.N    ??USB_DeviceHidEndpointsInit_4
    225                          {
    226                              interface = &interfaceList->interfaces[count].interface[index];
   \   00000056   0x1995             ADDS     R5,R2,R6
    227                              break;
    228                          }
    229                      }
    230                      hidHandle->interfaceNumber = interfaceList->interfaces[count].interfaceNumber;
   \                     ??USB_DeviceHidEndpointsInit_5: (+1)
   \   00000058   0x78D9             LDRB     R1,[R3, #+3]
   \   0000005A   0x7361             STRB     R1,[R4, #+13]
    231                      break;
    232                  }
    233              }
    234              if (!interface)
   \   0000005C   0xB33D             CBZ.N    R5,??USB_DeviceHidEndpointsInit_0
    235              {
    236                  /* Return error if the interface is not found. */
    237                  return error;
    238              }
    239          
    240              /* Keep new interface handle. */
    241              hidHandle->interfaceHandle = interface;
   \   0000005E   0x60A5             STR      R5,[R4, #+8]
    242          
    243              /* Initialize the endpoints of the new interface. */
    244              for (int count = 0U; count < interface->endpointList.count; count++)
   \   00000060   0xF04F 0x0800      MOV      R8,#+0
   \   00000064   0x....             LDR.N    R6,??DataTable1
   \   00000066   0x....             LDR.N    R7,??DataTable1_1
   \   00000068   0xE007             B.N      ??USB_DeviceHidEndpointsInit_6
    245              {
    246                  usb_device_endpoint_init_struct_t epInitStruct;
    247                  usb_device_endpoint_callback_struct_t ep_callback;
    248                  epInitStruct.zlt = 0U;
    249                  epInitStruct.endpointAddress = interface->endpointList.endpoint[count].endpointAddress;
    250                  epInitStruct.maxPacketSize = interface->endpointList.endpoint[count].maxPacketSize;
    251                  epInitStruct.transferType = interface->endpointList.endpoint[count].transferType;
    252          
    253                  if (USB_IN == ((epInitStruct.endpointAddress & USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_MASK) >>
    254                                 USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT))
    255                  {
    256                      ep_callback.callbackFn = USB_DeviceHidInterruptIn;
    257                  }
    258                  else
    259                  {
    260                      ep_callback.callbackFn = USB_DeviceHidInterruptOut;
    261                  }
    262                  ep_callback.callbackParam = hidHandle;
   \                     ??USB_DeviceHidEndpointsInit_7: (+1)
   \   0000006A   0x9403             STR      R4,[SP, #+12]
    263          
    264                  error = USB_DeviceInitEndpoint(hidHandle->handle, &epInitStruct, &ep_callback);
   \   0000006C   0xAA02             ADD      R2,SP,#+8
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x4669             MOV      R1,SP
   \   00000072   0x.... 0x....      BL       USB_DeviceInitEndpoint
   \   00000076   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??USB_DeviceHidEndpointsInit_6: (+1)
   \   0000007A   0x7929             LDRB     R1,[R5, #+4]
   \   0000007C   0x4588             CMP      R8,R1
   \   0000007E   0xDA16             BGE.N    ??USB_DeviceHidEndpointsInit_0
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   00000086   0x68A8             LDR      R0,[R5, #+8]
   \   00000088   0xF810 0x0028      LDRB     R0,[R0, R8, LSL #+2]
   \   0000008C   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   00000090   0x09C0             LSRS     R0,R0,#+7
   \   00000092   0x68A9             LDR      R1,[R5, #+8]
   \   00000094   0xEB01 0x0188      ADD      R1,R1,R8, LSL #+2
   \   00000098   0x2801             CMP      R0,#+1
   \   0000009A   0x884A             LDRH     R2,[R1, #+2]
   \   0000009C   0xF8AD 0x2000      STRH     R2,[SP, #+0]
   \   000000A0   0x7849             LDRB     R1,[R1, #+1]
   \   000000A2   0xF88D 0x1003      STRB     R1,[SP, #+3]
   \   000000A6   0xBF0C             ITE      EQ 
   \   000000A8   0x9702             STREQ    R7,[SP, #+8]
   \   000000AA   0x9602             STRNE    R6,[SP, #+8]
   \   000000AC   0xE7DD             B.N      ??USB_DeviceHidEndpointsInit_7
    265              }
    266              return error;
   \                     ??USB_DeviceHidEndpointsInit_0: (+1)
   \   000000AE   0xB004             ADD      SP,SP,#+16
   \   000000B0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    267          }
    268          
    269          /*!
    270           * @brief De-initialize the endpoints of the hid class.
    271           *
    272           * This callback function is used to de-initialize the endpoints of the hid class.
    273           *
    274           * @param hidHandle          The device hid class handle. It equals the value returned from
    275           * usb_device_class_config_struct_t::classHandle.
    276           *
    277           * @return A USB error code or kStatus_USB_Success.
    278           */

   \                                 In section .text, align 2, keep-with-next
    279          static usb_status_t USB_DeviceHidEndpointsDeinit(usb_device_hid_struct_t *hidHandle)
    280          {
   \                     USB_DeviceHidEndpointsDeinit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    281              usb_status_t error = kStatus_USB_Error;
   \   00000004   0x2001             MOVS     R0,#+1
    282          
    283              if (!hidHandle->interfaceHandle)
   \   00000006   0x68A1             LDR      R1,[R4, #+8]
   \   00000008   0xB161             CBZ.N    R1,??USB_DeviceHidEndpointsDeinit_0
    284              {
    285                  return error;
    286              }
    287              /* De-initialize all endpoints of the interface */
    288              for (int count = 0U; count < hidHandle->interfaceHandle->endpointList.count; count++)
   \   0000000A   0x2500             MOVS     R5,#+0
   \   0000000C   0xE006             B.N      ??USB_DeviceHidEndpointsDeinit_1
    289              {
    290                  error = USB_DeviceDeinitEndpoint(hidHandle->handle,
    291                                                   hidHandle->interfaceHandle->endpointList.endpoint[count].endpointAddress);
   \                     ??USB_DeviceHidEndpointsDeinit_2: (+1)
   \   0000000E   0x6888             LDR      R0,[R1, #+8]
   \   00000010   0xF810 0x1025      LDRB     R1,[R0, R5, LSL #+2]
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x.... 0x....      BL       USB_DeviceDeinitEndpoint
    292              }
   \   0000001A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??USB_DeviceHidEndpointsDeinit_1: (+1)
   \   0000001C   0x68A1             LDR      R1,[R4, #+8]
   \   0000001E   0x790A             LDRB     R2,[R1, #+4]
   \   00000020   0x4295             CMP      R5,R2
   \   00000022   0xDBF4             BLT.N    ??USB_DeviceHidEndpointsDeinit_2
   \                     ??USB_DeviceHidEndpointsDeinit_0: (+1)
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    293              return error;
    294          }
    295          
    296          /*!
    297           * @brief Handle the event passed to the hid class.
    298           *
    299           * This function handles the event passed to the hid class.
    300           *
    301           * @param handle          The hid class handle, got from the usb_device_class_config_struct_t::classHandle.
    302           * @param event           The event codes. Please refer to the enumeration usb_device_class_event_t.
    303           * @param param           The param type is determined by the event code.
    304           *
    305           * @return A USB error code or kStatus_USB_Success.
    306           * @retval kStatus_USB_Success              Free device handle successfully.
    307           * @retval kStatus_USB_InvalidParameter     The device handle not be found.
    308           * @retval kStatus_USB_InvalidRequest       The request is invalid, and the control pipe will be stalled by the caller.
    309           */

   \                                 In section .text, align 4, keep-with-next
    310          usb_status_t USB_DeviceHidEvent(void *handle, uint32_t event, void *param)
    311          {
   \                     USB_DeviceHidEvent: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4615             MOV      R5,R2
    312              usb_device_hid_struct_t *hidHandle;
    313              usb_device_hid_report_struct_t report;
    314              usb_status_t error = kStatus_USB_Error;
   \   00000006   0x2001             MOVS     R0,#+1
    315              uint16_t interfaceAlternate;
    316              uint8_t *temp8;
    317              uint8_t alternate;
    318          
    319              if ((!param) || (!handle))
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xBF14             ITE      NE 
   \   0000000C   0x2C00             CMPNE    R4,#+0
   \   0000000E   0x2003             MOVEQ    R0,#+3
   \   00000010   0xB084             SUB      SP,SP,#+16
    320              {
    321                  return kStatus_USB_InvalidHandle;
   \   00000012   0xD00B             BEQ.N    ??USB_DeviceHidEvent_1
    322              }
    323          
    324              /* Get the hid class handle. */
    325              hidHandle = (usb_device_hid_struct_t *)handle;
    326          
    327              switch (event)
   \   00000014   0x1E49             SUBS     R1,R1,#+1
   \   00000016   0x2905             CMP      R1,#+5
   \   00000018   0xD808             BHI.N    ??USB_DeviceHidEvent_1
   \   0000001A   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??USB_DeviceHidEvent_0:
   \   0000001E   0x5A 0x03          DC8      0x5A,0x3,0x8,0x18
   \              0x08 0x18    
   \   00000022   0x2E 0x44          DC8      0x2E,0x44
    328              {
    329                  case kUSB_DeviceClassEventDeviceReset:
    330                      /* Bus reset, clear the configuration. */
    331                      hidHandle->configuration = 0U;
   \                     ??USB_DeviceHidEvent_2: (+1)
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x7321             STRB     R1,[R4, #+12]
    332                      hidHandle->interruptInPipeBusy = 0U;
   \   00000028   0x7461             STRB     R1,[R4, #+17]
    333                      hidHandle->interruptOutPipeBusy = 0U;
   \   0000002A   0x74A1             STRB     R1,[R4, #+18]
    334                      break;
   \                     ??USB_DeviceHidEvent_1: (+1)
   \   0000002C   0xE0B9             B.N      ??USB_DeviceHidEvent_3
    335                  case kUSB_DeviceClassEventSetConfiguration:
    336                      /* Get the new configuration. */
    337                      temp8 = ((uint8_t *)param);
    338                      if (!hidHandle->configStruct)
   \                     ??USB_DeviceHidEvent_4: (+1)
   \   0000002E   0x6861             LDR      R1,[R4, #+4]
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xBF1E             ITTT     NE 
   \   00000034   0x7B21             LDRBNE   R1,[R4, #+12]
   \   00000036   0x782A             LDRBNE   R2,[R5, #+0]
   \   00000038   0x428A             CMPNE    R2,R1
    339                      {
    340                          break;
    341                      }
    342                      if (*temp8 == hidHandle->configuration)
   \   0000003A   0xD0F7             BEQ.N    ??USB_DeviceHidEvent_1
    343                      {
    344                          break;
    345                      }
    346          
    347                      /* De-initialize the endpoints when current configuration is none zero. */
    348                      if (hidHandle->configuration)
   \   0000003C   0xB111             CBZ.N    R1,??USB_DeviceHidEvent_5
    349                      {
    350                          error = USB_DeviceHidEndpointsDeinit(hidHandle);
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       USB_DeviceHidEndpointsDeinit
    351                      }
    352                      /* Save new configuration. */
    353                      hidHandle->configuration = *temp8;
   \                     ??USB_DeviceHidEvent_5: (+1)
   \   00000044   0x7828             LDRB     R0,[R5, #+0]
   \   00000046   0x7320             STRB     R0,[R4, #+12]
    354                      /* Clear the alternate setting value. */
    355                      hidHandle->alternate = 0U;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x73A0             STRB     R0,[R4, #+14]
    356          
    357                      /* Initialize the endpoints of the new current configuration by using the alternate setting 0. */
    358                      error = USB_DeviceHidEndpointsInit(hidHandle);
   \   0000004C   0xE011             B.N      ??USB_DeviceHidEvent_6
    359                      break;
    360                  case kUSB_DeviceClassEventSetInterface:
    361                      if (!hidHandle->configStruct)
   \                     ??USB_DeviceHidEvent_7: (+1)
   \   0000004E   0x6861             LDR      R1,[R4, #+4]
   \   00000050   0x2900             CMP      R1,#+0
   \   00000052   0xD0EB             BEQ.N    ??USB_DeviceHidEvent_1
    362                      {
    363                          break;
    364                      }
    365                      /* Get the new alternate setting of the interface */
    366                      interfaceAlternate = *((uint16_t *)param);
   \   00000054   0x8829             LDRH     R1,[R5, #+0]
    367                      /* Get the alternate setting value */
    368                      alternate = (uint8_t)(interfaceAlternate & 0xFFU);
    369          
    370                      /* Whether the interface belongs to the class. */
    371                      if (hidHandle->interfaceNumber != ((uint8_t)(interfaceAlternate >> 8U)))
   \   00000056   0x7B62             LDRB     R2,[R4, #+13]
   \   00000058   0x460D             MOV      R5,R1
   \   0000005A   0x0409             LSLS     R1,R1,#+16
   \   0000005C   0xEBB2 0x6F11      CMP      R2,R1, LSR #+24
   \   00000060   0xD10A             BNE.N    ??USB_DeviceHidEvent_8
    372                      {
    373                          break;
    374                      }
    375                      /* Only handle new alternate setting. */
    376                      if (alternate == hidHandle->alternate)
   \   00000062   0x7BA2             LDRB     R2,[R4, #+14]
   \   00000064   0xB2E9             UXTB     R1,R5
   \   00000066   0x4291             CMP      R1,R2
   \   00000068   0xD006             BEQ.N    ??USB_DeviceHidEvent_8
    377                      {
    378                          break;
    379                      }
    380                      /* De-initialize old endpoints */
    381                      error = USB_DeviceHidEndpointsDeinit(hidHandle);
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       USB_DeviceHidEndpointsDeinit
    382                      hidHandle->alternate = alternate;
   \   00000070   0x73A5             STRB     R5,[R4, #+14]
    383                      /* Initialize new endpoints */
    384                      error = USB_DeviceHidEndpointsInit(hidHandle);
   \                     ??USB_DeviceHidEvent_6: (+1)
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       USB_DeviceHidEndpointsInit
    385                      break;
   \                     ??USB_DeviceHidEvent_8: (+1)
   \   00000078   0xE093             B.N      ??USB_DeviceHidEvent_3
    386                  case kUSB_DeviceClassEventSetEndpointHalt:
    387                      if ((!hidHandle->configStruct) || (!hidHandle->interfaceHandle))
   \                     ??USB_DeviceHidEvent_9: (+1)
   \   0000007A   0x6861             LDR      R1,[R4, #+4]
   \   0000007C   0x2900             CMP      R1,#+0
   \   0000007E   0xBF1C             ITT      NE 
   \   00000080   0x68A1             LDRNE    R1,[R4, #+8]
   \   00000082   0x2900             CMPNE    R1,#+0
   \   00000084   0xD0F8             BEQ.N    ??USB_DeviceHidEvent_8
    388                      {
    389                          break;
    390                      }
    391                      /* Get the endpoint address */
    392                      temp8 = ((uint8_t *)param);
    393                      for (int count = 0U; count < hidHandle->interfaceHandle->endpointList.count; count++)
   \   00000086   0x2600             MOVS     R6,#+0
   \                     ??USB_DeviceHidEvent_10: (+1)
   \   00000088   0x68A2             LDR      R2,[R4, #+8]
   \   0000008A   0x7911             LDRB     R1,[R2, #+4]
   \   0000008C   0x428E             CMP      R6,R1
   \   0000008E   0xDAF3             BGE.N    ??USB_DeviceHidEvent_8
    394                      {
    395                          if (*temp8 == hidHandle->interfaceHandle->endpointList.endpoint[count].endpointAddress)
   \   00000090   0x6892             LDR      R2,[R2, #+8]
   \   00000092   0x7829             LDRB     R1,[R5, #+0]
   \   00000094   0xF812 0x2026      LDRB     R2,[R2, R6, LSL #+2]
   \   00000098   0x4291             CMP      R1,R2
   \   0000009A   0xBF04             ITT      EQ 
    396                          {
    397                              /* Only stall the endpoint belongs to the class */
    398                              error = USB_DeviceStallEndpoint(hidHandle->handle, *temp8);
   \   0000009C   0x6820             LDREQ    R0,[R4, #+0]
   \   0000009E   0x.... 0x....      BLEQ     USB_DeviceStallEndpoint
    399                          }
    400                      }
   \   000000A2   0x1C76             ADDS     R6,R6,#+1
   \   000000A4   0xE7F0             B.N      ??USB_DeviceHidEvent_10
    401                      break;
    402                  case kUSB_DeviceClassEventClearEndpointHalt:
    403                      if ((!hidHandle->configStruct) || (!hidHandle->interfaceHandle))
   \                     ??USB_DeviceHidEvent_11: (+1)
   \   000000A6   0x6861             LDR      R1,[R4, #+4]
   \   000000A8   0x2900             CMP      R1,#+0
   \   000000AA   0xBF1C             ITT      NE 
   \   000000AC   0x68A1             LDRNE    R1,[R4, #+8]
   \   000000AE   0x2900             CMPNE    R1,#+0
   \   000000B0   0xD077             BEQ.N    ??USB_DeviceHidEvent_3
    404                      {
    405                          break;
    406                      }
    407                      /* Get the endpoint address */
    408                      temp8 = ((uint8_t *)param);
    409                      for (int count = 0U; count < hidHandle->interfaceHandle->endpointList.count; count++)
   \   000000B2   0x2600             MOVS     R6,#+0
   \                     ??USB_DeviceHidEvent_12: (+1)
   \   000000B4   0x68A2             LDR      R2,[R4, #+8]
   \   000000B6   0x7911             LDRB     R1,[R2, #+4]
   \   000000B8   0x428E             CMP      R6,R1
   \   000000BA   0xDA72             BGE.N    ??USB_DeviceHidEvent_3
    410                      {
    411                          if (*temp8 == hidHandle->interfaceHandle->endpointList.endpoint[count].endpointAddress)
   \   000000BC   0x6892             LDR      R2,[R2, #+8]
   \   000000BE   0x7829             LDRB     R1,[R5, #+0]
   \   000000C0   0xF812 0x2026      LDRB     R2,[R2, R6, LSL #+2]
   \   000000C4   0x4291             CMP      R1,R2
   \   000000C6   0xBF04             ITT      EQ 
    412                          {
    413                              /* Only un-stall the endpoint belongs to the class */
    414                              error = USB_DeviceUnstallEndpoint(hidHandle->handle, *temp8);
   \   000000C8   0x6820             LDREQ    R0,[R4, #+0]
   \   000000CA   0x.... 0x....      BLEQ     USB_DeviceUnstallEndpoint
    415                          }
    416                      }
   \   000000CE   0x1C76             ADDS     R6,R6,#+1
   \   000000D0   0xE7F0             B.N      ??USB_DeviceHidEvent_12
    417                      break;
    418                  case kUSB_DeviceClassEventClassRequest:
    419                      if (param)
    420                      {
    421                          /* Handle the hid class specific request. */
    422                          usb_device_control_request_struct_t *controlRequest = (usb_device_control_request_struct_t *)param;
    423          
    424                          if ((controlRequest->setup->bmRequestType & USB_REQUEST_TYPE_RECIPIENT_MASK) !=
    425                              USB_REQUEST_TYPE_RECIPIENT_INTERFACE)
   \                     ??USB_DeviceHidEvent_13: (+1)
   \   000000D2   0x6829             LDR      R1,[R5, #+0]
   \   000000D4   0x780A             LDRB     R2,[R1, #+0]
   \   000000D6   0xF002 0x021F      AND      R2,R2,#0x1F
   \   000000DA   0x2A01             CMP      R2,#+1
   \   000000DC   0xBF02             ITTT     EQ 
   \   000000DE   0x790A             LDRBEQ   R2,[R1, #+4]
   \   000000E0   0x7B63             LDRBEQ   R3,[R4, #+13]
   \   000000E2   0x429A             CMPEQ    R2,R3
    426                          {
    427                              break;
    428                          }
    429          
    430                          if ((controlRequest->setup->wIndex & 0xFFU) != hidHandle->interfaceNumber)
   \   000000E4   0xD15D             BNE.N    ??USB_DeviceHidEvent_3
    431                          {
    432                              break;
    433                          }
    434          
    435                          switch (controlRequest->setup->bRequest)
   \   000000E6   0x784A             LDRB     R2,[R1, #+1]
   \   000000E8   0x2A01             CMP      R2,#+1
   \   000000EA   0x4620             MOV      R0,R4
   \   000000EC   0xD00A             BEQ.N    ??USB_DeviceHidEvent_14
   \   000000EE   0x2A02             CMP      R2,#+2
   \   000000F0   0xD013             BEQ.N    ??USB_DeviceHidEvent_15
   \   000000F2   0x2A03             CMP      R2,#+3
   \   000000F4   0xD01A             BEQ.N    ??USB_DeviceHidEvent_16
   \   000000F6   0x2A09             CMP      R2,#+9
   \   000000F8   0xD022             BEQ.N    ??USB_DeviceHidEvent_17
   \   000000FA   0x2A0A             CMP      R2,#+10
   \   000000FC   0xD040             BEQ.N    ??USB_DeviceHidEvent_18
   \   000000FE   0x2A0B             CMP      R2,#+11
   \   00000100   0xD045             BEQ.N    ??USB_DeviceHidEvent_19
   \   00000102   0xE04D             B.N      ??USB_DeviceHidEvent_20
    436                          {
    437                              case USB_DEVICE_HID_REQUEST_GET_REPORT:
    438                                  /* Get report request */
    439                                  report.reportType = (controlRequest->setup->wValue & 0xFF00U) >> 0x08U;
   \                     ??USB_DeviceHidEvent_14: (+1)
   \   00000104   0x8849             LDRH     R1,[R1, #+2]
   \   00000106   0x0A09             LSRS     R1,R1,#+8
   \   00000108   0xF88D 0x1008      STRB     R1,[SP, #+8]
    440                                  report.reportId = (controlRequest->setup->wValue & 0x00FFU);
    441                                  error = hidHandle->configStruct->classCallback((class_handle_t)hidHandle,
    442                                                                                 kUSB_DeviceHidEventGetReport, &report);
   \   0000010C   0x466A             MOV      R2,SP
   \   0000010E   0x6829             LDR      R1,[R5, #+0]
   \   00000110   0x8849             LDRH     R1,[R1, #+2]
   \   00000112   0xF88D 0x1009      STRB     R1,[SP, #+9]
   \   00000116   0x2103             MOVS     R1,#+3
   \   00000118   0xE020             B.N      ??USB_DeviceHidEvent_21
    443                                  controlRequest->buffer = report.reportBuffer;
    444                                  controlRequest->length = report.reportLength;
    445                                  break;
    446                              case USB_DEVICE_HID_REQUEST_GET_IDLE:
    447                                  /* Get idle request */
    448                                  error = hidHandle->configStruct->classCallback(
    449                                      (class_handle_t)hidHandle, kUSB_DeviceHidEventGetIdle, &hidHandle->idleRate);
   \                     ??USB_DeviceHidEvent_15: (+1)
   \   0000011A   0x6863             LDR      R3,[R4, #+4]
   \   0000011C   0x681B             LDR      R3,[R3, #+0]
   \   0000011E   0xF104 0x020F      ADD      R2,R4,#+15
   \   00000122   0x2104             MOVS     R1,#+4
   \   00000124   0x4798             BLX      R3
    450                                  controlRequest->buffer = &hidHandle->idleRate;
   \   00000126   0xF104 0x010F      ADD      R1,R4,#+15
   \   0000012A   0xE007             B.N      ??USB_DeviceHidEvent_22
    451                                  break;
    452                              case USB_DEVICE_HID_REQUEST_GET_PROTOCOL:
    453                                  /* Get protocol request */
    454                                  error = hidHandle->configStruct->classCallback(
    455                                      (class_handle_t)hidHandle, kUSB_DeviceHidEventGetIdle, &hidHandle->protocol);
   \                     ??USB_DeviceHidEvent_16: (+1)
   \   0000012C   0x6863             LDR      R3,[R4, #+4]
   \   0000012E   0x681B             LDR      R3,[R3, #+0]
   \   00000130   0xF104 0x0210      ADD      R2,R4,#+16
   \   00000134   0x2104             MOVS     R1,#+4
   \   00000136   0x4798             BLX      R3
    456                                  controlRequest->buffer = &hidHandle->protocol;
   \   00000138   0xF104 0x0110      ADD      R1,R4,#+16
   \                     ??USB_DeviceHidEvent_22: (+1)
   \   0000013C   0x6069             STR      R1,[R5, #+4]
    457                                  break;
   \   0000013E   0xE030             B.N      ??USB_DeviceHidEvent_3
    458                              case USB_DEVICE_HID_REQUEST_SET_REPORT:
    459                                  /* Set report request */
    460                                  report.reportType = (controlRequest->setup->wValue & 0xFF00U) >> 0x08U;
   \                     ??USB_DeviceHidEvent_17: (+1)
   \   00000140   0x8849             LDRH     R1,[R1, #+2]
   \   00000142   0x0A09             LSRS     R1,R1,#+8
   \   00000144   0xF88D 0x1008      STRB     R1,[SP, #+8]
    461                                  report.reportId = (controlRequest->setup->wValue & 0x00FFU);
   \   00000148   0x6829             LDR      R1,[R5, #+0]
   \   0000014A   0x8849             LDRH     R1,[R1, #+2]
   \   0000014C   0xF88D 0x1009      STRB     R1,[SP, #+9]
    462                                  if (controlRequest->isSetup)
   \   00000150   0x7B29             LDRB     R1,[R5, #+12]
   \   00000152   0xB159             CBZ.N    R1,??USB_DeviceHidEvent_23
    463                                  {
    464                                      report.reportLength = controlRequest->length;
   \   00000154   0x68A9             LDR      R1,[R5, #+8]
   \   00000156   0x9101             STR      R1,[SP, #+4]
    465                                      error = hidHandle->configStruct->classCallback(
    466                                          (class_handle_t)hidHandle, kUSB_DeviceHidEventRequestReportBuffer, &report);
   \   00000158   0x466A             MOV      R2,SP
   \   0000015A   0x2109             MOVS     R1,#+9
   \                     ??USB_DeviceHidEvent_21: (+1)
   \   0000015C   0x6863             LDR      R3,[R4, #+4]
   \   0000015E   0x681B             LDR      R3,[R3, #+0]
   \   00000160   0x4798             BLX      R3
    467                                      controlRequest->buffer = report.reportBuffer;
   \   00000162   0x9900             LDR      R1,[SP, #+0]
   \   00000164   0x6069             STR      R1,[R5, #+4]
    468                                      controlRequest->length = report.reportLength;
   \   00000166   0x9901             LDR      R1,[SP, #+4]
   \   00000168   0x60A9             STR      R1,[R5, #+8]
   \   0000016A   0xE01A             B.N      ??USB_DeviceHidEvent_3
    469                                  }
    470                                  else
    471                                  {
    472                                      report.reportBuffer = controlRequest->buffer;
   \                     ??USB_DeviceHidEvent_23: (+1)
   \   0000016C   0x6869             LDR      R1,[R5, #+4]
   \   0000016E   0x9100             STR      R1,[SP, #+0]
    473                                      report.reportLength = controlRequest->length;
    474                                      error = hidHandle->configStruct->classCallback((class_handle_t)hidHandle,
    475                                                                                     kUSB_DeviceHidEventSetReport, &report);
   \   00000170   0x466A             MOV      R2,SP
   \   00000172   0x68A9             LDR      R1,[R5, #+8]
   \   00000174   0x9101             STR      R1,[SP, #+4]
   \   00000176   0x2106             MOVS     R1,#+6
   \   00000178   0x6863             LDR      R3,[R4, #+4]
   \   0000017A   0x681B             LDR      R3,[R3, #+0]
   \   0000017C   0x4798             BLX      R3
   \   0000017E   0xE010             B.N      ??USB_DeviceHidEvent_3
    476                                  }
    477                                  break;
    478                              case USB_DEVICE_HID_REQUEST_SET_IDLE:
    479                                  /* Set idle request */
    480                                  {
    481                                      hidHandle->idleRate = (controlRequest->setup->wValue & 0xFF00U) >> 0x08U;
   \                     ??USB_DeviceHidEvent_18: (+1)
   \   00000180   0x8849             LDRH     R1,[R1, #+2]
   \   00000182   0x0A09             LSRS     R1,R1,#+8
   \   00000184   0x73E1             STRB     R1,[R4, #+15]
    482                                      error = hidHandle->configStruct->classCallback(
    483                                          (class_handle_t)hidHandle, kUSB_DeviceHidEventSetIdle, &controlRequest->setup->wValue);
   \   00000186   0x6829             LDR      R1,[R5, #+0]
   \   00000188   0x1C8A             ADDS     R2,R1,#+2
   \   0000018A   0x2107             MOVS     R1,#+7
   \   0000018C   0xE004             B.N      ??USB_DeviceHidEvent_24
    484                                  }
    485                                  break;
    486                              case USB_DEVICE_HID_REQUEST_SET_PROTOCOL:
    487                                  /* Set protocol request */
    488                                  {
    489                                      hidHandle->protocol = (controlRequest->setup->wValue & 0x00FFU);
   \                     ??USB_DeviceHidEvent_19: (+1)
   \   0000018E   0x8849             LDRH     R1,[R1, #+2]
   \   00000190   0x7421             STRB     R1,[R4, #+16]
    490                                      error = hidHandle->configStruct->classCallback(
    491                                          (class_handle_t)hidHandle, kUSB_DeviceHidEventSetProtocol, &hidHandle->protocol);
   \   00000192   0xF104 0x0210      ADD      R2,R4,#+16
   \   00000196   0x2108             MOVS     R1,#+8
   \                     ??USB_DeviceHidEvent_24: (+1)
   \   00000198   0x6863             LDR      R3,[R4, #+4]
   \   0000019A   0x681B             LDR      R3,[R3, #+0]
   \   0000019C   0x4798             BLX      R3
    492                                  }
    493                                  break;
   \   0000019E   0xE000             B.N      ??USB_DeviceHidEvent_3
    494                              default:
    495                                  error = kStatus_USB_InvalidRequest;
   \                     ??USB_DeviceHidEvent_20: (+1)
   \   000001A0   0x2005             MOVS     R0,#+5
    496                                  break;
    497                          }
    498                      }
    499                      break;
    500                  default:
    501                      break;
    502              }
    503              return error;
   \                     ??USB_DeviceHidEvent_3: (+1)
   \   000001A2   0xB004             ADD      SP,SP,#+16
   \   000001A4   0xBD70             POP      {R4-R6,PC}       ;; return
    504          }
    505          
    506          /*!
    507           * @brief Initialize the hid class.
    508           *
    509           * This function is used to initialize the hid class.
    510           *
    511           * @param controllerId   The controller id of the USB IP. Please refer to the enumeration usb_controller_index_t.
    512           * @param config          The class configuration information.
    513           * @param handle          It is out parameter, is used to return pointer of the hid class handle to the caller.
    514           *
    515           * @return A USB error code or kStatus_USB_Success.
    516           */

   \                                 In section .text, align 2, keep-with-next
    517          usb_status_t USB_DeviceHidInit(uint8_t controllerId, usb_device_class_config_struct_t *config, class_handle_t *handle)
    518          {
   \                     USB_DeviceHidInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
    519              usb_device_hid_struct_t *hidHandle;
    520              usb_status_t error = kStatus_USB_Error;
    521          
    522              /* Allocate a hid class handle. */
    523              error = USB_DeviceHidAllocateHandle(&hidHandle);
   \   00000006   0x2100             MOVS     R1,#+0
   \                     ??USB_DeviceHidInit_0: (+1)
   \   00000008   0x2314             MOVS     R3,#+20
   \   0000000A   0x....             LDR.N    R2,??DataTable1_2
   \   0000000C   0x434B             MULS     R3,R3,R1
   \   0000000E   0x18D6             ADDS     R6,R2,R3
   \   00000010   0x6832             LDR      R2,[R6, #+0]
   \   00000012   0xB122             CBZ.N    R2,??USB_DeviceHidInit_1
   \   00000014   0x1C49             ADDS     R1,R1,#+1
   \   00000016   0x2901             CMP      R1,#+1
   \   00000018   0xDBF6             BLT.N    ??USB_DeviceHidInit_0
   \   0000001A   0x2002             MOVS     R0,#+2
    524          
    525              if (kStatus_USB_Success != error)
    526              {
    527                  return error;
    528              }
    529          
    530              /* Get the device handle according to the controller id. */
    531              error = USB_DeviceClassGetDeviceHandle(controllerId, &hidHandle->handle);
    532          
    533              if (kStatus_USB_Success != error)
    534              {
    535                  return error;
   \   0000001C   0xBD70             POP      {R4-R6,PC}
    536              }
   \                     ??USB_DeviceHidInit_1: (+1)
   \   0000001E   0x4631             MOV      R1,R6
   \   00000020   0x.... 0x....      BL       USB_DeviceClassGetDeviceHandle
   \   00000024   0x0001             MOVS     R1,R0
   \   00000026   0xD10A             BNE.N    ??USB_DeviceHidInit_2
    537          
    538              if (!hidHandle->handle)
   \   00000028   0x6830             LDR      R0,[R6, #+0]
   \   0000002A   0xB908             CBNZ.N   R0,??USB_DeviceHidInit_3
    539              {
    540                  return kStatus_USB_InvalidHandle;
   \   0000002C   0x2003             MOVS     R0,#+3
   \   0000002E   0xBD70             POP      {R4-R6,PC}
    541              }
    542              /* Save the configuration of the class. */
    543              hidHandle->configStruct = config;
    544              /* Clear the configuration value. */
    545              hidHandle->configuration = 0U;
   \                     ??USB_DeviceHidInit_3: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x7330             STRB     R0,[R6, #+12]
   \   00000034   0x6074             STR      R4,[R6, #+4]
    546              hidHandle->alternate = 0xffU;
   \   00000036   0x20FF             MOVS     R0,#+255
   \   00000038   0x73B0             STRB     R0,[R6, #+14]
    547          
    548              *handle = (class_handle_t)hidHandle;
   \   0000003A   0x602E             STR      R6,[R5, #+0]
    549              return error;
   \   0000003C   0x2000             MOVS     R0,#+0
   \                     ??USB_DeviceHidInit_2: (+1)
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
    550          }
    551          
    552          /*!
    553           * @brief De-initialize the device hid class.
    554           *
    555           * The function de-initializes the device hid class.
    556           *
    557           * @param handle The hid class handle got from usb_device_class_config_struct_t::classHandle.
    558           *
    559           * @return A USB error code or kStatus_USB_Success.
    560           */

   \                                 In section .text, align 2, keep-with-next
    561          usb_status_t USB_DeviceHidDeinit(class_handle_t handle)
    562          {
   \                     USB_DeviceHidDeinit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    563              usb_device_hid_struct_t *hidHandle;
    564              usb_status_t error = kStatus_USB_Error;
    565          
    566              hidHandle = (usb_device_hid_struct_t *)handle;
    567          
    568              if (!hidHandle)
   \   00000004   0xD101             BNE.N    ??USB_DeviceHidDeinit_0
    569              {
    570                  return kStatus_USB_InvalidHandle;
   \   00000006   0x2003             MOVS     R0,#+3
   \   00000008   0xBD10             POP      {R4,PC}
    571              }
    572              /* De-initialzie the endpoints. */
    573              error = USB_DeviceHidEndpointsDeinit(hidHandle);
   \                     ??USB_DeviceHidDeinit_0: (+1)
   \   0000000A   0x.... 0x....      BL       USB_DeviceHidEndpointsDeinit
    574              /* Free the hid class handle. */
    575              USB_DeviceHidFreeHandle(hidHandle);
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x6021             STR      R1,[R4, #+0]
   \   00000012   0x6061             STR      R1,[R4, #+4]
   \   00000014   0x7321             STRB     R1,[R4, #+12]
   \   00000016   0x73A1             STRB     R1,[R4, #+14]
    576              return error;
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    577          }
    578          
    579          /*!
    580           * @brief Send data through a specified endpoint.
    581           *
    582           * The function is used to send data through a specified endpoint.
    583           * The function calls USB_DeviceSendRequest internally.
    584           *
    585           * @param handle The hid class handle got from usb_device_class_config_struct_t::classHandle.
    586           * @param ep     Endpoint index.
    587           * @param buffer The memory address to hold the data need to be sent.
    588           * @param length The data length need to be sent.
    589           *
    590           * @return A USB error code or kStatus_USB_Success.
    591           *
    592           * @note The return value just means if the sending request is successful or not; the transfer done is notified by
    593           * USB_DeviceHidInterruptIn.
    594           * Currently, only one transfer request can be supported for one specific endpoint.
    595           * If there is a specific requirement to support multiple transfer requests for one specific endpoint, the application
    596           * should implement a queue in the application level.
    597           * The subsequent transfer could begin only when the previous transfer is done (get notification through the endpoint
    598           * callback).
    599           */

   \                                 In section .text, align 2, keep-with-next
    600          usb_status_t USB_DeviceHidSend(class_handle_t handle, uint8_t ep, uint8_t *buffer, uint32_t length)
    601          {
   \                     USB_DeviceHidSend: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    602              usb_device_hid_struct_t *hidHandle;
    603              usb_status_t error = kStatus_USB_Error;
    604          
    605              if (!handle)
   \   00000004   0xD101             BNE.N    ??USB_DeviceHidSend_0
    606              {
    607                  return kStatus_USB_InvalidHandle;
   \   00000006   0x2003             MOVS     R0,#+3
   \   00000008   0xBD10             POP      {R4,PC}
    608              }
    609              hidHandle = (usb_device_hid_struct_t *)handle;
    610          
    611              if (hidHandle->interruptInPipeBusy)
   \                     ??USB_DeviceHidSend_0: (+1)
   \   0000000A   0x7C60             LDRB     R0,[R4, #+17]
   \   0000000C   0xB108             CBZ.N    R0,??USB_DeviceHidSend_1
    612              {
    613                  return kStatus_USB_Busy;
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD10             POP      {R4,PC}
    614              }
    615              error = USB_DeviceSendRequest(hidHandle->handle, ep, buffer, length);
   \                     ??USB_DeviceHidSend_1: (+1)
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       USB_DeviceSendRequest
    616              if (kStatus_USB_Success == error)
   \   00000018   0x0001             MOVS     R1,R0
   \   0000001A   0xBF04             ITT      EQ 
   \   0000001C   0x2101             MOVEQ    R1,#+1
   \   0000001E   0x7461             STRBEQ   R1,[R4, #+17]
    617              {
    618                  hidHandle->interruptInPipeBusy = 1U;
    619              }
    620              return error;
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    621          }
    622          
    623          /*!
    624           * @brief Receive data through a specified endpoint.
    625           *
    626           * The function is used to receive data through a specified endpoint.
    627           * The function calls USB_DeviceRecvRequest internally.
    628           *
    629           * @param handle The hid class handle got from usb_device_class_config_struct_t::classHandle.
    630           * @param ep     Endpoint index.
    631           * @param buffer The memory address to save the received data.
    632           * @param length The data length want to be received.
    633           *
    634           * @return A USB error code or kStatus_USB_Success.
    635           *
    636           * @note The return value just means if the receiving request is successful or not; the transfer done is notified by
    637           * USB_DeviceHidInterruptOut.
    638           * Currently, only one transfer request can be supported for one specific endpoint.
    639           * If there is a specific requirement to support multiple transfer requests for one specific endpoint, the application
    640           * should implement a queue in the application level.
    641           * The subsequent transfer could begin only when the previous transfer is done (get notification through the endpoint
    642           * callback).
    643           */

   \                                 In section .text, align 2, keep-with-next
    644          usb_status_t USB_DeviceHidRecv(class_handle_t handle, uint8_t ep, uint8_t *buffer, uint32_t length)
    645          {
   \                     USB_DeviceHidRecv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    646              usb_device_hid_struct_t *hidHandle;
    647              usb_status_t error = kStatus_USB_Error;
    648          
    649              if (!handle)
   \   00000004   0xD101             BNE.N    ??USB_DeviceHidRecv_0
    650              {
    651                  return kStatus_USB_InvalidHandle;
   \   00000006   0x2003             MOVS     R0,#+3
   \   00000008   0xBD10             POP      {R4,PC}
    652              }
    653              hidHandle = (usb_device_hid_struct_t *)handle;
    654          
    655              if (hidHandle->interruptOutPipeBusy)
   \                     ??USB_DeviceHidRecv_0: (+1)
   \   0000000A   0x7CA0             LDRB     R0,[R4, #+18]
   \   0000000C   0xB108             CBZ.N    R0,??USB_DeviceHidRecv_1
    656              {
    657                  return kStatus_USB_Busy;
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD10             POP      {R4,PC}
    658              }
    659              error = USB_DeviceRecvRequest(hidHandle->handle, ep, buffer, length);
   \                     ??USB_DeviceHidRecv_1: (+1)
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       USB_DeviceRecvRequest
    660              if (kStatus_USB_Success == error)
   \   00000018   0x0001             MOVS     R1,R0
   \   0000001A   0xBF04             ITT      EQ 
   \   0000001C   0x2101             MOVEQ    R1,#+1
   \   0000001E   0x74A1             STRBEQ   R1,[R4, #+18]
    661              {
    662                  hidHandle->interruptOutPipeBusy = 1U;
    663              }
    664              return error;
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    665          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     USB_DeviceHidInterruptOut

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     USB_DeviceHidInterruptIn

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     s_UsbDeviceHidHandle
    666          
    667          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   USB_DeviceHidDeinit
         8   -> USB_DeviceHidEndpointsDeinit
      16   USB_DeviceHidEndpointsDeinit
        16   -> USB_DeviceDeinitEndpoint
      40   USB_DeviceHidEndpointsInit
        40   -> USB_DeviceInitEndpoint
      32   USB_DeviceHidEvent
        32   -- Indirect call
        32   -> USB_DeviceHidEndpointsDeinit
        32   -> USB_DeviceHidEndpointsInit
        32   -> USB_DeviceStallEndpoint
        32   -> USB_DeviceUnstallEndpoint
      16   USB_DeviceHidInit
        16   -> USB_DeviceClassGetDeviceHandle
       8   USB_DeviceHidInterruptIn
         8   -- Indirect call
       8   USB_DeviceHidInterruptOut
         8   -- Indirect call
       8   USB_DeviceHidRecv
         8   -> USB_DeviceRecvRequest
       8   USB_DeviceHidSend
         8   -> USB_DeviceSendRequest


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
      26  USB_DeviceHidDeinit
      38  USB_DeviceHidEndpointsDeinit
     180  USB_DeviceHidEndpointsInit
     422  USB_DeviceHidEvent
      64  USB_DeviceHidInit
      36  USB_DeviceHidInterruptIn
      36  USB_DeviceHidInterruptOut
      34  USB_DeviceHidRecv
      34  USB_DeviceHidSend
      20  s_UsbDeviceHidHandle

 
 882 bytes in section .text
  20 bytes in section m_usb_global
 
 882 bytes of CODE memory
  20 bytes of DATA memory

Errors: none
Warnings: none
