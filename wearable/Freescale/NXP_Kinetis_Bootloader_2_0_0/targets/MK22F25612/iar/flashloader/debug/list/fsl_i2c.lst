###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Aug/2016  13:15:55
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\i2c\fsl_i2c.c
#    Command line =  
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\i2c\fsl_i2c.c"
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN256VDC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D BL_TARGET_RAM -lC
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj"
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices/MK22F25612\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/autobaud\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/osa\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/usb/device/class\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/bm_usb\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/devices\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/platform/CMSIS/Include\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/startup\"
#        -I "C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader/../../../../src/drivers/common\"
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\list\fsl_i2c.lst
#    Object file  =  
#        C:\Users\cwati\Documents\My
#        Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22F25612\iar\flashloader\debug\obj\fsl_i2c.o
#
###############################################################################

C:\Users\cwati\Documents\My Work\Freescale\Bootloader\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\i2c\fsl_i2c.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          #include "fsl_i2c.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_EnableClock(clock_ip_name_t)
   \                     CLOCK_EnableClock: (+1)
   \   00000000   0x0C01             LSRS     R1,R0,#+16
   \   00000002   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000006   0xF501 0x218E      ADD      R1,R1,#+290816
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0x680A             LDR      R2,[R1, #+0]
   \   0000000E   0xFA03 0xF000      LSL      R0,R3,R0
   \   00000012   0x4310             ORRS     R0,R0,R2
   \   00000014   0x6008             STR      R0,[R1, #+0]
   \   00000016   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_DisableClock(clock_ip_name_t)
   \                     CLOCK_DisableClock: (+1)
   \   00000000   0x0C01             LSRS     R1,R0,#+16
   \   00000002   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000006   0xF501 0x218E      ADD      R1,R1,#+290816
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0x680A             LDR      R2,[R1, #+0]
   \   0000000E   0xFA03 0xF000      LSL      R0,R3,R0
   \   00000012   0xEA22 0x0000      BIC      R0,R2,R0
   \   00000016   0x6008             STR      R0,[R1, #+0]
   \   00000018   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void EnableIRQ(IRQn_Type)
   \                     EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF000 0x021F      AND      R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable9  ;; 0xe000e100
   \   0000000C   0x0940             LSRS     R0,R0,#+5
   \   0000000E   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void I2C_Enable(I2C_Type *, bool)
   \                     I2C_Enable: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x7881             LDRB     R1,[R0, #+2]
   \   00000004   0xBF14             ITE      NE 
   \   00000006   0xF041 0x0180      ORRNE    R1,R1,#0x80
   \   0000000A   0xF001 0x017F      ANDEQ    R1,R1,#0x7F
   \   0000000E   0x7081             STRB     R1,[R0, #+2]
   \   00000010   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void I2C_MasterClearStatusFlags(I2C_Type *, uint32_t)
   \                     I2C_MasterClearStatusFlags: (+1)
   \   00000000   0x04CB             LSLS     R3,R1,#+19
   \   00000002   0xD503             BPL.N    ??I2C_MasterClearStatusFlags_0
   \   00000004   0x7983             LDRB     R3,[R0, #+6]
   \   00000006   0xEA43 0x2311      ORR      R3,R3,R1, LSR #+8
   \   0000000A   0x7183             STRB     R3,[R0, #+6]
   \                     ??I2C_MasterClearStatusFlags_0: (+1)
   \   0000000C   0x044B             LSLS     R3,R1,#+17
   \   0000000E   0xD503             BPL.N    ??I2C_MasterClearStatusFlags_1
   \   00000010   0x7983             LDRB     R3,[R0, #+6]
   \   00000012   0xEA43 0x2211      ORR      R2,R3,R1, LSR #+8
   \   00000016   0x7182             STRB     R2,[R0, #+6]
   \                     ??I2C_MasterClearStatusFlags_1: (+1)
   \   00000018   0x70C1             STRB     R1,[R0, #+3]
   \   0000001A   0x4770             BX       LR               ;; return
     31          
     32          /*******************************************************************************
     33           * Definitions
     34           ******************************************************************************/
     35          
     36          /*! @brief i2c transfer state. */
     37          enum _i2c_transfer_states
     38          {
     39              kIdleState = 0x0U,             /*!< I2C bus idle. */
     40              kCheckAddressState = 0x1U,     /*!< 7-bit address check state. */
     41              kSendCommandState = 0x2U,      /*!< Send command byte phase. */
     42              kSendDataState = 0x3U,         /*!< Send data transfer phase. */
     43              kReceiveDataBeginState = 0x4U, /*!< Receive data transfer phase begin. */
     44              kReceiveDataState = 0x5U,      /*!< Receive data transfer phase. */
     45          };
     46          
     47          /*! @brief Common sets of flags used by the driver. */
     48          enum _i2c_flag_constants
     49          {
     50          /*! All flags which are cleared by the driver upon starting a transfer. */
     51          #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
     52              kClearFlags = kI2C_ArbitrationLostFlag | kI2C_IntPendingFlag | kI2C_StartDetectFlag | kI2C_StopDetectFlag,
     53              kIrqFlags = kI2C_GlobalInterruptEnable | kI2C_StartStopDetectInterruptEnable,
     54          #elif defined(FSL_FEATURE_I2C_HAS_STOP_DETECT) && FSL_FEATURE_I2C_HAS_STOP_DETECT
     55              kClearFlags = kI2C_ArbitrationLostFlag | kI2C_IntPendingFlag | kI2C_StopDetectFlag,
     56              kIrqFlags = kI2C_GlobalInterruptEnable | kI2C_StopDetectInterruptEnable,
     57          #else
     58              kClearFlags = kI2C_ArbitrationLostFlag | kI2C_IntPendingFlag,
     59              kIrqFlags = kI2C_GlobalInterruptEnable,
     60          #endif
     61          
     62          };
     63          
     64          /*! @brief Typedef for interrupt handler. */
     65          typedef void (*i2c_isr_t)(I2C_Type *base, void *i2cHandle);
     66          
     67          /*******************************************************************************
     68           * Prototypes
     69           ******************************************************************************/
     70          
     71          /*!
     72           * @brief Get instance number for I2C module.
     73           *
     74           * @param base I2C peripheral base address.
     75           */
     76          uint32_t I2C_GetInstance(I2C_Type *base);
     77          
     78          /*!
     79           * @brief Set up master transfer, send slave address and decide the initial
     80           * transfer state.
     81           *
     82           * @param base I2C peripheral base address.
     83           * @param handle pointer to i2c_master_handle_t structure which stores the transfer state.
     84           * @param xfer pointer to i2c_master_transfer_t structure.
     85           */
     86          static status_t I2C_InitTransferStateMachine(I2C_Type *base, i2c_master_handle_t *handle, i2c_master_transfer_t *xfer);
     87          
     88          /*!
     89           * @brief Check and clear status operation.
     90           *
     91           * @param base I2C peripheral base address.
     92           * @param status current i2c hardware status.
     93           * @retval kStatus_Success No error found.
     94           * @retval kStatus_I2C_ArbitrationLost Transfer error, arbitration lost.
     95           * @retval kStatus_I2C_Nak Received Nak error.
     96           */
     97          static status_t I2C_CheckAndClearError(I2C_Type *base, uint32_t status);
     98          
     99          /*!
    100           * @brief Master run transfer state machine to perform a byte of transfer.
    101           *
    102           * @param base I2C peripheral base address.
    103           * @param handle pointer to i2c_master_handle_t structure which stores the transfer state
    104           * @param isDone input param to get whether the thing is done, true is done
    105           * @retval kStatus_Success No error found.
    106           * @retval kStatus_I2C_ArbitrationLost Transfer error, arbitration lost.
    107           * @retval kStatus_I2C_Nak Received Nak error.
    108           * @retval kStatus_I2C_Timeout Transfer error, wait signal timeout.
    109           */
    110          static status_t I2C_MasterTransferRunStateMachine(I2C_Type *base, i2c_master_handle_t *handle, bool *isDone);
    111          
    112          /*!
    113           * @brief I2C common interrupt handler.
    114           *
    115           * @param base I2C peripheral base address.
    116           * @param handle pointer to i2c_master_handle_t structure which stores the transfer state
    117           */
    118          static void I2C_TransferCommonIRQHandler(I2C_Type *base, void *handle);
    119          
    120          /*******************************************************************************
    121           * Variables
    122           ******************************************************************************/
    123          
    124          /*! @brief Pointers to i2c handles for each instance. */
    125          static void *s_i2cHandle[FSL_FEATURE_SOC_I2C_COUNT] = {NULL};
    126          
    127          /*! @brief SCL clock divider used to calculate baudrate. */

   \                                 In section .text, align 4, keep-with-next
    128          const uint16_t s_i2cDividerTable[] = {20,   22,   24,   26,   28,   30,   34,   40,   28,   32,   36,   40,  44,
   \                     s_i2cDividerTable:
   \   00000000   0x0014 0x0016      DC16 20, 22, 24, 26, 28, 30, 34, 40, 28, 32, 36, 40, 44, 48, 56, 68, 48
   \              0x0018 0x001A
   \              0x001C 0x001E
   \              0x0022 0x0028
   \              0x001C 0x0020
   \              0x0024 0x0028
   \              0x002C 0x0030
   \              0x0038 0x0044
   \              0x0030       
   \   00000022   0x0038 0x0040      DC16 56, 64, 72, 80, 88, 104, 128, 80, 96, 112, 128, 144, 160, 192, 240
   \              0x0048 0x0050
   \              0x0058 0x0068
   \              0x0080 0x0050
   \              0x0060 0x0070
   \              0x0080 0x0090
   \              0x00A0 0x00C0
   \              0x00F0       
   \   00000040   0x00A0 0x00C0      DC16 160, 192, 224, 256, 288, 320, 384, 480, 320, 384, 448, 512, 576
   \              0x00E0 0x0100
   \              0x0120 0x0140
   \              0x0180 0x01E0
   \              0x0140 0x0180
   \              0x01C0 0x0200
   \              0x0240       
   \   0000005A   0x0280 0x0300      DC16 640, 768, 960, 640, 768, 896, 1024, 1152, 1280, 1536, 1920, 1280
   \              0x03C0 0x0280
   \              0x0300 0x0380
   \              0x0400 0x0480
   \              0x0500 0x0600
   \              0x0780 0x0500
   \   00000072   0x0600 0x0700      DC16 1536, 1792, 2048, 2304, 2560, 3072, 3840
   \              0x0800 0x0900
   \              0x0A00 0x0C00
   \              0x0F00       
    129                                                48,   56,   68,   48,   56,   64,   72,   80,   88,   104,  128,  80,  96,
    130                                                112,  128,  144,  160,  192,  240,  160,  192,  224,  256,  288,  320, 384,
    131                                                480,  320,  384,  448,  512,  576,  640,  768,  960,  640,  768,  896, 1024,
    132                                                1152, 1280, 1536, 1920, 1280, 1536, 1792, 2048, 2304, 2560, 3072, 3840};
    133          
    134          /*! @brief Pointers to i2c bases for each instance. */

   \                                 In section .text, align 4, keep-with-next
    135          static I2C_Type *const s_i2cBases[] = I2C_BASE_PTRS;
   \                     s_i2cBases:
   \   00000000   0x40066000         DC32 40066000H, 40067000H
   \              0x40067000   
    136          
    137          /*! @brief Pointers to i2c IRQ number for each instance. */

   \                                 In section .text, align 4, keep-with-next
    138          const IRQn_Type s_i2cIrqs[] = I2C_IRQS;
   \                     s_i2cIrqs:
   \   00000000   0x18 0x19          DC8 24, 25
    139          
    140          /*! @brief Pointers to i2c clocks for each instance. */

   \                                 In section .text, align 4, keep-with-next
    141          const clock_ip_name_t s_i2cClocks[] = I2C_CLOCKS;
   \                     s_i2cClocks:
   \   00000000   0x10340006         DC32 271843334, 271843335
   \              0x10340007   

   \                                 In section .bss, align 4
   \                     s_i2cHandle:
   \   00000000                      DS8 8
   \   00000008                      DS8 4
   \   0000000C                      DS8 4
    142          
    143          /*! @brief Pointer to master IRQ handler for each instance. */
    144          static i2c_isr_t s_i2cMasterIsr;
    145          
    146          /*! @brief Pointer to slave IRQ handler for each instance. */
    147          static i2c_isr_t s_i2cSlaveIsr;
    148          
    149          /*******************************************************************************
    150           * Codes
    151           ******************************************************************************/
    152          

   \                                 In section .text, align 2, keep-with-next
    153          uint32_t I2C_GetInstance(I2C_Type *base)
    154          {
    155              uint32_t instance;
    156          
    157              /* Find the instance index from base address mappings. */
    158              for (instance = 0; instance < FSL_FEATURE_SOC_I2C_COUNT; instance++)
   \                     I2C_GetInstance: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x.... 0x....      ADR.W    R2,s_i2cBases
    159              {
    160                  if (s_i2cBases[instance] == base)
   \                     ??I2C_GetInstance_0: (+1)
   \   00000006   0xF852 0x3021      LDR      R3,[R2, R1, LSL #+2]
   \   0000000A   0x4283             CMP      R3,R0
   \   0000000C   0xD002             BEQ.N    ??I2C_GetInstance_1
    161                  {
    162                      break;
    163                  }
    164              }
   \   0000000E   0x1C49             ADDS     R1,R1,#+1
   \   00000010   0x2902             CMP      R1,#+2
   \   00000012   0xD3F8             BCC.N    ??I2C_GetInstance_0
    165          
    166              assert(instance < FSL_FEATURE_SOC_I2C_COUNT);
    167          
    168              return instance;
   \                     ??I2C_GetInstance_1: (+1)
   \   00000014   0x4608             MOV      R0,R1
   \   00000016   0x4770             BX       LR               ;; return
    169          }
    170          
    171          static status_t I2C_InitTransferStateMachine(I2C_Type *base, i2c_master_handle_t *handle, i2c_master_transfer_t *xfer)
    172          {
    173              status_t result = kStatus_Success;
    174              i2c_direction_t direction = xfer->direction;
    175              uint16_t timeout = UINT16_MAX;
    176          
    177              /* Initialize the handle transfer information. */
    178              handle->transfer = *xfer;
    179          
    180              /* Save total transfer size. */
    181              handle->transferSize = xfer->dataSize;
    182          
    183              /* Initial transfer state. */
    184              if (handle->transfer.subaddressSize > 0)
    185              {
    186                  handle->state = kSendCommandState;
    187                  if (xfer->direction == kI2C_Read)
    188                  {
    189                      direction = kI2C_Write;
    190                  }
    191              }
    192              else
    193              {
    194                  handle->state = kCheckAddressState;
    195              }
    196          
    197              /* Wait until the data register is ready for transmit. */
    198              while ((!(base->S & kI2C_TransferCompleteFlag)) && (--timeout))
    199              {
    200              }
    201          
    202              /* Failed to start the transfer. */
    203              if (timeout == 0)
    204              {
    205                  return kStatus_I2C_Timeout;
    206              }
    207          
    208              /* Clear all status before transfer. */
    209              I2C_MasterClearStatusFlags(base, kClearFlags);
    210          
    211              /* If repeated start is requested, send repeated start. */
    212              if (handle->transfer.flags & kI2C_TransferRepeatedStartFlag)
    213              {
    214                  result = I2C_MasterRepeatedStart(base, handle->transfer.slaveAddress, direction);
    215              }
    216              else /* For normal transfer, send start. */
    217              {
    218                  result = I2C_MasterStart(base, handle->transfer.slaveAddress, direction);
    219              }
    220          
    221              return result;
    222          }
    223          

   \                                 In section .text, align 2, keep-with-next
    224          static status_t I2C_CheckAndClearError(I2C_Type *base, uint32_t status)
    225          {
    226              status_t result = kStatus_Success;
   \                     I2C_CheckAndClearError: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    227          
    228              /* Check arbitration lost. */
    229              if (status & kI2C_ArbitrationLostFlag)
   \   00000002   0x06CB             LSLS     R3,R1,#+27
   \   00000004   0xD504             BPL.N    ??I2C_CheckAndClearError_0
    230              {
    231                  /* Clear arbitration lost flag. */
    232                  base->S = kI2C_ArbitrationLostFlag;
   \   00000006   0x2110             MOVS     R1,#+16
   \   00000008   0x70C1             STRB     R1,[R0, #+3]
    233                  result = kStatus_I2C_ArbitrationLost;
   \   0000000A   0xF240 0x424F      MOVW     R2,#+1103
   \   0000000E   0xE003             B.N      ??I2C_CheckAndClearError_1
    234              }
    235              /* Check NAK */
    236              else if (status & kI2C_ReceiveNakFlag)
   \                     ??I2C_CheckAndClearError_0: (+1)
   \   00000010   0x07C8             LSLS     R0,R1,#+31
   \   00000012   0xBF48             IT       MI 
   \   00000014   0xF240 0x424E      MOVWMI   R2,#+1102
    237              {
    238                  result = kStatus_I2C_Nak;
    239              }
    240              else
    241              {
    242              }
    243          
    244              return result;
   \                     ??I2C_CheckAndClearError_1: (+1)
   \   00000018   0x4610             MOV      R0,R2
   \   0000001A   0x4770             BX       LR               ;; return
    245          }
    246          

   \                                 In section .text, align 4, keep-with-next
    247          static status_t I2C_MasterTransferRunStateMachine(I2C_Type *base, i2c_master_handle_t *handle, bool *isDone)
    248          {
   \                     I2C_MasterTransferRunStateMachine: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0xB082             SUB      SP,SP,#+8
   \   00000008   0x4616             MOV      R6,R2
    249              status_t result = kStatus_Success;
    250              uint32_t statusFlags = base->S;
   \   0000000A   0xF895 0x8003      LDRB     R8,[R5, #+3]
    251              *isDone = false;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x7030             STRB     R0,[R6, #+0]
   \   00000012   0x460C             MOV      R4,R1
    252              volatile uint8_t dummy = 0;
   \   00000014   0xF88D 0x0000      STRB     R0,[SP, #+0]
    253              bool ignoreNak = ((handle->state == kSendDataState) && (handle->transfer.dataSize == 0U)) ||
    254                               ((handle->state == kReceiveDataState) && (handle->transfer.dataSize == 1U));
   \   00000018   0x7F20             LDRB     R0,[R4, #+28]
   \   0000001A   0x2803             CMP      R0,#+3
   \   0000001C   0xD104             BNE.N    ??I2C_MasterTransferRunStateMachine_1
   \   0000001E   0x6960             LDR      R0,[R4, #+20]
   \   00000020   0x1E47             SUBS     R7,R0,#+1
   \   00000022   0x41BF             SBCS     R7,R7,R7
   \   00000024   0x0FFF             LSRS     R7,R7,#+31
   \   00000026   0xE005             B.N      ??I2C_MasterTransferRunStateMachine_2
   \                     ??I2C_MasterTransferRunStateMachine_1: (+1)
   \   00000028   0x2805             CMP      R0,#+5
   \   0000002A   0xBF03             ITTTE    EQ 
   \   0000002C   0x6960             LDREQ    R0,[R4, #+20]
   \   0000002E   0x2801             CMPEQ    R0,#+1
   \   00000030   0x2701             MOVEQ    R7,#+1
   \   00000032   0x2700             MOVNE    R7,#+0
    255          
    256              /* Add this to avoid build warning. */
    257              dummy++;
   \                     ??I2C_MasterTransferRunStateMachine_2: (+1)
   \   00000034   0x.... 0x....      BL       ?Subroutine7
    258          
    259              /* Check & clear error flags. */
    260              result = I2C_CheckAndClearError(base, statusFlags);
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000038   0x4641             MOV      R1,R8
   \   0000003A   0x4628             MOV      R0,R5
   \   0000003C   0x.... 0x....      BL       I2C_CheckAndClearError
    261          
    262              /* Ignore Nak when it's appeared for last byte. */
    263              if ((result == kStatus_I2C_Nak) && ignoreNak)
   \   00000040   0xF240 0x414E      MOVW     R1,#+1102
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD103             BNE.N    ??I2C_MasterTransferRunStateMachine_3
   \   00000048   0x2F00             CMP      R7,#+0
   \   0000004A   0xD064             BEQ.N    ??I2C_MasterTransferRunStateMachine_4
    264              {
    265                  result = kStatus_Success;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xE001             B.N      ??I2C_MasterTransferRunStateMachine_5
    266              }
    267          
    268              if (result)
   \                     ??I2C_MasterTransferRunStateMachine_3: (+1)
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD160             BNE.N    ??I2C_MasterTransferRunStateMachine_4
    269              {
    270                  return result;
    271              }
    272          
    273              /* Handle Check address state to check the slave address is Acked in slave
    274                 probe application. */
    275              if (handle->state == kCheckAddressState)
   \                     ??I2C_MasterTransferRunStateMachine_5: (+1)
   \   00000054   0x7F22             LDRB     R2,[R4, #+28]
   \   00000056   0x2A01             CMP      R2,#+1
   \   00000058   0xD119             BNE.N    ??I2C_MasterTransferRunStateMachine_6
    276              {
    277                  if (statusFlags & kI2C_ReceiveNakFlag)
   \   0000005A   0xEA5F 0x72C8      LSLS     R2,R8,#+31
   \   0000005E   0xBF48             IT       MI 
   \   00000060   0x4608             MOVMI    R0,R1
    278                  {
    279                      return kStatus_I2C_Nak;
   \   00000062   0xD458             BMI.N    ??I2C_MasterTransferRunStateMachine_4
    280                  }
    281                  else
    282                  {
    283                      if (handle->transfer.direction == kI2C_Write)
   \   00000064   0x7961             LDRB     R1,[R4, #+5]
   \   00000066   0xB929             CBNZ.N   R1,??I2C_MasterTransferRunStateMachine_7
    284                      {
    285                          /* Next state, send data. */
    286                          handle->state = kSendDataState;
   \   00000068   0x2103             MOVS     R1,#+3
   \   0000006A   0x7721             STRB     R1,[R4, #+28]
    287                      }
    288                      else
    289                      {
    290                          /* Next state, receive data begin. */
    291                          handle->state = kReceiveDataBeginState;
    292                      }
    293                  }
    294              }
    295          
    296              /* Run state machine. */
    297              switch (handle->state)
    298              {
    299                  /* Send I2C command. */
    300                  case kSendCommandState:
    301                      if (handle->transfer.subaddressSize)
    302                      {
    303                          handle->transfer.subaddressSize--;
    304                          base->D = ((handle->transfer.subaddress) >> (8 * handle->transfer.subaddressSize));
    305                      }
    306                      else
    307                      {
    308                          if (handle->transfer.direction == kI2C_Write)
    309                          {
    310                              /* Next state, send data. */
    311                              handle->state = kSendDataState;
    312          
    313                              /* Send first byte of data. */
    314                              if (handle->transfer.dataSize > 0)
    315                              {
    316                                  base->D = *handle->transfer.data;
    317                                  handle->transfer.data++;
    318                                  handle->transfer.dataSize--;
    319                              }
    320                          }
    321                          else
    322                          {
    323                              /* Send repeated start and slave address. */
    324                              result = I2C_MasterRepeatedStart(base, handle->transfer.slaveAddress, kI2C_Read);
    325          
    326                              /* Next state, receive data begin. */
    327                              handle->state = kReceiveDataBeginState;
    328                          }
    329                      }
    330                      break;
    331          
    332                  /* Send I2C data. */
    333                  case kSendDataState:
    334                      /* Send one byte of data. */
    335                      if (handle->transfer.dataSize > 0)
   \                     ??I2C_MasterTransferRunStateMachine_8: (+1)
   \   0000006C   0x6961             LDR      R1,[R4, #+20]
   \   0000006E   0x2900             CMP      R1,#+0
   \   00000070   0xD038             BEQ.N    ??I2C_MasterTransferRunStateMachine_9
    336                      {
    337                          base->D = *handle->transfer.data;
   \   00000072   0xE025             B.N      ??I2C_MasterTransferRunStateMachine_10
    338                          handle->transfer.data++;
    339                          handle->transfer.dataSize--;
    340                      }
   \                     ??I2C_MasterTransferRunStateMachine_7: (+1)
   \   00000074   0x2104             MOVS     R1,#+4
   \   00000076   0x7721             STRB     R1,[R4, #+28]
    341                      else
    342                      {
    343                          *isDone = true;
    344                      }
    345                      break;
    346          
    347                  /* Start I2C data receive. */
    348                  case kReceiveDataBeginState:
    349                      base->C1 &= ~(I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
   \                     ??I2C_MasterTransferRunStateMachine_11: (+1)
   \   00000078   0x78A9             LDRB     R1,[R5, #+2]
   \   0000007A   0xF001 0x01E7      AND      R1,R1,#0xE7
   \   0000007E   0x70A9             STRB     R1,[R5, #+2]
    350          
    351                      /* Send nak at the last receive byte. */
    352                      if (handle->transfer.dataSize == 1)
   \   00000080   0x.... 0x....      BL       ?Subroutine5
    353                      {
    354                          base->C1 |= I2C_C1_TXAK_MASK;
    355                      }
    356          
    357                      /* Read dummy to release the bus. */
    358                      dummy = base->D;
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000084   0x7929             LDRB     R1,[R5, #+4]
   \   00000086   0xF88D 0x1000      STRB     R1,[SP, #+0]
    359          
    360                      /* Next state, receive data. */
    361                      handle->state = kReceiveDataState;
   \   0000008A   0x2105             MOVS     R1,#+5
   \   0000008C   0xE028             B.N      ??I2C_MasterTransferRunStateMachine_12
   \                     ??I2C_MasterTransferRunStateMachine_6: (+1)
   \   0000008E   0x1E92             SUBS     R2,R2,#+2
   \   00000090   0x2A03             CMP      R2,#+3
   \   00000092   0xD840             BHI.N    ??I2C_MasterTransferRunStateMachine_4
   \   00000094   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??I2C_MasterTransferRunStateMachine_0:
   \   00000098   0x04 0x03          DC8      0x4,0x3,0x2,0x29
   \              0x02 0x29    
   \                     ??I2C_MasterTransferRunStateMachine_13: (+1)
   \   0000009C   0xE7EC             B.N      ??I2C_MasterTransferRunStateMachine_11
   \                     ??I2C_MasterTransferRunStateMachine_14: (+1)
   \   0000009E   0xE7E5             B.N      ??I2C_MasterTransferRunStateMachine_8
   \                     ??I2C_MasterTransferRunStateMachine_15: (+1)
   \   000000A0   0x7B21             LDRB     R1,[R4, #+12]
   \   000000A2   0x000A             MOVS     R2,R1
   \   000000A4   0xD006             BEQ.N    ??I2C_MasterTransferRunStateMachine_16
   \   000000A6   0x1E49             SUBS     R1,R1,#+1
   \   000000A8   0x7321             STRB     R1,[R4, #+12]
   \   000000AA   0x00C9             LSLS     R1,R1,#+3
   \   000000AC   0x68A2             LDR      R2,[R4, #+8]
   \   000000AE   0x40CA             LSRS     R2,R2,R1
   \   000000B0   0x712A             STRB     R2,[R5, #+4]
   \   000000B2   0xE030             B.N      ??I2C_MasterTransferRunStateMachine_4
   \                     ??I2C_MasterTransferRunStateMachine_16: (+1)
   \   000000B4   0x7961             LDRB     R1,[R4, #+5]
   \   000000B6   0xB969             CBNZ.N   R1,??I2C_MasterTransferRunStateMachine_17
   \   000000B8   0x2103             MOVS     R1,#+3
   \   000000BA   0x7721             STRB     R1,[R4, #+28]
   \   000000BC   0x6961             LDR      R1,[R4, #+20]
   \   000000BE   0xB351             CBZ.N    R1,??I2C_MasterTransferRunStateMachine_4
   \                     ??I2C_MasterTransferRunStateMachine_10: (+1)
   \   000000C0   0x6921             LDR      R1,[R4, #+16]
   \   000000C2   0x7809             LDRB     R1,[R1, #+0]
   \   000000C4   0x7129             STRB     R1,[R5, #+4]
   \   000000C6   0x6921             LDR      R1,[R4, #+16]
   \   000000C8   0x1C49             ADDS     R1,R1,#+1
   \   000000CA   0x6121             STR      R1,[R4, #+16]
   \   000000CC   0x6961             LDR      R1,[R4, #+20]
   \   000000CE   0x1E49             SUBS     R1,R1,#+1
   \   000000D0   0x6161             STR      R1,[R4, #+20]
   \   000000D2   0xE020             B.N      ??I2C_MasterTransferRunStateMachine_4
   \                     ??I2C_MasterTransferRunStateMachine_17: (+1)
   \   000000D4   0x7921             LDRB     R1,[R4, #+4]
   \   000000D6   0x2201             MOVS     R2,#+1
   \   000000D8   0x4628             MOV      R0,R5
   \   000000DA   0x.... 0x....      BL       I2C_MasterRepeatedStart
   \   000000DE   0x2104             MOVS     R1,#+4
   \                     ??I2C_MasterTransferRunStateMachine_12: (+1)
   \   000000E0   0x7721             STRB     R1,[R4, #+28]
   \   000000E2   0xE018             B.N      ??I2C_MasterTransferRunStateMachine_4
   \                     ??I2C_MasterTransferRunStateMachine_9: (+1)
   \   000000E4   0x2101             MOVS     R1,#+1
   \   000000E6   0x7031             STRB     R1,[R6, #+0]
   \   000000E8   0xE015             B.N      ??I2C_MasterTransferRunStateMachine_4
    362                      break;
    363          
    364                  /* Receive I2C data. */
    365                  case kReceiveDataState:
    366                      /* Receive one byte of data. */
    367                      if (handle->transfer.dataSize--)
   \                     ??I2C_MasterTransferRunStateMachine_18: (+1)
   \   000000EA   0x6961             LDR      R1,[R4, #+20]
   \   000000EC   0x1E4A             SUBS     R2,R1,#+1
   \   000000EE   0x6162             STR      R2,[R4, #+20]
   \   000000F0   0xB189             CBZ.N    R1,??I2C_MasterTransferRunStateMachine_4
    368                      {
    369                          if (handle->transfer.dataSize == 0)
   \   000000F2   0x6961             LDR      R1,[R4, #+20]
   \   000000F4   0xB939             CBNZ.N   R1,??I2C_MasterTransferRunStateMachine_19
    370                          {
    371                              *isDone = true;
   \   000000F6   0x2101             MOVS     R1,#+1
   \   000000F8   0x7031             STRB     R1,[R6, #+0]
    372          
    373                              /* Send stop if kI2C_TransferNoStop is not asserted. */
    374                              if (!(handle->transfer.flags & kI2C_TransferNoStopFlag))
   \   000000FA   0x7821             LDRB     R1,[R4, #+0]
   \   000000FC   0x0749             LSLS     R1,R1,#+29
   \   000000FE   0xBF5C             ITT      PL 
    375                              {
    376                                  result = I2C_MasterStop(base);
   \   00000100   0x4628             MOVPL    R0,R5
   \   00000102   0x.... 0x....      BLPL     I2C_MasterStop
    377                              }
    378                          }
    379          
    380                          /* Send NAK at the last receive byte. */
    381                          if (handle->transfer.dataSize == 1)
   \                     ??I2C_MasterTransferRunStateMachine_19: (+1)
   \   00000106   0x.... 0x....      BL       ?Subroutine5
    382                          {
    383                              base->C1 |= I2C_C1_TXAK_MASK;
    384                          }
    385          
    386                          /* Read the data byte into the transfer buffer. */
    387                          *handle->transfer.data = base->D;
   \                     ??CrossCallReturnLabel_3: (+1)
   \   0000010A   0x6921             LDR      R1,[R4, #+16]
   \   0000010C   0x792A             LDRB     R2,[R5, #+4]
   \   0000010E   0x700A             STRB     R2,[R1, #+0]
    388                          handle->transfer.data++;
   \   00000110   0x6921             LDR      R1,[R4, #+16]
   \   00000112   0x1C49             ADDS     R1,R1,#+1
   \   00000114   0x6121             STR      R1,[R4, #+16]
    389                      }
    390                      break;
    391          
    392                  default:
    393                      break;
    394              }
    395          
    396              return result;
   \                     ??I2C_MasterTransferRunStateMachine_4: (+1)
   \   00000116   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    397          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x6961             LDR      R1,[R4, #+20]
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD103             BNE.N    ??Subroutine5_0
   \   00000006   0x78A9             LDRB     R1,[R5, #+2]
   \   00000008   0xF041 0x0108      ORR      R1,R1,#0x8
   \   0000000C   0x70A9             STRB     R1,[R5, #+2]
   \                     ??Subroutine5_0: (+1)
   \   0000000E   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000000A   0x4770             BX       LR
    398          

   \                                 In section .text, align 2, keep-with-next
    399          static void I2C_TransferCommonIRQHandler(I2C_Type *base, void *handle)
    400          {
    401              /* Check if master interrupt. */
    402              if ((base->S & kI2C_ArbitrationLostFlag) || (base->C1 & I2C_C1_MST_MASK))
   \                     I2C_TransferCommonIRQHandler: (+1)
   \   00000000   0x78C3             LDRB     R3,[R0, #+3]
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable9_1
   \   00000006   0x06DB             LSLS     R3,R3,#+27
   \   00000008   0xD402             BMI.N    ??I2C_TransferCommonIRQHandler_0
   \   0000000A   0x7883             LDRB     R3,[R0, #+2]
   \   0000000C   0x069B             LSLS     R3,R3,#+26
   \   0000000E   0xD501             BPL.N    ??I2C_TransferCommonIRQHandler_1
    403              {
    404                  s_i2cMasterIsr(base, handle);
   \                     ??I2C_TransferCommonIRQHandler_0: (+1)
   \   00000010   0x6892             LDR      R2,[R2, #+8]
   \   00000012   0x4710             BX       R2
    405              }
    406              else
    407              {
    408                  s_i2cSlaveIsr(base, handle);
   \                     ??I2C_TransferCommonIRQHandler_1: (+1)
   \   00000014   0x68D2             LDR      R2,[R2, #+12]
   \   00000016   0x4710             BX       R2
    409              }
    410          }
    411          

   \                                 In section .text, align 2, keep-with-next
    412          void I2C_MasterInit(I2C_Type *base, const i2c_master_config_t *masterConfig, uint32_t srcClock_Hz)
    413          {
   \                     I2C_MasterInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    414              assert(masterConfig && srcClock_Hz);
    415          
    416              /* Temporary register for filter read. */
    417              uint8_t fltReg;
    418          #if defined(FSL_FEATURE_I2C_HAS_HIGH_DRIVE_SELECTION) && FSL_FEATURE_I2C_HAS_HIGH_DRIVE_SELECTION
    419              uint8_t c2Reg;
    420          #endif
    421          
    422              /* Enable I2C clock. */
    423              CLOCK_EnableClock(s_i2cClocks[I2C_GetInstance(base)]);
   \   00000008   0x.... 0x....      BL       I2C_GetInstance
   \   0000000C   0x.... 0x....      BL       ?Subroutine9
    424          
    425              /* Disable I2C prior to configuring it. */
    426              base->C1 &= ~(I2C_C1_IICEN_MASK);
   \                     ??CrossCallReturnLabel_11: (+1)
   \   00000010   0x78A0             LDRB     R0,[R4, #+2]
   \   00000012   0xF000 0x007F      AND      R0,R0,#0x7F
   \   00000016   0x70A0             STRB     R0,[R4, #+2]
    427          
    428              /* Clear all flags. */
    429              I2C_MasterClearStatusFlags(base, kClearFlags);
   \   00000018   0xF245 0x0112      MOVW     R1,#+20498
   \   0000001C   0x.... 0x....      BL       ?Subroutine10
    430          
    431              /* Configure baud rate. */
    432              I2C_MasterSetBaudRate(base, masterConfig->baudRate_Bps, srcClock_Hz);
   \                     ??CrossCallReturnLabel_15: (+1)
   \   00000020   0x6869             LDR      R1,[R5, #+4]
   \   00000022   0x4632             MOV      R2,R6
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       I2C_MasterSetBaudRate
    433          
    434          #if defined(FSL_FEATURE_I2C_HAS_HIGH_DRIVE_SELECTION) && FSL_FEATURE_I2C_HAS_HIGH_DRIVE_SELECTION
    435              /* Configure high drive feature. */
    436              c2Reg = base->C2;
    437              c2Reg &= ~(I2C_C2_HDRS_MASK);
    438              c2Reg |= I2C_C2_HDRS(masterConfig->enableHighDrive);
    439              base->C2 = c2Reg;
   \   0000002A   0x7960             LDRB     R0,[R4, #+5]
   \   0000002C   0x7869             LDRB     R1,[R5, #+1]
   \   0000002E   0x.... 0x....      BL       ?Subroutine12
    440          #endif
    441          
    442              /* Read out the FLT register. */
    443              fltReg = base->FLT;
    444          
    445          #if defined(FSL_FEATURE_I2C_HAS_STOP_HOLD_OFF) && FSL_FEATURE_I2C_HAS_STOP_HOLD_OFF
    446              /* Configure the stop / hold enable. */
    447              fltReg &= ~(I2C_FLT_SHEN_MASK);
    448              fltReg |= I2C_FLT_SHEN(masterConfig->enableStopHold);
    449          #endif
    450          
    451              /* Configure the glitch filter value. */
    452              fltReg &= ~(I2C_FLT_FLT_MASK);
    453              fltReg |= I2C_FLT_FLT(masterConfig->glitchFilterWidth);
    454          
    455              /* Write the register value back to the filter register. */
    456              base->FLT = fltReg;
   \                     ??CrossCallReturnLabel_20: (+1)
   \   00000032   0x79A0             LDRB     R0,[R4, #+6]
   \   00000034   0x78A9             LDRB     R1,[R5, #+2]
   \   00000036   0xF000 0x007F      AND      R0,R0,#0x7F
   \   0000003A   0xEA40 0x10C1      ORR      R0,R0,R1, LSL #+7
   \   0000003E   0x7A29             LDRB     R1,[R5, #+8]
   \   00000040   0xF000 0x00F0      AND      R0,R0,#0xF0
   \   00000044   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000048   0x4308             ORRS     R0,R1,R0
   \   0000004A   0x71A0             STRB     R0,[R4, #+6]
    457          
    458              /* Enable the I2C peripheral based on the configuration. */
    459              base->C1 = I2C_C1_IICEN(masterConfig->enableMaster);
   \   0000004C   0x7828             LDRB     R0,[R5, #+0]
   \   0000004E   0x01C0             LSLS     R0,R0,#+7
   \   00000050   0x70A0             STRB     R0,[R4, #+2]
    460          }
   \   00000052   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \   00000000   0xF000 0x00DF      AND      R0,R0,#0xDF
   \   00000004   0xEA40 0x1041      ORR      R0,R0,R1, LSL #+5
   \   00000008   0x7160             STRB     R0,[R4, #+5]
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \   00000000   0x.... 0x....      ADR.W    R1,s_i2cClocks
   \   00000004   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000008   0x....             B.N      CLOCK_EnableClock

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \   00000000   0x4620             MOV      R0,R4
   \   00000002   0x....             B.N      I2C_MasterClearStatusFlags
    461          

   \                                 In section .text, align 2, keep-with-next
    462          void I2C_MasterDeinit(I2C_Type *base)
   \                     I2C_MasterDeinit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x....             B.N      ?Subroutine2

   \                                 In section .text, align 2, keep-with-next
    463          {
   \                     ?Subroutine2: (+1)
   \   00000000   0x4604             MOV      R4,R0
    464              /* Disable I2C module. */
    465              I2C_Enable(base, false);
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      BL       I2C_Enable
    466          
    467              /* Disable I2C clock. */
    468              CLOCK_DisableClock(s_i2cClocks[I2C_GetInstance(base)]);
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       I2C_GetInstance
   \   0000000E   0x.... 0x....      ADR.W    R1,s_i2cClocks
   \   00000012   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000016   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001A   0x....             B.N      CLOCK_DisableClock
    469          }
    470          

   \                                 In section .text, align 2, keep-with-next
    471          void I2C_MasterGetDefaultConfig(i2c_master_config_t *masterConfig)
    472          {
    473              assert(masterConfig);
    474          
    475              /* Default baud rate at 100kbps. */
    476              masterConfig->baudRate_Bps = 100000U;
   \                     I2C_MasterGetDefaultConfig: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x186a0
   \   00000004   0x6041             STR      R1,[R0, #+4]
    477          
    478          /* Default pin high drive is disabled. */
    479          #if defined(FSL_FEATURE_I2C_HAS_HIGH_DRIVE_SELECTION) && FSL_FEATURE_I2C_HAS_HIGH_DRIVE_SELECTION
    480              masterConfig->enableHighDrive = false;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x7041             STRB     R1,[R0, #+1]
    481          #endif
    482          
    483          /* Default stop hold enable is disabled. */
    484          #if defined(FSL_FEATURE_I2C_HAS_STOP_HOLD_OFF) && FSL_FEATURE_I2C_HAS_STOP_HOLD_OFF
    485              masterConfig->enableStopHold = false;
   \   0000000A   0x7081             STRB     R1,[R0, #+2]
    486          #endif
    487          
    488              /* Default glitch filter value is no filter. */
    489              masterConfig->glitchFilterWidth = 0U;
   \   0000000C   0x7201             STRB     R1,[R0, #+8]
    490          
    491              /* Enable the I2C peripheral. */
    492              masterConfig->enableMaster = true;
   \   0000000E   0x....             B.N      ?Subroutine0
    493          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x7001             STRB     R1,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    494          

   \                                 In section .text, align 2, keep-with-next
    495          void I2C_EnableInterrupts(I2C_Type *base, uint32_t mask)
    496          {
    497              if (mask & kI2C_GlobalInterruptEnable)
   \                     I2C_EnableInterrupts: (+1)
   \   00000000   0x064A             LSLS     R2,R1,#+25
   \   00000002   0xD503             BPL.N    ??I2C_EnableInterrupts_0
    498              {
    499                  base->C1 |= I2C_C1_IICIE_MASK;
   \   00000004   0x7882             LDRB     R2,[R0, #+2]
   \   00000006   0xF042 0x0240      ORR      R2,R2,#0x40
   \   0000000A   0x7082             STRB     R2,[R0, #+2]
    500              }
    501          
    502          #if defined(FSL_FEATURE_I2C_HAS_STOP_DETECT) && FSL_FEATURE_I2C_HAS_STOP_DETECT
    503              if (mask & kI2C_StopDetectInterruptEnable)
    504              {
    505                  base->FLT |= I2C_FLT_STOPIE_MASK;
    506              }
    507          #endif /* FSL_FEATURE_I2C_HAS_STOP_DETECT */
    508          
    509          #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
    510              if (mask & kI2C_StartStopDetectInterruptEnable)
   \                     ??I2C_EnableInterrupts_0: (+1)
   \   0000000C   0x0689             LSLS     R1,R1,#+26
   \   0000000E   0xD503             BPL.N    ??I2C_EnableInterrupts_1
    511              {
    512                  base->FLT |= I2C_FLT_SSIE_MASK;
   \   00000010   0x7981             LDRB     R1,[R0, #+6]
   \   00000012   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000016   0x7181             STRB     R1,[R0, #+6]
    513              }
    514          #endif /* FSL_FEATURE_I2C_HAS_START_STOP_DETECT */
    515          }
   \                     ??I2C_EnableInterrupts_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    516          

   \                                 In section .text, align 2, keep-with-next
    517          void I2C_DisableInterrupts(I2C_Type *base, uint32_t mask)
    518          {
    519              if (mask & kI2C_GlobalInterruptEnable)
   \                     I2C_DisableInterrupts: (+1)
   \   00000000   0x064A             LSLS     R2,R1,#+25
   \   00000002   0xD503             BPL.N    ??I2C_DisableInterrupts_0
    520              {
    521                  base->C1 &= ~I2C_C1_IICIE_MASK;
   \   00000004   0x7882             LDRB     R2,[R0, #+2]
   \   00000006   0xF002 0x02BF      AND      R2,R2,#0xBF
   \   0000000A   0x7082             STRB     R2,[R0, #+2]
    522              }
    523          
    524          #if defined(FSL_FEATURE_I2C_HAS_STOP_DETECT) && FSL_FEATURE_I2C_HAS_STOP_DETECT
    525              if (mask & kI2C_StopDetectInterruptEnable)
    526              {
    527                  base->FLT &= ~I2C_FLT_STOPIE_MASK;
    528              }
    529          #endif /* FSL_FEATURE_I2C_HAS_STOP_DETECT */
    530          
    531          #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
    532              if (mask & kI2C_StartStopDetectInterruptEnable)
   \                     ??I2C_DisableInterrupts_0: (+1)
   \   0000000C   0x0689             LSLS     R1,R1,#+26
   \   0000000E   0xD503             BPL.N    ??I2C_DisableInterrupts_1
    533              {
    534                  base->FLT &= ~I2C_FLT_SSIE_MASK;
   \   00000010   0x7981             LDRB     R1,[R0, #+6]
   \   00000012   0xF001 0x01DF      AND      R1,R1,#0xDF
   \   00000016   0x7181             STRB     R1,[R0, #+6]
    535              }
    536          #endif /* FSL_FEATURE_I2C_HAS_START_STOP_DETECT */
    537          }
   \                     ??I2C_DisableInterrupts_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    538          

   \                                 In section .text, align 2, keep-with-next
    539          void I2C_MasterSetBaudRate(I2C_Type *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz)
    540          {
   \                     I2C_MasterSetBaudRate: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    541              uint32_t multiplier;
    542              uint32_t computedRate;
    543              uint32_t absError;
    544              uint32_t bestError = UINT32_MAX;
   \   00000004   0xF04F 0x33FF      MOV      R3,#-1
    545              uint32_t bestMult = 0u;
   \   00000008   0x2400             MOVS     R4,#+0
    546              uint32_t bestIcr = 0u;
   \   0000000A   0x2500             MOVS     R5,#+0
    547              uint8_t mult;
    548              uint8_t i;
    549          
    550              /* Search for the settings with the lowest error. Mult is the MULT field of the I2C_F register,
    551               * and ranges from 0-2. It selects the multiplier factor for the divider. */
    552              for (mult = 0u; (mult <= 2u) && (bestError != 0); ++mult)
   \   0000000C   0x2600             MOVS     R6,#+0
   \   0000000E   0x.... 0x....      ADR.W    R8,s_i2cDividerTable
    553              {
    554                  multiplier = 1u << mult;
   \                     ??I2C_MasterSetBaudRate_0: (+1)
   \   00000012   0x2701             MOVS     R7,#+1
   \   00000014   0xFA07 0xFC06      LSL      R12,R7,R6
    555          
    556                  /* Scan table to find best match. */
    557                  for (i = 0u; i < sizeof(s_i2cDividerTable) / sizeof(uint16_t); ++i)
   \   00000018   0xF04F 0x0E00      MOV      LR,#+0
    558                  {
    559                      computedRate = srcClock_Hz / (multiplier * s_i2cDividerTable[i]);
   \                     ??I2C_MasterSetBaudRate_1: (+1)
   \   0000001C   0xF838 0x701E      LDRH     R7,[R8, LR, LSL #+1]
   \   00000020   0xFB07 0xF70C      MUL      R7,R7,R12
   \   00000024   0xFBB2 0xF7F7      UDIV     R7,R2,R7
    560                      absError = baudRate_Bps > computedRate ? (baudRate_Bps - computedRate) : (computedRate - baudRate_Bps);
   \   00000028   0x428F             CMP      R7,R1
   \   0000002A   0xBF34             ITE      CC 
   \   0000002C   0x1BCF             SUBCC    R7,R1,R7
   \   0000002E   0x1A7F             SUBCS    R7,R7,R1
    561          
    562                      if (absError < bestError)
   \   00000030   0x429F             CMP      R7,R3
   \   00000032   0xD203             BCS.N    ??I2C_MasterSetBaudRate_2
    563                      {
    564                          bestMult = mult;
   \   00000034   0x4634             MOV      R4,R6
    565                          bestIcr = i;
   \   00000036   0x4675             MOV      R5,LR
    566                          bestError = absError;
   \   00000038   0x463B             MOV      R3,R7
    567          
    568                          /* If the error is 0, then we can stop searching because we won't find a better match. */
    569                          if (absError == 0)
   \   0000003A   0xB127             CBZ.N    R7,??I2C_MasterSetBaudRate_3
    570                          {
    571                              break;
    572                          }
    573                      }
    574                  }
   \                     ??I2C_MasterSetBaudRate_2: (+1)
   \   0000003C   0xF10E 0x0E01      ADD      LR,LR,#+1
   \   00000040   0xF1BE 0x0F40      CMP      LR,#+64
   \   00000044   0xD3EA             BCC.N    ??I2C_MasterSetBaudRate_1
    575              }
   \                     ??I2C_MasterSetBaudRate_3: (+1)
   \   00000046   0x1C76             ADDS     R6,R6,#+1
   \   00000048   0x2E03             CMP      R6,#+3
   \   0000004A   0xD201             BCS.N    ??I2C_MasterSetBaudRate_4
   \   0000004C   0x2B00             CMP      R3,#+0
   \   0000004E   0xD1E0             BNE.N    ??I2C_MasterSetBaudRate_0
    576          
    577              /* Set frequency register based on best settings. */
    578              base->F = I2C_F_MULT(bestMult) | I2C_F_ICR(bestIcr);
   \                     ??I2C_MasterSetBaudRate_4: (+1)
   \   00000050   0xF005 0x013F      AND      R1,R5,#0x3F
   \   00000054   0xEA41 0x1184      ORR      R1,R1,R4, LSL #+6
   \   00000058   0x7041             STRB     R1,[R0, #+1]
    579          }
   \   0000005A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    580          

   \                                 In section .text, align 2, keep-with-next
    581          status_t I2C_MasterStart(I2C_Type *base, uint8_t address, i2c_direction_t direction)
    582          {
   \                     I2C_MasterStart: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4617             MOV      R7,R2
    583              status_t result = kStatus_Success;
    584              uint32_t statusFlags = I2C_MasterGetStatusFlags(base);
    585          
    586              /* Return an error if the bus is already in use. */
    587              if (statusFlags & kI2C_BusBusyFlag)
   \   00000008   0x.... 0x....      BL       I2C_MasterGetStatusFlags
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0x0680             LSLS     R0,R0,#+26
   \   00000010   0xBF48             IT       MI 
   \   00000012   0xF240 0x444C      MOVWMI   R4,#+1100
    588              {
    589                  result = kStatus_I2C_Busy;
   \   00000016   0xD40A             BMI.N    ??I2C_MasterStart_0
    590              }
    591              else
    592              {
    593                  /* Send the START signal. */
    594                  base->C1 |= I2C_C1_MST_MASK | I2C_C1_TX_MASK;
   \   00000018   0x78A8             LDRB     R0,[R5, #+2]
   \   0000001A   0xF040 0x0030      ORR      R0,R0,#0x30
   \   0000001E   0x70A8             STRB     R0,[R5, #+2]
    595          
    596          #if defined(FSL_FEATURE_I2C_HAS_DOUBLE_BUFFERING) && FSL_FEATURE_I2C_HAS_DOUBLE_BUFFERING
    597                  while (!(base->S2 & I2C_S2_EMPTY_MASK))
    598                  {
    599                  }
    600          #endif /* FSL_FEATURE_I2C_HAS_DOUBLE_BUFFERING */
    601          
    602                  base->D = (((uint32_t)address) << 1U | ((direction == kI2C_Read) ? 1U : 0U));
   \   00000020   0x2F01             CMP      R7,#+1
   \   00000022   0xBF0C             ITE      EQ 
   \   00000024   0x2001             MOVEQ    R0,#+1
   \   00000026   0x2000             MOVNE    R0,#+0
   \   00000028   0xEA40 0x0046      ORR      R0,R0,R6, LSL #+1
   \   0000002C   0x7128             STRB     R0,[R5, #+4]
    603              }
    604          
    605              return result;
   \                     ??I2C_MasterStart_0: (+1)
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    606          }
    607          

   \                                 In section .text, align 2, keep-with-next
    608          status_t I2C_MasterRepeatedStart(I2C_Type *base, uint8_t address, i2c_direction_t direction)
    609          {
   \                     I2C_MasterRepeatedStart: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4617             MOV      R7,R2
    610              status_t result = kStatus_Success;
    611              uint8_t savedMult;
    612              uint32_t statusFlags = I2C_MasterGetStatusFlags(base);
   \   00000008   0x.... 0x....      BL       I2C_MasterGetStatusFlags
   \   0000000C   0x2600             MOVS     R6,#+0
    613              uint8_t timeDelay = 6;
   \   0000000E   0x2106             MOVS     R1,#+6
    614          
    615              /* Return an error if the bus is already in use, but not by us. */
    616              if ((statusFlags & kI2C_BusBusyFlag) && ((base->C1 & I2C_C1_MST_MASK) == 0))
   \   00000010   0x0680             LSLS     R0,R0,#+26
   \   00000012   0xD505             BPL.N    ??I2C_MasterRepeatedStart_0
   \   00000014   0x78A0             LDRB     R0,[R4, #+2]
   \   00000016   0x0680             LSLS     R0,R0,#+26
   \   00000018   0xBF58             IT       PL 
   \   0000001A   0xF240 0x464C      MOVWPL   R6,#+1100
    617              {
    618                  result = kStatus_I2C_Busy;
   \   0000001E   0xD515             BPL.N    ??I2C_MasterRepeatedStart_1
    619              }
    620              else
    621              {
    622                  savedMult = base->F;
   \                     ??I2C_MasterRepeatedStart_0: (+1)
   \   00000020   0x7860             LDRB     R0,[R4, #+1]
    623                  base->F = savedMult & (~I2C_F_MULT_MASK);
   \   00000022   0xF000 0x023F      AND      R2,R0,#0x3F
   \   00000026   0x7062             STRB     R2,[R4, #+1]
    624          
    625                  /* We are already in a transfer, so send a repeated start. */
    626                  base->C1 |= I2C_C1_RSTA_MASK;
   \   00000028   0x78A2             LDRB     R2,[R4, #+2]
   \   0000002A   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000002E   0x70A2             STRB     R2,[R4, #+2]
    627          
    628                  /* Restore the multiplier factor. */
    629                  base->F = savedMult;
   \   00000030   0x7060             STRB     R0,[R4, #+1]
   \   00000032   0xE000             B.N      ??I2C_MasterRepeatedStart_2
    630          
    631                  /* Add some delay to wait the Re-Start signal. */
    632                  while (timeDelay--)
    633                  {
    634                      __NOP();
   \                     ??I2C_MasterRepeatedStart_3: (+1)
   \   00000034   0xBF00             Nop      
    635                  }
   \                     ??I2C_MasterRepeatedStart_2: (+1)
   \   00000036   0x4608             MOV      R0,R1
   \   00000038   0x1E41             SUBS     R1,R0,#+1
   \   0000003A   0xB2C0             UXTB     R0,R0
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD1F9             BNE.N    ??I2C_MasterRepeatedStart_3
    636          
    637          #if defined(FSL_FEATURE_I2C_HAS_DOUBLE_BUFFERING) && FSL_FEATURE_I2C_HAS_DOUBLE_BUFFERING
    638                  while (!(base->S2 & I2C_S2_EMPTY_MASK))
    639                  {
    640                  }
    641          #endif /* FSL_FEATURE_I2C_HAS_DOUBLE_BUFFERING */
    642          
    643                  base->D = (((uint32_t)address) << 1U | ((direction == kI2C_Read) ? 1U : 0U));
   \   00000040   0x2F01             CMP      R7,#+1
   \   00000042   0xBF08             IT       EQ 
   \   00000044   0x2001             MOVEQ    R0,#+1
   \   00000046   0xEA40 0x0045      ORR      R0,R0,R5, LSL #+1
   \   0000004A   0x7120             STRB     R0,[R4, #+4]
    644              }
    645          
    646              return result;
   \                     ??I2C_MasterRepeatedStart_1: (+1)
   \   0000004C   0x4630             MOV      R0,R6
   \   0000004E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    647          }
    648          

   \                                 In section .text, align 2, keep-with-next
    649          status_t I2C_MasterStop(I2C_Type *base)
    650          {
    651              status_t result = kStatus_Success;
    652              uint16_t timeout = UINT16_MAX;
    653          
    654              /* Issue the STOP command on the bus. */
    655              base->C1 &= ~(I2C_C1_MST_MASK | I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
   \                     I2C_MasterStop: (+1)
   \   00000000   0x7883             LDRB     R3,[R0, #+2]
   \   00000002   0xF003 0x03C7      AND      R3,R3,#0xC7
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0xF64F 0x72FF      MOVW     R2,#+65535
   \   0000000C   0x7083             STRB     R3,[R0, #+2]
    656          
    657              /* Wait until data transfer complete. */
    658              while ((base->S & kI2C_BusBusyFlag) && (--timeout))
   \                     ??I2C_MasterStop_0: (+1)
   \   0000000E   0x78C3             LDRB     R3,[R0, #+3]
   \   00000010   0x069B             LSLS     R3,R3,#+26
   \   00000012   0xD504             BPL.N    ??I2C_MasterStop_1
   \   00000014   0x1E52             SUBS     R2,R2,#+1
   \   00000016   0xB293             UXTH     R3,R2
   \   00000018   0x2B00             CMP      R3,#+0
   \   0000001A   0xD1F8             BNE.N    ??I2C_MasterStop_0
   \   0000001C   0xE001             B.N      ??I2C_MasterStop_2
    659              {
    660              }
    661          
    662              if (timeout == 0)
   \                     ??I2C_MasterStop_1: (+1)
   \   0000001E   0xB292             UXTH     R2,R2
   \   00000020   0xB90A             CBNZ.N   R2,??I2C_MasterStop_3
    663              {
    664                  result = kStatus_I2C_Timeout;
   \                     ??I2C_MasterStop_2: (+1)
   \   00000022   0xF44F 0x618A      MOV      R1,#+1104
    665              }
    666          
    667              return result;
   \                     ??I2C_MasterStop_3: (+1)
   \   00000026   0x4608             MOV      R0,R1
   \   00000028   0x4770             BX       LR               ;; return
    668          }
    669          

   \                                 In section .text, align 2, keep-with-next
    670          uint32_t I2C_MasterGetStatusFlags(I2C_Type *base)
    671          {
    672              uint32_t statusFlags = base->S;
   \                     I2C_MasterGetStatusFlags: (+1)
   \   00000000   0x78C1             LDRB     R1,[R0, #+3]
    673          
    674          #ifdef I2C_HAS_STOP_DETECT
    675              /* Look up the STOPF bit from the filter register. */
    676              if (base->FLT & I2C_FLT_STOPF_MASK)
   \   00000002   0x7982             LDRB     R2,[R0, #+6]
    677              {
    678                  statusFlags |= kI2C_StopDetectFlag;
    679              }
    680          #endif
    681          
    682          #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
    683              /* Look up the STARTF bit from the filter register. */
    684              if (base->FLT & I2C_FLT_STARTF_MASK)
   \   00000004   0x7980             LDRB     R0,[R0, #+6]
   \   00000006   0x0652             LSLS     R2,R2,#+25
   \   00000008   0xBF48             IT       MI 
   \   0000000A   0xF441 0x4180      ORRMI    R1,R1,#0x4000
   \   0000000E   0x06C0             LSLS     R0,R0,#+27
   \   00000010   0xBF48             IT       MI 
   \   00000012   0xF441 0x5180      ORRMI    R1,R1,#0x1000
    685              {
    686                  statusFlags |= kI2C_StartDetectFlag;
    687              }
    688          #endif /* FSL_FEATURE_I2C_HAS_START_STOP_DETECT */
    689          
    690              return statusFlags;
   \   00000016   0x4608             MOV      R0,R1
   \   00000018   0x4770             BX       LR               ;; return
    691          }
    692          

   \                                 In section .text, align 2, keep-with-next
    693          status_t I2C_MasterWriteBlocking(I2C_Type *base, const uint8_t *txBuff, size_t txSize)
    694          {
   \                     I2C_MasterWriteBlocking: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4613             MOV      R3,R2
    695              status_t result = kStatus_Success;
   \   00000004   0x2200             MOVS     R2,#+0
    696              uint8_t statusFlags = 0;
    697          
    698              /* Wait until the data register is ready for transmit. */
    699              while (!(base->S & kI2C_TransferCompleteFlag))
   \                     ??I2C_MasterWriteBlocking_0: (+1)
   \   00000006   0x78C4             LDRB     R4,[R0, #+3]
   \   00000008   0x0624             LSLS     R4,R4,#+24
   \   0000000A   0xD5FC             BPL.N    ??I2C_MasterWriteBlocking_0
    700              {
    701              }
    702          
    703              /* Clear the IICIF flag. */
    704              base->S = kI2C_IntPendingFlag;
   \   0000000C   0x2402             MOVS     R4,#+2
   \   0000000E   0x70C4             STRB     R4,[R0, #+3]
    705          
    706              /* Setup the I2C peripheral to transmit data. */
    707              base->C1 |= I2C_C1_TX_MASK;
   \   00000010   0x7884             LDRB     R4,[R0, #+2]
   \   00000012   0xF044 0x0410      ORR      R4,R4,#0x10
   \   00000016   0x7084             STRB     R4,[R0, #+2]
    708          
    709              while (txSize--)
   \                     ??I2C_MasterWriteBlocking_1: (+1)
   \   00000018   0x461C             MOV      R4,R3
   \   0000001A   0x1E63             SUBS     R3,R4,#+1
   \   0000001C   0xB1BC             CBZ.N    R4,??I2C_MasterWriteBlocking_2
    710              {
    711                  /* Send a byte of data. */
    712                  base->D = *txBuff++;
   \   0000001E   0xF811 0x4B01      LDRB     R4,[R1], #+1
   \   00000022   0x7104             STRB     R4,[R0, #+4]
    713          
    714                  /* Wait until data transfer complete. */
    715                  while (!(base->S & kI2C_IntPendingFlag))
   \                     ??I2C_MasterWriteBlocking_3: (+1)
   \   00000024   0x78C4             LDRB     R4,[R0, #+3]
   \   00000026   0x07A4             LSLS     R4,R4,#+30
   \   00000028   0xD5FC             BPL.N    ??I2C_MasterWriteBlocking_3
    716                  {
    717                  }
    718          
    719                  statusFlags = base->S;
    720          
    721                  /* Clear the IICIF flag. */
    722                  base->S = kI2C_IntPendingFlag;
   \   0000002A   0x2502             MOVS     R5,#+2
   \   0000002C   0x78C4             LDRB     R4,[R0, #+3]
   \   0000002E   0x70C5             STRB     R5,[R0, #+3]
    723          
    724                  /* Check if arbitration lost or no acknowledgement (NAK), return failure status. */
    725                  if (statusFlags & kI2C_ArbitrationLostFlag)
   \   00000030   0x06E5             LSLS     R5,R4,#+27
   \   00000032   0xD503             BPL.N    ??I2C_MasterWriteBlocking_4
    726                  {
    727                      base->S = kI2C_ArbitrationLostFlag;
   \   00000034   0x2210             MOVS     R2,#+16
   \   00000036   0x70C2             STRB     R2,[R0, #+3]
    728                      result = kStatus_I2C_ArbitrationLost;
   \   00000038   0xF240 0x424F      MOVW     R2,#+1103
    729                  }
    730          
    731                  if (statusFlags & kI2C_ReceiveNakFlag)
   \                     ??I2C_MasterWriteBlocking_4: (+1)
   \   0000003C   0x07E4             LSLS     R4,R4,#+31
   \   0000003E   0xD504             BPL.N    ??I2C_MasterWriteBlocking_5
    732                  {
    733                      base->S = kI2C_ReceiveNakFlag;
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0x70C1             STRB     R1,[R0, #+3]
    734                      result = kStatus_I2C_Nak;
   \   00000044   0xF240 0x424E      MOVW     R2,#+1102
   \   00000048   0xE001             B.N      ??I2C_MasterWriteBlocking_2
    735                  }
    736          
    737                  if (result != kStatus_Success)
   \                     ??I2C_MasterWriteBlocking_5: (+1)
   \   0000004A   0x2A00             CMP      R2,#+0
   \   0000004C   0xD0E4             BEQ.N    ??I2C_MasterWriteBlocking_1
    738                  {
    739                      /* Breaking out of the send loop. */
    740                      break;
    741                  }
    742              }
    743          
    744              return result;
   \                     ??I2C_MasterWriteBlocking_2: (+1)
   \   0000004E   0x4610             MOV      R0,R2
   \   00000050   0xBD30             POP      {R4,R5,PC}       ;; return
    745          }
    746          

   \                                 In section .text, align 2, keep-with-next
    747          status_t I2C_MasterReadBlocking(I2C_Type *base, uint8_t *rxBuff, size_t rxSize)
    748          {
   \                     I2C_MasterReadBlocking: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    749              status_t result = kStatus_Success;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x460D             MOV      R5,R1
    750              volatile uint8_t dummy = 0;
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000000E   0x4616             MOV      R6,R2
    751          
    752              /* Add this to avoid build warning. */
    753              dummy++;
   \   00000010   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000014   0x1C49             ADDS     R1,R1,#+1
   \   00000016   0xF88D 0x1000      STRB     R1,[SP, #+0]
    754          
    755              /* Wait until the data register is ready for transmit. */
    756              while (!(base->S & kI2C_TransferCompleteFlag))
   \                     ??I2C_MasterReadBlocking_0: (+1)
   \   0000001A   0x78E1             LDRB     R1,[R4, #+3]
   \   0000001C   0x0609             LSLS     R1,R1,#+24
   \   0000001E   0xD5FC             BPL.N    ??I2C_MasterReadBlocking_0
    757              {
    758              }
    759          
    760              /* Clear the IICIF flag. */
    761              base->S = kI2C_IntPendingFlag;
   \   00000020   0x2102             MOVS     R1,#+2
   \   00000022   0x70E1             STRB     R1,[R4, #+3]
    762          
    763              /* Setup the I2C peripheral to receive data. */
    764              base->C1 &= ~(I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
    765          
    766              /* If rxSize equals 1, configure to send NAK. */
    767              if (rxSize == 1)
   \   00000024   0x2E01             CMP      R6,#+1
   \   00000026   0x78A1             LDRB     R1,[R4, #+2]
   \   00000028   0xF001 0x01E7      AND      R1,R1,#0xE7
   \   0000002C   0x70A1             STRB     R1,[R4, #+2]
   \   0000002E   0x.... 0x....      BL       ?Subroutine6
    768              {
    769                  /* Issue NACK on read. */
    770                  base->C1 |= I2C_C1_TXAK_MASK;
    771              }
    772          
    773              /* Do dummy read. */
    774              dummy = base->D;
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000032   0x7921             LDRB     R1,[R4, #+4]
   \   00000034   0xF88D 0x1000      STRB     R1,[SP, #+0]
   \   00000038   0xE005             B.N      ??I2C_MasterReadBlocking_1
    775          
    776              while ((rxSize--))
    777              {
    778                  /* Wait until data transfer complete. */
    779                  while (!(base->S & kI2C_IntPendingFlag))
    780                  {
    781                  }
    782          
    783                  /* Clear the IICIF flag. */
    784                  base->S = kI2C_IntPendingFlag;
    785          
    786                  /* Single byte use case. */
    787                  if (rxSize == 0)
    788                  {
    789                      /* Read the final byte. */
    790                      result = I2C_MasterStop(base);
    791                  }
    792          
    793                  if (rxSize == 1)
   \                     ??I2C_MasterReadBlocking_2: (+1)
   \   0000003A   0x2E01             CMP      R6,#+1
   \   0000003C   0x.... 0x....      BL       ?Subroutine6
    794                  {
    795                      /* Issue NACK on read. */
    796                      base->C1 |= I2C_C1_TXAK_MASK;
    797                  }
    798          
    799                  /* Read from the data register. */
    800                  *rxBuff++ = base->D;
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000040   0x7921             LDRB     R1,[R4, #+4]
   \   00000042   0xF805 0x1B01      STRB     R1,[R5], #+1
   \                     ??I2C_MasterReadBlocking_1: (+1)
   \   00000046   0x4631             MOV      R1,R6
   \   00000048   0x1E4E             SUBS     R6,R1,#+1
   \   0000004A   0xB149             CBZ.N    R1,??I2C_MasterReadBlocking_3
   \                     ??I2C_MasterReadBlocking_4: (+1)
   \   0000004C   0x78E1             LDRB     R1,[R4, #+3]
   \   0000004E   0x0789             LSLS     R1,R1,#+30
   \   00000050   0xD5FC             BPL.N    ??I2C_MasterReadBlocking_4
   \   00000052   0x2102             MOVS     R1,#+2
   \   00000054   0x2E00             CMP      R6,#+0
   \   00000056   0x70E1             STRB     R1,[R4, #+3]
   \   00000058   0xD1EF             BNE.N    ??I2C_MasterReadBlocking_2
   \   0000005A   0x.... 0x....      BL       ?Subroutine11
    801              }
   \                     ??CrossCallReturnLabel_19: (+1)
   \   0000005E   0xE7EF             B.N      ??CrossCallReturnLabel_5
    802          
    803              return result;
   \                     ??I2C_MasterReadBlocking_3: (+1)
   \   00000060   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    804          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0xD103             BNE.N    ??Subroutine6_0
   \   00000002   0x78A1             LDRB     R1,[R4, #+2]
   \   00000004   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000008   0x70A1             STRB     R1,[R4, #+2]
   \                     ??Subroutine6_0: (+1)
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \   00000000   0x4620             MOV      R0,R4
   \   00000002   0x....             B.N      I2C_MasterStop
    805          

   \                                 In section .text, align 2, keep-with-next
    806          status_t I2C_MasterTransferBlocking(I2C_Type *base, i2c_master_transfer_t *xfer)
    807          {
   \                     I2C_MasterTransferBlocking: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4604             MOV      R4,R0
    808              assert(xfer);
    809          
    810              i2c_direction_t direction = xfer->direction;
   \   00000006   0x796E             LDRB     R6,[R5, #+5]
    811              status_t result = kStatus_Success;
    812          
    813              /* Clear all status before transfer. */
    814              I2C_MasterClearStatusFlags(base, kClearFlags);
   \   00000008   0xF245 0x0112      MOVW     R1,#+20498
   \   0000000C   0x.... 0x....      BL       I2C_MasterClearStatusFlags
    815          
    816              /* Wait until ready to complete. */
    817              while (!(base->S & kI2C_TransferCompleteFlag))
   \                     ??I2C_MasterTransferBlocking_0: (+1)
   \   00000010   0x78E0             LDRB     R0,[R4, #+3]
   \   00000012   0x0600             LSLS     R0,R0,#+24
   \   00000014   0xD5FC             BPL.N    ??I2C_MasterTransferBlocking_0
    818              {
    819              }
    820          
    821              /* Change to send write address when it's a read operation with command. */
    822              if ((xfer->subaddressSize > 0) && (xfer->direction == kI2C_Read))
   \   00000016   0x7B28             LDRB     R0,[R5, #+12]
   \   00000018   0xB118             CBZ.N    R0,??I2C_MasterTransferBlocking_1
   \   0000001A   0x7968             LDRB     R0,[R5, #+5]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xBF08             IT       EQ 
   \   00000020   0x2600             MOVEQ    R6,#+0
    823              {
    824                  direction = kI2C_Write;
    825              }
    826          
    827              /* If repeated start is requested, send repeated start. */
    828              if (xfer->flags & kI2C_TransferRepeatedStartFlag)
   \                     ??I2C_MasterTransferBlocking_1: (+1)
   \   00000022   0x7828             LDRB     R0,[R5, #+0]
   \   00000024   0x7929             LDRB     R1,[R5, #+4]
   \   00000026   0x0780             LSLS     R0,R0,#+30
   \   00000028   0x4632             MOV      R2,R6
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0xD502             BPL.N    ??I2C_MasterTransferBlocking_2
    829              {
    830                  result = I2C_MasterRepeatedStart(base, xfer->slaveAddress, direction);
   \   0000002E   0x.... 0x....      BL       I2C_MasterRepeatedStart
   \   00000032   0xE001             B.N      ??I2C_MasterTransferBlocking_3
    831              }
    832              else /* For normal transfer, send start. */
    833              {
    834                  result = I2C_MasterStart(base, xfer->slaveAddress, direction);
   \                     ??I2C_MasterTransferBlocking_2: (+1)
   \   00000034   0x.... 0x....      BL       I2C_MasterStart
   \                     ??I2C_MasterTransferBlocking_3: (+1)
   \   00000038   0x0007             MOVS     R7,R0
    835              }
    836          
    837              /* Return if error. */
    838              if (result)
   \   0000003A   0xD154             BNE.N    ??I2C_MasterTransferBlocking_4
    839              {
    840                  return result;
    841              }
    842          
    843              /* Send subaddress. */
    844              if (xfer->subaddressSize)
   \   0000003C   0x7B28             LDRB     R0,[R5, #+12]
   \   0000003E   0xF240 0x464E      MOVW     R6,#+1102
   \   00000042   0xB308             CBZ.N    R0,??I2C_MasterTransferBlocking_5
    845              {
    846                  do
    847                  {
    848                      /* Wait until data transfer complete. */
    849                      while (!(base->S & kI2C_IntPendingFlag))
   \                     ??I2C_MasterTransferBlocking_6: (+1)
   \   00000044   0x78E0             LDRB     R0,[R4, #+3]
   \   00000046   0x0780             LSLS     R0,R0,#+30
   \   00000048   0xD5FC             BPL.N    ??I2C_MasterTransferBlocking_6
    850                      {
    851                      }
    852          
    853                      /* Clear interrupt pending flag. */
    854                      base->S = kI2C_IntPendingFlag;
   \   0000004A   0x.... 0x....      BL       ?Subroutine8
    855          
    856                      /* Check if there's transfer error. */
    857                      result = I2C_CheckAndClearError(base, base->S);
   \                     ??CrossCallReturnLabel_9: (+1)
   \   0000004E   0x0007             MOVS     R7,R0
    858          
    859                      if (result)
   \   00000050   0xD123             BNE.N    ??I2C_MasterTransferBlocking_7
    860                      {
    861                          if (result == kStatus_I2C_Nak)
    862                          {
    863                              I2C_MasterStop(base);
    864                          }
    865          
    866                          return result;
    867                      }
    868          
    869                      xfer->subaddressSize--;
   \   00000052   0x7B28             LDRB     R0,[R5, #+12]
    870                      base->D = ((xfer->subaddress) >> (8 * xfer->subaddressSize));
   \   00000054   0x68A9             LDR      R1,[R5, #+8]
   \   00000056   0x1E40             SUBS     R0,R0,#+1
   \   00000058   0x7328             STRB     R0,[R5, #+12]
   \   0000005A   0x00C0             LSLS     R0,R0,#+3
   \   0000005C   0x40C1             LSRS     R1,R1,R0
   \   0000005E   0x7121             STRB     R1,[R4, #+4]
    871          
    872                  } while ((xfer->subaddressSize > 0) && (result == kStatus_Success));
   \   00000060   0x7B28             LDRB     R0,[R5, #+12]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD1EE             BNE.N    ??I2C_MasterTransferBlocking_6
    873          
    874                  if (xfer->direction == kI2C_Read)
   \   00000066   0x7968             LDRB     R0,[R5, #+5]
   \   00000068   0x2801             CMP      R0,#+1
   \   0000006A   0xD10D             BNE.N    ??I2C_MasterTransferBlocking_5
    875                  {
    876                      /* Wait until data transfer complete. */
    877                      while (!(base->S & kI2C_IntPendingFlag))
   \                     ??I2C_MasterTransferBlocking_8: (+1)
   \   0000006C   0x78E0             LDRB     R0,[R4, #+3]
   \   0000006E   0x0780             LSLS     R0,R0,#+30
   \   00000070   0xD5FC             BPL.N    ??I2C_MasterTransferBlocking_8
    878                      {
    879                      }
    880          
    881                      /* Clear pending flag. */
    882                      base->S = kI2C_IntPendingFlag;
   \   00000072   0x.... 0x....      BL       ?Subroutine8
    883          
    884                      /* Check if there's transfer error. */
    885                      result = I2C_CheckAndClearError(base, base->S);
   \                     ??CrossCallReturnLabel_8: (+1)
   \   00000076   0x0007             MOVS     R7,R0
    886          
    887                      if (result)
   \   00000078   0xD10F             BNE.N    ??I2C_MasterTransferBlocking_7
    888                      {
    889                          if (result == kStatus_I2C_Nak)
    890                          {
    891                              I2C_MasterStop(base);
    892                          }
    893          
    894                          return result;
    895                      }
    896          
    897                      /* Send repeated start and slave address. */
    898                      result = I2C_MasterRepeatedStart(base, xfer->slaveAddress, kI2C_Read);
   \   0000007A   0x7929             LDRB     R1,[R5, #+4]
   \   0000007C   0x2201             MOVS     R2,#+1
   \   0000007E   0x4620             MOV      R0,R4
   \   00000080   0x.... 0x....      BL       I2C_MasterRepeatedStart
   \   00000084   0x0007             MOVS     R7,R0
    899          
    900                      /* Return if error. */
    901                      if (result)
   \   00000086   0xD12E             BNE.N    ??I2C_MasterTransferBlocking_4
    902                      {
    903                          return result;
    904                      }
    905                  }
    906              }
    907          
    908              /* Wait until address + command transfer complete. */
    909              while (!(base->S & kI2C_IntPendingFlag))
   \                     ??I2C_MasterTransferBlocking_5: (+1)
   \   00000088   0x78E0             LDRB     R0,[R4, #+3]
   \   0000008A   0x0780             LSLS     R0,R0,#+30
   \   0000008C   0xD5FC             BPL.N    ??I2C_MasterTransferBlocking_5
    910              {
    911              }
    912          
    913              /* Check if there's transfer error. */
    914              result = I2C_CheckAndClearError(base, base->S);
   \   0000008E   0x78E1             LDRB     R1,[R4, #+3]
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x.... 0x....      BL       I2C_CheckAndClearError
   \   00000096   0x0007             MOVS     R7,R0
    915          
    916              /* Return if error. */
    917              if (result)
   \   00000098   0xD004             BEQ.N    ??I2C_MasterTransferBlocking_9
    918              {
    919                  if (result == kStatus_I2C_Nak)
   \                     ??I2C_MasterTransferBlocking_7: (+1)
   \   0000009A   0x42B7             CMP      R7,R6
   \   0000009C   0xD123             BNE.N    ??I2C_MasterTransferBlocking_4
    920                  {
    921                      I2C_MasterStop(base);
   \   0000009E   0x.... 0x....      BL       ?Subroutine11
    922                  }
    923          
    924                  return result;
    925              }
   \                     ??CrossCallReturnLabel_18: (+1)
   \   000000A2   0xE020             B.N      ??I2C_MasterTransferBlocking_4
    926          
    927              /* Transmit data. */
    928              if ((xfer->direction == kI2C_Write) && (xfer->dataSize > 0))
   \                     ??I2C_MasterTransferBlocking_9: (+1)
   \   000000A4   0x7968             LDRB     R0,[R5, #+5]
   \   000000A6   0xB998             CBNZ.N   R0,??I2C_MasterTransferBlocking_10
   \   000000A8   0x6968             LDR      R0,[R5, #+20]
   \   000000AA   0xB188             CBZ.N    R0,??I2C_MasterTransferBlocking_10
    929              {
    930                  /* Send Data. */
    931                  result = I2C_MasterWriteBlocking(base, xfer->data, xfer->dataSize);
   \   000000AC   0x696A             LDR      R2,[R5, #+20]
   \   000000AE   0x6929             LDR      R1,[R5, #+16]
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0x.... 0x....      BL       I2C_MasterWriteBlocking
   \   000000B6   0x0007             MOVS     R7,R0
    932          
    933                  if (((result == kStatus_Success) && (!(xfer->flags & kI2C_TransferNoStopFlag))) || (result == kStatus_I2C_Nak))
   \   000000B8   0xD103             BNE.N    ??I2C_MasterTransferBlocking_11
   \   000000BA   0x7828             LDRB     R0,[R5, #+0]
   \   000000BC   0x0740             LSLS     R0,R0,#+29
   \   000000BE   0xD407             BMI.N    ??I2C_MasterTransferBlocking_10
   \   000000C0   0xE001             B.N      ??I2C_MasterTransferBlocking_12
   \                     ??I2C_MasterTransferBlocking_11: (+1)
   \   000000C2   0x42B7             CMP      R7,R6
   \   000000C4   0xD104             BNE.N    ??I2C_MasterTransferBlocking_10
    934                  {
    935                      /* Clear the IICIF flag. */
    936                      base->S = kI2C_IntPendingFlag;
   \                     ??I2C_MasterTransferBlocking_12: (+1)
   \   000000C6   0x2002             MOVS     R0,#+2
   \   000000C8   0x70E0             STRB     R0,[R4, #+3]
    937          
    938                      /* Send stop. */
    939                      result = I2C_MasterStop(base);
   \   000000CA   0x.... 0x....      BL       ?Subroutine11
    940                  }
    941              }
   \                     ??CrossCallReturnLabel_17: (+1)
   \   000000CE   0x4607             MOV      R7,R0
    942          
    943              /* Receive Data. */
    944              if ((xfer->direction == kI2C_Read) && (xfer->dataSize > 0))
   \                     ??I2C_MasterTransferBlocking_10: (+1)
   \   000000D0   0x7968             LDRB     R0,[R5, #+5]
   \   000000D2   0x2801             CMP      R0,#+1
   \   000000D4   0xD107             BNE.N    ??I2C_MasterTransferBlocking_4
   \   000000D6   0x6968             LDR      R0,[R5, #+20]
   \   000000D8   0xB128             CBZ.N    R0,??I2C_MasterTransferBlocking_4
    945              {
    946                  result = I2C_MasterReadBlocking(base, xfer->data, xfer->dataSize);
   \   000000DA   0x696A             LDR      R2,[R5, #+20]
   \   000000DC   0x6929             LDR      R1,[R5, #+16]
   \   000000DE   0x4620             MOV      R0,R4
   \   000000E0   0x.... 0x....      BL       I2C_MasterReadBlocking
   \   000000E4   0x4607             MOV      R7,R0
    947              }
    948          
    949              return result;
   \                     ??I2C_MasterTransferBlocking_4: (+1)
   \   000000E6   0x4638             MOV      R0,R7
   \   000000E8   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    950          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \   00000000   0x2002             MOVS     R0,#+2
   \   00000002   0x70E0             STRB     R0,[R4, #+3]
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x78E1             LDRB     R1,[R4, #+3]
   \   00000008   0x....             B.N      I2C_CheckAndClearError
    951          

   \                                 In section .text, align 2, keep-with-next
    952          void I2C_MasterTransferCreateHandle(I2C_Type *base,
    953                                              i2c_master_handle_t *handle,
    954                                              i2c_master_transfer_callback_t callback,
    955                                              void *userData)
    956          {
   \                     I2C_MasterTransferCreateHandle: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine4
    957              assert(handle);
    958          
    959              uint32_t instance = I2C_GetInstance(base);
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000006   0x4607             MOV      R7,R0
    960          
    961              /* Zero handle. */
    962              memset(handle, 0, sizeof(*handle));
   \   00000008   0x2128             MOVS     R1,#+40
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       __aeabi_memclr4
    963          
    964              /* Set callback and userData. */
    965              handle->completionCallback = callback;
    966              handle->userData = userData;
    967          
    968              /* Save the context in global variables to support the double weak mechanism. */
    969              s_i2cHandle[instance] = handle;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \   00000014   0x6225             STR      R5,[R4, #+32]
   \   00000016   0x6266             STR      R6,[R4, #+36]
   \   00000018   0xF840 0x4027      STR      R4,[R0, R7, LSL #+2]
    970          
    971              /* Save master interrupt handler. */
    972              s_i2cMasterIsr = I2C_MasterTransferHandleIRQ;
   \   0000001C   0x.... 0x....      ADR.W    R1,I2C_MasterTransferHandleIRQ
   \   00000020   0x6081             STR      R1,[R0, #+8]
    973          
    974              /* Enable NVIC interrupt. */
    975              EnableIRQ(s_i2cIrqs[instance]);
   \   00000022   0x....             B.N      ?Subroutine3
    976          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x.... 0x....      ADR.W    R0,s_i2cIrqs
   \   00000004   0x57C0             LDRSB    R0,[R0, R7]
   \   00000006   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   0000000A   0x....             B.N      EnableIRQ

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x460C             MOV      R4,R1
   \   00000002   0x4615             MOV      R5,R2
   \   00000004   0x461E             MOV      R6,R3
   \   00000006   0x....             B.N      I2C_GetInstance
    977          

   \                                 In section .text, align 2, keep-with-next
    978          status_t I2C_MasterTransferNonBlocking(I2C_Type *base, i2c_master_handle_t *handle, i2c_master_transfer_t *xfer)
    979          {
   \                     I2C_MasterTransferNonBlocking: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4680             MOV      R8,R0
    980              assert(handle);
    981              assert(xfer);
    982          
    983              status_t result = kStatus_Success;
    984          
    985              /* Check if the I2C bus is idle - if not return busy status. */
    986              if (handle->state != kIdleState)
   \   00000008   0x7F28             LDRB     R0,[R5, #+28]
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0xB110             CBZ.N    R0,??I2C_MasterTransferNonBlocking_0
    987              {
    988                  result = kStatus_I2C_Busy;
   \   0000000E   0xF240 0x454C      MOVW     R5,#+1100
   \   00000012   0xE038             B.N      ??I2C_MasterTransferNonBlocking_1
    989              }
    990              else
    991              {
    992                  /* Start up the master transfer state machine. */
    993                  result = I2C_InitTransferStateMachine(base, handle, xfer);
   \                     ??I2C_MasterTransferNonBlocking_0: (+1)
   \   00000014   0x7977             LDRB     R7,[R6, #+5]
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x4631             MOV      R1,R6
   \   0000001A   0x2218             MOVS     R2,#+24
   \   0000001C   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000020   0x6970             LDR      R0,[R6, #+20]
   \   00000022   0x61A8             STR      R0,[R5, #+24]
   \   00000024   0xF64F 0x74FF      MOVW     R4,#+65535
   \   00000028   0x7B28             LDRB     R0,[R5, #+12]
   \   0000002A   0xB130             CBZ.N    R0,??I2C_MasterTransferNonBlocking_2
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0x7728             STRB     R0,[R5, #+28]
   \   00000030   0x7970             LDRB     R0,[R6, #+5]
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xD103             BNE.N    ??I2C_MasterTransferNonBlocking_3
   \   00000036   0x2700             MOVS     R7,#+0
   \   00000038   0xE001             B.N      ??I2C_MasterTransferNonBlocking_3
   \                     ??I2C_MasterTransferNonBlocking_2: (+1)
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x7728             STRB     R0,[R5, #+28]
   \                     ??I2C_MasterTransferNonBlocking_3: (+1)
   \   0000003E   0xF898 0x0003      LDRB     R0,[R8, #+3]
   \   00000042   0x0600             LSLS     R0,R0,#+24
   \   00000044   0xD404             BMI.N    ??I2C_MasterTransferNonBlocking_4
   \   00000046   0x1E64             SUBS     R4,R4,#+1
   \   00000048   0xB2A0             UXTH     R0,R4
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD1F7             BNE.N    ??I2C_MasterTransferNonBlocking_3
   \   0000004E   0xE001             B.N      ??I2C_MasterTransferNonBlocking_5
   \                     ??I2C_MasterTransferNonBlocking_4: (+1)
   \   00000050   0xB2A4             UXTH     R4,R4
   \   00000052   0xB914             CBNZ.N   R4,??I2C_MasterTransferNonBlocking_6
   \                     ??I2C_MasterTransferNonBlocking_5: (+1)
   \   00000054   0xF44F 0x658A      MOV      R5,#+1104
   \   00000058   0xE015             B.N      ??I2C_MasterTransferNonBlocking_1
   \                     ??I2C_MasterTransferNonBlocking_6: (+1)
   \   0000005A   0xF245 0x0112      MOVW     R1,#+20498
   \   0000005E   0x4640             MOV      R0,R8
   \   00000060   0x.... 0x....      BL       I2C_MasterClearStatusFlags
   \   00000064   0x7828             LDRB     R0,[R5, #+0]
   \   00000066   0x7929             LDRB     R1,[R5, #+4]
   \   00000068   0x0780             LSLS     R0,R0,#+30
   \   0000006A   0x463A             MOV      R2,R7
   \   0000006C   0x4640             MOV      R0,R8
   \   0000006E   0xD502             BPL.N    ??I2C_MasterTransferNonBlocking_7
   \   00000070   0x.... 0x....      BL       I2C_MasterRepeatedStart
   \   00000074   0xE001             B.N      ??I2C_MasterTransferNonBlocking_8
   \                     ??I2C_MasterTransferNonBlocking_7: (+1)
   \   00000076   0x.... 0x....      BL       I2C_MasterStart
   \                     ??I2C_MasterTransferNonBlocking_8: (+1)
   \   0000007A   0x0005             MOVS     R5,R0
    994          
    995                  if (result == kStatus_Success)
   \   0000007C   0xD103             BNE.N    ??I2C_MasterTransferNonBlocking_1
    996                  {
    997                      /* Enable the I2C interrupts. */
    998                      I2C_EnableInterrupts(base, kI2C_GlobalInterruptEnable);
   \   0000007E   0x2140             MOVS     R1,#+64
   \   00000080   0x4640             MOV      R0,R8
   \   00000082   0x.... 0x....      BL       I2C_EnableInterrupts
    999                  }
   1000              }
   1001          
   1002              return result;
   \                     ??I2C_MasterTransferNonBlocking_1: (+1)
   \   00000086   0x4628             MOV      R0,R5
   \   00000088   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1003          }
   1004          

   \                                 In section .text, align 2, keep-with-next
   1005          void I2C_MasterTransferAbort(I2C_Type *base, i2c_master_handle_t *handle)
   1006          {
   \                     I2C_MasterTransferAbort: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
   1007              assert(handle);
   1008          
   1009              /* Disable interrupt. */
   1010              I2C_DisableInterrupts(base, kI2C_GlobalInterruptEnable);
   \   00000004   0x2140             MOVS     R1,#+64
   \   00000006   0x.... 0x....      BL       I2C_DisableInterrupts
   1011          
   1012              /* Reset the state to idle. */
   1013              handle->state = kIdleState;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x7720             STRB     R0,[R4, #+28]
   1014          }
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
   1015          

   \                                 In section .text, align 2, keep-with-next
   1016          status_t I2C_MasterTransferGetCount(I2C_Type *base, i2c_master_handle_t *handle, size_t *count)
   1017          {
   1018              assert(handle);
   1019          
   1020              if (!count)
   \                     I2C_MasterTransferGetCount: (+1)
   \   00000000   0xB90A             CBNZ.N   R2,??I2C_MasterTransferGetCount_0
   1021              {
   1022                  return kStatus_InvalidArgument;
   \   00000002   0x2004             MOVS     R0,#+4
   \   00000004   0x4770             BX       LR
   1023              }
   1024          
   1025              *count = handle->transferSize - handle->transfer.dataSize;
   \                     ??I2C_MasterTransferGetCount_0: (+1)
   \   00000006   0x6988             LDR      R0,[R1, #+24]
   \   00000008   0x6949             LDR      R1,[R1, #+20]
   \   0000000A   0x1A40             SUBS     R0,R0,R1
   \   0000000C   0x....             B.N      ?Subroutine1
   1026          
   1027              return kStatus_Success;
   1028          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x6010             STR      R0,[R2, #+0]
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
   1029          

   \                                 In section .text, align 4, keep-with-next
   1030          void I2C_MasterTransferHandleIRQ(I2C_Type *base, void *i2cHandle)
   1031          {
   \                     I2C_MasterTransferHandleIRQ: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   1032              assert(i2cHandle);
   1033          
   1034              i2c_master_handle_t *handle = (i2c_master_handle_t *)i2cHandle;
   1035              status_t result = kStatus_Success;
   1036              bool isDone;
   1037          
   1038              /* Clear the interrupt flag. */
   1039              base->S = kI2C_IntPendingFlag;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0x70E0             STRB     R0,[R4, #+3]
   \   00000008   0x460D             MOV      R5,R1
   1040          
   1041              /* Check transfer complete flag. */
   1042              result = I2C_MasterTransferRunStateMachine(base, handle, &isDone);
   \   0000000A   0x466A             MOV      R2,SP
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       I2C_MasterTransferRunStateMachine
   \   00000012   0x4606             MOV      R6,R0
   1043          
   1044              if (isDone || result)
   \   00000014   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xBF08             IT       EQ 
   \   0000001C   0x2E00             CMPEQ    R6,#+0
   \   0000001E   0xD01C             BEQ.N    ??I2C_MasterTransferHandleIRQ_0
   1045              {
   1046                  /* Send stop command if transfer done or received Nak. */
   1047                  if ((!(handle->transfer.flags & kI2C_TransferNoStopFlag)) || (result == kStatus_I2C_Nak))
   \   00000020   0x7828             LDRB     R0,[R5, #+0]
   \   00000022   0x0740             LSLS     R0,R0,#+29
   \   00000024   0xD503             BPL.N    ??I2C_MasterTransferHandleIRQ_1
   \   00000026   0xF240 0x404E      MOVW     R0,#+1102
   \   0000002A   0x4286             CMP      R6,R0
   \   0000002C   0xD107             BNE.N    ??I2C_MasterTransferHandleIRQ_2
   1048                  {
   1049                      /* Ensure stop command is a need. */
   1050                      if ((base->C1 & I2C_C1_MST_MASK))
   \                     ??I2C_MasterTransferHandleIRQ_1: (+1)
   \   0000002E   0x78A0             LDRB     R0,[R4, #+2]
   \   00000030   0x0680             LSLS     R0,R0,#+26
   \   00000032   0xD504             BPL.N    ??I2C_MasterTransferHandleIRQ_2
   1051                      {
   1052                          if (I2C_MasterStop(base) != kStatus_Success)
   \   00000034   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_16: (+1)
   \   00000038   0xB108             CBZ.N    R0,??I2C_MasterTransferHandleIRQ_2
   1053                          {
   1054                              result = kStatus_I2C_Timeout;
   \   0000003A   0xF44F 0x668A      MOV      R6,#+1104
   1055                          }
   1056                      }
   1057                  }
   1058          
   1059                  /* Restore handle to idle state. */
   1060                  handle->state = kIdleState;
   \                     ??I2C_MasterTransferHandleIRQ_2: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7728             STRB     R0,[R5, #+28]
   1061          
   1062                  /* Disable interrupt. */
   1063                  I2C_DisableInterrupts(base, kI2C_GlobalInterruptEnable);
   \   00000042   0x2140             MOVS     R1,#+64
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      BL       I2C_DisableInterrupts
   1064          
   1065                  /* Call the callback function after the function has completed. */
   1066                  if (handle->completionCallback)
   \   0000004A   0x6A2F             LDR      R7,[R5, #+32]
   \   0000004C   0x0038             MOVS     R0,R7
   \   0000004E   0xD004             BEQ.N    ??I2C_MasterTransferHandleIRQ_0
   1067                  {
   1068                      handle->completionCallback(base, handle, result, handle->userData);
   \   00000050   0x6A6B             LDR      R3,[R5, #+36]
   \   00000052   0x4632             MOV      R2,R6
   \   00000054   0x4629             MOV      R1,R5
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x47B8             BLX      R7
   1069                  }
   1070              }
   1071          }
   \                     ??I2C_MasterTransferHandleIRQ_0: (+1)
   \   0000005A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1072          

   \                                 In section .text, align 2, keep-with-next
   1073          void I2C_SlaveInit(I2C_Type *base, const i2c_slave_config_t *slaveConfig)
   1074          {
   \                     I2C_SlaveInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1075              assert(slaveConfig);
   1076          
   1077              uint8_t tmpReg;
   1078          
   1079              CLOCK_EnableClock(s_i2cClocks[I2C_GetInstance(base)]);
   \   00000006   0x.... 0x....      BL       I2C_GetInstance
   \   0000000A   0x.... 0x....      BL       ?Subroutine9
   1080          
   1081              /* Configure addressing mode. */
   1082              switch (slaveConfig->addressingMode)
   \                     ??CrossCallReturnLabel_10: (+1)
   \   0000000E   0x7AA8             LDRB     R0,[R5, #+10]
   \   00000010   0xB110             CBZ.N    R0,??I2C_SlaveInit_0
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xD004             BEQ.N    ??I2C_SlaveInit_1
   \   00000016   0xE00D             B.N      ??I2C_SlaveInit_2
   1083              {
   1084                  case kI2C_Address7bit:
   1085                      base->A1 = ((uint32_t)(slaveConfig->slaveAddress)) << 1U;
   \                     ??I2C_SlaveInit_0: (+1)
   \   00000018   0x88E8             LDRH     R0,[R5, #+6]
   \   0000001A   0x0040             LSLS     R0,R0,#+1
   \   0000001C   0x7020             STRB     R0,[R4, #+0]
   1086                      break;
   \   0000001E   0xE009             B.N      ??I2C_SlaveInit_2
   1087          
   1088                  case kI2C_RangeMatch:
   1089                      assert(slaveConfig->slaveAddress < slaveConfig->upperAddress);
   1090                      base->A1 = ((uint32_t)(slaveConfig->slaveAddress)) << 1U;
   \                     ??I2C_SlaveInit_1: (+1)
   \   00000020   0x88E8             LDRH     R0,[R5, #+6]
   \   00000022   0x0040             LSLS     R0,R0,#+1
   \   00000024   0x7020             STRB     R0,[R4, #+0]
   1091                      base->RA = ((uint32_t)(slaveConfig->upperAddress)) << 1U;
   \   00000026   0x8928             LDRH     R0,[R5, #+8]
   \   00000028   0x0040             LSLS     R0,R0,#+1
   \   0000002A   0x71E0             STRB     R0,[R4, #+7]
   1092                      base->C2 |= I2C_C2_RMEN_MASK;
   \   0000002C   0x7960             LDRB     R0,[R4, #+5]
   \   0000002E   0xF040 0x0008      ORR      R0,R0,#0x8
   \   00000032   0x7160             STRB     R0,[R4, #+5]
   1093                      break;
   1094          
   1095                  default:
   1096                      break;
   1097              }
   1098          
   1099              /* Configure low power wake up feature. */
   1100              tmpReg = base->C1;
   1101              tmpReg &= ~I2C_C1_WUEN_MASK;
   1102              base->C1 = tmpReg | I2C_C1_WUEN(slaveConfig->enableWakeUp) | I2C_C1_IICEN(slaveConfig->enableSlave);
   \                     ??I2C_SlaveInit_2: (+1)
   \   00000034   0x78A0             LDRB     R0,[R4, #+2]
   \   00000036   0x78A9             LDRB     R1,[R5, #+2]
   \   00000038   0xF000 0x00FD      AND      R0,R0,#0xFD
   \   0000003C   0xEA40 0x0041      ORR      R0,R0,R1, LSL #+1
   \   00000040   0x7829             LDRB     R1,[R5, #+0]
   \   00000042   0xEA40 0x10C1      ORR      R0,R0,R1, LSL #+7
   \   00000046   0x70A0             STRB     R0,[R4, #+2]
   1103          
   1104              /* Configure general call & baud rate control & high drive feature. */
   1105              tmpReg = base->C2;
   1106              tmpReg &= ~(I2C_C2_SBRC_MASK | I2C_C2_GCAEN_MASK);
   1107              tmpReg |= I2C_C2_SBRC(slaveConfig->enableBaudRateCtl) | I2C_C2_GCAEN(slaveConfig->enableGeneralCall);
   1108          #if defined(FSL_FEATURE_I2C_HAS_HIGH_DRIVE_SELECTION) && FSL_FEATURE_I2C_HAS_HIGH_DRIVE_SELECTION
   1109              tmpReg &= ~I2C_C2_HDRS_MASK;
   1110              tmpReg |= I2C_C2_HDRS(slaveConfig->enableHighDrive);
   1111          #endif
   1112              base->C2 = tmpReg;
   \   00000048   0x7960             LDRB     R0,[R4, #+5]
   \   0000004A   0x7929             LDRB     R1,[R5, #+4]
   \   0000004C   0xF000 0x006F      AND      R0,R0,#0x6F
   \   00000050   0xEA40 0x1001      ORR      R0,R0,R1, LSL #+4
   \   00000054   0x7869             LDRB     R1,[R5, #+1]
   \   00000056   0xEA40 0x10C1      ORR      R0,R0,R1, LSL #+7
   \   0000005A   0x78E9             LDRB     R1,[R5, #+3]
   \   0000005C   0x.... 0x....      BL       ?Subroutine12
   1113          }
   \                     ??CrossCallReturnLabel_21: (+1)
   \   00000060   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1114          

   \                                 In section .text, align 2, keep-with-next
   1115          void I2C_SlaveDeinit(I2C_Type *base)
   \                     I2C_SlaveDeinit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002                      REQUIRE ?Subroutine2
   \   00000002                      ;; // Fall through to label ?Subroutine2
   1116          {
   1117              /* Disable I2C module. */
   1118              I2C_Enable(base, false);
   1119          
   1120              /* Disable I2C clock. */
   1121              CLOCK_DisableClock(s_i2cClocks[I2C_GetInstance(base)]);
   1122          }
   1123          

   \                                 In section .text, align 2, keep-with-next
   1124          void I2C_SlaveGetDefaultConfig(i2c_slave_config_t *slaveConfig)
   1125          {
   1126              assert(slaveConfig);
   1127          
   1128              /* By default slave is addressed with 7-bit address. */
   1129              slaveConfig->addressingMode = kI2C_Address7bit;
   \                     I2C_SlaveGetDefaultConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7281             STRB     R1,[R0, #+10]
   1130          
   1131              /* General call mode is disabled by default. */
   1132              slaveConfig->enableGeneralCall = false;
   \   00000004   0x7041             STRB     R1,[R0, #+1]
   1133          
   1134              /* Slave address match waking up MCU from low power mode is disabled. */
   1135              slaveConfig->enableWakeUp = false;
   \   00000006   0x7081             STRB     R1,[R0, #+2]
   1136          
   1137          #if defined(FSL_FEATURE_I2C_HAS_HIGH_DRIVE_SELECTION) && FSL_FEATURE_I2C_HAS_HIGH_DRIVE_SELECTION
   1138              /* Default pin high drive is disabled. */
   1139              slaveConfig->enableHighDrive = false;
   \   00000008   0x70C1             STRB     R1,[R0, #+3]
   1140          #endif
   1141          
   1142              /* Independent slave mode baud rate at maximum frequency is disabled. */
   1143              slaveConfig->enableBaudRateCtl = false;
   \   0000000A   0x7101             STRB     R1,[R0, #+4]
   1144          
   1145              /* Enable the I2C peripheral. */
   1146              slaveConfig->enableSlave = true;
   \   0000000C                      REQUIRE ?Subroutine0
   \   0000000C                      ;; // Fall through to label ?Subroutine0
   1147          }
   1148          

   \                                 In section .text, align 2, keep-with-next
   1149          status_t I2C_SlaveWriteBlocking(I2C_Type *base, const uint8_t *txBuff, size_t txSize)
   1150          {
   1151              return I2C_MasterWriteBlocking(base, txBuff, txSize);
   \                     I2C_SlaveWriteBlocking: (+1)
   \   00000000   0x....             B.N      I2C_MasterWriteBlocking
   1152          }
   1153          

   \                                 In section .text, align 2, keep-with-next
   1154          void I2C_SlaveReadBlocking(I2C_Type *base, uint8_t *rxBuff, size_t rxSize)
   1155          {
   1156              /* Clear the IICIF flag. */
   1157              base->S = kI2C_IntPendingFlag;
   \                     I2C_SlaveReadBlocking: (+1)
   \   00000000   0x2302             MOVS     R3,#+2
   \   00000002   0x70C3             STRB     R3,[R0, #+3]
   1158          
   1159              /* Wait until the data register is ready for receive. */
   1160              while (!(base->S & kI2C_TransferCompleteFlag))
   \                     ??I2C_SlaveReadBlocking_0: (+1)
   \   00000004   0x78C3             LDRB     R3,[R0, #+3]
   \   00000006   0x061B             LSLS     R3,R3,#+24
   \   00000008   0xD5FC             BPL.N    ??I2C_SlaveReadBlocking_0
   1161              {
   1162              }
   1163          
   1164              /* Setup the I2C peripheral to receive data. */
   1165              base->C1 &= ~(I2C_C1_TX_MASK);
   \   0000000A   0x7883             LDRB     R3,[R0, #+2]
   \   0000000C   0xF003 0x03EF      AND      R3,R3,#0xEF
   \   00000010   0x7083             STRB     R3,[R0, #+2]
   1166          
   1167              while (rxSize--)
   \                     ??I2C_SlaveReadBlocking_1: (+1)
   \   00000012   0x4613             MOV      R3,R2
   \   00000014   0x1E5A             SUBS     R2,R3,#+1
   \   00000016   0xB143             CBZ.N    R3,??I2C_SlaveReadBlocking_2
   1168              {
   1169                  /* Clear the IICIF flag. */
   1170                  base->S = kI2C_IntPendingFlag;
   \   00000018   0x2302             MOVS     R3,#+2
   \   0000001A   0x70C3             STRB     R3,[R0, #+3]
   1171          
   1172                  /* Read from the data register. */
   1173                  *rxBuff++ = base->D;
   \   0000001C   0x7903             LDRB     R3,[R0, #+4]
   \   0000001E   0xF801 0x3B01      STRB     R3,[R1], #+1
   1174          
   1175                  /* Wait until data transfer complete. */
   1176                  while (!(base->S & kI2C_IntPendingFlag))
   \                     ??I2C_SlaveReadBlocking_3: (+1)
   \   00000022   0x78C3             LDRB     R3,[R0, #+3]
   \   00000024   0x079B             LSLS     R3,R3,#+30
   \   00000026   0xD5FC             BPL.N    ??I2C_SlaveReadBlocking_3
   \   00000028   0xE7F3             B.N      ??I2C_SlaveReadBlocking_1
   1177                  {
   1178                  }
   1179              }
   1180          }
   \                     ??I2C_SlaveReadBlocking_2: (+1)
   \   0000002A   0x4770             BX       LR               ;; return
   1181          

   \                                 In section .text, align 2, keep-with-next
   1182          void I2C_SlaveTransferCreateHandle(I2C_Type *base,
   1183                                             i2c_slave_handle_t *handle,
   1184                                             i2c_slave_transfer_callback_t callback,
   1185                                             void *userData)
   1186          {
   \                     I2C_SlaveTransferCreateHandle: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine4
   1187              assert(handle);
   1188          
   1189              uint32_t instance = I2C_GetInstance(base);
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000006   0x4607             MOV      R7,R0
   1190          
   1191              /* Zero handle. */
   1192              memset(handle, 0, sizeof(*handle));
   \   00000008   0x2124             MOVS     R1,#+36
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       __aeabi_memclr4
   1193          
   1194              /* Set callback and userData. */
   1195              handle->callback = callback;
   1196              handle->userData = userData;
   1197          
   1198              /* Save the context in global variables to support the double weak mechanism. */
   1199              s_i2cHandle[instance] = handle;
   \   00000010   0x....             LDR.N    R0,??DataTable9_1
   \   00000012   0x61E5             STR      R5,[R4, #+28]
   \   00000014   0x6226             STR      R6,[R4, #+32]
   \   00000016   0xF840 0x4027      STR      R4,[R0, R7, LSL #+2]
   1200          
   1201              /* Save slave interrupt handler. */
   1202              s_i2cSlaveIsr = I2C_SlaveTransferHandleIRQ;
   \   0000001A   0x.... 0x....      ADR.W    R1,I2C_SlaveTransferHandleIRQ
   \   0000001E   0x60C1             STR      R1,[R0, #+12]
   1203          
   1204              /* Enable NVIC interrupt. */
   1205              EnableIRQ(s_i2cIrqs[instance]);
   \   00000020                      REQUIRE ?Subroutine3
   \   00000020                      ;; // Fall through to label ?Subroutine3
   1206          }
   1207          

   \                                 In section .text, align 2, keep-with-next
   1208          status_t I2C_SlaveTransferNonBlocking(I2C_Type *base, i2c_slave_handle_t *handle, uint32_t eventMask)
   1209          {
   \                     I2C_SlaveTransferNonBlocking: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4604             MOV      R4,R0
   1210              assert(handle);
   1211          
   1212              /* Check if the I2C bus is idle - if not return busy status. */
   1213              if (handle->isBusy)
   \   00000006   0x7828             LDRB     R0,[R5, #+0]
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0xB110             CBZ.N    R0,??I2C_SlaveTransferNonBlocking_0
   1214              {
   1215                  return kStatus_I2C_Busy;
   \   0000000C   0xF240 0x404C      MOVW     R0,#+1100
   \   00000010   0xBD70             POP      {R4-R6,PC}
   1216              }
   1217              else
   1218              {
   1219                  /* Disable LPI2C IRQ sources while we configure stuff. */
   1220                  I2C_DisableInterrupts(base, kIrqFlags);
   \                     ??I2C_SlaveTransferNonBlocking_0: (+1)
   \   00000012   0x2160             MOVS     R1,#+96
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       I2C_DisableInterrupts
   1221          
   1222                  /* Clear transfer in handle. */
   1223                  memset(&handle->transfer, 0, sizeof(handle->transfer));
   \   0000001A   0x2114             MOVS     R1,#+20
   \   0000001C   0x1D28             ADDS     R0,R5,#+4
   \   0000001E   0x.... 0x....      BL       __aeabi_memclr4
   1224          
   1225                  /* Record that we're busy. */
   1226                  handle->isBusy = true;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x7028             STRB     R0,[R5, #+0]
   1227          
   1228                  /* Set up event mask. tx and rx are always enabled. */
   1229                  handle->eventMask = eventMask | kI2C_SlaveTransmitEvent | kI2C_SlaveReceiveEvent;
   1230          
   1231                  /* Clear all flags. */
   1232                  I2C_SlaveClearStatusFlags(base, kClearFlags);
   \   00000026   0xF245 0x0112      MOVW     R1,#+20498
   \   0000002A   0xF046 0x0006      ORR      R0,R6,#0x6
   \   0000002E   0x61A8             STR      R0,[R5, #+24]
   \   00000030   0x.... 0x....      BL       ?Subroutine10
   1233          
   1234                  /* Enable I2C internal IRQ sources. NVIC IRQ was enabled in CreateHandle() */
   1235                  I2C_EnableInterrupts(base, kIrqFlags);
   \                     ??CrossCallReturnLabel_14: (+1)
   \   00000034   0x2160             MOVS     R1,#+96
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       I2C_EnableInterrupts
   1236              }
   1237          
   1238              return kStatus_Success;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
   1239          }
   1240          

   \                                 In section .text, align 2, keep-with-next
   1241          void I2C_SlaveTransferAbort(I2C_Type *base, i2c_slave_handle_t *handle)
   1242          {
   \                     I2C_SlaveTransferAbort: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
   1243              assert(handle);
   1244          
   1245              if (handle->isBusy)
   \   00000004   0x7821             LDRB     R1,[R4, #+0]
   \   00000006   0xB141             CBZ.N    R1,??I2C_SlaveTransferAbort_0
   1246              {
   1247                  /* Disable interrupts. */
   1248                  I2C_DisableInterrupts(base, kIrqFlags);
   \   00000008   0x2160             MOVS     R1,#+96
   \   0000000A   0x.... 0x....      BL       I2C_DisableInterrupts
   1249          
   1250                  /* Reset transfer info. */
   1251                  memset(&handle->transfer, 0, sizeof(handle->transfer));
   \   0000000E   0x2114             MOVS     R1,#+20
   \   00000010   0x1D20             ADDS     R0,R4,#+4
   \   00000012   0x.... 0x....      BL       __aeabi_memclr4
   1252          
   1253                  /* Reset the state to idle. */
   1254                  handle->isBusy = false;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x7020             STRB     R0,[R4, #+0]
   1255              }
   1256          }
   \                     ??I2C_SlaveTransferAbort_0: (+1)
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
   1257          

   \                                 In section .text, align 2, keep-with-next
   1258          status_t I2C_SlaveTransferGetCount(I2C_Type *base, i2c_slave_handle_t *handle, size_t *count)
   1259          {
   1260              assert(handle);
   1261          
   1262              if (!count)
   \                     I2C_SlaveTransferGetCount: (+1)
   \   00000000   0xB90A             CBNZ.N   R2,??I2C_SlaveTransferGetCount_0
   1263              {
   1264                  return kStatus_InvalidArgument;
   \   00000002   0x2004             MOVS     R0,#+4
   \   00000004   0x4770             BX       LR
   1265              }
   1266          
   1267              /* Catch when there is not an active transfer. */
   1268              if (!handle->isBusy)
   \                     ??I2C_SlaveTransferGetCount_0: (+1)
   \   00000006   0x7808             LDRB     R0,[R1, #+0]
   \   00000008   0xB910             CBNZ.N   R0,??I2C_SlaveTransferGetCount_1
   1269              {
   1270                  *count = 0;
   \   0000000A   0x6010             STR      R0,[R2, #+0]
   1271                  return kStatus_NoTransferInProgress;
   \   0000000C   0x2006             MOVS     R0,#+6
   \   0000000E   0x4770             BX       LR
   1272              }
   1273          
   1274              /* For an active transfer, just return the count from the handle. */
   1275              *count = handle->transfer.transferredCount;
   \                     ??I2C_SlaveTransferGetCount_1: (+1)
   \   00000010   0x6948             LDR      R0,[R1, #+20]
   \   00000012                      REQUIRE ?Subroutine1
   \   00000012                      ;; // Fall through to label ?Subroutine1
   1276          
   1277              return kStatus_Success;
   1278          }
   1279          

   \                                 In section .text, align 4, keep-with-next
   1280          void I2C_SlaveTransferHandleIRQ(I2C_Type *base, void *i2cHandle)
   1281          {
   \                     I2C_SlaveTransferHandleIRQ: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   1282              assert(i2cHandle);
   1283          
   1284              uint16_t status;
   1285              bool doTransmit = false;
   1286              i2c_slave_handle_t *handle = (i2c_slave_handle_t *)i2cHandle;
   1287              i2c_slave_transfer_t *xfer;
   1288              volatile uint8_t dummy = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000000A   0x460D             MOV      R5,R1
   1289          
   1290              /* Add this to avoid build warning. */
   1291              dummy++;
   \   0000000C   0x.... 0x....      BL       ?Subroutine7
   1292          
   1293              status = I2C_SlaveGetStatusFlags(base);
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       I2C_MasterGetStatusFlags
   \   00000016   0x4606             MOV      R6,R0
   1294              xfer = &(handle->transfer);
   1295          
   1296          #ifdef I2C_HAS_STOP_DETECT
   1297              /* Check stop flag. */
   1298              if (status & kI2C_StopDetectFlag)
   \   00000018   0x0470             LSLS     R0,R6,#+17
   \   0000001A   0xD50D             BPL.N    ??I2C_SlaveTransferHandleIRQ_0
   1299              {
   1300                  I2C_MasterClearStatusFlags(base, kI2C_StopDetectFlag);
   \   0000001C   0xF44F 0x4180      MOV      R1,#+16384
   \   00000020   0x.... 0x....      BL       ?Subroutine10
   1301          
   1302                  /* Clear the interrupt flag. */
   1303                  base->S = kI2C_IntPendingFlag;
   \                     ??CrossCallReturnLabel_13: (+1)
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0x70E0             STRB     R0,[R4, #+3]
   1304          
   1305                  /* Call slave callback if this is the STOP of the transfer. */
   1306                  if (handle->isBusy)
   \   00000028   0x7828             LDRB     R0,[R5, #+0]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD025             BEQ.N    ??I2C_SlaveTransferHandleIRQ_1
   1307                  {
   1308                      xfer->event = kI2C_SlaveCompletionEvent;
   \   0000002E   0x2020             MOVS     R0,#+32
   \   00000030   0x7128             STRB     R0,[R5, #+4]
   1309                      xfer->completionStatus = kStatus_Success;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x6128             STR      R0,[R5, #+16]
   1310                      handle->isBusy = false;
   \   00000036   0xE027             B.N      ??I2C_SlaveTransferHandleIRQ_2
   1311          
   1312                      if ((handle->eventMask & xfer->event) && (handle->callback))
   1313                      {
   1314                          handle->callback(base, xfer, handle->userData);
   1315                      }
   1316                  }
   1317          
   1318                  return;
   1319              }
   1320          #endif /* I2C_HAS_STOP_DETECT */
   1321          
   1322          #if defined(FSL_FEATURE_I2C_HAS_START_STOP_DETECT) && FSL_FEATURE_I2C_HAS_START_STOP_DETECT
   1323              /* Check start flag. */
   1324              if (status & kI2C_StartDetectFlag)
   \                     ??I2C_SlaveTransferHandleIRQ_0: (+1)
   \   00000038   0x04F0             LSLS     R0,R6,#+19
   \   0000003A   0xD511             BPL.N    ??I2C_SlaveTransferHandleIRQ_3
   1325              {
   1326                  I2C_MasterClearStatusFlags(base, kI2C_StartDetectFlag);
   \   0000003C   0xF44F 0x5180      MOV      R1,#+4096
   \   00000040   0x.... 0x....      BL       ?Subroutine10
   1327          
   1328                  /* Clear the interrupt flag. */
   1329                  base->S = kI2C_IntPendingFlag;
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000044   0x2002             MOVS     R0,#+2
   \   00000046   0x70E0             STRB     R0,[R4, #+3]
   1330          
   1331                  xfer->event = kI2C_SlaveRepeatedStartEvent;
   \   00000048   0x2010             MOVS     R0,#+16
   \   0000004A   0x7128             STRB     R0,[R5, #+4]
   1332          
   1333                  if ((handle->eventMask & xfer->event) && (handle->callback))
   \   0000004C   0x7E28             LDRB     R0,[R5, #+24]
   \   0000004E   0x06C0             LSLS     R0,R0,#+27
   \   00000050   0xD504             BPL.N    ??CrossCallReturnLabel_27
   \   00000052   0x69EB             LDR      R3,[R5, #+28]
   \   00000054   0x0018             MOVS     R0,R3
   \   00000056   0xD001             BEQ.N    ??CrossCallReturnLabel_27
   1334                  {
   1335                      handle->callback(base, xfer, handle->userData);
   \   00000058   0x.... 0x....      BL       ?Subroutine14
   1336                  }
   1337          
   1338                  if (!(status & kI2C_AddressMatchFlag))
   \                     ??CrossCallReturnLabel_27: (+1)
   \   0000005C   0x0670             LSLS     R0,R6,#+25
   \   0000005E   0xD566             BPL.N    ??I2C_SlaveTransferHandleIRQ_4
   1339                  {
   1340                      return;
   1341                  }
   1342              }
   1343          #endif /* FSL_FEATURE_I2C_HAS_START_STOP_DETECT */
   1344          
   1345              /* Clear the interrupt flag. */
   1346              base->S = kI2C_IntPendingFlag;
   \                     ??I2C_SlaveTransferHandleIRQ_3: (+1)
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0x70E0             STRB     R0,[R4, #+3]
   1347          
   1348              /* Check NAK */
   1349              if (status & kI2C_ReceiveNakFlag)
   \   00000064   0x07F0             LSLS     R0,R6,#+31
   \   00000066   0xD51E             BPL.N    ??I2C_SlaveTransferHandleIRQ_5
   1350              {
   1351                  /* Set receive mode. */
   1352                  base->C1 &= ~(I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
   \   00000068   0x78A0             LDRB     R0,[R4, #+2]
   \   0000006A   0xF000 0x00E7      AND      R0,R0,#0xE7
   \   0000006E   0x70A0             STRB     R0,[R4, #+2]
   1353          
   1354                  /* Read dummy. */
   1355                  dummy = base->D;
   \   00000070   0x7920             LDRB     R0,[R4, #+4]
   \   00000072   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1356          
   1357                  if (handle->transfer.dataSize != 0)
   \   00000076   0x68E8             LDR      R0,[R5, #+12]
   \   00000078   0x2800             CMP      R0,#+0
   \                     ??I2C_SlaveTransferHandleIRQ_1: (+1)
   \   0000007A   0xD058             BEQ.N    ??I2C_SlaveTransferHandleIRQ_4
   1358                  {
   1359                      xfer->event = kI2C_SlaveCompletionEvent;
   \   0000007C   0x2020             MOVS     R0,#+32
   \   0000007E   0x7128             STRB     R0,[R5, #+4]
   1360                      xfer->completionStatus = kStatus_I2C_Nak;
   \   00000080   0xF240 0x404E      MOVW     R0,#+1102
   \   00000084   0x6128             STR      R0,[R5, #+16]
   1361                      handle->isBusy = false;
   \   00000086   0x2000             MOVS     R0,#+0
   \                     ??I2C_SlaveTransferHandleIRQ_2: (+1)
   \   00000088   0x7028             STRB     R0,[R5, #+0]
   1362          
   1363                      if ((handle->eventMask & xfer->event) && (handle->callback))
   \   0000008A   0x7929             LDRB     R1,[R5, #+4]
   \   0000008C   0x69A8             LDR      R0,[R5, #+24]
   \   0000008E   0x4208             TST      R0,R1
   \   00000090   0xD04D             BEQ.N    ??I2C_SlaveTransferHandleIRQ_4
   \   00000092   0x69EB             LDR      R3,[R5, #+28]
   \   00000094   0x0018             MOVS     R0,R3
   \   00000096   0xD04A             BEQ.N    ??I2C_SlaveTransferHandleIRQ_4
   1364                      {
   1365                          handle->callback(base, xfer, handle->userData);
   \   00000098   0x6A2A             LDR      R2,[R5, #+32]
   \   0000009A   0x1D29             ADDS     R1,R5,#+4
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0xB001             ADD      SP,SP,#+4
   \   000000A0   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   000000A4   0x4718             BX       R3
   1366                      }
   1367                  }
   1368                  else
   1369                  {
   1370          #ifndef I2C_HAS_STOP_DETECT
   1371                      xfer->event = kI2C_SlaveCompletionEvent;
   1372                      xfer->completionStatus = kStatus_Success;
   1373                      handle->isBusy = false;
   1374          
   1375                      if ((handle->eventMask & xfer->event) && (handle->callback))
   1376                      {
   1377                          handle->callback(base, xfer, handle->userData);
   1378                      }
   1379          #endif /* !FSL_FEATURE_I2C_HAS_START_STOP_DETECT or !FSL_FEATURE_I2C_HAS_STOP_DETECT */
   1380                  }
   1381              }
   1382              /* Check address match. */
   1383              else if (status & kI2C_AddressMatchFlag)
   \                     ??I2C_SlaveTransferHandleIRQ_5: (+1)
   \   000000A6   0x0670             LSLS     R0,R6,#+25
   \   000000A8   0xF006 0x0704      AND      R7,R6,#0x4
   \   000000AC   0xD533             BPL.N    ??I2C_SlaveTransferHandleIRQ_6
   1384              {
   1385                  handle->isBusy = true;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0x7028             STRB     R0,[R5, #+0]
   1386                  xfer->event = kI2C_SlaveAddressMatchEvent;
   \   000000B2   0x7128             STRB     R0,[R5, #+4]
   1387          
   1388                  if ((handle->eventMask & xfer->event) && (handle->callback))
   \   000000B4   0x7E28             LDRB     R0,[R5, #+24]
   \   000000B6   0x07C0             LSLS     R0,R0,#+31
   \   000000B8   0xD504             BPL.N    ??CrossCallReturnLabel_26
   \   000000BA   0x69EB             LDR      R3,[R5, #+28]
   \   000000BC   0x0018             MOVS     R0,R3
   \   000000BE   0xD001             BEQ.N    ??CrossCallReturnLabel_26
   1389                  {
   1390                      handle->callback(base, xfer, handle->userData);
   \   000000C0   0x.... 0x....      BL       ?Subroutine14
   1391                  }
   1392          
   1393                  /* Slave transmit, master reading from slave. */
   1394                  if (status & kI2C_TransferDirectionFlag)
   \                     ??CrossCallReturnLabel_26: (+1)
   \   000000C4   0x2F00             CMP      R7,#+0
   \   000000C6   0x78A0             LDRB     R0,[R4, #+2]
   \   000000C8   0xD012             BEQ.N    ??I2C_SlaveTransferHandleIRQ_7
   1395                  {
   1396                      /* Change direction to send data. */
   1397                      base->C1 |= I2C_C1_TX_MASK;
   \   000000CA   0xF040 0x0010      ORR      R0,R0,#0x10
   \   000000CE   0x70A0             STRB     R0,[R4, #+2]
   1398          
   1399                      /* If we're out of data, invoke callback to get more. */
   1400                      if ((!xfer->data) || (!xfer->dataSize))
   \   000000D0   0x68A8             LDR      R0,[R5, #+8]
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xBF1C             ITT      NE 
   \   000000D6   0x68E8             LDRNE    R0,[R5, #+12]
   \   000000D8   0x2800             CMPNE    R0,#+0
   \   000000DA   0xD11F             BNE.N    ??I2C_SlaveTransferHandleIRQ_8
   1401                      {
   1402                          xfer->event = kI2C_SlaveTransmitEvent;
   \   000000DC   0x2002             MOVS     R0,#+2
   \   000000DE   0x7128             STRB     R0,[R5, #+4]
   1403          
   1404                          if (handle->callback)
   \   000000E0   0x69EB             LDR      R3,[R5, #+28]
   \   000000E2   0x0018             MOVS     R0,R3
   \   000000E4   0xD001             BEQ.N    ??CrossCallReturnLabel_25
   1405                          {
   1406                              handle->callback(base, xfer, handle->userData);
   \   000000E6   0x.... 0x....      BL       ?Subroutine14
   1407                          }
   1408          
   1409                          /* Clear the transferred count now that we have a new buffer. */
   1410                          xfer->transferredCount = 0;
   \                     ??CrossCallReturnLabel_25: (+1)
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0x6168             STR      R0,[R5, #+20]
   \   000000EE   0xE015             B.N      ??I2C_SlaveTransferHandleIRQ_8
   1411                      }
   1412          
   1413                      doTransmit = true;
   1414                  }
   1415                  else
   1416                  {
   1417                      /* Slave receive, master writing to slave. */
   1418                      base->C1 &= ~(I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
   \                     ??I2C_SlaveTransferHandleIRQ_7: (+1)
   \   000000F0   0xF000 0x00E7      AND      R0,R0,#0xE7
   \   000000F4   0x70A0             STRB     R0,[R4, #+2]
   1419          
   1420                      /* If we're out of data, invoke callback to get more. */
   1421                      if ((!xfer->data) || (!xfer->dataSize))
   \   000000F6   0x68A8             LDR      R0,[R5, #+8]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xBF1C             ITT      NE 
   \   000000FC   0x68E8             LDRNE    R0,[R5, #+12]
   \   000000FE   0x2800             CMPNE    R0,#+0
   \   00000100   0xD112             BNE.N    ??I2C_SlaveTransferHandleIRQ_9
   1422                      {
   1423                          xfer->event = kI2C_SlaveReceiveEvent;
   \   00000102   0x2004             MOVS     R0,#+4
   \   00000104   0x7128             STRB     R0,[R5, #+4]
   1424          
   1425                          if (handle->callback)
   \   00000106   0x69EB             LDR      R3,[R5, #+28]
   \   00000108   0x0018             MOVS     R0,R3
   \   0000010A   0xD001             BEQ.N    ??CrossCallReturnLabel_24
   1426                          {
   1427                              handle->callback(base, xfer, handle->userData);
   \   0000010C   0x.... 0x....      BL       ?Subroutine14
   1428                          }
   1429          
   1430                          /* Clear the transferred count now that we have a new buffer. */
   1431                          xfer->transferredCount = 0;
   \                     ??CrossCallReturnLabel_24: (+1)
   \   00000110   0x2000             MOVS     R0,#+0
   \   00000112   0x6168             STR      R0,[R5, #+20]
   1432                      }
   1433          
   1434                      /* Read dummy to release the bus. */
   1435                      dummy = base->D;
   \   00000114   0xE008             B.N      ??I2C_SlaveTransferHandleIRQ_9
   1436                  }
   1437              }
   1438              /* Check transfer complete flag. */
   1439              else if (status & kI2C_TransferCompleteFlag)
   \                     ??I2C_SlaveTransferHandleIRQ_6: (+1)
   \   00000116   0x0630             LSLS     R0,R6,#+24
   \   00000118   0xD506             BPL.N    ??I2C_SlaveTransferHandleIRQ_9
   1440              {
   1441                  /* Slave transmit, master reading from slave. */
   1442                  if (status & kI2C_TransferDirectionFlag)
   \   0000011A   0xB14F             CBZ.N    R7,??I2C_SlaveTransferHandleIRQ_10
   1443                  {
   1444                      doTransmit = true;
   1445                  }
   1446                  else
   1447                  {
   1448                      /* Slave receive, master writing to slave. */
   1449                      uint8_t data = base->D;
   1450          
   1451                      if (handle->transfer.dataSize)
   1452                      {
   1453                          /* Receive data. */
   1454                          *handle->transfer.data++ = data;
   1455                          handle->transfer.dataSize--;
   1456                          xfer->transferredCount++;
   1457                          if (!handle->transfer.dataSize)
   1458                          {
   1459          #ifndef I2C_HAS_STOP_DETECT
   1460                              xfer->event = kI2C_SlaveCompletionEvent;
   1461                              xfer->completionStatus = kStatus_Success;
   1462                              handle->isBusy = false;
   1463          
   1464                              /* Proceed receive complete event. */
   1465                              if ((handle->eventMask & xfer->event) && (handle->callback))
   1466                              {
   1467                                  handle->callback(base, xfer, handle->userData);
   1468                              }
   1469          #endif /* !FSL_FEATURE_I2C_HAS_START_STOP_DETECT or !FSL_FEATURE_I2C_HAS_STOP_DETECT */
   1470                          }
   1471                      }
   1472                  }
   1473              }
   1474              else
   1475              {
   1476                  /* Read dummy to release bus. */
   1477                  dummy = base->D;
   1478              }
   1479          
   1480              /* Send data if there is the need. */
   1481              if (doTransmit)
   1482              {
   1483                  if (handle->transfer.dataSize)
   \                     ??I2C_SlaveTransferHandleIRQ_8: (+1)
   \   0000011C   0x68E8             LDR      R0,[R5, #+12]
   \   0000011E   0xB998             CBNZ.N   R0,??I2C_SlaveTransferHandleIRQ_11
   1484                  {
   1485                      /* Send data. */
   1486                      base->D = *handle->transfer.data++;
   1487                      handle->transfer.dataSize--;
   1488                      xfer->transferredCount++;
   1489                  }
   1490                  else
   1491                  {
   1492                      /* Switch to receive mode. */
   1493                      base->C1 &= ~(I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);
   \   00000120   0x78A0             LDRB     R0,[R4, #+2]
   \   00000122   0xF000 0x00E7      AND      R0,R0,#0xE7
   \   00000126   0x70A0             STRB     R0,[R4, #+2]
   1494          
   1495                      /* Read dummy to release bus. */
   1496                      dummy = base->D;
   \                     ??I2C_SlaveTransferHandleIRQ_9: (+1)
   \   00000128   0x7920             LDRB     R0,[R4, #+4]
   \   0000012A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1497          
   1498          #ifndef I2C_HAS_STOP_DETECT
   1499                      xfer->event = kI2C_SlaveCompletionEvent;
   1500                      xfer->completionStatus = kStatus_Success;
   1501                      handle->isBusy = false;
   1502          
   1503                      /* Proceed txdone event. */
   1504                      if ((handle->eventMask & xfer->event) && (handle->callback))
   1505                      {
   1506                          handle->callback(base, xfer, handle->userData);
   1507                      }
   1508          #endif /* !FSL_FEATURE_I2C_HAS_START_STOP_DETECT or !FSL_FEATURE_I2C_HAS_STOP_DETECT */
   1509                  }
   1510              }
   1511          }
   \                     ??I2C_SlaveTransferHandleIRQ_4: (+1)
   \   0000012E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   \                     ??I2C_SlaveTransferHandleIRQ_10: (+1)
   \   00000130   0x7920             LDRB     R0,[R4, #+4]
   \   00000132   0x68E9             LDR      R1,[R5, #+12]
   \   00000134   0x2900             CMP      R1,#+0
   \   00000136   0xD0FA             BEQ.N    ??I2C_SlaveTransferHandleIRQ_4
   \   00000138   0x68A9             LDR      R1,[R5, #+8]
   \   0000013A   0x1C4A             ADDS     R2,R1,#+1
   \   0000013C   0x60AA             STR      R2,[R5, #+8]
   \   0000013E   0x7008             STRB     R0,[R1, #+0]
   \   00000140   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_22: (+1)
   \   00000144   0x68E8             LDR      R0,[R5, #+12]
   \   00000146   0xBDF1             POP      {R0,R4-R7,PC}
   \                     ??I2C_SlaveTransferHandleIRQ_11: (+1)
   \   00000148   0x68A8             LDR      R0,[R5, #+8]
   \   0000014A   0x1C41             ADDS     R1,R0,#+1
   \   0000014C   0x60A9             STR      R1,[R5, #+8]
   \   0000014E   0x7800             LDRB     R0,[R0, #+0]
   \   00000150   0x7120             STRB     R0,[R4, #+4]
   \   00000152   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_23: (+1)
   \   00000156   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \   00000000   0x6A2A             LDR      R2,[R5, #+32]
   \   00000002   0x1D29             ADDS     R1,R5,#+4
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x4718             BX       R3

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \   00000000   0x68E8             LDR      R0,[R5, #+12]
   \   00000002   0x1E40             SUBS     R0,R0,#+1
   \   00000004   0x60E8             STR      R0,[R5, #+12]
   \   00000006   0x6968             LDR      R0,[R5, #+20]
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   \   0000000A   0x6168             STR      R0,[R5, #+20]
   \   0000000C   0x4770             BX       LR
   1512          

   \                                 In section .text, align 2, keep-with-next
   1513          void I2C0_DriverIRQHandler(void)
   1514          {
   1515              I2C_TransferCommonIRQHandler(I2C0, s_i2cHandle[0]);
   \                     I2C0_DriverIRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable9_1
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40066000
   \   00000006   0x....             B.N      I2C_TransferCommonIRQHandler
   1516          }
   1517          
   1518          #if (FSL_FEATURE_SOC_I2C_COUNT > 1)

   \                                 In section .text, align 2, keep-with-next
   1519          void I2C1_DriverIRQHandler(void)
   1520          {
   1521              I2C_TransferCommonIRQHandler(I2C1, s_i2cHandle[1]);
   \                     I2C1_DriverIRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable9_1
   \   00000002   0x6841             LDR      R1,[R0, #+4]
   \   00000004   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40067000
   \   00000006   0x.... 0x....      B.W      I2C_TransferCommonIRQHandler
   1522          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     s_i2cHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x000186A0         DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x40066000         DC32     0x40066000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x40067000         DC32     0x40067000
   1523          #endif /* I2C COUNT > 1 */
   1524          
   1525          #if (FSL_FEATURE_SOC_I2C_COUNT > 2)
   1526          void I2C2_DriverIRQHandler(void)
   1527          {
   1528              I2C_TransferCommonIRQHandler(I2C2, s_i2cHandle[2]);
   1529          }
   1530          #endif /* I2C COUNT > 2 */
   1531          #if (FSL_FEATURE_SOC_I2C_COUNT > 3)
   1532          void I2C3_DriverIRQHandler(void)
   1533          {
   1534              I2C_TransferCommonIRQHandler(I2C3, s_i2cHandle[3]);
   1535          }
   1536          #endif /* I2C COUNT > 3 */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CLOCK_DisableClock
       0   CLOCK_EnableClock
       0   EnableIRQ
       0   I2C0_DriverIRQHandler
         0   -> I2C_TransferCommonIRQHandler
       0   I2C1_DriverIRQHandler
         0   -> I2C_TransferCommonIRQHandler
       0   I2C_CheckAndClearError
       0   I2C_DisableInterrupts
       0   I2C_Enable
       0   I2C_EnableInterrupts
       0   I2C_GetInstance
       0   I2C_MasterClearStatusFlags
       8   I2C_MasterDeinit
         0   -> CLOCK_DisableClock
         8   -> I2C_Enable
         8   -> I2C_GetInstance
       0   I2C_MasterGetDefaultConfig
       0   I2C_MasterGetStatusFlags
      16   I2C_MasterInit
        16   -> CLOCK_EnableClock
        16   -> I2C_GetInstance
        16   -> I2C_MasterClearStatusFlags
        16   -> I2C_MasterSetBaudRate
      24   I2C_MasterReadBlocking
        24   -> I2C_MasterStop
      24   I2C_MasterRepeatedStart
        24   -> I2C_MasterGetStatusFlags
      24   I2C_MasterSetBaudRate
      24   I2C_MasterStart
        24   -> I2C_MasterGetStatusFlags
       0   I2C_MasterStop
       8   I2C_MasterTransferAbort
         8   -> I2C_DisableInterrupts
      24   I2C_MasterTransferBlocking
        24   -> I2C_CheckAndClearError
        24   -> I2C_MasterClearStatusFlags
        24   -> I2C_MasterReadBlocking
        24   -> I2C_MasterRepeatedStart
        24   -> I2C_MasterStart
        24   -> I2C_MasterStop
        24   -> I2C_MasterWriteBlocking
      24   I2C_MasterTransferCreateHandle
         0   -> EnableIRQ
        24   -> I2C_GetInstance
        24   -> __aeabi_memclr4
       0   I2C_MasterTransferGetCount
      24   I2C_MasterTransferHandleIRQ
        24   -- Indirect call
        24   -> I2C_DisableInterrupts
        24   -> I2C_MasterStop
        24   -> I2C_MasterTransferRunStateMachine
      24   I2C_MasterTransferNonBlocking
        24   -> I2C_EnableInterrupts
        24   -> I2C_MasterClearStatusFlags
        24   -> I2C_MasterRepeatedStart
        24   -> I2C_MasterStart
        24   -> __aeabi_memcpy4
      32   I2C_MasterTransferRunStateMachine
        32   -> I2C_CheckAndClearError
        32   -> I2C_MasterRepeatedStart
        32   -> I2C_MasterStop
      12   I2C_MasterWriteBlocking
       0   I2C_SlaveDeinit
         0   -> CLOCK_DisableClock
         8   -> I2C_Enable
         8   -> I2C_GetInstance
       0   I2C_SlaveGetDefaultConfig
      16   I2C_SlaveInit
        16   -> CLOCK_EnableClock
        16   -> I2C_GetInstance
       0   I2C_SlaveReadBlocking
       8   I2C_SlaveTransferAbort
         8   -> I2C_DisableInterrupts
         8   -> __aeabi_memclr4
      24   I2C_SlaveTransferCreateHandle
         0   -> EnableIRQ
        24   -> I2C_GetInstance
        24   -> __aeabi_memclr4
       0   I2C_SlaveTransferGetCount
      24   I2C_SlaveTransferHandleIRQ
         0   -- Indirect call
        24   -- Indirect call
        24   -> I2C_MasterClearStatusFlags
        24   -> I2C_MasterGetStatusFlags
      16   I2C_SlaveTransferNonBlocking
        16   -> I2C_DisableInterrupts
        16   -> I2C_EnableInterrupts
        16   -> I2C_MasterClearStatusFlags
        16   -> __aeabi_memclr4
       0   I2C_SlaveWriteBlocking
         0   -> I2C_MasterWriteBlocking
       0   I2C_TransferCommonIRQHandler
         0   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       6  ?Subroutine0
       6  ?Subroutine1
       4  ?Subroutine10
       4  ?Subroutine11
      12  ?Subroutine12
      14  ?Subroutine13
       8  ?Subroutine14
      28  ?Subroutine2
      12  ?Subroutine3
       8  ?Subroutine4
      16  ?Subroutine5
      12  ?Subroutine6
      12  ?Subroutine7
      10  ?Subroutine8
      10  ?Subroutine9
      26  CLOCK_DisableClock
      24  CLOCK_EnableClock
      20  EnableIRQ
       8  I2C0_DriverIRQHandler
      10  I2C1_DriverIRQHandler
      28  I2C_CheckAndClearError
      26  I2C_DisableInterrupts
      18  I2C_Enable
      26  I2C_EnableInterrupts
      24  I2C_GetInstance
      28  I2C_MasterClearStatusFlags
       4  I2C_MasterDeinit
      16  I2C_MasterGetDefaultConfig
      26  I2C_MasterGetStatusFlags
      84  I2C_MasterInit
      98  I2C_MasterReadBlocking
      80  I2C_MasterRepeatedStart
      94  I2C_MasterSetBaudRate
      50  I2C_MasterStart
      42  I2C_MasterStop
      16  I2C_MasterTransferAbort
     234  I2C_MasterTransferBlocking
      36  I2C_MasterTransferCreateHandle
      14  I2C_MasterTransferGetCount
      92  I2C_MasterTransferHandleIRQ
     140  I2C_MasterTransferNonBlocking
     282  I2C_MasterTransferRunStateMachine
      82  I2C_MasterWriteBlocking
       2  I2C_SlaveDeinit
      12  I2C_SlaveGetDefaultConfig
      98  I2C_SlaveInit
      44  I2C_SlaveReadBlocking
      28  I2C_SlaveTransferAbort
      32  I2C_SlaveTransferCreateHandle
      18  I2C_SlaveTransferGetCount
     344  I2C_SlaveTransferHandleIRQ
      64  I2C_SlaveTransferNonBlocking
       2  I2C_SlaveWriteBlocking
      24  I2C_TransferCommonIRQHandler
       8  s_i2cBases
       8  s_i2cClocks
     128  s_i2cDividerTable
      16  s_i2cHandle
          s_i2cMasterIsr
          s_i2cSlaveIsr
       2  s_i2cIrqs

 
    16 bytes in section .bss
 2 624 bytes in section .text
 
 2 624 bytes of CODE memory
    16 bytes of DATA memory

Errors: none
Warnings: none
