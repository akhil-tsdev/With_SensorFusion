###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:15
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_msc_ufi.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_msc_ufi.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\usb_device_msc_ufi.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\usb_device_msc_ufi.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_msc_ufi.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "usb_device_config.h"
     32          #include "usb.h"
     33          #include "usb_device.h"
     34          
     35          #include "usb_device_class.h"
     36          
     37          #if USB_DEVICE_CONFIG_MSC
     38          #include "usb_device_msc_ufi.h"
     39          #include "usb_device_msc.h"
     40          /*******************************************************************************
     41           * Definitions
     42           ******************************************************************************/
     43          
     44          /*******************************************************************************
     45           * Prototypes
     46           ******************************************************************************/
     47          /*******************************************************************************
     48           * Variables
     49           ******************************************************************************/
     50          /*******************************************************************************
     51           * Code
     52           ******************************************************************************/
     53          

   \                                 In section .rodata, align 4
     54          const usb_device_inquiry_data_fromat_struct_t g_InquiryInfoConst = {
   \                     g_InquiryInfoConst:
   \   00000000   0x00 0x80          DC8 0, 128, 4, 2, 32, 0, 0, 0, 70, 83, 76, 32, 83, 69, 77, 73, 70, 83
   \              0x04 0x02    
   \              0x20 0x00    
   \              0x00 0x00    
   \              0x46 0x53    
   \              0x4C 0x20    
   \              0x53 0x45    
   \              0x4D 0x49    
   \              0x46 0x53    
   \   00000012   0x4C 0x20          DC8 76, 32, 77, 65, 83, 83, 32, 83, 84, 79, 82, 65, 71, 69, 48, 48, 48
   \              0x4D 0x41    
   \              0x53 0x53    
   \              0x20 0x53    
   \              0x54 0x4F    
   \              0x52 0x41    
   \              0x47 0x45    
   \              0x30 0x30    
   \              0x30         
   \   00000023   0x31               DC8 49
     55              (USB_DEVICE_MSC_UFI_PERIPHERAL_QUALIFIER << USB_DEVICE_MSC_UFI_PERIPHERAL_QUALIFIER_SHIFT) |
     56                  USB_DEVICE_MSC_UFI_PERIPHERAL_DEVICE_TYPE,
     57              (uint8_t)(USB_DEVICE_MSC_UFI_REMOVABLE_MEDIUM_BIT << USB_DEVICE_MSC_UFI_REMOVABLE_MEDIUM_BIT_SHIFT),
     58              USB_DEVICE_MSC_UFI_VERSIONS,
     59              0x02,
     60              USB_DEVICE_MSC_UFI_ADDITIONAL_LENGTH,
     61              {0x00, 0x00, 0x00},
     62              {'F', 'S', 'L', ' ', 'S', 'E', 'M', 'I'},
     63              {'F', 'S', 'L', ' ', 'M', 'A', 'S', 'S', ' ', 'S', 'T', 'O', 'R', 'A', 'G', 'E'},
     64              {'0', '0', '0', '1'}};

   \                                 In section .rodata, align 4
     65          const usb_device_mode_parameters_header_struct_t g_ModeParametersHeaderConst = {
   \                     g_ModeParametersHeaderConst:
   \   00000000   0x0000             DC16 0
   \   00000002   0x00 0x00          DC8 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
     66              /*refer to ufi spec mode parameter header*/
     67              0x0000, /*!< Mode Data Length*/
     68              0x00,   /*!<Default medium type (current mounted medium type)*/
     69              0x00,   /*!MODE SENSE command, a Write Protected bit of zero indicates the medium is write enabled*/
     70              {0x00, 0x00, 0x00, 0x00} /*!<This bit should be set to zero*/
     71          };
     72          /*!
     73           * @brief Thirteen possiable case check.
     74           *
     75           * This function handle the the thirteen possible cases of host expectations and device intent in the absence of
     76           *overriding error conditions.
     77           *
     78           * @param handle          The device msc class hanlde.
     79           *
     80           *@return A USB error code or kStatus_USB_Success. more information about return value ,refer to
     81           *USB_DeviceMscLbaTransfer and USB_DeviceRecvRequest
     82           */
     83          

   \                                 In section .text, align 2, keep-with-next
     84          usb_status_t USB_DeviceMscUfiThirteenCasesCheck(usb_device_msc_struct_t *mscHandle)
     85          {
   \                     USB_DeviceMscUfiThirteenCasesCheck: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
     86              usb_status_t error = kStatus_USB_Success;
   \   00000004   0x2500             MOVS     R5,#+0
     87              usb_device_msc_ufi_struct_t *ufi;
     88              usb_device_msc_thirteen_case_struct_t *mscCheckEvent;
     89          
     90              mscCheckEvent = (usb_device_msc_thirteen_case_struct_t *)&mscHandle->mscUfi.thirteenCase;
   \   00000006   0xF114 0x006C      ADDS     R0,R4,#+108
   \   0000000A   0x0007             MOVS     R7,R0
     91              ufi = &mscHandle->mscUfi;
   \   0000000C   0xF114 0x0058      ADDS     R0,R4,#+88
   \   00000010   0x0006             MOVS     R6,R0
     92              /* The following code describe the thirteen possiable cases of host
     93                  exceptations and device intent in absence of overriding error conditions ,refer to bulk-only spec chapter 6.7
     94                 The Thirteen Cases*/
     95              if (mscCheckEvent->hostExpectedDataLength == 0)
   \   00000012   0x6838             LDR      R0,[R7, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD10C             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_0
     96              {
     97                  /*Host expects no data transfers*/
     98                  mscHandle->mscCsw.dataResidue = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6520             STR      R0,[R4, #+80]
     99                  if (mscCheckEvent->deviceExpectedDataLength == 0)
   \   0000001C   0x6878             LDR      R0,[R7, #+4]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD103             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_1
    100                  { /*case 1, Device intends to transfer no data*/
    101                      mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_PASSED;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xF884 0x0054      STRB     R0,[R4, #+84]
   \   00000028   0xE179             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_2
    102                  }
    103                  else
    104                  { /*case 2 ,Device intends to send data to the host; */
    105                      /*case 3, Device intends to receive data from the host*/
    106                      /*set csw status to 02h*/
    107                      mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_PHASE_ERROR;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_1: (+1)
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xF884 0x0054      STRB     R0,[R4, #+84]
   \   00000030   0xE175             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_2
    108                  }
    109              }
    110              else if (mscCheckEvent->hostExpectedDirection)
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_0: (+1)
   \   00000032   0x7D78             LDRB     R0,[R7, #+21]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xF000 0x80C2      BEQ.W    ??USB_DeviceMscUfiThirteenCasesCheck_3
    111              {
    112                  /*Host expects to receive data from the device*/
    113                  if (mscCheckEvent->deviceExpectedDataLength == 0)
   \   0000003A   0x6878             LDR      R0,[R7, #+4]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD11C             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_4
    114                  {
    115                      /*case 4, Device intends to transfer no data*/
    116                      mscHandle->mscCsw.dataResidue =
    117                          mscCheckEvent->hostExpectedDataLength - mscCheckEvent->deviceExpectedDataLength;
   \   00000040   0x6838             LDR      R0,[R7, #+0]
   \   00000042   0x6879             LDR      R1,[R7, #+4]
   \   00000044   0x1A40             SUBS     R0,R0,R1
   \   00000046   0x6520             STR      R0,[R4, #+80]
    118                      error = USB_DeviceSendRequest(mscHandle->handle, mscHandle->bulkInEndpoint, mscCheckEvent->buffer,
    119                                                    mscCheckEvent->deviceExpectedDataLength);
   \   00000048   0x687B             LDR      R3,[R7, #+4]
   \   0000004A   0x68BA             LDR      R2,[R7, #+8]
   \   0000004C   0xF894 0x10F9      LDRB     R1,[R4, #+249]
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x.... 0x....      BL       USB_DeviceSendRequest
   \   00000056   0x0005             MOVS     R5,R0
    120          
    121                      if (kStatus_USB_Success == error)
   \   00000058   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005A   0x2D00             CMP      R5,#+0
   \   0000005C   0xD103             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_5
    122                      {
    123                          mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_PASSED;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF884 0x0054      STRB     R0,[R4, #+84]
   \   00000064   0xE006             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_6
    124                      }
    125                      else
    126                      {
    127                          mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_FAILED;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_5: (+1)
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xF884 0x0054      STRB     R0,[R4, #+84]
    128                          ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_MEDIUM_ERROR;
   \   0000006C   0x2003             MOVS     R0,#+3
   \   0000006E   0x70B0             STRB     R0,[R6, #+2]
    129                          ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_UNRECOVERED_READ_ERROR;
   \   00000070   0x2011             MOVS     R0,#+17
   \   00000072   0x7330             STRB     R0,[R6, #+12]
    130                      }
    131                      error = kStatus_USB_InvalidRequest;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_6: (+1)
   \   00000074   0x2005             MOVS     R0,#+5
   \   00000076   0x0005             MOVS     R5,R0
   \   00000078   0xE151             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_2
    132                  }
    133                  else if (mscCheckEvent->deviceExpectedDirection)
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_4: (+1)
   \   0000007A   0x7DB8             LDRB     R0,[R7, #+22]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xF000 0x808E      BEQ.W    ??USB_DeviceMscUfiThirteenCasesCheck_7
    134                  {
    135                      if (mscCheckEvent->hostExpectedDataLength > mscCheckEvent->deviceExpectedDataLength)
   \   00000082   0x6878             LDR      R0,[R7, #+4]
   \   00000084   0x6839             LDR      R1,[R7, #+0]
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xD228             BCS.N    ??USB_DeviceMscUfiThirteenCasesCheck_8
    136                      {
    137                          /*case 5, device intends to send less data than the host indicated*/
    138                          mscHandle->mscCsw.dataResidue =
    139                              mscCheckEvent->hostExpectedDataLength - mscCheckEvent->deviceExpectedDataLength;
   \   0000008A   0x6838             LDR      R0,[R7, #+0]
   \   0000008C   0x6879             LDR      R1,[R7, #+4]
   \   0000008E   0x1A40             SUBS     R0,R0,R1
   \   00000090   0x6520             STR      R0,[R4, #+80]
    140          
    141                          if (ufi->thirteenCase.lbaSendRecvSelect == 1)
   \   00000092   0xF896 0x0028      LDRB     R0,[R6, #+40]
   \   00000096   0x2801             CMP      R0,#+1
   \   00000098   0xD107             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_9
    142                          {
    143                              error = USB_DeviceMscLbaTransfer(mscHandle, USB_IN, &mscCheckEvent->lbaInformation);
   \   0000009A   0xF117 0x020C      ADDS     R2,R7,#+12
   \   0000009E   0x2101             MOVS     R1,#+1
   \   000000A0   0x0020             MOVS     R0,R4
   \   000000A2   0x.... 0x....      BL       USB_DeviceMscLbaTransfer
   \   000000A6   0x0005             MOVS     R5,R0
   \   000000A8   0xE007             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_10
    144                          }
    145                          else
    146                          {
    147                              error = USB_DeviceSendRequest(mscHandle->handle, mscHandle->bulkInEndpoint, mscCheckEvent->buffer,
    148                                                            mscCheckEvent->deviceExpectedDataLength);
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_9: (+1)
   \   000000AA   0x687B             LDR      R3,[R7, #+4]
   \   000000AC   0x68BA             LDR      R2,[R7, #+8]
   \   000000AE   0xF894 0x10F9      LDRB     R1,[R4, #+249]
   \   000000B2   0x6820             LDR      R0,[R4, #+0]
   \   000000B4   0x.... 0x....      BL       USB_DeviceSendRequest
   \   000000B8   0x0005             MOVS     R5,R0
    149                          }
    150          
    151                          if (kStatus_USB_Success == error)
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_10: (+1)
   \   000000BA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BC   0x2D00             CMP      R5,#+0
   \   000000BE   0xD103             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_11
    152                          {
    153                              mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_PASSED;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xF884 0x0054      STRB     R0,[R4, #+84]
   \   000000C6   0xE006             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_12
    154                          }
    155                          else
    156                          {
    157                              mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_FAILED;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_11: (+1)
   \   000000C8   0x2001             MOVS     R0,#+1
   \   000000CA   0xF884 0x0054      STRB     R0,[R4, #+84]
    158                              ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_MEDIUM_ERROR;
   \   000000CE   0x2003             MOVS     R0,#+3
   \   000000D0   0x70B0             STRB     R0,[R6, #+2]
    159                              ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_UNRECOVERED_READ_ERROR;
   \   000000D2   0x2011             MOVS     R0,#+17
   \   000000D4   0x7330             STRB     R0,[R6, #+12]
    160                          }
    161                          error = kStatus_USB_InvalidRequest;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_12: (+1)
   \   000000D6   0x2005             MOVS     R0,#+5
   \   000000D8   0x0005             MOVS     R5,R0
   \   000000DA   0xE120             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_2
    162                      }
    163                      else if (mscCheckEvent->hostExpectedDataLength == mscCheckEvent->deviceExpectedDataLength)
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_8: (+1)
   \   000000DC   0x6838             LDR      R0,[R7, #+0]
   \   000000DE   0x6879             LDR      R1,[R7, #+4]
   \   000000E0   0x4288             CMP      R0,R1
   \   000000E2   0xD124             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_13
    164                      { /*case 6*,device intends to send dCBWDataTransferLength excepted by the host*/
    165                          mscHandle->mscCsw.dataResidue = 0;
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0x6520             STR      R0,[R4, #+80]
    166                          if (ufi->thirteenCase.lbaSendRecvSelect == 1)
   \   000000E8   0xF896 0x0028      LDRB     R0,[R6, #+40]
   \   000000EC   0x2801             CMP      R0,#+1
   \   000000EE   0xD107             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_14
    167                          {
    168                              error = USB_DeviceMscLbaTransfer(mscHandle, USB_IN, &mscCheckEvent->lbaInformation);
   \   000000F0   0xF117 0x020C      ADDS     R2,R7,#+12
   \   000000F4   0x2101             MOVS     R1,#+1
   \   000000F6   0x0020             MOVS     R0,R4
   \   000000F8   0x.... 0x....      BL       USB_DeviceMscLbaTransfer
   \   000000FC   0x0005             MOVS     R5,R0
   \   000000FE   0xE007             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_15
    169                          }
    170                          else
    171                          {
    172                              error = USB_DeviceSendRequest(mscHandle->handle, mscHandle->bulkInEndpoint, mscCheckEvent->buffer,
    173                                                            mscCheckEvent->deviceExpectedDataLength);
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_14: (+1)
   \   00000100   0x687B             LDR      R3,[R7, #+4]
   \   00000102   0x68BA             LDR      R2,[R7, #+8]
   \   00000104   0xF894 0x10F9      LDRB     R1,[R4, #+249]
   \   00000108   0x6820             LDR      R0,[R4, #+0]
   \   0000010A   0x.... 0x....      BL       USB_DeviceSendRequest
   \   0000010E   0x0005             MOVS     R5,R0
    174                          }
    175          
    176                          if (kStatus_USB_Success == error)
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_15: (+1)
   \   00000110   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000112   0x2D00             CMP      R5,#+0
   \   00000114   0xD103             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_16
    177                          {
    178                              mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_PASSED;
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0xF884 0x0054      STRB     R0,[R4, #+84]
   \   0000011C   0xE0FF             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_2
    179                          }
    180                          else
    181                          {
    182                              mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_FAILED;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_16: (+1)
   \   0000011E   0x2001             MOVS     R0,#+1
   \   00000120   0xF884 0x0054      STRB     R0,[R4, #+84]
    183                              ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_MEDIUM_ERROR;
   \   00000124   0x2003             MOVS     R0,#+3
   \   00000126   0x70B0             STRB     R0,[R6, #+2]
    184                              ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_UNRECOVERED_READ_ERROR;
   \   00000128   0x2011             MOVS     R0,#+17
   \   0000012A   0x7330             STRB     R0,[R6, #+12]
   \   0000012C   0xE0F7             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_2
    185                          }
    186                      }
    187                      else
    188                      { /*case 7, device intends to send more data than the host indicated*/
    189                          mscHandle->mscCsw.dataResidue = 0;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_13: (+1)
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0x6520             STR      R0,[R4, #+80]
    190          
    191                          if (ufi->thirteenCase.lbaSendRecvSelect == 1)
   \   00000132   0xF896 0x0028      LDRB     R0,[R6, #+40]
   \   00000136   0x2801             CMP      R0,#+1
   \   00000138   0xD112             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_17
    192                          {
    193                              mscCheckEvent->lbaInformation.transferNumber =
    194                                  mscCheckEvent->hostExpectedDataLength / mscHandle->lengthOfEachLba;
   \   0000013A   0x6838             LDR      R0,[R7, #+0]
   \   0000013C   0x69A1             LDR      R1,[R4, #+24]
   \   0000013E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000142   0x6138             STR      R0,[R7, #+16]
    195                              mscHandle->mscCsw.dataResidue =
    196                                  mscCheckEvent->hostExpectedDataLength -
    197                                  mscCheckEvent->lbaInformation.transferNumber * mscHandle->lengthOfEachLba;
   \   00000144   0x6838             LDR      R0,[R7, #+0]
   \   00000146   0x6939             LDR      R1,[R7, #+16]
   \   00000148   0x69A2             LDR      R2,[R4, #+24]
   \   0000014A   0xFB02 0x0011      MLS      R0,R2,R1,R0
   \   0000014E   0x6520             STR      R0,[R4, #+80]
    198                              error = USB_DeviceMscLbaTransfer(mscHandle, USB_IN, &mscCheckEvent->lbaInformation);
   \   00000150   0xF117 0x020C      ADDS     R2,R7,#+12
   \   00000154   0x2101             MOVS     R1,#+1
   \   00000156   0x0020             MOVS     R0,R4
   \   00000158   0x.... 0x....      BL       USB_DeviceMscLbaTransfer
   \   0000015C   0x0005             MOVS     R5,R0
   \   0000015E   0xE007             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_18
    199                          }
    200                          else
    201                          {
    202                              error = USB_DeviceSendRequest(mscHandle->handle, mscHandle->bulkInEndpoint, mscCheckEvent->buffer,
    203                                                            mscCheckEvent->hostExpectedDataLength);
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_17: (+1)
   \   00000160   0x683B             LDR      R3,[R7, #+0]
   \   00000162   0x68BA             LDR      R2,[R7, #+8]
   \   00000164   0xF894 0x10F9      LDRB     R1,[R4, #+249]
   \   00000168   0x6820             LDR      R0,[R4, #+0]
   \   0000016A   0x.... 0x....      BL       USB_DeviceSendRequest
   \   0000016E   0x0005             MOVS     R5,R0
    204                          }
    205          
    206                          if (kStatus_USB_Success == error)
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_18: (+1)
   \   00000170   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000172   0x2D00             CMP      R5,#+0
   \   00000174   0xD10B             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_19
    207                          {
    208                              if (ufi->thirteenCase.lbaSendRecvSelect == 1)
   \   00000176   0xF896 0x0028      LDRB     R0,[R6, #+40]
   \   0000017A   0x2801             CMP      R0,#+1
   \   0000017C   0xD103             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_20
    209                              {
    210                                  mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_PHASE_ERROR;
   \   0000017E   0x2002             MOVS     R0,#+2
   \   00000180   0xF884 0x0054      STRB     R0,[R4, #+84]
   \   00000184   0xE0CB             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_2
    211                              }
    212                              else
    213                              {
    214                                  mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_PASSED;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_20: (+1)
   \   00000186   0x2000             MOVS     R0,#+0
   \   00000188   0xF884 0x0054      STRB     R0,[R4, #+84]
   \   0000018C   0xE0C7             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_2
    215                              }
    216                          }
    217                          else
    218                          {
    219                              mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_FAILED;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_19: (+1)
   \   0000018E   0x2001             MOVS     R0,#+1
   \   00000190   0xF884 0x0054      STRB     R0,[R4, #+84]
    220                              ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_MEDIUM_ERROR;
   \   00000194   0x2003             MOVS     R0,#+3
   \   00000196   0x70B0             STRB     R0,[R6, #+2]
    221                              ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_UNRECOVERED_READ_ERROR;
   \   00000198   0x2011             MOVS     R0,#+17
   \   0000019A   0x7330             STRB     R0,[R6, #+12]
   \   0000019C   0xE0BF             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_2
    222                          }
    223                      }
    224                  }
    225                  else
    226                  {
    227                      /*case 8, device intends to receive data from the host*/
    228                      mscHandle->mscCsw.dataResidue = mscCheckEvent->hostExpectedDataLength;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_7: (+1)
   \   0000019E   0x6838             LDR      R0,[R7, #+0]
   \   000001A0   0x6520             STR      R0,[R4, #+80]
    229                      error = USB_DeviceSendRequest(mscHandle->handle, mscHandle->bulkInEndpoint, mscCheckEvent->buffer, 0);
   \   000001A2   0x2300             MOVS     R3,#+0
   \   000001A4   0x68BA             LDR      R2,[R7, #+8]
   \   000001A6   0xF894 0x10F9      LDRB     R1,[R4, #+249]
   \   000001AA   0x6820             LDR      R0,[R4, #+0]
   \   000001AC   0x.... 0x....      BL       USB_DeviceSendRequest
   \   000001B0   0x0005             MOVS     R5,R0
    230                      mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_PHASE_ERROR;
   \   000001B2   0x2002             MOVS     R0,#+2
   \   000001B4   0xF884 0x0054      STRB     R0,[R4, #+84]
    231                      error = kStatus_USB_InvalidRequest;
   \   000001B8   0x2005             MOVS     R0,#+5
   \   000001BA   0x0005             MOVS     R5,R0
   \   000001BC   0xE0AF             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_2
    232                  }
    233              }
    234              else
    235              {
    236                  /*Host expects to send data to the device*/
    237                  if (0 == mscCheckEvent->deviceExpectedDataLength)
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_3: (+1)
   \   000001BE   0x6878             LDR      R0,[R7, #+4]
   \   000001C0   0x2800             CMP      R0,#+0
   \   000001C2   0xD10F             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_21
    238                  { /*case 9,Device intends to transfer no data*/
    239                      USB_DeviceStallEndpoint(mscHandle->handle, mscHandle->bulkOutEndpoint);
   \   000001C4   0xF894 0x10FA      LDRB     R1,[R4, #+250]
   \   000001C8   0x6820             LDR      R0,[R4, #+0]
   \   000001CA   0x.... 0x....      BL       USB_DeviceStallEndpoint
    240                      mscHandle->mscCsw.dataResidue = mscCheckEvent->hostExpectedDataLength;
   \   000001CE   0x6838             LDR      R0,[R7, #+0]
   \   000001D0   0x6520             STR      R0,[R4, #+80]
    241                      mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_FAILED;
   \   000001D2   0x2001             MOVS     R0,#+1
   \   000001D4   0xF884 0x0054      STRB     R0,[R4, #+84]
    242                      mscHandle->outEndpointStallFlag = 1;
   \   000001D8   0x2001             MOVS     R0,#+1
   \   000001DA   0xF884 0x00EF      STRB     R0,[R4, #+239]
    243                      error = kStatus_USB_InvalidRequest;
   \   000001DE   0x2005             MOVS     R0,#+5
   \   000001E0   0x0005             MOVS     R5,R0
   \   000001E2   0xE09C             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_2
    244                  }
    245                  else if (mscCheckEvent->deviceExpectedDirection)
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_21: (+1)
   \   000001E4   0x7DB8             LDRB     R0,[R7, #+22]
   \   000001E6   0x2800             CMP      R0,#+0
   \   000001E8   0xD00F             BEQ.N    ??USB_DeviceMscUfiThirteenCasesCheck_22
    246                  { /*case 10,Device intends to send data to the host*/
    247                      USB_DeviceStallEndpoint(mscHandle->handle, mscHandle->bulkOutEndpoint);
   \   000001EA   0xF894 0x10FA      LDRB     R1,[R4, #+250]
   \   000001EE   0x6820             LDR      R0,[R4, #+0]
   \   000001F0   0x.... 0x....      BL       USB_DeviceStallEndpoint
    248                      mscHandle->mscCsw.dataResidue = mscCheckEvent->hostExpectedDataLength;
   \   000001F4   0x6838             LDR      R0,[R7, #+0]
   \   000001F6   0x6520             STR      R0,[R4, #+80]
    249                      mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_PHASE_ERROR;
   \   000001F8   0x2002             MOVS     R0,#+2
   \   000001FA   0xF884 0x0054      STRB     R0,[R4, #+84]
    250                      mscHandle->outEndpointStallFlag = 1;
   \   000001FE   0x2001             MOVS     R0,#+1
   \   00000200   0xF884 0x00EF      STRB     R0,[R4, #+239]
    251                      error = kStatus_USB_InvalidRequest;
   \   00000204   0x2005             MOVS     R0,#+5
   \   00000206   0x0005             MOVS     R5,R0
   \   00000208   0xE089             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_2
    252                  }
    253                  else
    254                  {
    255                      if (mscCheckEvent->hostExpectedDataLength > mscCheckEvent->deviceExpectedDataLength)
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_22: (+1)
   \   0000020A   0x6878             LDR      R0,[R7, #+4]
   \   0000020C   0x6839             LDR      R1,[R7, #+0]
   \   0000020E   0x4288             CMP      R0,R1
   \   00000210   0xD228             BCS.N    ??USB_DeviceMscUfiThirteenCasesCheck_23
    256                      { /*case 11, device intends to process less than the amount of data that the host indicated*/
    257                          mscHandle->mscCsw.dataResidue =
    258                              mscCheckEvent->hostExpectedDataLength - mscCheckEvent->deviceExpectedDataLength;
   \   00000212   0x6838             LDR      R0,[R7, #+0]
   \   00000214   0x6879             LDR      R1,[R7, #+4]
   \   00000216   0x1A40             SUBS     R0,R0,R1
   \   00000218   0x6520             STR      R0,[R4, #+80]
    259          
    260                          if (ufi->thirteenCase.lbaSendRecvSelect == 1)
   \   0000021A   0xF896 0x0028      LDRB     R0,[R6, #+40]
   \   0000021E   0x2801             CMP      R0,#+1
   \   00000220   0xD107             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_24
    261                          {
    262                              error = USB_DeviceMscLbaTransfer(mscHandle, USB_OUT, &mscCheckEvent->lbaInformation);
   \   00000222   0xF117 0x020C      ADDS     R2,R7,#+12
   \   00000226   0x2100             MOVS     R1,#+0
   \   00000228   0x0020             MOVS     R0,R4
   \   0000022A   0x.... 0x....      BL       USB_DeviceMscLbaTransfer
   \   0000022E   0x0005             MOVS     R5,R0
   \   00000230   0xE007             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_25
    263                          }
    264                          else
    265                          {
    266                              error = USB_DeviceRecvRequest(mscHandle->handle, mscHandle->bulkOutEndpoint, mscCheckEvent->buffer,
    267                                                            mscCheckEvent->deviceExpectedDataLength);
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_24: (+1)
   \   00000232   0x687B             LDR      R3,[R7, #+4]
   \   00000234   0x68BA             LDR      R2,[R7, #+8]
   \   00000236   0xF894 0x10FA      LDRB     R1,[R4, #+250]
   \   0000023A   0x6820             LDR      R0,[R4, #+0]
   \   0000023C   0x.... 0x....      BL       USB_DeviceRecvRequest
   \   00000240   0x0005             MOVS     R5,R0
    268                          }
    269          
    270                          if (kStatus_USB_Success == error)
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_25: (+1)
   \   00000242   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000244   0x2D00             CMP      R5,#+0
   \   00000246   0xD103             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_26
    271                          {
    272                              mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_PASSED;
   \   00000248   0x2000             MOVS     R0,#+0
   \   0000024A   0xF884 0x0054      STRB     R0,[R4, #+84]
   \   0000024E   0xE006             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_27
    273                          }
    274                          else
    275                          {
    276                              mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_FAILED;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_26: (+1)
   \   00000250   0x2001             MOVS     R0,#+1
   \   00000252   0xF884 0x0054      STRB     R0,[R4, #+84]
    277                              ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_MEDIUM_ERROR;
   \   00000256   0x2003             MOVS     R0,#+3
   \   00000258   0x70B0             STRB     R0,[R6, #+2]
    278                              ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_WRITE_FAULT;
   \   0000025A   0x2003             MOVS     R0,#+3
   \   0000025C   0x7330             STRB     R0,[R6, #+12]
    279                          }
    280                          error = kStatus_USB_InvalidRequest;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_27: (+1)
   \   0000025E   0x2005             MOVS     R0,#+5
   \   00000260   0x0005             MOVS     R5,R0
   \   00000262   0xE05C             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_2
    281                      }
    282                      else if (mscCheckEvent->hostExpectedDataLength == mscCheckEvent->deviceExpectedDataLength)
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_23: (+1)
   \   00000264   0x6838             LDR      R0,[R7, #+0]
   \   00000266   0x6879             LDR      R1,[R7, #+4]
   \   00000268   0x4288             CMP      R0,R1
   \   0000026A   0xD124             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_28
    283                      { /*case 12,device intends to processequal to the amount of data that the host indicated*/
    284                          mscHandle->mscCsw.dataResidue = 0;
   \   0000026C   0x2000             MOVS     R0,#+0
   \   0000026E   0x6520             STR      R0,[R4, #+80]
    285                          if (ufi->thirteenCase.lbaSendRecvSelect == 1)
   \   00000270   0xF896 0x0028      LDRB     R0,[R6, #+40]
   \   00000274   0x2801             CMP      R0,#+1
   \   00000276   0xD107             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_29
    286                          {
    287                              error = USB_DeviceMscLbaTransfer(mscHandle, USB_OUT, &mscCheckEvent->lbaInformation);
   \   00000278   0xF117 0x020C      ADDS     R2,R7,#+12
   \   0000027C   0x2100             MOVS     R1,#+0
   \   0000027E   0x0020             MOVS     R0,R4
   \   00000280   0x.... 0x....      BL       USB_DeviceMscLbaTransfer
   \   00000284   0x0005             MOVS     R5,R0
   \   00000286   0xE007             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_30
    288                          }
    289                          else
    290                          {
    291                              error = USB_DeviceRecvRequest(mscHandle->handle, mscHandle->bulkOutEndpoint, mscCheckEvent->buffer,
    292                                                            mscCheckEvent->deviceExpectedDataLength);
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_29: (+1)
   \   00000288   0x687B             LDR      R3,[R7, #+4]
   \   0000028A   0x68BA             LDR      R2,[R7, #+8]
   \   0000028C   0xF894 0x10FA      LDRB     R1,[R4, #+250]
   \   00000290   0x6820             LDR      R0,[R4, #+0]
   \   00000292   0x.... 0x....      BL       USB_DeviceRecvRequest
   \   00000296   0x0005             MOVS     R5,R0
    293                          }
    294                          if (kStatus_USB_Success == error)
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_30: (+1)
   \   00000298   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000029A   0x2D00             CMP      R5,#+0
   \   0000029C   0xD103             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_31
    295                          {
    296                              mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_PASSED;
   \   0000029E   0x2000             MOVS     R0,#+0
   \   000002A0   0xF884 0x0054      STRB     R0,[R4, #+84]
   \   000002A4   0xE03B             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_2
    297                          }
    298                          else
    299                          {
    300                              mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_FAILED;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_31: (+1)
   \   000002A6   0x2001             MOVS     R0,#+1
   \   000002A8   0xF884 0x0054      STRB     R0,[R4, #+84]
    301                              ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_MEDIUM_ERROR;
   \   000002AC   0x2003             MOVS     R0,#+3
   \   000002AE   0x70B0             STRB     R0,[R6, #+2]
    302                              ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_WRITE_FAULT;
   \   000002B0   0x2003             MOVS     R0,#+3
   \   000002B2   0x7330             STRB     R0,[R6, #+12]
   \   000002B4   0xE033             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_2
    303                          }
    304                      }
    305                      else
    306                      { /*case 13,device  intends to process more data than the host indicated*/
    307                          mscHandle->mscCsw.dataResidue = 0;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_28: (+1)
   \   000002B6   0x2000             MOVS     R0,#+0
   \   000002B8   0x6520             STR      R0,[R4, #+80]
    308                          if (ufi->thirteenCase.lbaSendRecvSelect == 1)
   \   000002BA   0xF896 0x0028      LDRB     R0,[R6, #+40]
   \   000002BE   0x2801             CMP      R0,#+1
   \   000002C0   0xD112             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_32
    309                          {
    310                              mscCheckEvent->lbaInformation.transferNumber =
    311                                  mscCheckEvent->hostExpectedDataLength / mscHandle->lengthOfEachLba;
   \   000002C2   0x6838             LDR      R0,[R7, #+0]
   \   000002C4   0x69A1             LDR      R1,[R4, #+24]
   \   000002C6   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000002CA   0x6138             STR      R0,[R7, #+16]
    312                              mscHandle->mscCsw.dataResidue =
    313                                  mscCheckEvent->hostExpectedDataLength -
    314                                  mscCheckEvent->lbaInformation.transferNumber * mscHandle->lengthOfEachLba;
   \   000002CC   0x6838             LDR      R0,[R7, #+0]
   \   000002CE   0x6939             LDR      R1,[R7, #+16]
   \   000002D0   0x69A2             LDR      R2,[R4, #+24]
   \   000002D2   0xFB02 0x0011      MLS      R0,R2,R1,R0
   \   000002D6   0x6520             STR      R0,[R4, #+80]
    315                              error = USB_DeviceMscLbaTransfer(mscHandle, USB_OUT, &mscCheckEvent->lbaInformation);
   \   000002D8   0xF117 0x020C      ADDS     R2,R7,#+12
   \   000002DC   0x2100             MOVS     R1,#+0
   \   000002DE   0x0020             MOVS     R0,R4
   \   000002E0   0x.... 0x....      BL       USB_DeviceMscLbaTransfer
   \   000002E4   0x0005             MOVS     R5,R0
   \   000002E6   0xE007             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_33
    316                          }
    317                          else
    318                          {
    319                              error = USB_DeviceRecvRequest(mscHandle->handle, mscHandle->bulkOutEndpoint, mscCheckEvent->buffer,
    320                                                            mscCheckEvent->hostExpectedDataLength);
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_32: (+1)
   \   000002E8   0x683B             LDR      R3,[R7, #+0]
   \   000002EA   0x68BA             LDR      R2,[R7, #+8]
   \   000002EC   0xF894 0x10FA      LDRB     R1,[R4, #+250]
   \   000002F0   0x6820             LDR      R0,[R4, #+0]
   \   000002F2   0x.... 0x....      BL       USB_DeviceRecvRequest
   \   000002F6   0x0005             MOVS     R5,R0
    321                          }
    322          
    323                          if (kStatus_USB_Success == error)
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_33: (+1)
   \   000002F8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002FA   0x2D00             CMP      R5,#+0
   \   000002FC   0xD10B             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_34
    324                          {
    325                              if (ufi->thirteenCase.lbaSendRecvSelect == 1)
   \   000002FE   0xF896 0x0028      LDRB     R0,[R6, #+40]
   \   00000302   0x2801             CMP      R0,#+1
   \   00000304   0xD103             BNE.N    ??USB_DeviceMscUfiThirteenCasesCheck_35
    326                              {
    327                                  mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_PHASE_ERROR;
   \   00000306   0x2002             MOVS     R0,#+2
   \   00000308   0xF884 0x0054      STRB     R0,[R4, #+84]
   \   0000030C   0xE007             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_2
    328                              }
    329                              else
    330                              {
    331                                  mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_PASSED;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_35: (+1)
   \   0000030E   0x2000             MOVS     R0,#+0
   \   00000310   0xF884 0x0054      STRB     R0,[R4, #+84]
   \   00000314   0xE003             B.N      ??USB_DeviceMscUfiThirteenCasesCheck_2
    332                              }
    333                          }
    334                          else
    335                          {
    336                              ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_MEDIUM_ERROR;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_34: (+1)
   \   00000316   0x2003             MOVS     R0,#+3
   \   00000318   0x70B0             STRB     R0,[R6, #+2]
    337                              ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_WRITE_FAULT;
   \   0000031A   0x2003             MOVS     R0,#+3
   \   0000031C   0x7330             STRB     R0,[R6, #+12]
    338                          }
    339                      }
    340                  }
    341              }
    342              return error;
   \                     ??USB_DeviceMscUfiThirteenCasesCheck_2: (+1)
   \   0000031E   0x0028             MOVS     R0,R5
   \   00000320   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000322   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    343          }
    344          
    345          /*!
    346           * @brief request sense command.
    347           *
    348           * The REQUEST SENSE command instructs the UFI device to transfer sense data to the host for the specified  logical
    349           *unit.
    350           *
    351           * @param handle          The device msc class hanlde.
    352           *
    353           *@return A USB error code or kStatus_USB_Success.
    354           */

   \                                 In section .text, align 2, keep-with-next
    355          usb_status_t USB_DeviceMscUfiRequestSenseCommand(usb_device_msc_struct_t *mscHandle)
    356          {
   \                     USB_DeviceMscUfiRequestSenseCommand: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    357              usb_device_msc_ufi_struct_t *ufi = NULL;
   \   00000004   0x2500             MOVS     R5,#+0
    358              usb_status_t error;
    359          
    360              ufi = &mscHandle->mscUfi;
   \   00000006   0xF114 0x0058      ADDS     R0,R4,#+88
   \   0000000A   0x0005             MOVS     R5,R0
    361              ufi->thirteenCase.deviceExpectedDataLength = USB_DEVICE_MSC_UFI_REQ_SENSE_DATA_LENGTH;
   \   0000000C   0x2012             MOVS     R0,#+18
   \   0000000E   0x61A8             STR      R0,[R5, #+24]
    362              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF885 0x002A      STRB     R0,[R5, #+42]
    363              ufi->thirteenCase.buffer = (uint8_t *)&ufi->requestSense;
   \   00000016   0x61ED             STR      R5,[R5, #+28]
    364              ufi->thirteenCase.lbaSendRecvSelect = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF885 0x0028      STRB     R0,[R5, #+40]
    365              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       USB_DeviceMscUfiThirteenCasesCheck
   \   00000024   0x0006             MOVS     R6,R0
    366          
    367              return error;
   \   00000026   0x0030             MOVS     R0,R6
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return
    368          }
    369          
    370          /*!
    371           * @brief inquiry command.
    372           *
    373           * The INQUIRY command requests that information regarding parameters of the UFI device itself be sent to the host.
    374           *
    375           * @param handle          The device msc class hanlde.
    376           *
    377           *@return A USB error code or kStatus_USB_Success.
    378          */

   \                                 In section .text, align 2, keep-with-next
    379          usb_status_t USB_DeviceMscUfiInquiryCommand(usb_device_msc_struct_t *mscHandle)
    380          {
   \                     USB_DeviceMscUfiInquiryCommand: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
    381              usb_device_msc_ufi_struct_t *ufi = NULL;
   \   00000006   0x2500             MOVS     R5,#+0
    382              usb_status_t error;
    383              uint8_t i;
    384              uint32_t temp;
    385              
    386              ufi = &mscHandle->mscUfi;
   \   00000008   0xF114 0x0058      ADDS     R0,R4,#+88
   \   0000000C   0x0005             MOVS     R5,R0
    387          
    388              temp = (uint32_t)&g_InquiryInfoConst;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable3
   \   00000012   0x4680             MOV      R8,R0
    389              uint8_t * ptr = (uint8_t *)temp;
   \   00000014   0x46C1             MOV      R9,R8
    390              uint8_t * pointer = (uint8_t *)&ufi->InquiryInfo;
   \   00000016   0xF115 0x0A40      ADDS     R10,R5,#+64
    391              for (i = 0; i < sizeof(usb_device_inquiry_data_fromat_struct_t); i++)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x0007             MOVS     R7,R0
   \                     ??USB_DeviceMscUfiInquiryCommand_0: (+1)
   \   0000001E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000020   0x2F24             CMP      R7,#+36
   \   00000022   0xD207             BCS.N    ??USB_DeviceMscUfiInquiryCommand_1
    392              {
    393                  pointer[i] =  ptr[i];    
   \   00000024   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000026   0xF819 0x0007      LDRB     R0,[R9, R7]
   \   0000002A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002C   0xF80A 0x0007      STRB     R0,[R10, R7]
    394          
    395              }
   \   00000030   0x1C7F             ADDS     R7,R7,#+1
   \   00000032   0xE7F4             B.N      ??USB_DeviceMscUfiInquiryCommand_0
    396              ufi->thirteenCase.deviceExpectedDataLength = USB_DEVICE_MSC_UFI_INQUIRY_ALLOCATION_LENGTH;
   \                     ??USB_DeviceMscUfiInquiryCommand_1: (+1)
   \   00000034   0x2024             MOVS     R0,#+36
   \   00000036   0x61A8             STR      R0,[R5, #+24]
    397              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xF885 0x002A      STRB     R0,[R5, #+42]
    398              ufi->thirteenCase.buffer = (uint8_t *)&ufi->InquiryInfo;
   \   0000003E   0xF115 0x0040      ADDS     R0,R5,#+64
   \   00000042   0x61E8             STR      R0,[R5, #+28]
    399              ufi->thirteenCase.lbaSendRecvSelect = 0;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF885 0x0028      STRB     R0,[R5, #+40]
    400          
    401              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x.... 0x....      BL       USB_DeviceMscUfiThirteenCasesCheck
   \   00000050   0x0006             MOVS     R6,R0
    402              return error;
   \   00000052   0x0030             MOVS     R0,R6
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    403          }
    404          
    405          /*!
    406           * @brief read command.
    407           *
    408           * The READ(10),READ(12) command requests that the UFI device transfer data to the host.
    409           *
    410           * @param handle          The device msc class hanlde.
    411           *
    412           *@return A USB error code or kStatus_USB_Success.
    413          */

   \                                 In section .text, align 2, keep-with-next
    414          usb_status_t USB_DeviceMscUfiReadCommand(usb_device_msc_struct_t *mscHandle)
    415          {
   \                     USB_DeviceMscUfiReadCommand: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    416              usb_device_msc_ufi_struct_t *ufi = NULL;
   \   00000006   0x2500             MOVS     R5,#+0
    417              usb_status_t error;
    418              uint32_t logicalBlockAddress = 0;
   \   00000008   0xF05F 0x0800      MOVS     R8,#+0
    419              uint32_t lbaTransferLength = 0;
   \   0000000C   0x2700             MOVS     R7,#+0
    420          
    421              ufi = &mscHandle->mscUfi;
   \   0000000E   0xF114 0x0058      ADDS     R0,R4,#+88
   \   00000012   0x0005             MOVS     R5,R0
    422          
    423              logicalBlockAddress = ((uint32_t)mscHandle->mscCbw.cbwcb[2] << 24);
   \   00000014   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000018   0x0600             LSLS     R0,R0,#+24
   \   0000001A   0x4680             MOV      R8,R0
    424              logicalBlockAddress |= ((uint32_t)mscHandle->mscCbw.cbwcb[3] << 16);
   \   0000001C   0xF894 0x003A      LDRB     R0,[R4, #+58]
   \   00000020   0xEA58 0x4800      ORRS     R8,R8,R0, LSL #+16
    425              logicalBlockAddress |= ((uint32_t)mscHandle->mscCbw.cbwcb[4] << 8);
   \   00000024   0xF894 0x003B      LDRB     R0,[R4, #+59]
   \   00000028   0xEA58 0x2800      ORRS     R8,R8,R0, LSL #+8
    426              logicalBlockAddress |= ((uint32_t)mscHandle->mscCbw.cbwcb[5]);
   \   0000002C   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \   00000030   0xEA50 0x0808      ORRS     R8,R0,R8
    427          
    428              if (mscHandle->mscCbw.cbwcb[0] == USB_DEVICE_MSC_READ_10_COMMAND)
   \   00000034   0xF894 0x0037      LDRB     R0,[R4, #+55]
   \   00000038   0x2828             CMP      R0,#+40
   \   0000003A   0xD108             BNE.N    ??USB_DeviceMscUfiReadCommand_0
    429              {
    430                  lbaTransferLength = (uint16_t)((uint16_t)mscHandle->mscCbw.cbwcb[7] << 8);
   \   0000003C   0xF894 0x003E      LDRB     R0,[R4, #+62]
   \   00000040   0x0200             LSLS     R0,R0,#+8
   \   00000042   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000044   0x0007             MOVS     R7,R0
    431                  lbaTransferLength |= (uint16_t)mscHandle->mscCbw.cbwcb[8];
   \   00000046   0xF894 0x003F      LDRB     R0,[R4, #+63]
   \   0000004A   0x4307             ORRS     R7,R0,R7
   \   0000004C   0xE012             B.N      ??USB_DeviceMscUfiReadCommand_1
    432              }
    433              else if (mscHandle->mscCbw.cbwcb[0] == USB_DEVICE_MSC_READ_12_COMMAND)
   \                     ??USB_DeviceMscUfiReadCommand_0: (+1)
   \   0000004E   0xF894 0x0037      LDRB     R0,[R4, #+55]
   \   00000052   0x28A8             CMP      R0,#+168
   \   00000054   0xD10E             BNE.N    ??USB_DeviceMscUfiReadCommand_1
    434              {
    435                  lbaTransferLength = ((uint32_t)mscHandle->mscCbw.cbwcb[6] << 24);
   \   00000056   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000005A   0x0600             LSLS     R0,R0,#+24
   \   0000005C   0x0007             MOVS     R7,R0
    436                  lbaTransferLength |= ((uint32_t)mscHandle->mscCbw.cbwcb[7] << 16);
   \   0000005E   0xF894 0x003E      LDRB     R0,[R4, #+62]
   \   00000062   0xEA57 0x4700      ORRS     R7,R7,R0, LSL #+16
    437                  lbaTransferLength |= ((uint32_t)mscHandle->mscCbw.cbwcb[8] << 8);
   \   00000066   0xF894 0x003F      LDRB     R0,[R4, #+63]
   \   0000006A   0xEA57 0x2700      ORRS     R7,R7,R0, LSL #+8
    438                  lbaTransferLength |= ((uint32_t)mscHandle->mscCbw.cbwcb[9]);
   \   0000006E   0xF894 0x0040      LDRB     R0,[R4, #+64]
   \   00000072   0x4307             ORRS     R7,R0,R7
    439              }
    440              else
    441              {
    442              
    443              }
    444          
    445              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
   \                     ??USB_DeviceMscUfiReadCommand_1: (+1)
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xF885 0x002A      STRB     R0,[R5, #+42]
    446              ufi->thirteenCase.deviceExpectedDataLength = mscHandle->lengthOfEachLba * lbaTransferLength;
   \   0000007A   0x69A0             LDR      R0,[R4, #+24]
   \   0000007C   0x4378             MULS     R0,R7,R0
   \   0000007E   0x61A8             STR      R0,[R5, #+24]
    447              ufi->thirteenCase.buffer = NULL;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x61E8             STR      R0,[R5, #+28]
    448          
    449              ufi->thirteenCase.lbaSendRecvSelect = 1;
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0xF885 0x0028      STRB     R0,[R5, #+40]
    450              ufi->thirteenCase.lbaInformation.startingLogicalBlockAddress = logicalBlockAddress;
   \   0000008A   0xF8C5 0x8020      STR      R8,[R5, #+32]
    451              ufi->thirteenCase.lbaInformation.transferNumber = lbaTransferLength;
   \   0000008E   0x626F             STR      R7,[R5, #+36]
    452          
    453              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
   \   00000090   0x0020             MOVS     R0,R4
   \   00000092   0x.... 0x....      BL       USB_DeviceMscUfiThirteenCasesCheck
   \   00000096   0x0006             MOVS     R6,R0
    454              return error;
   \   00000098   0x0030             MOVS     R0,R6
   \   0000009A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    455          }
    456          
    457          /*!
    458           * @brief write command.
    459           *
    460           * The WRITE(10),WRITE(12) command requests that the UFI device write the data transferred by the host to the medium.
    461           *
    462           * @param handle          The device msc class hanlde.
    463           *
    464           *@return A USB error code or kStatus_USB_Success.
    465          */

   \                                 In section .text, align 2, keep-with-next
    466          usb_status_t USB_DeviceMscUfiWriteCommand(usb_device_msc_struct_t *mscHandle)
    467          {
   \                     USB_DeviceMscUfiWriteCommand: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    468              usb_device_msc_ufi_struct_t *ufi = NULL;
   \   00000006   0x2500             MOVS     R5,#+0
    469              usb_status_t error;
    470              uint32_t logicalBlockAddress = 0;
   \   00000008   0xF05F 0x0800      MOVS     R8,#+0
    471              uint32_t lbaTransferLength = 0;
   \   0000000C   0x2700             MOVS     R7,#+0
    472          
    473              ufi = &mscHandle->mscUfi;
   \   0000000E   0xF114 0x0058      ADDS     R0,R4,#+88
   \   00000012   0x0005             MOVS     R5,R0
    474          
    475              logicalBlockAddress = ((uint32_t)mscHandle->mscCbw.cbwcb[2] << 24);
   \   00000014   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000018   0x0600             LSLS     R0,R0,#+24
   \   0000001A   0x4680             MOV      R8,R0
    476              logicalBlockAddress |= ((uint32_t)mscHandle->mscCbw.cbwcb[3] << 16);
   \   0000001C   0xF894 0x003A      LDRB     R0,[R4, #+58]
   \   00000020   0xEA58 0x4800      ORRS     R8,R8,R0, LSL #+16
    477              logicalBlockAddress |= ((uint32_t)mscHandle->mscCbw.cbwcb[4] << 8);
   \   00000024   0xF894 0x003B      LDRB     R0,[R4, #+59]
   \   00000028   0xEA58 0x2800      ORRS     R8,R8,R0, LSL #+8
    478              logicalBlockAddress |= ((uint32_t)mscHandle->mscCbw.cbwcb[5]);
   \   0000002C   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \   00000030   0xEA50 0x0808      ORRS     R8,R0,R8
    479          
    480              if (mscHandle->mscCbw.cbwcb[0] == USB_DEVICE_MSC_WRITE_10_COMMAND)
   \   00000034   0xF894 0x0037      LDRB     R0,[R4, #+55]
   \   00000038   0x282A             CMP      R0,#+42
   \   0000003A   0xD108             BNE.N    ??USB_DeviceMscUfiWriteCommand_0
    481              {
    482                  lbaTransferLength = (uint16_t)((uint16_t)mscHandle->mscCbw.cbwcb[7] << 8);
   \   0000003C   0xF894 0x003E      LDRB     R0,[R4, #+62]
   \   00000040   0x0200             LSLS     R0,R0,#+8
   \   00000042   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000044   0x0007             MOVS     R7,R0
    483                  lbaTransferLength |= (uint16_t)mscHandle->mscCbw.cbwcb[8];
   \   00000046   0xF894 0x003F      LDRB     R0,[R4, #+63]
   \   0000004A   0x4307             ORRS     R7,R0,R7
   \   0000004C   0xE012             B.N      ??USB_DeviceMscUfiWriteCommand_1
    484              }
    485              else if (mscHandle->mscCbw.cbwcb[0] == USB_DEVICE_MSC_WRITE_12_COMMAND)
   \                     ??USB_DeviceMscUfiWriteCommand_0: (+1)
   \   0000004E   0xF894 0x0037      LDRB     R0,[R4, #+55]
   \   00000052   0x28AA             CMP      R0,#+170
   \   00000054   0xD10E             BNE.N    ??USB_DeviceMscUfiWriteCommand_1
    486              {
    487                  lbaTransferLength = ((uint32_t)mscHandle->mscCbw.cbwcb[6] << 24);
   \   00000056   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000005A   0x0600             LSLS     R0,R0,#+24
   \   0000005C   0x0007             MOVS     R7,R0
    488                  lbaTransferLength |= ((uint32_t)mscHandle->mscCbw.cbwcb[7] << 16);
   \   0000005E   0xF894 0x003E      LDRB     R0,[R4, #+62]
   \   00000062   0xEA57 0x4700      ORRS     R7,R7,R0, LSL #+16
    489                  lbaTransferLength |= ((uint32_t)mscHandle->mscCbw.cbwcb[8] << 8);
   \   00000066   0xF894 0x003F      LDRB     R0,[R4, #+63]
   \   0000006A   0xEA57 0x2700      ORRS     R7,R7,R0, LSL #+8
    490                  lbaTransferLength |= ((uint32_t)mscHandle->mscCbw.cbwcb[9]);
   \   0000006E   0xF894 0x0040      LDRB     R0,[R4, #+64]
   \   00000072   0x4307             ORRS     R7,R0,R7
    491              }
    492              else
    493              {
    494              }
    495              ufi->thirteenCase.deviceExpectedDirection = USB_OUT;
   \                     ??USB_DeviceMscUfiWriteCommand_1: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xF885 0x002A      STRB     R0,[R5, #+42]
    496              ufi->thirteenCase.deviceExpectedDataLength = mscHandle->lengthOfEachLba * lbaTransferLength;
   \   0000007A   0x69A0             LDR      R0,[R4, #+24]
   \   0000007C   0x4378             MULS     R0,R7,R0
   \   0000007E   0x61A8             STR      R0,[R5, #+24]
    497              ufi->thirteenCase.buffer = NULL;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x61E8             STR      R0,[R5, #+28]
    498          
    499              ufi->thirteenCase.lbaSendRecvSelect = 1;
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0xF885 0x0028      STRB     R0,[R5, #+40]
    500              ufi->thirteenCase.lbaInformation.startingLogicalBlockAddress = logicalBlockAddress;
   \   0000008A   0xF8C5 0x8020      STR      R8,[R5, #+32]
    501              ufi->thirteenCase.lbaInformation.transferNumber = lbaTransferLength;
   \   0000008E   0x626F             STR      R7,[R5, #+36]
    502          
    503              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
   \   00000090   0x0020             MOVS     R0,R4
   \   00000092   0x.... 0x....      BL       USB_DeviceMscUfiThirteenCasesCheck
   \   00000096   0x0006             MOVS     R6,R0
    504              return error;
   \   00000098   0x0030             MOVS     R0,R6
   \   0000009A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    505          }
    506          
    507          /*!
    508           * @brief test unit ready command.
    509           *
    510           * The TEST UNIT READY command provides a means to check if the UFI device is ready.
    511           *
    512           * @param handle          The device msc class hanlde.
    513           *
    514           *@return A USB error code or kStatus_USB_Success.
    515          */

   \                                 In section .text, align 2, keep-with-next
    516          usb_status_t USB_DeviceMscUfiTestUnitReadyCommand(usb_device_msc_struct_t *mscHandle)
    517          {
   \                     USB_DeviceMscUfiTestUnitReadyCommand: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    518              usb_device_msc_ufi_struct_t *ufi = NULL;
   \   00000004   0x2500             MOVS     R5,#+0
    519              usb_status_t error;
    520          
    521              ufi = &mscHandle->mscUfi;
   \   00000006   0xF114 0x0058      ADDS     R0,R4,#+88
   \   0000000A   0x0005             MOVS     R5,R0
    522          
    523              ufi->thirteenCase.deviceExpectedDataLength = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x61A8             STR      R0,[R5, #+24]
    524              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF885 0x002A      STRB     R0,[R5, #+42]
    525              ufi->thirteenCase.buffer = NULL;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x61E8             STR      R0,[R5, #+28]
    526              ufi->thirteenCase.lbaSendRecvSelect = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF885 0x0028      STRB     R0,[R5, #+40]
    527          
    528              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       USB_DeviceMscUfiThirteenCasesCheck
   \   00000026   0x0006             MOVS     R6,R0
    529              return error;
   \   00000028   0x0030             MOVS     R0,R6
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0xBD70             POP      {R4-R6,PC}       ;; return
    530          }
    531          
    532          /*!
    533           * @brief verify command.
    534           *
    535           * The VERIFY command requests that the UFI device verify the data on the medium.
    536           *
    537           * @param handle          The device msc class hanlde.
    538           *
    539           *@return A USB error code or kStatus_USB_Success.
    540          */

   \                                 In section .text, align 2, keep-with-next
    541          usb_status_t USB_DeviceMscUfiVerifyCommand(usb_device_msc_struct_t *mscHandle)
    542          {
   \                     USB_DeviceMscUfiVerifyCommand: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    543              usb_device_msc_ufi_struct_t *ufi = NULL;
   \   00000004   0x2500             MOVS     R5,#+0
    544              usb_status_t error;
    545          
    546              ufi = &mscHandle->mscUfi;
   \   00000006   0xF114 0x0058      ADDS     R0,R4,#+88
   \   0000000A   0x0005             MOVS     R5,R0
    547          
    548              ufi->thirteenCase.deviceExpectedDataLength = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x61A8             STR      R0,[R5, #+24]
    549              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF885 0x002A      STRB     R0,[R5, #+42]
    550              ufi->thirteenCase.buffer = NULL;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x61E8             STR      R0,[R5, #+28]
    551              ufi->thirteenCase.lbaSendRecvSelect = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF885 0x0028      STRB     R0,[R5, #+40]
    552          
    553              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       USB_DeviceMscUfiThirteenCasesCheck
   \   00000026   0x0006             MOVS     R6,R0
    554              return error;
   \   00000028   0x0030             MOVS     R0,R6
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0xBD70             POP      {R4-R6,PC}       ;; return
    555          }
    556          
    557          /*!
    558           * @brief mode sense command.
    559           *
    560           * The MODE SENSE command allows the UFI device to report medium or device parameters to the host.
    561           *
    562           * @param handle          The device msc class hanlde.
    563           *
    564           *@return A USB error code or kStatus_USB_Success.
    565          */

   \                                 In section .text, align 2, keep-with-next
    566          usb_status_t USB_DeviceMscUfiModeSenseCommand(usb_device_msc_struct_t *mscHandle)
    567          {
   \                     USB_DeviceMscUfiModeSenseCommand: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
    568              usb_device_msc_ufi_struct_t *ufi = NULL;
   \   00000006   0x2500             MOVS     R5,#+0
    569              usb_status_t error;
    570              uint8_t i;
    571              uint32_t temp;
    572              
    573              ufi = &mscHandle->mscUfi;
   \   00000008   0xF114 0x0058      ADDS     R0,R4,#+88
   \   0000000C   0x0005             MOVS     R5,R0
    574          
    575              temp = (uint32_t)&g_ModeParametersHeaderConst;
   \   0000000E   0x....             LDR.N    R0,??DataTable3_1
   \   00000010   0x4680             MOV      R8,R0
    576              uint8_t * ptr = (uint8_t *)temp;
   \   00000012   0x46C1             MOV      R9,R8
    577              uint8_t * pointer = (uint8_t *)&ufi->ModeParametersHeader;
   \   00000014   0xF115 0x0A64      ADDS     R10,R5,#+100
    578              for (i = 0; i < sizeof(usb_device_mode_parameters_header_struct_t); i++)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0007             MOVS     R7,R0
   \                     ??USB_DeviceMscUfiModeSenseCommand_0: (+1)
   \   0000001C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000001E   0x2F08             CMP      R7,#+8
   \   00000020   0xD207             BCS.N    ??USB_DeviceMscUfiModeSenseCommand_1
    579              {
    580                  pointer[i] =  ptr[i];    
   \   00000022   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000024   0xF819 0x0007      LDRB     R0,[R9, R7]
   \   00000028   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002A   0xF80A 0x0007      STRB     R0,[R10, R7]
    581          
    582              }
   \   0000002E   0x1C7F             ADDS     R7,R7,#+1
   \   00000030   0xE7F4             B.N      ??USB_DeviceMscUfiModeSenseCommand_0
    583              ufi->thirteenCase.deviceExpectedDataLength = sizeof(g_ModeParametersHeaderConst);
   \                     ??USB_DeviceMscUfiModeSenseCommand_1: (+1)
   \   00000032   0x2008             MOVS     R0,#+8
   \   00000034   0x61A8             STR      R0,[R5, #+24]
    584              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xF885 0x002A      STRB     R0,[R5, #+42]
    585              ufi->thirteenCase.buffer = (uint8_t *)&ufi->ModeParametersHeader;
   \   0000003C   0xF115 0x0064      ADDS     R0,R5,#+100
   \   00000040   0x61E8             STR      R0,[R5, #+28]
    586              ufi->thirteenCase.lbaSendRecvSelect = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xF885 0x0028      STRB     R0,[R5, #+40]
    587          
    588              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       USB_DeviceMscUfiThirteenCasesCheck
   \   0000004E   0x0006             MOVS     R6,R0
    589              return error;
   \   00000050   0x0030             MOVS     R0,R6
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    590          }
    591          
    592          /*!
    593           * @brief mode select command.
    594           *
    595           * The MODE SELECT command allows the host to specify medium or device parameters to the UFI device.
    596           *
    597           * @param handle          The device msc class hanlde.
    598           *
    599           *@return A USB error code or kStatus_USB_Success.
    600          */

   \                                 In section .text, align 2, keep-with-next
    601          usb_status_t USB_DeviceMscUfiModeSelectCommand(usb_device_msc_struct_t *mscHandle)
    602          {
   \                     USB_DeviceMscUfiModeSelectCommand: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
    603              usb_device_msc_ufi_struct_t *ufi = NULL;
   \   00000006   0x2500             MOVS     R5,#+0
    604              usb_status_t error = kStatus_USB_TransferFailed;
   \   00000008   0x260B             MOVS     R6,#+11
    605              uint8_t i;
    606              uint32_t temp;
    607              
    608              ufi = &mscHandle->mscUfi;
   \   0000000A   0xF114 0x0058      ADDS     R0,R4,#+88
   \   0000000E   0x0005             MOVS     R5,R0
    609          
    610              temp = (uint32_t)&g_ModeParametersHeaderConst;
   \   00000010   0x....             LDR.N    R0,??DataTable3_1
   \   00000012   0x4680             MOV      R8,R0
    611              uint8_t * ptr = (uint8_t *)temp;
   \   00000014   0x46C1             MOV      R9,R8
    612              uint8_t * pointer = (uint8_t *)&ufi->ModeParametersHeader;
   \   00000016   0xF115 0x0A64      ADDS     R10,R5,#+100
    613              for (i = 0; i < sizeof(usb_device_mode_parameters_header_struct_t); i++)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x0007             MOVS     R7,R0
   \                     ??USB_DeviceMscUfiModeSelectCommand_0: (+1)
   \   0000001E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000020   0x2F08             CMP      R7,#+8
   \   00000022   0xD207             BCS.N    ??USB_DeviceMscUfiModeSelectCommand_1
    614              {
    615                  pointer[i] =  ptr[i];    
   \   00000024   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000026   0xF819 0x0007      LDRB     R0,[R9, R7]
   \   0000002A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002C   0xF80A 0x0007      STRB     R0,[R10, R7]
    616          
    617              }
   \   00000030   0x1C7F             ADDS     R7,R7,#+1
   \   00000032   0xE7F4             B.N      ??USB_DeviceMscUfiModeSelectCommand_0
    618          
    619              ufi->thirteenCase.deviceExpectedDataLength = sizeof(g_ModeParametersHeaderConst);
   \                     ??USB_DeviceMscUfiModeSelectCommand_1: (+1)
   \   00000034   0x2008             MOVS     R0,#+8
   \   00000036   0x61A8             STR      R0,[R5, #+24]
    620              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xF885 0x002A      STRB     R0,[R5, #+42]
    621              ufi->thirteenCase.buffer = (uint8_t *)&ufi->ModeParametersHeader;
   \   0000003E   0xF115 0x0064      ADDS     R0,R5,#+100
   \   00000042   0x61E8             STR      R0,[R5, #+28]
    622              ufi->thirteenCase.lbaSendRecvSelect = 0;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF885 0x0028      STRB     R0,[R5, #+40]
    623          
    624              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x.... 0x....      BL       USB_DeviceMscUfiThirteenCasesCheck
   \   00000050   0x0006             MOVS     R6,R0
    625          
    626              if (mscHandle->mscCbw.cbwcb[1] & 0x01)
   \   00000052   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   00000056   0x07C0             LSLS     R0,R0,#+31
   \   00000058   0xD503             BPL.N    ??USB_DeviceMscUfiModeSelectCommand_2
    627              {
    628                  ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_ILLEGAL_REQUEST;
   \   0000005A   0x2005             MOVS     R0,#+5
   \   0000005C   0x70A8             STRB     R0,[R5, #+2]
    629                  ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_INVALID_FIELD_IN_COMMAND_PKT;
   \   0000005E   0x2024             MOVS     R0,#+36
   \   00000060   0x7328             STRB     R0,[R5, #+12]
    630              }
    631              return error;
   \                     ??USB_DeviceMscUfiModeSelectCommand_2: (+1)
   \   00000062   0x0030             MOVS     R0,R6
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    632          }
    633          
    634          /*!
    635           * @brief read capacity command.
    636           *
    637           * The READ CAPACITIY command allows the host to request capacities of the currently installed medium.
    638           *
    639           * @param handle          The device msc class hanlde.
    640           *
    641           *@return A USB error code or kStatus_USB_Success.
    642          */

   \                                 In section .text, align 2, keep-with-next
    643          usb_status_t USB_DeviceMscUfiReadCapacityCommand(usb_device_msc_struct_t *mscHandle)
    644          {
   \                     USB_DeviceMscUfiReadCapacityCommand: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    645              usb_device_msc_ufi_struct_t *ufi = NULL;
   \   00000004   0x2500             MOVS     R5,#+0
    646              usb_status_t error = kStatus_USB_TransferFailed;
   \   00000006   0x260B             MOVS     R6,#+11
    647          
    648              ufi = &mscHandle->mscUfi;
   \   00000008   0xF114 0x0058      ADDS     R0,R4,#+88
   \   0000000C   0x0005             MOVS     R5,R0
    649          
    650              if (mscHandle->mscCbw.cbwcb[0] == USB_DEVICE_MSC_READ_CAPACITY_10_COMMAND)
   \   0000000E   0xF894 0x0037      LDRB     R0,[R4, #+55]
   \   00000012   0x2825             CMP      R0,#+37
   \   00000014   0xD105             BNE.N    ??USB_DeviceMscUfiReadCapacityCommand_0
    651              {
    652                  ufi->thirteenCase.deviceExpectedDataLength = USB_DEVICE_MSC_UFI_READ_CAPACITY_DATA_LENGTH;
   \   00000016   0x2008             MOVS     R0,#+8
   \   00000018   0x61A8             STR      R0,[R5, #+24]
    653                  ufi->thirteenCase.buffer = (uint8_t *)&(ufi->readCapacity);
   \   0000001A   0xF115 0x002C      ADDS     R0,R5,#+44
   \   0000001E   0x61E8             STR      R0,[R5, #+28]
   \   00000020   0xE004             B.N      ??USB_DeviceMscUfiReadCapacityCommand_1
    654              }
    655              else
    656              {
    657                  ufi->thirteenCase.deviceExpectedDataLength = USB_DEVICE_MSC_UFI_READ_CAPACITY16_DATA_LENGTH;
   \                     ??USB_DeviceMscUfiReadCapacityCommand_0: (+1)
   \   00000022   0x200C             MOVS     R0,#+12
   \   00000024   0x61A8             STR      R0,[R5, #+24]
    658                  ufi->thirteenCase.buffer = (uint8_t *)&(ufi->readCapacity16);
   \   00000026   0xF115 0x0034      ADDS     R0,R5,#+52
   \   0000002A   0x61E8             STR      R0,[R5, #+28]
    659              }
    660              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
   \                     ??USB_DeviceMscUfiReadCapacityCommand_1: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF885 0x002A      STRB     R0,[R5, #+42]
    661              ufi->thirteenCase.lbaSendRecvSelect = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF885 0x0028      STRB     R0,[R5, #+40]
    662          
    663              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       USB_DeviceMscUfiThirteenCasesCheck
   \   0000003E   0x0006             MOVS     R6,R0
    664              return error;
   \   00000040   0x0030             MOVS     R0,R6
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0xBD70             POP      {R4-R6,PC}       ;; return
    665          }
    666          
    667          /*!
    668           * @brief read format capacity command.
    669           *
    670           * The READ FORMAT CAPACITIES command allows the host to request a list of the possible capacities that
    671          * can be formatted on the currently installed medium.
    672           *
    673           * @param handle          The device msc class hanlde.
    674           *
    675           *@return A USB error code or kStatus_USB_Success.
    676          */

   \                                 In section .text, align 2, keep-with-next
    677          usb_status_t USB_DeviceMscUfiReadFormatCapacityCommand(usb_device_msc_struct_t *mscHandle)
    678          {
   \                     USB_DeviceMscUfiReadFormatCapacityCommand: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x0004             MOVS     R4,R0
    679              usb_device_msc_ufi_struct_t *ufi = NULL;
   \   00000008   0x2500             MOVS     R5,#+0
    680              usb_status_t error = kStatus_USB_TransferFailed;
   \   0000000A   0x200B             MOVS     R0,#+11
   \   0000000C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    681              usb_device_current_max_capacity_descriptor_struct_t current_max_head;
    682              usb_device_formattable_capacity_descriptor_struct_t formattable_capacity_head;
    683              usb_device_capacity_list_header_struct_t capacityListHead = {{0x00, 0x00, 0x00}, 0x00};
   \   00000010   0x....             LDR.N    R0,??DataTable3_2
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x9002             STR      R0,[SP, #+8]
    684              uint32_t response_size;
    685              uint16_t allocation_length;
    686              uint8_t num_formattable_cap_desc;
    687              uint8_t descriptor_code;
    688              uint8_t count = 0;
   \   00000016   0xF05F 0x0A00      MOVS     R10,#+0
    689              uint8_t i = 0;
   \   0000001A   0xF05F 0x0B00      MOVS     R11,#+0
    690              uint8_t j = 0;
   \   0000001E   0xF05F 0x0900      MOVS     R9,#+0
    691              uint8_t *ptr;
    692          
    693              ufi = &mscHandle->mscUfi;
   \   00000022   0xF114 0x0058      ADDS     R0,R4,#+88
   \   00000026   0x0005             MOVS     R5,R0
    694              allocation_length = (uint16_t)((uint8_t)(mscHandle->mscCbw.cbwcb[7] << 8) | mscHandle->mscCbw.cbwcb[8]);
   \   00000028   0xF894 0x003F      LDRB     R0,[R4, #+63]
   \   0000002C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    695              /*referance ufi command spec table-33 Descriptor Code definition*/
    696              num_formattable_cap_desc = (uint8_t)(ufi->formattedDisk ? (mscHandle->implementingDiskDrive ? 0x02 : 0x03) : 0x00);
   \   00000030   0xF895 0x006C      LDRB     R0,[R5, #+108]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD006             BEQ.N    ??USB_DeviceMscUfiReadFormatCapacityCommand_0
   \   00000038   0x69E0             LDR      R0,[R4, #+28]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD001             BEQ.N    ??USB_DeviceMscUfiReadFormatCapacityCommand_1
   \   0000003E   0x2702             MOVS     R7,#+2
   \   00000040   0xE002             B.N      ??USB_DeviceMscUfiReadFormatCapacityCommand_2
   \                     ??USB_DeviceMscUfiReadFormatCapacityCommand_1: (+1)
   \   00000042   0x2703             MOVS     R7,#+3
   \   00000044   0xE000             B.N      ??USB_DeviceMscUfiReadFormatCapacityCommand_2
   \                     ??USB_DeviceMscUfiReadFormatCapacityCommand_0: (+1)
   \   00000046   0x2700             MOVS     R7,#+0
    697          
    698              formattable_capacity_head.blockNumber = mscHandle->totalLogicalBlockNumber;
   \                     ??USB_DeviceMscUfiReadFormatCapacityCommand_2: (+1)
   \   00000048   0x6960             LDR      R0,[R4, #+20]
   \   0000004A   0x9003             STR      R0,[SP, #+12]
    699              formattable_capacity_head.blockLength = mscHandle->lengthOfEachLba;
   \   0000004C   0x69A0             LDR      R0,[R4, #+24]
   \   0000004E   0x9004             STR      R0,[SP, #+16]
    700          
    701              descriptor_code =
    702                  (uint8_t)(ufi->formattedDisk ? USB_DEVICE_MSC_UFI_FORMATTED_MEDIA : USB_DEVICE_MSC_UFI_UNFORMATTED_MEDIA);
   \   00000050   0xF895 0x006C      LDRB     R0,[R5, #+108]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD002             BEQ.N    ??USB_DeviceMscUfiReadFormatCapacityCommand_3
   \   00000058   0xF05F 0x0802      MOVS     R8,#+2
   \   0000005C   0xE001             B.N      ??USB_DeviceMscUfiReadFormatCapacityCommand_4
   \                     ??USB_DeviceMscUfiReadFormatCapacityCommand_3: (+1)
   \   0000005E   0xF05F 0x0801      MOVS     R8,#+1
    703              capacityListHead.capacityListLength = num_formattable_cap_desc * 8;
   \                     ??USB_DeviceMscUfiReadFormatCapacityCommand_4: (+1)
   \   00000062   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000064   0x00F8             LSLS     R0,R7,#+3
   \   00000066   0xF88D 0x000B      STRB     R0,[SP, #+11]
    704              current_max_head.blockNumber = mscHandle->totalLogicalBlockNumber;
   \   0000006A   0x6960             LDR      R0,[R4, #+20]
   \   0000006C   0x9005             STR      R0,[SP, #+20]
    705              current_max_head.descriptorCodeBlockLength = (uint8_t)(descriptor_code << 24) | mscHandle->lengthOfEachLba;
   \   0000006E   0x69A0             LDR      R0,[R4, #+24]
   \   00000070   0x9006             STR      R0,[SP, #+24]
    706          
    707              response_size = sizeof(usb_device_capacity_list_header_struct_t) +
    708                              sizeof(usb_device_current_max_capacity_descriptor_struct_t) +
    709                              sizeof(usb_device_formattable_capacity_descriptor_struct_t) * num_formattable_cap_desc;
   \   00000072   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000074   0x00F8             LSLS     R0,R7,#+3
   \   00000076   0x300C             ADDS     R0,R0,#+12
   \   00000078   0x9001             STR      R0,[SP, #+4]
    710          
    711              if (response_size > allocation_length)
   \   0000007A   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000007E   0x9901             LDR      R1,[SP, #+4]
   \   00000080   0x4288             CMP      R0,R1
   \   00000082   0xD202             BCS.N    ??USB_DeviceMscUfiReadFormatCapacityCommand_5
    712              {
    713                  response_size = allocation_length;
   \   00000084   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000088   0x9001             STR      R0,[SP, #+4]
    714              }
    715              if (sizeof(ufi->formatCapacityData) < response_size)
    716              {
    717          #if (defined(_DEBUG) && _DEBUG)
    718                  usb_echo("format_capacity_response_data buff size less than need\n");
    719          #endif
    720              }
    721          
    722              ptr = (uint8_t *)&capacityListHead;
   \                     ??USB_DeviceMscUfiReadFormatCapacityCommand_5: (+1)
   \   0000008A   0xA802             ADD      R0,SP,#+8
   \   0000008C   0x0006             MOVS     R6,R0
    723              for (count = 0; count < sizeof(capacityListHead); count++)
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x4682             MOV      R10,R0
   \                     ??USB_DeviceMscUfiReadFormatCapacityCommand_6: (+1)
   \   00000092   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000096   0xF1BA 0x0F04      CMP      R10,#+4
   \   0000009A   0xD20E             BCS.N    ??USB_DeviceMscUfiReadFormatCapacityCommand_7
    724              {
    725                  ufi->formatCapacityData[count] = ptr[i++];
   \   0000009C   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000A0   0xF816 0x000B      LDRB     R0,[R6, R11]
   \   000000A4   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000A8   0xEB05 0x010A      ADD      R1,R5,R10
   \   000000AC   0xF881 0x006D      STRB     R0,[R1, #+109]
   \   000000B0   0xF11B 0x0B01      ADDS     R11,R11,#+1
    726              }
   \   000000B4   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   000000B8   0xE7EB             B.N      ??USB_DeviceMscUfiReadFormatCapacityCommand_6
    727              ptr = (uint8_t *)&current_max_head;
   \                     ??USB_DeviceMscUfiReadFormatCapacityCommand_7: (+1)
   \   000000BA   0xA805             ADD      R0,SP,#+20
   \   000000BC   0x0006             MOVS     R6,R0
    728              i = 0;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x4683             MOV      R11,R0
    729              for (; i < sizeof(current_max_head); count++)
   \                     ??USB_DeviceMscUfiReadFormatCapacityCommand_8: (+1)
   \   000000C2   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000C6   0xF1BB 0x0F08      CMP      R11,#+8
   \   000000CA   0xD20E             BCS.N    ??USB_DeviceMscUfiReadFormatCapacityCommand_9
    730              {
    731                  ufi->formatCapacityData[count] = ptr[i++];
   \   000000CC   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000D0   0xF816 0x000B      LDRB     R0,[R6, R11]
   \   000000D4   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000D8   0xEB05 0x010A      ADD      R1,R5,R10
   \   000000DC   0xF881 0x006D      STRB     R0,[R1, #+109]
   \   000000E0   0xF11B 0x0B01      ADDS     R11,R11,#+1
    732              }
   \   000000E4   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   000000E8   0xE7EB             B.N      ??USB_DeviceMscUfiReadFormatCapacityCommand_8
    733          
    734              if (ufi->formattedDisk)
   \                     ??USB_DeviceMscUfiReadFormatCapacityCommand_9: (+1)
   \   000000EA   0xF895 0x006C      LDRB     R0,[R5, #+108]
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD020             BEQ.N    ??USB_DeviceMscUfiReadFormatCapacityCommand_10
    735              {
    736                  for (i = 0; i < num_formattable_cap_desc; i++)
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0x4683             MOV      R11,R0
   \                     ??USB_DeviceMscUfiReadFormatCapacityCommand_11: (+1)
   \   000000F6   0x4658             MOV      R0,R11
   \   000000F8   0x0039             MOVS     R1,R7
   \   000000FA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000FC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000FE   0x4288             CMP      R0,R1
   \   00000100   0xD218             BCS.N    ??USB_DeviceMscUfiReadFormatCapacityCommand_10
    737                  {
    738                      ptr = (uint8_t *)&formattable_capacity_head;
   \   00000102   0xA803             ADD      R0,SP,#+12
   \   00000104   0x0006             MOVS     R6,R0
    739          
    740                      for (; count < sizeof(formattable_capacity_head); count++)
   \                     ??USB_DeviceMscUfiReadFormatCapacityCommand_12: (+1)
   \   00000106   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000010A   0xF1BA 0x0F08      CMP      R10,#+8
   \   0000010E   0xD20E             BCS.N    ??USB_DeviceMscUfiReadFormatCapacityCommand_13
    741                      {
    742                          ufi->formatCapacityData[count] = ptr[j++];
   \   00000110   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000114   0xF816 0x0009      LDRB     R0,[R6, R9]
   \   00000118   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000011C   0xEB05 0x010A      ADD      R1,R5,R10
   \   00000120   0xF881 0x006D      STRB     R0,[R1, #+109]
   \   00000124   0xF119 0x0901      ADDS     R9,R9,#+1
    743                      }
   \   00000128   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   0000012C   0xE7EB             B.N      ??USB_DeviceMscUfiReadFormatCapacityCommand_12
    744                  }
   \                     ??USB_DeviceMscUfiReadFormatCapacityCommand_13: (+1)
   \   0000012E   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   00000132   0xE7E0             B.N      ??USB_DeviceMscUfiReadFormatCapacityCommand_11
    745              }
    746          
    747              ufi->thirteenCase.deviceExpectedDataLength = response_size;
   \                     ??USB_DeviceMscUfiReadFormatCapacityCommand_10: (+1)
   \   00000134   0x9801             LDR      R0,[SP, #+4]
   \   00000136   0x61A8             STR      R0,[R5, #+24]
    748              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
   \   00000138   0x2001             MOVS     R0,#+1
   \   0000013A   0xF885 0x002A      STRB     R0,[R5, #+42]
    749              ufi->thirteenCase.buffer = ufi->formatCapacityData;
   \   0000013E   0xF115 0x006D      ADDS     R0,R5,#+109
   \   00000142   0x61E8             STR      R0,[R5, #+28]
    750              ufi->thirteenCase.lbaSendRecvSelect = 0;
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0xF885 0x0028      STRB     R0,[R5, #+40]
    751          
    752              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
   \   0000014A   0x0020             MOVS     R0,R4
   \   0000014C   0x.... 0x....      BL       USB_DeviceMscUfiThirteenCasesCheck
   \   00000150   0xF88D 0x0002      STRB     R0,[SP, #+2]
    753          
    754              return error;
   \   00000154   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000158   0xB007             ADD      SP,SP,#+28
   \   0000015A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    755          }
    756          
    757          /*!
    758           * @brief format unit command.
    759           *
    760           * The Host sends the FORMAT UNIT command to physically format one track of a diskette according to the selected
    761           *options.
    762           *
    763           * @param handle          The device msc class hanlde.
    764           *
    765           *@return A USB error code or kStatus_USB_Success.
    766          */

   \                                 In section .text, align 2, keep-with-next
    767          usb_status_t USB_DeviceMscUfiFormatUnitCommand(usb_device_msc_struct_t *mscHandle)
    768          {
   \                     USB_DeviceMscUfiFormatUnitCommand: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    769              usb_device_msc_ufi_struct_t *ufi = NULL;
   \   00000004   0x2500             MOVS     R5,#+0
    770              usb_status_t error;
    771          
    772              ufi = &mscHandle->mscUfi;
   \   00000006   0xF114 0x0058      ADDS     R0,R4,#+88
   \   0000000A   0x0005             MOVS     R5,R0
    773          
    774              ufi->thirteenCase.deviceExpectedDataLength = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x61A8             STR      R0,[R5, #+24]
    775              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF885 0x002A      STRB     R0,[R5, #+42]
    776              ufi->thirteenCase.buffer = NULL;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x61E8             STR      R0,[R5, #+28]
    777              ufi->thirteenCase.lbaSendRecvSelect = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF885 0x0028      STRB     R0,[R5, #+40]
    778          
    779              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       USB_DeviceMscUfiThirteenCasesCheck
   \   00000026   0x0006             MOVS     R6,R0
    780          
    781              if (mscHandle->mscCsw.cswStatus != USB_DEVICE_MSC_PHASE_ERROR)
   \   00000028   0xF894 0x0054      LDRB     R0,[R4, #+84]
   \   0000002C   0x2802             CMP      R0,#+2
   \   0000002E   0xD010             BEQ.N    ??USB_DeviceMscUfiFormatUnitCommand_0
    782              {
    783                  if ((mscHandle->mscCbw.cbwcb[1] & 0x1f) == 0x17)
   \   00000030   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   00000034   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000038   0x2817             CMP      R0,#+23
   \   0000003A   0xD103             BNE.N    ??USB_DeviceMscUfiFormatUnitCommand_1
    784                  {
    785                      mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_PASSED;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xF884 0x0054      STRB     R0,[R4, #+84]
   \   00000042   0xE006             B.N      ??USB_DeviceMscUfiFormatUnitCommand_0
    786                  }
    787                  else
    788                  {
    789                      mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_FAILED;
   \                     ??USB_DeviceMscUfiFormatUnitCommand_1: (+1)
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xF884 0x0054      STRB     R0,[R4, #+84]
    790                      ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_ILLEGAL_REQUEST;
   \   0000004A   0x2005             MOVS     R0,#+5
   \   0000004C   0x70A8             STRB     R0,[R5, #+2]
    791                      ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_INVALID_FIELD_IN_COMMAND_PKT;
   \   0000004E   0x2024             MOVS     R0,#+36
   \   00000050   0x7328             STRB     R0,[R5, #+12]
    792                  }
    793              }
    794              return error;
   \                     ??USB_DeviceMscUfiFormatUnitCommand_0: (+1)
   \   00000052   0x0030             MOVS     R0,R6
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
    795          }
    796          
    797          /*!
    798           * @brief prevent allow medium command.
    799           *
    800           * This command tells the UFI device to enable or disable the removal of the medium in the logical unit.
    801           *
    802           * @param handle          The device msc class hanlde.
    803           *
    804           *@return A USB error code or kStatus_USB_Success.
    805          */

   \                                 In section .text, align 2, keep-with-next
    806          usb_status_t USB_DeviceMscUfiPreventAllowMediumCommand(usb_device_msc_struct_t *mscHandle)
    807          {
   \                     USB_DeviceMscUfiPreventAllowMediumCommand: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    808              usb_device_msc_ufi_struct_t *ufi = NULL;
   \   00000004   0x2500             MOVS     R5,#+0
    809              usb_status_t error;
    810              uint8_t prevent;
    811          
    812              ufi = &mscHandle->mscUfi;
   \   00000006   0xF114 0x0058      ADDS     R0,R4,#+88
   \   0000000A   0x0005             MOVS     R5,R0
    813              prevent = mscHandle->mscCbw.cbwcb[4] & USB_DEVICE_MSC_UFI_PREVENT_ALLOW_REMOVAL_MASK;
   \   0000000C   0xF894 0x003B      LDRB     R0,[R4, #+59]
   \   00000010   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000014   0x0007             MOVS     R7,R0
    814          
    815              ufi->thirteenCase.deviceExpectedDataLength = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x61A8             STR      R0,[R5, #+24]
    816              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xF885 0x002A      STRB     R0,[R5, #+42]
    817              ufi->thirteenCase.buffer = NULL;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x61E8             STR      R0,[R5, #+28]
    818              ufi->thirteenCase.lbaSendRecvSelect = 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF885 0x0028      STRB     R0,[R5, #+40]
    819          
    820              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       USB_DeviceMscUfiThirteenCasesCheck
   \   00000030   0x0006             MOVS     R6,R0
    821          
    822              if (mscHandle->mscCsw.cswStatus != USB_DEVICE_MSC_PHASE_ERROR)
   \   00000032   0xF894 0x0054      LDRB     R0,[R4, #+84]
   \   00000036   0x2802             CMP      R0,#+2
   \   00000038   0xD009             BEQ.N    ??USB_DeviceMscUfiPreventAllowMediumCommand_0
    823              {
    824                  if ((!USB_DEVICE_CONFIG_MSC_SUPPORT_DISK_LOCKING_MECHANISM && prevent))
   \   0000003A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003C   0x2F00             CMP      R7,#+0
   \   0000003E   0xD006             BEQ.N    ??USB_DeviceMscUfiPreventAllowMediumCommand_0
    825                  {
    826                      mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_FAILED;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF884 0x0054      STRB     R0,[R4, #+84]
    827                      ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_ILLEGAL_REQUEST;
   \   00000046   0x2005             MOVS     R0,#+5
   \   00000048   0x70A8             STRB     R0,[R5, #+2]
    828                      ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_INVALID_FIELD_IN_COMMAND_PKT;
   \   0000004A   0x2024             MOVS     R0,#+36
   \   0000004C   0x7328             STRB     R0,[R5, #+12]
    829                  }
    830              }
    831          
    832              if (mscHandle->configurationStruct->classCallback != NULL)
   \                     ??USB_DeviceMscUfiPreventAllowMediumCommand_0: (+1)
   \   0000004E   0x6860             LDR      R0,[R4, #+4]
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD005             BEQ.N    ??USB_DeviceMscUfiPreventAllowMediumCommand_1
    833              {
    834                  mscHandle->configurationStruct->classCallback((class_handle_t)mscHandle, kUSB_DeviceMscEventRemovalRequest,
    835                                                                NULL);
   \   00000056   0x2200             MOVS     R2,#+0
   \   00000058   0x2107             MOVS     R1,#+7
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x6863             LDR      R3,[R4, #+4]
   \   0000005E   0x681B             LDR      R3,[R3, #+0]
   \   00000060   0x4798             BLX      R3
    836              }
    837          
    838              return error;
   \                     ??USB_DeviceMscUfiPreventAllowMediumCommand_1: (+1)
   \   00000062   0x0030             MOVS     R0,R6
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    839          }
    840          
    841          /*!
    842           * @brief send diagnostic command.
    843           *
    844           * The SEND DIAGNOSTIC command requests the UFI device to do a reset or perform a self-test.
    845           *
    846           * @param handle          The device msc class hanlde.
    847           *
    848           *@return A USB error code or kStatus_USB_Success.
    849          */

   \                                 In section .text, align 2, keep-with-next
    850          usb_status_t USB_DeviceMscUfiSendDiagnosticCommand(usb_device_msc_struct_t *mscHandle)
    851          {
   \                     USB_DeviceMscUfiSendDiagnosticCommand: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    852              usb_device_msc_ufi_struct_t *ufi = NULL;
   \   00000004   0x2500             MOVS     R5,#+0
    853              usb_status_t error;
    854          
    855              ufi = &mscHandle->mscUfi;
   \   00000006   0xF114 0x0058      ADDS     R0,R4,#+88
   \   0000000A   0x0005             MOVS     R5,R0
    856          
    857              ufi->thirteenCase.deviceExpectedDataLength = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x61A8             STR      R0,[R5, #+24]
    858              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF885 0x002A      STRB     R0,[R5, #+42]
    859              ufi->thirteenCase.buffer = NULL;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x61E8             STR      R0,[R5, #+28]
    860              ufi->thirteenCase.lbaSendRecvSelect = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF885 0x0028      STRB     R0,[R5, #+40]
    861          
    862              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       USB_DeviceMscUfiThirteenCasesCheck
   \   00000026   0x0006             MOVS     R6,R0
    863              return error;
   \   00000028   0x0030             MOVS     R0,R6
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0xBD70             POP      {R4-R6,PC}       ;; return
    864          }
    865          
    866          /*!
    867           * @brief start stop unit command.
    868           *
    869           * The START-STOP UNIT command instructs the UFI device to enable or disable media access operations.
    870           *
    871           * @param handle          The device msc class hanlde.
    872           *
    873           *@return A USB error code or kStatus_USB_Success.
    874          */

   \                                 In section .text, align 2, keep-with-next
    875          usb_status_t USB_DeviceMscUfiStartStopUnitCommand(usb_device_msc_struct_t *mscHandle)
    876          {
   \                     USB_DeviceMscUfiStartStopUnitCommand: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    877              usb_device_msc_ufi_struct_t *ufi = NULL;
   \   00000006   0x2500             MOVS     R5,#+0
    878              usb_status_t error;
    879              uint8_t loej_start;
    880          
    881              ufi = &mscHandle->mscUfi;
   \   00000008   0xF114 0x0058      ADDS     R0,R4,#+88
   \   0000000C   0x0005             MOVS     R5,R0
    882              loej_start = mscHandle->mscCbw.cbwcb[4] & USB_DEVICE_MSC_UFI_LOAD_EJECT_START_MASK;
   \   0000000E   0xF894 0x003B      LDRB     R0,[R4, #+59]
   \   00000012   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000016   0xF88D 0x0000      STRB     R0,[SP, #+0]
    883          
    884              ufi->thirteenCase.deviceExpectedDataLength = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x61A8             STR      R0,[R5, #+24]
    885              ufi->thirteenCase.deviceExpectedDirection = USB_IN;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF885 0x002A      STRB     R0,[R5, #+42]
    886              ufi->thirteenCase.buffer = NULL;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x61E8             STR      R0,[R5, #+28]
    887              ufi->thirteenCase.lbaSendRecvSelect = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF885 0x0028      STRB     R0,[R5, #+40]
    888          
    889              error = USB_DeviceMscUfiThirteenCasesCheck(mscHandle);
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       USB_DeviceMscUfiThirteenCasesCheck
   \   00000034   0x0006             MOVS     R6,R0
    890          
    891              if (mscHandle->mscCsw.cswStatus != USB_DEVICE_MSC_PHASE_ERROR)
   \   00000036   0xF894 0x0054      LDRB     R0,[R4, #+84]
   \   0000003A   0x2802             CMP      R0,#+2
   \   0000003C   0xD009             BEQ.N    ??USB_DeviceMscUfiStartStopUnitCommand_0
    892              {
    893                  if (mscHandle->configurationStruct->classCallback != NULL)
   \   0000003E   0x6860             LDR      R0,[R4, #+4]
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD005             BEQ.N    ??USB_DeviceMscUfiStartStopUnitCommand_0
    894                  {
    895                      mscHandle->configurationStruct->classCallback((class_handle_t)mscHandle, kUSB_DeviceMscEventStopEjectMedia,
    896                                                                    (void *)&loej_start);
   \   00000046   0x466A             MOV      R2,SP
   \   00000048   0x2108             MOVS     R1,#+8
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x6863             LDR      R3,[R4, #+4]
   \   0000004E   0x681B             LDR      R3,[R3, #+0]
   \   00000050   0x4798             BLX      R3
    897                  }
    898              }
    899          
    900              return error;
   \                     ??USB_DeviceMscUfiStartStopUnitCommand_0: (+1)
   \   00000052   0x0030             MOVS     R0,R6
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    901          }
    902          
    903          /*!
    904           * @brief  unsupport command.
    905           *
    906           * Handle unsupported command .
    907           *
    908           * @param handle          The device msc class hanlde.
    909           *
    910           *@return A USB error code or kStatus_USB_Success.
    911          */

   \                                 In section .text, align 2, keep-with-next
    912          usb_status_t USB_DeviceMscUfiUnsupportCommand(usb_device_msc_struct_t *mscHandle)
    913          {
   \                     USB_DeviceMscUfiUnsupportCommand: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    914              usb_device_msc_ufi_struct_t *ufi = NULL;
   \   00000002   0x2200             MOVS     R2,#+0
    915          
    916              ufi = &mscHandle->mscUfi;
   \   00000004   0xF111 0x0058      ADDS     R0,R1,#+88
   \   00000008   0x0002             MOVS     R2,R0
    917          
    918              mscHandle->mscCsw.dataResidue = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x6508             STR      R0,[R1, #+80]
    919              mscHandle->mscCsw.cswStatus = USB_DEVICE_MSC_COMMAND_FAILED;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0054      STRB     R0,[R1, #+84]
    920          
    921              ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_ILLEGAL_REQUEST;
   \   00000014   0x2005             MOVS     R0,#+5
   \   00000016   0x7090             STRB     R0,[R2, #+2]
    922              ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_INVALID_COMMAND_OPCODE;
   \   00000018   0x2020             MOVS     R0,#+32
   \   0000001A   0x7310             STRB     R0,[R2, #+12]
    923              ufi->requestSense.additionalSenseQualifer = USB_DEVICE_MSC_UFI_NO_SENSE;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x7350             STRB     R0,[R2, #+13]
    924          
    925              return kStatus_USB_Success;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x4770             BX       LR               ;; return
    926          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     g_InquiryInfoConst

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     g_ModeParametersHeaderConst

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    927          
    928          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   USB_DeviceMscUfiFormatUnitCommand
        16   -> USB_DeviceMscUfiThirteenCasesCheck
      32   USB_DeviceMscUfiInquiryCommand
        32   -> USB_DeviceMscUfiThirteenCasesCheck
      32   USB_DeviceMscUfiModeSelectCommand
        32   -> USB_DeviceMscUfiThirteenCasesCheck
      32   USB_DeviceMscUfiModeSenseCommand
        32   -> USB_DeviceMscUfiThirteenCasesCheck
      24   USB_DeviceMscUfiPreventAllowMediumCommand
        24   -- Indirect call
        24   -> USB_DeviceMscUfiThirteenCasesCheck
      16   USB_DeviceMscUfiReadCapacityCommand
        16   -> USB_DeviceMscUfiThirteenCasesCheck
      24   USB_DeviceMscUfiReadCommand
        24   -> USB_DeviceMscUfiThirteenCasesCheck
      64   USB_DeviceMscUfiReadFormatCapacityCommand
        64   -> USB_DeviceMscUfiThirteenCasesCheck
      16   USB_DeviceMscUfiRequestSenseCommand
        16   -> USB_DeviceMscUfiThirteenCasesCheck
      16   USB_DeviceMscUfiSendDiagnosticCommand
        16   -> USB_DeviceMscUfiThirteenCasesCheck
      24   USB_DeviceMscUfiStartStopUnitCommand
        24   -- Indirect call
        24   -> USB_DeviceMscUfiThirteenCasesCheck
      16   USB_DeviceMscUfiTestUnitReadyCommand
        16   -> USB_DeviceMscUfiThirteenCasesCheck
      24   USB_DeviceMscUfiThirteenCasesCheck
        24   -> USB_DeviceMscLbaTransfer
        24   -> USB_DeviceRecvRequest
        24   -> USB_DeviceSendRequest
        24   -> USB_DeviceStallEndpoint
       0   USB_DeviceMscUfiUnsupportCommand
      16   USB_DeviceMscUfiVerifyCommand
        16   -> USB_DeviceMscUfiThirteenCasesCheck
      24   USB_DeviceMscUfiWriteCommand
        24   -> USB_DeviceMscUfiThirteenCasesCheck


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ?_0
      88  USB_DeviceMscUfiFormatUnitCommand
      90  USB_DeviceMscUfiInquiryCommand
     106  USB_DeviceMscUfiModeSelectCommand
      88  USB_DeviceMscUfiModeSenseCommand
     104  USB_DeviceMscUfiPreventAllowMediumCommand
      70  USB_DeviceMscUfiReadCapacityCommand
     160  USB_DeviceMscUfiReadCommand
     350  USB_DeviceMscUfiReadFormatCapacityCommand
      44  USB_DeviceMscUfiRequestSenseCommand
      46  USB_DeviceMscUfiSendDiagnosticCommand
      88  USB_DeviceMscUfiStartStopUnitCommand
      46  USB_DeviceMscUfiTestUnitReadyCommand
     804  USB_DeviceMscUfiThirteenCasesCheck
      36  USB_DeviceMscUfiUnsupportCommand
      46  USB_DeviceMscUfiVerifyCommand
     160  USB_DeviceMscUfiWriteCommand
      36  g_InquiryInfoConst
       8  g_ModeParametersHeaderConst

 
    48 bytes in section .rodata
 2 338 bytes in section .text
 
 2 338 bytes of CODE  memory
    48 bytes of CONST memory

Errors: none
Warnings: none
