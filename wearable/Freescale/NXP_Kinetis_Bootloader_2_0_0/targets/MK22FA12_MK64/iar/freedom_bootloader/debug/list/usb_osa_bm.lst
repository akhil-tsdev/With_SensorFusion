###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:16
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\osa\usb_osa_bm.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\osa\usb_osa_bm.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\usb_osa_bm.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\usb_osa_bm.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\osa\usb_osa_bm.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          #include "stdint.h"
     31          #include "usb.h"
     32          #include "usb_osa.h"
     33          #include "stdlib.h"
     34          #include "fsl_device_registers.h"
     35          
     36          /*******************************************************************************
     37           * Definitions
     38           ******************************************************************************/
     39          #define USB_OSA_BM_EVENT_COUNT (2U)
     40          #define USB_OSA_BM_SEM_COUNT (1U)
     41          #define USB_OSA_BM_MSGQ_COUNT (1U)
     42          #define USB_OSA_BM_MSG_COUNT (8U)
     43          #define USB_OSA_BM_MSG_SIZE (4U)
     44          
     45          /* BM Event status structure */
     46          typedef struct _usb_osa_event_struct
     47          {
     48              uint32_t value; /* Event mask */
     49              uint32_t flag;  /* Event flags, includes auto clear flag */
     50              uint8_t isUsed; /* Is used */
     51          } usb_osa_event_struct_t;
     52          
     53          /* BM semaphore status structure */
     54          typedef struct _usb_osa_sem_struct
     55          {
     56              uint32_t value; /* Semaphore count */
     57              uint8_t isUsed; /* Is used */
     58          } usb_osa_sem_struct_t;
     59          
     60          /* BM msg status structure */
     61          typedef struct _usb_osa_msg_struct
     62          {
     63              uint32_t msg[USB_OSA_BM_MSG_SIZE]; /* Message entity pointer */
     64          } usb_osa_msg_struct_t;
     65          
     66          /* BM msgq status structure */
     67          typedef struct _usb_osa_msgq_struct
     68          {
     69              usb_osa_msg_struct_t msgs[USB_OSA_BM_MSG_COUNT]; /* Message entity list */
     70              uint32_t count;                                  /* Max message entity count */
     71              uint32_t msgSize;                                /* Size of each message */
     72              uint32_t msgCount;                               /* Valid messages */
     73              uint32_t index;                                  /* The first empty message entity index */
     74              uint32_t current;                                /* The vaild message index */
     75              uint8_t isUsed;                                  /* Is used */
     76          } usb_osa_msgq_struct_t;
     77          
     78          /*******************************************************************************
     79           * Prototypes
     80           ******************************************************************************/
     81          
     82          /*******************************************************************************
     83           * Variables
     84           ******************************************************************************/
     85          

   \                                 In section m_usb_global, align 1
     86          USB_GLOBAL static uint8_t s_UsbBmCriticalLevel;
   \                     s_UsbBmCriticalLevel:
   \   00000000                      DS8 1

   \                                 In section m_usb_global, align 4
     87          USB_GLOBAL static usb_osa_sem_struct_t s_UsbBmSemStruct[USB_OSA_BM_SEM_COUNT];
   \                     s_UsbBmSemStruct:
   \   00000000                      DS8 8

   \                                 In section m_usb_global, align 4
     88          USB_GLOBAL static usb_osa_event_struct_t s_UsbBmEventStruct[USB_OSA_BM_EVENT_COUNT];
   \                     s_UsbBmEventStruct:
   \   00000000                      DS8 24

   \                                 In section m_usb_global, align 4
     89          USB_GLOBAL static usb_osa_msgq_struct_t s_UsbBmMsgqStruct[USB_OSA_BM_MSGQ_COUNT];
   \                     s_UsbBmMsgqStruct:
   \   00000000                      DS8 152
     90          
     91          /*******************************************************************************
     92           * Code
     93           ******************************************************************************/
     94          

   \                                 In section .text, align 2, keep-with-next
     95          void *USB_OsaMemoryAllocate(uint32_t length)
     96          {
   \                     USB_OsaMemoryAllocate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     97              void *p = (void *)malloc(length);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       malloc
     98              uint8_t *temp = (uint8_t *)p;
   \   0000000A   0x0001             MOVS     R1,R0
     99              if (p)
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD006             BEQ.N    ??USB_OsaMemoryAllocate_0
    100              {
    101                  for (uint32_t count = 0U; count < length; count++)
   \   00000010   0x2200             MOVS     R2,#+0
   \                     ??USB_OsaMemoryAllocate_1: (+1)
   \   00000012   0x42A2             CMP      R2,R4
   \   00000014   0xD203             BCS.N    ??USB_OsaMemoryAllocate_0
    102                  {
    103                      temp[count] = 0U;
   \   00000016   0x2300             MOVS     R3,#+0
   \   00000018   0x548B             STRB     R3,[R1, R2]
    104                  }
   \   0000001A   0x1C52             ADDS     R2,R2,#+1
   \   0000001C   0xE7F9             B.N      ??USB_OsaMemoryAllocate_1
    105              }
    106              return p;
   \                     ??USB_OsaMemoryAllocate_0: (+1)
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    107          }
    108          

   \                                 In section .text, align 2, keep-with-next
    109          void USB_OsaMemoryFree(void *p)
    110          {
   \                     USB_OsaMemoryFree: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    111              free(p);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       free
    112          }
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
    113          

   \                                 In section .text, align 4, keep-with-next
    114          void USB_BmEnterCritical(void)
    115          {
    116              if (0U == s_UsbBmCriticalLevel)
   \                     USB_BmEnterCritical: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable5
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD100             BNE.N    ??USB_BmEnterCritical_0
    117              {
    118          #ifdef __CC_ARM
    119                  __disable_irq();
    120          #else
    121                  __ASM("CPSID i");
   \   00000008   0xB672             CPSID i
    122          #endif
    123              }
    124              s_UsbBmCriticalLevel++;
   \                     ??USB_BmEnterCritical_0: (+1)
   \   0000000A   0x....             LDR.N    R0,??DataTable5
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0x....             LDR.N    R1,??DataTable5
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    125          }
   \   00000014   0x4770             BX       LR               ;; return
    126          

   \                                 In section .text, align 4, keep-with-next
    127          void USB_BmExitCritical(void)
    128          {
    129              if (s_UsbBmCriticalLevel)
   \                     USB_BmExitCritical: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable5
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD004             BEQ.N    ??USB_BmExitCritical_0
    130              {
    131                  s_UsbBmCriticalLevel--;
   \   00000008   0x....             LDR.N    R0,??DataTable5
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x1E40             SUBS     R0,R0,#+1
   \   0000000E   0x....             LDR.N    R1,??DataTable5
   \   00000010   0x7008             STRB     R0,[R1, #+0]
    132              }
    133              if (0U == s_UsbBmCriticalLevel)
   \                     ??USB_BmExitCritical_0: (+1)
   \   00000012   0x....             LDR.N    R0,??DataTable5
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD100             BNE.N    ??USB_BmExitCritical_1
    134              {
    135          #ifdef __CC_ARM
    136                  __enable_irq();
    137          #else
    138                  __ASM("CPSIE i");
   \   0000001A   0xB662             CPSIE i
    139          #endif
    140              }
    141          }
   \                     ??USB_BmExitCritical_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
    142          

   \                                 In section .text, align 2, keep-with-next
    143          usb_osa_status_t USB_OsaEventCreate(usb_osa_event_handle *handle, uint32_t flag)
    144          {
   \                     USB_OsaEventCreate: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    145              usb_osa_event_struct_t *event = NULL;
   \   00000006   0x2600             MOVS     R6,#+0
    146              USB_OSA_SR_ALLOC();
    147          
    148              if (!handle)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??USB_OsaEventCreate_0
    149              {
    150                  return kStatus_USB_OSA_Error;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE023             B.N      ??USB_OsaEventCreate_1
    151              }
    152          
    153              USB_OSA_ENTER_CRITICAL();
   \                     ??USB_OsaEventCreate_0: (+1)
   \   00000010   0x.... 0x....      BL       USB_BmEnterCritical
    154              for (uint32_t i = 0; i < USB_OSA_BM_EVENT_COUNT; i++)
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??USB_OsaEventCreate_2: (+1)
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD20F             BCS.N    ??USB_OsaEventCreate_3
    155              {
    156                  if (0 == s_UsbBmEventStruct[i].isUsed)
   \   0000001A   0x....             LDR.N    R1,??DataTable5_1
   \   0000001C   0x220C             MOVS     R2,#+12
   \   0000001E   0xFB02 0xF200      MUL      R2,R2,R0
   \   00000022   0x4411             ADD      R1,R1,R2
   \   00000024   0x7A09             LDRB     R1,[R1, #+8]
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD105             BNE.N    ??USB_OsaEventCreate_4
    157                  {
    158                      event = &s_UsbBmEventStruct[i];
   \   0000002A   0x....             LDR.N    R1,??DataTable5_1
   \   0000002C   0x220C             MOVS     R2,#+12
   \   0000002E   0x4350             MULS     R0,R2,R0
   \   00000030   0x4408             ADD      R0,R1,R0
   \   00000032   0x0006             MOVS     R6,R0
    159                      break;
   \   00000034   0xE001             B.N      ??USB_OsaEventCreate_3
    160                  }
    161              }
   \                     ??USB_OsaEventCreate_4: (+1)
   \   00000036   0x1C40             ADDS     R0,R0,#+1
   \   00000038   0xE7ED             B.N      ??USB_OsaEventCreate_2
    162          
    163              if (NULL == event)
   \                     ??USB_OsaEventCreate_3: (+1)
   \   0000003A   0x2E00             CMP      R6,#+0
   \   0000003C   0xD103             BNE.N    ??USB_OsaEventCreate_5
    164              {
    165                  USB_OSA_EXIT_CRITICAL();
   \   0000003E   0x.... 0x....      BL       USB_BmExitCritical
    166                  return kStatus_USB_OSA_Error;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xE008             B.N      ??USB_OsaEventCreate_1
    167              }
    168          
    169              event->value = 0U;
   \                     ??USB_OsaEventCreate_5: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x6030             STR      R0,[R6, #+0]
    170              event->flag = flag;
   \   0000004A   0x6075             STR      R5,[R6, #+4]
    171              event->isUsed = 1;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x7230             STRB     R0,[R6, #+8]
    172              *handle = event;
   \   00000050   0x6026             STR      R6,[R4, #+0]
    173              USB_OSA_EXIT_CRITICAL();
   \   00000052   0x.... 0x....      BL       USB_BmExitCritical
    174              return kStatus_USB_OSA_Success;
   \   00000056   0x2000             MOVS     R0,#+0
   \                     ??USB_OsaEventCreate_1: (+1)
   \   00000058   0xBD70             POP      {R4-R6,PC}       ;; return
    175          }
    176          

   \                                 In section .text, align 2, keep-with-next
    177          usb_osa_status_t USB_OsaEventDestroy(usb_osa_event_handle handle)
    178          {
   \                     USB_OsaEventDestroy: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    179              usb_osa_event_struct_t *event = (usb_osa_event_struct_t *)handle;
   \   00000004   0x0025             MOVS     R5,R4
    180              USB_OSA_SR_ALLOC();
    181          
    182              if (handle)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??USB_OsaEventDestroy_0
    183              {
    184                  USB_OSA_ENTER_CRITICAL();
   \   0000000A   0x.... 0x....      BL       USB_BmEnterCritical
    185                  event->isUsed = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x7228             STRB     R0,[R5, #+8]
    186                  USB_OSA_EXIT_CRITICAL();
   \   00000012   0x.... 0x....      BL       USB_BmExitCritical
    187                  return kStatus_USB_OSA_Success;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE000             B.N      ??USB_OsaEventDestroy_1
    188              }
    189              return kStatus_USB_OSA_Error;
   \                     ??USB_OsaEventDestroy_0: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \                     ??USB_OsaEventDestroy_1: (+1)
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    190          }
    191          

   \                                 In section .text, align 2, keep-with-next
    192          usb_osa_status_t USB_OsaEventSet(usb_osa_event_handle handle, uint32_t bitMask)
    193          {
   \                     USB_OsaEventSet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    194              usb_osa_event_struct_t *event = (usb_osa_event_struct_t *)handle;
   \   00000006   0x0026             MOVS     R6,R4
    195              USB_OSA_SR_ALLOC();
    196          
    197              if (handle)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD008             BEQ.N    ??USB_OsaEventSet_0
    198              {
    199                  USB_OSA_ENTER_CRITICAL();
   \   0000000C   0x.... 0x....      BL       USB_BmEnterCritical
    200                  event->value |= bitMask;
   \   00000010   0x6830             LDR      R0,[R6, #+0]
   \   00000012   0x4328             ORRS     R0,R5,R0
   \   00000014   0x6030             STR      R0,[R6, #+0]
    201                  USB_OSA_EXIT_CRITICAL();
   \   00000016   0x.... 0x....      BL       USB_BmExitCritical
    202                  return kStatus_USB_OSA_Success;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE000             B.N      ??USB_OsaEventSet_1
    203              }
    204              return kStatus_USB_OSA_Error;
   \                     ??USB_OsaEventSet_0: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \                     ??USB_OsaEventSet_1: (+1)
   \   00000020   0xBD70             POP      {R4-R6,PC}       ;; return
    205          }
    206          

   \                                 In section .text, align 2, keep-with-next
    207          usb_osa_status_t USB_OsaEventWait(
    208              usb_osa_event_handle handle, uint32_t bitMask, uint32_t flag, uint32_t timeout, uint32_t *bitSet)
    209          {
   \                     USB_OsaEventWait: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8020      LDR      R8,[SP, #+32]
    210              usb_osa_event_struct_t *event = (usb_osa_event_struct_t *)handle;
   \   00000010   0x46A1             MOV      R9,R4
    211              uint32_t bits;
    212              USB_OSA_SR_ALLOC();
    213          
    214              if (handle)
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD027             BEQ.N    ??USB_OsaEventWait_0
    215              {
    216                  USB_OSA_ENTER_CRITICAL();
   \   00000016   0x.... 0x....      BL       USB_BmEnterCritical
    217                  bits = event->value & bitMask;
   \   0000001A   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   0000001E   0x4028             ANDS     R0,R5,R0
   \   00000020   0x4682             MOV      R10,R0
    218                  if (flag)
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD005             BEQ.N    ??USB_OsaEventWait_1
    219                  {
    220                      if (bits != bitMask)
   \   00000026   0x45AA             CMP      R10,R5
   \   00000028   0xD00A             BEQ.N    ??USB_OsaEventWait_2
    221                      {
    222                          USB_OSA_EXIT_CRITICAL();
   \   0000002A   0x.... 0x....      BL       USB_BmExitCritical
    223                          return kStatus_USB_OSA_TimeOut;
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xE01A             B.N      ??USB_OsaEventWait_3
    224                      }
    225                  }
    226                  else
    227                  {
    228                      if (!bits)
   \                     ??USB_OsaEventWait_1: (+1)
   \   00000032   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000036   0xD103             BNE.N    ??USB_OsaEventWait_2
    229                      {
    230                          USB_OSA_EXIT_CRITICAL();
   \   00000038   0x.... 0x....      BL       USB_BmExitCritical
    231                          return kStatus_USB_OSA_TimeOut;
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0xE013             B.N      ??USB_OsaEventWait_3
    232                      }
    233                  }
    234                  if (bitSet)
   \                     ??USB_OsaEventWait_2: (+1)
   \   00000040   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000044   0xD001             BEQ.N    ??USB_OsaEventWait_4
    235                  {
    236                      *bitSet = bits;
   \   00000046   0xF8C8 0xA000      STR      R10,[R8, #+0]
    237                  }
    238                  if (event->flag)
   \                     ??USB_OsaEventWait_4: (+1)
   \   0000004A   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD005             BEQ.N    ??USB_OsaEventWait_5
    239                  {
    240                      event->value &= ~bits;
   \   00000052   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000056   0xEA30 0x000A      BICS     R0,R0,R10
   \   0000005A   0xF8C9 0x0000      STR      R0,[R9, #+0]
    241                  }
    242                  USB_OSA_EXIT_CRITICAL();
   \                     ??USB_OsaEventWait_5: (+1)
   \   0000005E   0x.... 0x....      BL       USB_BmExitCritical
    243                  return kStatus_USB_OSA_Success;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xE000             B.N      ??USB_OsaEventWait_3
    244              }
    245              return kStatus_USB_OSA_Error;
   \                     ??USB_OsaEventWait_0: (+1)
   \   00000066   0x2001             MOVS     R0,#+1
   \                     ??USB_OsaEventWait_3: (+1)
   \   00000068   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    246          }
    247          

   \                                 In section .text, align 2, keep-with-next
    248          usb_osa_status_t USB_OsaEventCheck(usb_osa_event_handle handle, uint32_t bitMask, uint32_t *bitSet)
    249          {
   \                     USB_OsaEventCheck: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    250              usb_osa_event_struct_t *event = (usb_osa_event_struct_t *)handle;
   \   0000000A   0x0027             MOVS     R7,R4
    251              uint32_t bits;
    252              USB_OSA_SR_ALLOC();
    253          
    254              if (handle)
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD013             BEQ.N    ??USB_OsaEventCheck_0
    255              {
    256                  USB_OSA_ENTER_CRITICAL();
   \   00000010   0x.... 0x....      BL       USB_BmEnterCritical
    257                  bits = event->value & bitMask;
   \   00000014   0x6838             LDR      R0,[R7, #+0]
   \   00000016   0x4028             ANDS     R0,R5,R0
   \   00000018   0x4680             MOV      R8,R0
    258          
    259                  if (!bits)
   \   0000001A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001E   0xD103             BNE.N    ??USB_OsaEventCheck_1
    260                  {
    261                      USB_OSA_EXIT_CRITICAL();
   \   00000020   0x.... 0x....      BL       USB_BmExitCritical
    262                      return kStatus_USB_OSA_Error;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE008             B.N      ??USB_OsaEventCheck_2
    263                  }
    264          
    265                  if (bitSet)
   \                     ??USB_OsaEventCheck_1: (+1)
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD001             BEQ.N    ??USB_OsaEventCheck_3
    266                  {
    267                      *bitSet = bits;
   \   0000002C   0xF8C6 0x8000      STR      R8,[R6, #+0]
    268                  }
    269                  USB_OSA_EXIT_CRITICAL();
   \                     ??USB_OsaEventCheck_3: (+1)
   \   00000030   0x.... 0x....      BL       USB_BmExitCritical
    270                  return kStatus_USB_OSA_Success;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xE000             B.N      ??USB_OsaEventCheck_2
    271              }
    272              return kStatus_USB_OSA_Error;
   \                     ??USB_OsaEventCheck_0: (+1)
   \   00000038   0x2001             MOVS     R0,#+1
   \                     ??USB_OsaEventCheck_2: (+1)
   \   0000003A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    273          }
    274          

   \                                 In section .text, align 2, keep-with-next
    275          usb_osa_status_t USB_OsaEventClear(usb_osa_event_handle handle, uint32_t bitMask)
    276          {
   \                     USB_OsaEventClear: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    277              usb_osa_event_struct_t *event = (usb_osa_event_struct_t *)handle;
   \   00000006   0x0026             MOVS     R6,R4
    278              uint32_t bits;
    279              USB_OSA_SR_ALLOC();
    280          
    281              if (handle)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD00B             BEQ.N    ??USB_OsaEventClear_0
    282              {
    283                  USB_OSA_ENTER_CRITICAL();
   \   0000000C   0x.... 0x....      BL       USB_BmEnterCritical
    284                  bits = event->value & bitMask;
   \   00000010   0x6830             LDR      R0,[R6, #+0]
   \   00000012   0x4028             ANDS     R0,R5,R0
   \   00000014   0x0007             MOVS     R7,R0
    285                  event->value &= ~bits;
   \   00000016   0x6830             LDR      R0,[R6, #+0]
   \   00000018   0x43B8             BICS     R0,R0,R7
   \   0000001A   0x6030             STR      R0,[R6, #+0]
    286                  USB_OSA_EXIT_CRITICAL();
   \   0000001C   0x.... 0x....      BL       USB_BmExitCritical
    287                  return kStatus_USB_OSA_Success;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE000             B.N      ??USB_OsaEventClear_1
    288              }
    289              return kStatus_USB_OSA_Error;
   \                     ??USB_OsaEventClear_0: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \                     ??USB_OsaEventClear_1: (+1)
   \   00000026   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    290          }
    291          

   \                                 In section .text, align 2, keep-with-next
    292          usb_osa_status_t USB_OsaSemCreate(usb_osa_sem_handle *handle, uint32_t count)
    293          {
   \                     USB_OsaSemCreate: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    294              usb_osa_sem_struct_t *sem = NULL;
   \   00000006   0x2600             MOVS     R6,#+0
    295              USB_OSA_SR_ALLOC();
    296          
    297              if (!handle)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??USB_OsaSemCreate_0
    298              {
    299                  return kStatus_USB_OSA_Error;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE01E             B.N      ??USB_OsaSemCreate_1
    300              }
    301          
    302              USB_OSA_ENTER_CRITICAL();
   \                     ??USB_OsaSemCreate_0: (+1)
   \   00000010   0x.... 0x....      BL       USB_BmEnterCritical
    303              for (uint32_t i = 0; i < USB_OSA_BM_SEM_COUNT; i++)
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??USB_OsaSemCreate_2: (+1)
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD10C             BNE.N    ??USB_OsaSemCreate_3
    304              {
    305                  if (0 == s_UsbBmSemStruct[i].isUsed)
   \   0000001A   0x....             LDR.N    R1,??DataTable5_2
   \   0000001C   0xEB01 0x01C0      ADD      R1,R1,R0, LSL #+3
   \   00000020   0x7909             LDRB     R1,[R1, #+4]
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xD104             BNE.N    ??USB_OsaSemCreate_4
    306                  {
    307                      sem = &s_UsbBmSemStruct[i];
   \   00000026   0x....             LDR.N    R1,??DataTable5_2
   \   00000028   0xEB01 0x00C0      ADD      R0,R1,R0, LSL #+3
   \   0000002C   0x0006             MOVS     R6,R0
    308                      break;
   \   0000002E   0xE001             B.N      ??USB_OsaSemCreate_3
    309                  }
    310              }
   \                     ??USB_OsaSemCreate_4: (+1)
   \   00000030   0x1C40             ADDS     R0,R0,#+1
   \   00000032   0xE7F0             B.N      ??USB_OsaSemCreate_2
    311              if (NULL == sem)
   \                     ??USB_OsaSemCreate_3: (+1)
   \   00000034   0x2E00             CMP      R6,#+0
   \   00000036   0xD103             BNE.N    ??USB_OsaSemCreate_5
    312              {
    313                  USB_OSA_EXIT_CRITICAL();
   \   00000038   0x.... 0x....      BL       USB_BmExitCritical
    314                  return kStatus_USB_OSA_Error;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xE006             B.N      ??USB_OsaSemCreate_1
    315              }
    316          
    317              sem->value = count;
   \                     ??USB_OsaSemCreate_5: (+1)
   \   00000040   0x6035             STR      R5,[R6, #+0]
    318              sem->isUsed = 1;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x7130             STRB     R0,[R6, #+4]
    319              *handle = sem;
   \   00000046   0x6026             STR      R6,[R4, #+0]
    320              USB_OSA_EXIT_CRITICAL();
   \   00000048   0x.... 0x....      BL       USB_BmExitCritical
    321              return kStatus_USB_OSA_Success;
   \   0000004C   0x2000             MOVS     R0,#+0
   \                     ??USB_OsaSemCreate_1: (+1)
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return
    322          }
    323          

   \                                 In section .text, align 2, keep-with-next
    324          usb_osa_status_t USB_OsaSemDestroy(usb_osa_sem_handle handle)
    325          {
   \                     USB_OsaSemDestroy: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    326              usb_osa_sem_struct_t *sem = (usb_osa_sem_struct_t *)handle;
   \   00000004   0x0025             MOVS     R5,R4
    327              USB_OSA_SR_ALLOC();
    328          
    329              if (handle)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??USB_OsaSemDestroy_0
    330              {
    331                  USB_OSA_ENTER_CRITICAL();
   \   0000000A   0x.... 0x....      BL       USB_BmEnterCritical
    332                  sem->isUsed = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x7128             STRB     R0,[R5, #+4]
    333                  USB_OSA_EXIT_CRITICAL();
   \   00000012   0x.... 0x....      BL       USB_BmExitCritical
    334                  return kStatus_USB_OSA_Success;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE000             B.N      ??USB_OsaSemDestroy_1
    335              }
    336              return kStatus_USB_OSA_Error;
   \                     ??USB_OsaSemDestroy_0: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \                     ??USB_OsaSemDestroy_1: (+1)
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    337          }
    338          

   \                                 In section .text, align 2, keep-with-next
    339          usb_osa_status_t USB_OsaSemPost(usb_osa_sem_handle handle)
    340          {
   \                     USB_OsaSemPost: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    341              usb_osa_sem_struct_t *sem = (usb_osa_sem_struct_t *)handle;
   \   00000004   0x0025             MOVS     R5,R4
    342              USB_OSA_SR_ALLOC();
    343          
    344              if (!handle)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??USB_OsaSemPost_0
    345              {
    346                  return kStatus_USB_OSA_Error;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE007             B.N      ??USB_OsaSemPost_1
    347              }
    348          
    349              USB_OSA_ENTER_CRITICAL();
   \                     ??USB_OsaSemPost_0: (+1)
   \   0000000E   0x.... 0x....      BL       USB_BmEnterCritical
    350              sem->value++;
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x6028             STR      R0,[R5, #+0]
    351              USB_OSA_EXIT_CRITICAL();
   \   00000018   0x.... 0x....      BL       USB_BmExitCritical
    352              return kStatus_USB_OSA_Success;
   \   0000001C   0x2000             MOVS     R0,#+0
   \                     ??USB_OsaSemPost_1: (+1)
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    353          }
    354          

   \                                 In section .text, align 2, keep-with-next
    355          usb_osa_status_t USB_OsaSemWait(usb_osa_sem_handle handle, uint32_t timeout)
    356          {
   \                     USB_OsaSemWait: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    357              usb_osa_sem_struct_t *sem = (usb_osa_sem_struct_t *)handle;
   \   00000006   0x0026             MOVS     R6,R4
    358              USB_OSA_SR_ALLOC();
    359          
    360              if (!handle)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??USB_OsaSemWait_0
    361              {
    362                  return kStatus_USB_OSA_Error;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE00E             B.N      ??USB_OsaSemWait_1
    363              }
    364          
    365              USB_OSA_ENTER_CRITICAL();
   \                     ??USB_OsaSemWait_0: (+1)
   \   00000010   0x.... 0x....      BL       USB_BmEnterCritical
    366              if (sem->value)
   \   00000014   0x6830             LDR      R0,[R6, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD006             BEQ.N    ??USB_OsaSemWait_2
    367              {
    368                  sem->value--;
   \   0000001A   0x6830             LDR      R0,[R6, #+0]
   \   0000001C   0x1E40             SUBS     R0,R0,#+1
   \   0000001E   0x6030             STR      R0,[R6, #+0]
    369              }
    370              else
    371              {
    372                  USB_OSA_EXIT_CRITICAL();
    373                  return kStatus_USB_OSA_TimeOut;
    374              }
    375              USB_OSA_EXIT_CRITICAL();
   \   00000020   0x.... 0x....      BL       USB_BmExitCritical
    376              return kStatus_USB_OSA_Success;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE002             B.N      ??USB_OsaSemWait_1
   \                     ??USB_OsaSemWait_2: (+1)
   \   00000028   0x.... 0x....      BL       USB_BmExitCritical
   \   0000002C   0x2002             MOVS     R0,#+2
   \                     ??USB_OsaSemWait_1: (+1)
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
    377          }
    378          

   \                                 In section .text, align 2, keep-with-next
    379          usb_osa_status_t USB_OsaMutexCreate(usb_osa_mutex_handle *handle)
    380          {
   \                     USB_OsaMutexCreate: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    381              if (!handle)
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD101             BNE.N    ??USB_OsaMutexCreate_0
    382              {
    383                  return kStatus_USB_OSA_Error;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xE002             B.N      ??USB_OsaMutexCreate_1
    384              }
    385              *handle = (usb_osa_mutex_handle)0xFFFF0000U;
   \                     ??USB_OsaMutexCreate_0: (+1)
   \   0000000A   0x....             LDR.N    R0,??DataTable5_3  ;; 0xffff0000
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    386              return kStatus_USB_OSA_Success;
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??USB_OsaMutexCreate_1: (+1)
   \   00000010   0x4770             BX       LR               ;; return
    387          }
    388          

   \                                 In section .text, align 2, keep-with-next
    389          usb_osa_status_t USB_OsaMutexDestroy(usb_osa_mutex_handle handle)
    390          {
   \                     USB_OsaMutexDestroy: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    391              return kStatus_USB_OSA_Success;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
    392          }

   \                                 In section .text, align 2, keep-with-next
    393          usb_osa_status_t USB_OsaMutexLock(usb_osa_mutex_handle handle)
    394          {
   \                     USB_OsaMutexLock: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    395              return kStatus_USB_OSA_Success;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
    396          }

   \                                 In section .text, align 2, keep-with-next
    397          usb_osa_status_t USB_OsaMutexUnlock(usb_osa_mutex_handle handle)
    398          {
   \                     USB_OsaMutexUnlock: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    399              return kStatus_USB_OSA_Success;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
    400          }
    401          

   \                                 In section .text, align 2, keep-with-next
    402          usb_osa_status_t USB_OsaMsgqCreate(usb_osa_msgq_handle *handle, uint32_t count, uint32_t size)
    403          {
   \                     USB_OsaMsgqCreate: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    404              usb_osa_msgq_struct_t *msgq = NULL;
   \   00000008   0x2700             MOVS     R7,#+0
    405              USB_OSA_SR_ALLOC();
    406          
    407              if (!handle)
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD101             BNE.N    ??USB_OsaMsgqCreate_0
    408              {
    409                  return kStatus_USB_OSA_Error;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE033             B.N      ??USB_OsaMsgqCreate_1
    410              }
    411              USB_OSA_ENTER_CRITICAL();
   \                     ??USB_OsaMsgqCreate_0: (+1)
   \   00000012   0x.... 0x....      BL       USB_BmEnterCritical
    412          
    413              for (uint32_t i = 0; i < USB_OSA_BM_MSGQ_COUNT; i++)
   \   00000016   0x2000             MOVS     R0,#+0
   \                     ??USB_OsaMsgqCreate_2: (+1)
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD110             BNE.N    ??USB_OsaMsgqCreate_3
    414              {
    415                  if (0 == s_UsbBmMsgqStruct[i].isUsed)
   \   0000001C   0x....             LDR.N    R1,??DataTable5_4
   \   0000001E   0x2298             MOVS     R2,#+152
   \   00000020   0xFB02 0xF200      MUL      R2,R2,R0
   \   00000024   0x4411             ADD      R1,R1,R2
   \   00000026   0xF891 0x1094      LDRB     R1,[R1, #+148]
   \   0000002A   0x2900             CMP      R1,#+0
   \   0000002C   0xD105             BNE.N    ??USB_OsaMsgqCreate_4
    416                  {
    417                      msgq = &s_UsbBmMsgqStruct[i];
   \   0000002E   0x....             LDR.N    R1,??DataTable5_4
   \   00000030   0x2298             MOVS     R2,#+152
   \   00000032   0x4350             MULS     R0,R2,R0
   \   00000034   0x4408             ADD      R0,R1,R0
   \   00000036   0x0007             MOVS     R7,R0
    418                      break;
   \   00000038   0xE001             B.N      ??USB_OsaMsgqCreate_3
    419                  }
    420              }
   \                     ??USB_OsaMsgqCreate_4: (+1)
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \   0000003C   0xE7EC             B.N      ??USB_OsaMsgqCreate_2
    421              if ((NULL == msgq) || (count > USB_OSA_BM_MSG_COUNT) || (size > USB_OSA_BM_MSG_SIZE))
   \                     ??USB_OsaMsgqCreate_3: (+1)
   \   0000003E   0x2F00             CMP      R7,#+0
   \   00000040   0xD003             BEQ.N    ??USB_OsaMsgqCreate_5
   \   00000042   0x2D09             CMP      R5,#+9
   \   00000044   0xD201             BCS.N    ??USB_OsaMsgqCreate_5
   \   00000046   0x2E05             CMP      R6,#+5
   \   00000048   0xD303             BCC.N    ??USB_OsaMsgqCreate_6
    422              {
    423                  USB_OSA_EXIT_CRITICAL();
   \                     ??USB_OsaMsgqCreate_5: (+1)
   \   0000004A   0x.... 0x....      BL       USB_BmExitCritical
    424                  return kStatus_USB_OSA_Error;
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xE013             B.N      ??USB_OsaMsgqCreate_1
    425              }
    426              msgq->count = count;
   \                     ??USB_OsaMsgqCreate_6: (+1)
   \   00000052   0xF8C7 0x5080      STR      R5,[R7, #+128]
    427              msgq->msgSize = size;
   \   00000056   0xF8C7 0x6084      STR      R6,[R7, #+132]
    428              msgq->msgCount = 0U;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF8C7 0x0088      STR      R0,[R7, #+136]
    429              msgq->index = 0U;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xF8C7 0x008C      STR      R0,[R7, #+140]
    430              msgq->current = 0U;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xF8C7 0x0090      STR      R0,[R7, #+144]
    431              msgq->isUsed = 1;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xF887 0x0094      STRB     R0,[R7, #+148]
    432              *handle = msgq;
   \   00000072   0x6027             STR      R7,[R4, #+0]
    433              USB_OSA_EXIT_CRITICAL();
   \   00000074   0x.... 0x....      BL       USB_BmExitCritical
    434              return kStatus_USB_OSA_Success;
   \   00000078   0x2000             MOVS     R0,#+0
   \                     ??USB_OsaMsgqCreate_1: (+1)
   \   0000007A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    435          }
    436          

   \                                 In section .text, align 2, keep-with-next
    437          usb_osa_status_t USB_OsaMsgqDestroy(usb_osa_msgq_handle handle)
    438          {
   \                     USB_OsaMsgqDestroy: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    439              usb_osa_msgq_struct_t *msgq = (usb_osa_msgq_struct_t *)handle;
   \   00000004   0x0025             MOVS     R5,R4
    440              USB_OSA_SR_ALLOC();
    441          
    442              if (!handle)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??USB_OsaMsgqDestroy_0
    443              {
    444                  return kStatus_USB_OSA_Error;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE007             B.N      ??USB_OsaMsgqDestroy_1
    445              }
    446              USB_OSA_ENTER_CRITICAL();
   \                     ??USB_OsaMsgqDestroy_0: (+1)
   \   0000000E   0x.... 0x....      BL       USB_BmEnterCritical
    447              msgq->isUsed = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF885 0x0094      STRB     R0,[R5, #+148]
    448              USB_OSA_EXIT_CRITICAL();
   \   00000018   0x.... 0x....      BL       USB_BmExitCritical
    449              return kStatus_USB_OSA_Success;
   \   0000001C   0x2000             MOVS     R0,#+0
   \                     ??USB_OsaMsgqDestroy_1: (+1)
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    450          }
    451          

   \                                 In section .text, align 2, keep-with-next
    452          usb_osa_status_t USB_OsaMsgqSend(usb_osa_msgq_handle handle, void *msg)
    453          {
   \                     USB_OsaMsgqSend: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    454              usb_osa_msgq_struct_t *msgq = (usb_osa_msgq_struct_t *)handle;
   \   00000008   0x0026             MOVS     R6,R4
    455              usb_osa_msg_struct_t *msgEntity;
    456              uint32_t *p;
    457              uint32_t *q;
    458              uint32_t count;
    459              USB_OSA_SR_ALLOC();
    460          
    461              if (!handle)
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD101             BNE.N    ??USB_OsaMsgqSend_0
    462              {
    463                  return kStatus_USB_OSA_Error;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE03E             B.N      ??USB_OsaMsgqSend_1
    464              }
    465              USB_OSA_ENTER_CRITICAL();
   \                     ??USB_OsaMsgqSend_0: (+1)
   \   00000012   0x.... 0x....      BL       USB_BmEnterCritical
    466              if (msgq->msgCount >= msgq->count)
   \   00000016   0xF8D6 0x0088      LDR      R0,[R6, #+136]
   \   0000001A   0xF8D6 0x1080      LDR      R1,[R6, #+128]
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD303             BCC.N    ??USB_OsaMsgqSend_2
    467              {
    468                  USB_OSA_EXIT_CRITICAL();
   \   00000022   0x.... 0x....      BL       USB_BmExitCritical
    469                  return kStatus_USB_OSA_Error;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE032             B.N      ??USB_OsaMsgqSend_1
    470              }
    471          
    472              msgEntity = &msgq->msgs[msgq->index];
   \                     ??USB_OsaMsgqSend_2: (+1)
   \   0000002A   0xF8D6 0x008C      LDR      R0,[R6, #+140]
   \   0000002E   0x0100             LSLS     R0,R0,#+4
   \   00000030   0x4430             ADD      R0,R6,R0
   \   00000032   0x0007             MOVS     R7,R0
    473              p = (uint32_t *)&msgEntity->msg[0];
   \   00000034   0x46B8             MOV      R8,R7
    474              q = (uint32_t *)msg;
   \   00000036   0x46A9             MOV      R9,R5
    475          
    476              for (count = 0U; count < msgq->msgSize; count++)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x4682             MOV      R10,R0
   \                     ??USB_OsaMsgqSend_3: (+1)
   \   0000003C   0xF8D6 0x0084      LDR      R0,[R6, #+132]
   \   00000040   0x4582             CMP      R10,R0
   \   00000042   0xD206             BCS.N    ??USB_OsaMsgqSend_4
    477              {
    478                  p[count] = q[count];
   \   00000044   0xF859 0x002A      LDR      R0,[R9, R10, LSL #+2]
   \   00000048   0xF848 0x002A      STR      R0,[R8, R10, LSL #+2]
    479              }
   \   0000004C   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   00000050   0xE7F4             B.N      ??USB_OsaMsgqSend_3
    480          
    481              if (0U == msgq->msgCount)
   \                     ??USB_OsaMsgqSend_4: (+1)
   \   00000052   0xF8D6 0x0088      LDR      R0,[R6, #+136]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD103             BNE.N    ??USB_OsaMsgqSend_5
    482              {
    483                  msgq->current = msgq->index;
   \   0000005A   0xF8D6 0x008C      LDR      R0,[R6, #+140]
   \   0000005E   0xF8C6 0x0090      STR      R0,[R6, #+144]
    484              }
    485          
    486              msgq->msgCount++;
   \                     ??USB_OsaMsgqSend_5: (+1)
   \   00000062   0xF8D6 0x0088      LDR      R0,[R6, #+136]
   \   00000066   0x1C40             ADDS     R0,R0,#+1
   \   00000068   0xF8C6 0x0088      STR      R0,[R6, #+136]
    487              msgq->index++;
   \   0000006C   0xF8D6 0x008C      LDR      R0,[R6, #+140]
   \   00000070   0x1C40             ADDS     R0,R0,#+1
   \   00000072   0xF8C6 0x008C      STR      R0,[R6, #+140]
    488              msgq->index = msgq->index % msgq->count;
   \   00000076   0xF8D6 0x008C      LDR      R0,[R6, #+140]
   \   0000007A   0xF8D6 0x1080      LDR      R1,[R6, #+128]
   \   0000007E   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   00000082   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   00000086   0xF8C6 0x008C      STR      R0,[R6, #+140]
    489          
    490              USB_OSA_EXIT_CRITICAL();
   \   0000008A   0x.... 0x....      BL       USB_BmExitCritical
    491          
    492              return kStatus_USB_OSA_Success;
   \   0000008E   0x2000             MOVS     R0,#+0
   \                     ??USB_OsaMsgqSend_1: (+1)
   \   00000090   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    493          }
    494          

   \                                 In section .text, align 2, keep-with-next
    495          usb_osa_status_t USB_OsaMsgqRecv(usb_osa_msgq_handle handle, void *msg, uint32_t timeout)
    496          {
   \                     USB_OsaMsgqRecv: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    497              usb_osa_msgq_struct_t *msgq = (usb_osa_msgq_struct_t *)handle;
   \   0000000A   0x0027             MOVS     R7,R4
    498              usb_osa_msg_struct_t *msgEntity;
    499              uint32_t *p;
    500              uint32_t *q;
    501              uint32_t count;
    502              USB_OSA_SR_ALLOC();
    503          
    504              if (!handle)
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD101             BNE.N    ??USB_OsaMsgqRecv_0
    505              {
    506                  return kStatus_USB_OSA_Error;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xE034             B.N      ??USB_OsaMsgqRecv_1
    507              }
    508              USB_OSA_ENTER_CRITICAL();
   \                     ??USB_OsaMsgqRecv_0: (+1)
   \   00000014   0x.... 0x....      BL       USB_BmEnterCritical
    509              if (msgq->msgCount < 1U)
   \   00000018   0xF8D7 0x0088      LDR      R0,[R7, #+136]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD103             BNE.N    ??USB_OsaMsgqRecv_2
    510              {
    511                  USB_OSA_EXIT_CRITICAL();
   \   00000020   0x.... 0x....      BL       USB_BmExitCritical
    512                  return kStatus_USB_OSA_TimeOut;
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xE02A             B.N      ??USB_OsaMsgqRecv_1
    513              }
    514          
    515              msgEntity = &msgq->msgs[msgq->current];
   \                     ??USB_OsaMsgqRecv_2: (+1)
   \   00000028   0xF8D7 0x0090      LDR      R0,[R7, #+144]
   \   0000002C   0x0100             LSLS     R0,R0,#+4
   \   0000002E   0x4438             ADD      R0,R7,R0
   \   00000030   0x4680             MOV      R8,R0
    516              q = (uint32_t *)&msgEntity->msg[0];
   \   00000032   0x46C2             MOV      R10,R8
    517              p = (uint32_t *)msg;
   \   00000034   0x46A9             MOV      R9,R5
    518          
    519              for (count = 0U; count < msgq->msgSize; count++)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x4683             MOV      R11,R0
   \                     ??USB_OsaMsgqRecv_3: (+1)
   \   0000003A   0xF8D7 0x0084      LDR      R0,[R7, #+132]
   \   0000003E   0x4583             CMP      R11,R0
   \   00000040   0xD206             BCS.N    ??USB_OsaMsgqRecv_4
    520              {
    521                  p[count] = q[count];
   \   00000042   0xF85A 0x002B      LDR      R0,[R10, R11, LSL #+2]
   \   00000046   0xF849 0x002B      STR      R0,[R9, R11, LSL #+2]
    522              }
   \   0000004A   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   0000004E   0xE7F4             B.N      ??USB_OsaMsgqRecv_3
    523          
    524              msgq->msgCount--;
   \                     ??USB_OsaMsgqRecv_4: (+1)
   \   00000050   0xF8D7 0x0088      LDR      R0,[R7, #+136]
   \   00000054   0x1E40             SUBS     R0,R0,#+1
   \   00000056   0xF8C7 0x0088      STR      R0,[R7, #+136]
    525              msgq->current++;
   \   0000005A   0xF8D7 0x0090      LDR      R0,[R7, #+144]
   \   0000005E   0x1C40             ADDS     R0,R0,#+1
   \   00000060   0xF8C7 0x0090      STR      R0,[R7, #+144]
    526              msgq->current = msgq->current % msgq->count;
   \   00000064   0xF8D7 0x0090      LDR      R0,[R7, #+144]
   \   00000068   0xF8D7 0x1080      LDR      R1,[R7, #+128]
   \   0000006C   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   00000070   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   00000074   0xF8C7 0x0090      STR      R0,[R7, #+144]
    527          
    528              USB_OSA_EXIT_CRITICAL();
   \   00000078   0x.... 0x....      BL       USB_BmExitCritical
    529          
    530              return kStatus_USB_OSA_Success;
   \   0000007C   0x2000             MOVS     R0,#+0
   \                     ??USB_OsaMsgqRecv_1: (+1)
   \   0000007E   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    531          }
    532          

   \                                 In section .text, align 2, keep-with-next
    533          usb_osa_status_t USB_OsaMsgqCheck(usb_osa_msgq_handle handle, void *msg)
    534          {
   \                     USB_OsaMsgqCheck: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    535              usb_osa_msgq_struct_t *msgq = (usb_osa_msgq_struct_t *)handle;
   \   00000006   0x0026             MOVS     R6,R4
    536              uint32_t msgCount;
    537              USB_OSA_SR_ALLOC();
    538          
    539              if (!handle)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??USB_OsaMsgqCheck_0
    540              {
    541                  return kStatus_USB_OSA_Error;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE012             B.N      ??USB_OsaMsgqCheck_1
    542              }
    543          
    544              USB_OSA_ENTER_CRITICAL();
   \                     ??USB_OsaMsgqCheck_0: (+1)
   \   00000010   0x.... 0x....      BL       USB_BmEnterCritical
    545              msgCount = msgq->msgCount;
   \   00000014   0xF8D6 0x0088      LDR      R0,[R6, #+136]
   \   00000018   0x0007             MOVS     R7,R0
    546              USB_OSA_EXIT_CRITICAL();
   \   0000001A   0x.... 0x....      BL       USB_BmExitCritical
    547          
    548              if (msgCount)
   \   0000001E   0x2F00             CMP      R7,#+0
   \   00000020   0xD008             BEQ.N    ??USB_OsaMsgqCheck_2
    549              {
    550                  if (kStatus_USB_OSA_Success == USB_OsaMsgqRecv(msgq, msg, 0U))
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x0029             MOVS     R1,R5
   \   00000026   0x0030             MOVS     R0,R6
   \   00000028   0x.... 0x....      BL       USB_OsaMsgqRecv
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD101             BNE.N    ??USB_OsaMsgqCheck_2
    551                  {
    552                      return kStatus_USB_OSA_Success;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE000             B.N      ??USB_OsaMsgqCheck_1
    553                  }
    554              }
    555          
    556              return kStatus_USB_OSA_Error;
   \                     ??USB_OsaMsgqCheck_2: (+1)
   \   00000034   0x2001             MOVS     R0,#+1
   \                     ??USB_OsaMsgqCheck_1: (+1)
   \   00000036   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    557          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     s_UsbBmCriticalLevel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     s_UsbBmEventStruct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     s_UsbBmSemStruct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0xFFFF0000         DC32     0xffff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     s_UsbBmMsgqStruct

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   USB_BmEnterCritical
       0   USB_BmExitCritical
      24   USB_OsaEventCheck
        24   -> USB_BmEnterCritical
        24   -> USB_BmExitCritical
      24   USB_OsaEventClear
        24   -> USB_BmEnterCritical
        24   -> USB_BmExitCritical
      16   USB_OsaEventCreate
        16   -> USB_BmEnterCritical
        16   -> USB_BmExitCritical
      16   USB_OsaEventDestroy
        16   -> USB_BmEnterCritical
        16   -> USB_BmExitCritical
      16   USB_OsaEventSet
        16   -> USB_BmEnterCritical
        16   -> USB_BmExitCritical
      32   USB_OsaEventWait
        32   -> USB_BmEnterCritical
        32   -> USB_BmExitCritical
       8   USB_OsaMemoryAllocate
         8   -> malloc
       8   USB_OsaMemoryFree
         8   -> free
      24   USB_OsaMsgqCheck
        24   -> USB_BmEnterCritical
        24   -> USB_BmExitCritical
        24   -> USB_OsaMsgqRecv
      24   USB_OsaMsgqCreate
        24   -> USB_BmEnterCritical
        24   -> USB_BmExitCritical
      16   USB_OsaMsgqDestroy
        16   -> USB_BmEnterCritical
        16   -> USB_BmExitCritical
      40   USB_OsaMsgqRecv
        40   -> USB_BmEnterCritical
        40   -> USB_BmExitCritical
      32   USB_OsaMsgqSend
        32   -> USB_BmEnterCritical
        32   -> USB_BmExitCritical
       0   USB_OsaMutexCreate
       0   USB_OsaMutexDestroy
       0   USB_OsaMutexLock
       0   USB_OsaMutexUnlock
      16   USB_OsaSemCreate
        16   -> USB_BmEnterCritical
        16   -> USB_BmExitCritical
      16   USB_OsaSemDestroy
        16   -> USB_BmEnterCritical
        16   -> USB_BmExitCritical
      16   USB_OsaSemPost
        16   -> USB_BmEnterCritical
        16   -> USB_BmExitCritical
      16   USB_OsaSemWait
        16   -> USB_BmEnterCritical
        16   -> USB_BmExitCritical


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
      22  USB_BmEnterCritical
      30  USB_BmExitCritical
      62  USB_OsaEventCheck
      40  USB_OsaEventClear
      90  USB_OsaEventCreate
      30  USB_OsaEventDestroy
      34  USB_OsaEventSet
     108  USB_OsaEventWait
      32  USB_OsaMemoryAllocate
      12  USB_OsaMemoryFree
      56  USB_OsaMsgqCheck
     124  USB_OsaMsgqCreate
      32  USB_OsaMsgqDestroy
     130  USB_OsaMsgqRecv
     148  USB_OsaMsgqSend
      18  USB_OsaMutexCreate
       6  USB_OsaMutexDestroy
       6  USB_OsaMutexLock
       6  USB_OsaMutexUnlock
      80  USB_OsaSemCreate
      30  USB_OsaSemDestroy
      32  USB_OsaSemPost
      48  USB_OsaSemWait
       1  s_UsbBmCriticalLevel
      24  s_UsbBmEventStruct
     152  s_UsbBmMsgqStruct
       8  s_UsbBmSemStruct

 
 1 196 bytes in section .text
   185 bytes in section m_usb_global
 
 1 196 bytes of CODE memory
   185 bytes of DATA memory

Errors: none
Warnings: none
