###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:23:55
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\bl_main.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\bl_main.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\bl_main.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\bl_main.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\bl_main.c
      1          /*
      2           * Copyright (c) 2013-2016, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include <stdbool.h>
     32          #include "utilities/fsl_assert.h"
     33          #include "bootloader/bl_context.h"
     34          #include "bootloader/bl_peripheral.h"
     35          #include "bootloader/bl_shutdown_cleanup.h"
     36          #include "bootloader_common.h"
     37          #include "microseconds/microseconds.h"
     38          #include "bootloader/bootloader.h"
     39          #include "flash/fsl_flash.h"
     40          #include "smc/smc.h"
     41          #include "microseconds/microseconds.h"
     42          #include "property/property.h"
     43          #include "utilities/vector_table_info.h"
     44          #include "utilities/fsl_rtos_abstraction.h"
     45          #if BL_FEATURE_CRC_CHECK
     46          #include "bootloader/bl_app_crc_check.h"
     47          #endif
     48          #if BL_FEATURE_QSPI_MODULE
     49          #include "qspi/qspi.h"
     50          #endif
     51          #include "memory/memory.h"
     52          
     53          #if BL_FEATURE_RELIABLE_UPDATE
     54          #include "bootloader/bl_reliable_update.h"
     55          #endif
     56          
     57          //! @addtogroup bl_core
     58          //! @{
     59          
     60          ////////////////////////////////////////////////////////////////////////////////
     61          // Prototypes
     62          ////////////////////////////////////////////////////////////////////////////////
     63          
     64          #if DEBUG && !DEBUG_PRINT_DISABLE
     65          static const char *get_peripheral_name(uint32_t peripheralTypeMask);
     66          #endif
     67          
     68          #if !BL_FEATURE_TIMEOUT
     69          static void get_user_application_entry(uint32_t *appEntry, uint32_t *appStack);
     70          static void jump_to_application(uint32_t applicationAddress, uint32_t stackPointer);
     71          static bool is_direct_boot(void);
     72          #endif // !BL_FEATURE_TIMEOUT
     73          static peripheral_descriptor_t const *get_active_peripheral(void);
     74          static void bootloader_init(void);
     75          static void bootloader_run(void);
     76          static void bootloader_flash_init(void);
     77          #if BL_FEATURE_QSPI_MODULE
     78          static void configure_quadspi_as_needed(void);
     79          #endif
     80          
     81          int main(void);
     82          
     83          // Not used, but needed to resolve reference in startup.s.
     84          // uint32_t g_bootloaderTree;
     85          
     86          ////////////////////////////////////////////////////////////////////////////////
     87          // Variables
     88          ////////////////////////////////////////////////////////////////////////////////
     89          
     90          #if DEBUG && !DEBUG_PRINT_DISABLE
     91          static const char *const kPeripheralNames[] = {
     92              "UART", // kPeripheralType_UART
     93              "I2C",  // kPeripheralType_I2CSlave
     94              "SPI",  // kPeripheralType_SPISlave
     95              "CAN",  // kPeripheralType_CAN
     96              "HID",  // kPeripheralType_USB_HID
     97              "CDC",  // kPeripheralType_USB_CDC
     98              "DFU",  // kPeripheralType_USB_DFU
     99              "MSD"   // kPeripheralType_USB_MSC
    100          };
    101          #endif // DEBUG
    102          
    103          ////////////////////////////////////////////////////////////////////////////////
    104          // Code
    105          ////////////////////////////////////////////////////////////////////////////////
    106          
    107          #if DEBUG && !DEBUG_PRINT_DISABLE
    108          //! @brief Returns the name of a peripheral given its type mask.
    109          const char *get_peripheral_name(uint32_t peripheralTypeMask)
    110          {
    111              uint32_t i;
    112              for (i = 0; i < ARRAY_SIZE(kPeripheralNames); ++i)
    113              {
    114                  if (peripheralTypeMask & (1 << i))
    115                  {
    116                      return kPeripheralNames[i];
    117                  }
    118              }
    119          
    120              return "Unknown peripheral";
    121          }
    122          #endif // DEBUG
    123          
    124          #if !BL_FEATURE_TIMEOUT
    125          //! @brief Returns the user application address and stack pointer.
    126          //!
    127          //! For flash-resident and rom-resident target, gets the user application address
    128          //! and stack pointer from the APP_VECTOR_TABLE.
    129          //! Ram-resident version does not support jumping to application address.

   \                                 In section .text, align 2, keep-with-next
    130          static void get_user_application_entry(uint32_t *appEntry, uint32_t *appStack)
    131          {
    132              assert(appEntry);
    133              assert(appStack);
    134          
    135          #if BL_TARGET_RAM
    136              *appEntry = 0;
    137              *appStack = 0;
    138          #else
    139          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    140              // Check if address of SP and PC is in an execute-only region.
    141              if (!is_in_execute_only_region(kDefaultVectorTableAddress, 8))
    142              {
    143                  *appEntry = APP_VECTOR_TABLE[kInitialPC];
    144                  *appStack = APP_VECTOR_TABLE[kInitialSP];
    145              }
    146              else
    147              {
    148                  // Set to invalid value when vector table is in execute-only region,
    149                  // as ROM doesn't support jumping to an application in such region so far.
    150                  // The main purpose of below operation is to prevent ROM from inifinit loop
    151                  // between NVIC_SystemReset() and fetching SP and PC frome execute-only region.
    152                  *appEntry = 0;
    153                  *appStack = 0;
    154              }
    155          #else
    156              *appEntry = APP_VECTOR_TABLE[kInitialPC];
   \                     get_user_application_entry: (+1)
   \   00000000   0xF24F 0x0204      MOVW     R2,#+61444
   \   00000004   0x6812             LDR      R2,[R2, #+0]
   \   00000006   0x6002             STR      R2,[R0, #+0]
    157              *appStack = APP_VECTOR_TABLE[kInitialSP];
   \   00000008   0xF44F 0x4270      MOV      R2,#+61440
   \   0000000C   0x6812             LDR      R2,[R2, #+0]
   \   0000000E   0x600A             STR      R2,[R1, #+0]
    158          #endif //  FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    159          #endif // BL_TARGET_RAM
    160          }
   \   00000010   0x4770             BX       LR               ;; return
    161          #endif // BL_FEATURE_TIMEOUT
    162          
    163          #if !BL_FEATURE_TIMEOUT

   \                                 In section .text, align 2, keep-with-next
    164          bool is_direct_boot(void)
    165          {
    166              bootloader_configuration_data_t *configurationData =
    167                  &g_bootloaderContext.propertyInterface->store->configurationData;
   \                     is_direct_boot: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable6
   \   00000002   0x6880             LDR      R0,[R0, #+8]
   \   00000004   0x6900             LDR      R0,[R0, #+16]
   \   00000006   0x306C             ADDS     R0,R0,#+108
    168          
    169              return (~configurationData->bootFlags) & kBootFlag_DirectBoot;
   \   00000008   0x7F80             LDRB     R0,[R0, #+30]
   \   0000000A   0x43C0             MVNS     R0,R0
   \   0000000C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000010   0x4770             BX       LR               ;; return
    170          }
    171          #endif // !BL_FEATURE_TIMEOUT
    172          
    173          #if !BL_FEATURE_TIMEOUT
    174          //! @brief Exits bootloader and jumps to the user application.

   \                                 In section .text, align 2, keep-with-next
    175          static void jump_to_application(uint32_t applicationAddress, uint32_t stackPointer)
    176          {
   \                     jump_to_application: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    177          #if BL_FEATURE_OTFAD_MODULE
    178              quadspi_cache_clear();
    179              oftfad_resume_as_needed();
    180          #endif
    181          
    182              shutdown_cleanup(kShutdownType_Shutdown);
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       shutdown_cleanup
    183          
    184              // Create the function call to the user application.
    185              // Static variables are needed since changed the stack pointer out from under the compiler
    186              // we need to ensure the values we are using are not stored on the previous stack
    187              static uint32_t s_stackPointer = 0;
    188              s_stackPointer = stackPointer;
   \   0000000C   0x....             LDR.N    R0,??DataTable6_1
   \   0000000E   0x6005             STR      R5,[R0, #+0]
    189              static void (*farewellBootloader)(void) = 0;
    190              farewellBootloader = (void (*)(void))applicationAddress;
   \   00000010   0x....             LDR.N    R0,??DataTable6_2
   \   00000012   0x6004             STR      R4,[R0, #+0]
    191          
    192              // Set the VTOR to the application vector table address.
    193              SCB->VTOR = (uint32_t)APP_VECTOR_TABLE;
   \   00000014   0xF44F 0x4070      MOV      R0,#+61440
   \   00000018   0x....             LDR.N    R1,??DataTable6_3  ;; 0xe000ed08
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    194          
    195              // Set stack pointers to the application stack pointer.
    196              __set_MSP(s_stackPointer);
   \   0000001C   0x....             LDR.N    R0,??DataTable6_1
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF380 0x8808      MSR      MSP,R0
    197              __set_PSP(s_stackPointer);
   \   00000024   0x....             LDR.N    R0,??DataTable6_1
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF380 0x8809      MSR      PSP,R0
    198          
    199              // Jump to the application.
    200              farewellBootloader();
   \   0000002C   0x....             LDR.N    R0,??DataTable6_2
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x4780             BLX      R0
    201              // Dummy fcuntion call, should never go to this fcuntion call
    202              shutdown_cleanup(kShutdownType_Shutdown);
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      BL       shutdown_cleanup
    203          }
   \   00000038   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .bss, align 4
   \                     `jump_to_application::s_stackPointer`:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     `jump_to_application::farewellBootloader`:
   \   00000000                      DS8 4
    204          #endif // !BL_FEATURE_TIMEOUT
    205          
    206          //! A given jump address is considered valid if:
    207          //! - Not 0x00000000
    208          //! - Not 0xffffffff
    209          //! - Not the reset handler entry point for the bootloader
    210          //! - Is in flash or is in RAM or QuadSPI (if available)
    211          //! @note this interface is also used by the configure_quadspi command

   \                                 In section .text, align 2, keep-with-next
    212          bool is_valid_application_location(uint32_t applicationAddress)
    213          {
   \                     is_valid_application_location: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    214              const memory_map_entry_t *map;
    215              // Verify that the jumpLocation is non zero and then either within flash or RAM, both calculations are:
    216              // (jumpLocation >= startAddress) && (jumpLocation < (startAddress + size))
    217              if ((!applicationAddress) ||              // address is not null AND
    218                  (applicationAddress == 0xffffffff) || // address is not blank Flash (0xff) AND
    219                  (applicationAddress == (uint32_t)&Reset_Handler))
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD005             BEQ.N    ??is_valid_application_location_0
   \   0000000A   0xF114 0x0F01      CMN      R4,#+1
   \   0000000E   0xD002             BEQ.N    ??is_valid_application_location_0
   \   00000010   0x....             LDR.N    R0,??DataTable6_4
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD101             BNE.N    ??is_valid_application_location_1
    220              {
    221                  return false;
   \                     ??is_valid_application_location_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE011             B.N      ??is_valid_application_location_2
    222              }
    223          
    224              bool isValid = false;
   \                     ??is_valid_application_location_1: (+1)
   \   0000001A   0x2500             MOVS     R5,#+0
    225              const uint32_t minThumb2InstructionSize = 2; // smallest thumb2 instruction size is 16-bit.
   \   0000001C   0x2602             MOVS     R6,#+2
    226              // Check if the application address is in valid executable memory range
    227              status_t status = find_map_entry(applicationAddress, minThumb2InstructionSize, &map);
   \   0000001E   0x466A             MOV      R2,SP
   \   00000020   0x0031             MOVS     R1,R6
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       find_map_entry
   \   00000028   0x0001             MOVS     R1,R0
    228              if ((status == kStatus_Success) && (map->isExecutable))
   \   0000002A   0x2900             CMP      R1,#+0
   \   0000002C   0xD105             BNE.N    ??is_valid_application_location_3
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
   \   00000030   0x7A00             LDRB     R0,[R0, #+8]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD001             BEQ.N    ??is_valid_application_location_3
    229              {
    230                  isValid = true;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x0005             MOVS     R5,R0
    231              }
    232          
    233              return isValid;
   \                     ??is_valid_application_location_3: (+1)
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??is_valid_application_location_2: (+1)
   \   0000003E   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    234          }
    235          
    236          #if !BL_FEATURE_TIMEOUT
    237          //! @brief Jump application is considered ready for executing if the location is valid and crc check is passed

   \                                 In section .text, align 2, keep-with-next
    238          static bool is_application_ready_for_executing(uint32_t applicationAddress)
    239          {
   \                     is_application_ready_for_executing: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    240              bool result = is_valid_application_location(applicationAddress);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       is_valid_application_location
   \   0000000A   0x0005             MOVS     R5,R0
    241          
    242          #if BL_FEATURE_OTFAD_MODULE
    243              if (result && is_qspi_present())
    244              {
    245                  quadspi_cache_clear();
    246                  status_t status = otfad_init_as_needed();
    247                  if (status != kStatus_Success)
    248                  {
    249                      result = false;
    250                  }
    251                  update_qspi_otfad_init_status(status);
    252              }
    253          #endif
    254          
    255          #if BL_FEATURE_CRC_CHECK
    256              // Validate application crc only if its location is valid
    257              if (result)
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD002             BEQ.N    ??is_application_ready_for_executing_0
    258              {
    259                  result = is_application_crc_check_pass();
   \   00000012   0x.... 0x....      BL       is_application_crc_check_pass
   \   00000016   0x0005             MOVS     R5,R0
    260              }
    261          
    262          #if BL_FEATURE_OTFAD_MODULE
    263              otfad_bypass_as_needed();
    264          #endif // BL_FEATURE_OTFAD_MODULE
    265          
    266          #endif
    267          
    268              return result;
   \                     ??is_application_ready_for_executing_0: (+1)
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    269          }
    270          #endif // !BL_FEATURE_TIMEOUT
    271          
    272          //! @brief Determines the active peripheral.
    273          //!
    274          //! This function has several stages:
    275          //! - Init enabled peripherals.
    276          //! - Compute timeout.
    277          //! - Wait for peripheral activity with timeout.
    278          //! - Shutdown inactive peripherals.
    279          //!
    280          //! If peripheral detection times out, then this function will call jump_to_application() to
    281          //! directly enter the user application.
    282          //!
    283          //! The timeout value comes from the BCA if set, or the #BL_DEFAULT_PERIPHERAL_DETECT_TIMEOUT
    284          //! configuration macro. If the boot pin is asserted, or if there is not a valid user application
    285          //! in flash, then the timeout is disabled and peripheral detection will continue infinitely.

   \                                 In section .text, align 2, keep-with-next
    286          static peripheral_descriptor_t const *get_active_peripheral(void)
    287          {
   \                     get_active_peripheral: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
    288              peripheral_descriptor_t const *peripheral;
    289              peripheral_descriptor_t const *activePeripheral = NULL;
   \   00000006   0xF05F 0x0800      MOVS     R8,#+0
    290              bootloader_configuration_data_t *configurationData =
    291                  &g_bootloaderContext.propertyInterface->store->configurationData;
   \   0000000A   0x....             LDR.N    R0,??DataTable6
   \   0000000C   0x6880             LDR      R0,[R0, #+8]
   \   0000000E   0x6900             LDR      R0,[R0, #+16]
   \   00000010   0x306C             ADDS     R0,R0,#+108
   \   00000012   0x9000             STR      R0,[SP, #+0]
    292          
    293              // Bring up all the peripherals
    294              for (peripheral = g_peripherals; peripheral->typeMask != 0; ++peripheral)
   \   00000014   0x....             LDR.N    R0,??DataTable6_5
   \   00000016   0x4681             MOV      R9,R0
   \                     ??get_active_peripheral_0: (+1)
   \   00000018   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD010             BEQ.N    ??get_active_peripheral_1
    295              {
    296                  // Check that the peripheral is enabled in the user configuration data
    297                  if (configurationData->enabledPeripherals & peripheral->typeMask)
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x7C00             LDRB     R0,[R0, #+16]
   \   00000024   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \   00000028   0x4208             TST      R0,R1
   \   0000002A   0xD007             BEQ.N    ??get_active_peripheral_2
    298                  {
    299                      assert(peripheral->controlInterface->init);
    300          
    301                      debug_printf("Initing %s\r\n", get_peripheral_name(peripheral->typeMask));
    302                      peripheral->controlInterface->init(peripheral, peripheral->packetInterface->byteReceivedCallback);
   \   0000002C   0xF8D9 0x0014      LDR      R0,[R9, #+20]
   \   00000030   0x6981             LDR      R1,[R0, #+24]
   \   00000032   0x4648             MOV      R0,R9
   \   00000034   0xF8D9 0x200C      LDR      R2,[R9, #+12]
   \   00000038   0x6852             LDR      R2,[R2, #+4]
   \   0000003A   0x4790             BLX      R2
    303                  }
    304              }
   \                     ??get_active_peripheral_2: (+1)
   \   0000003C   0xF119 0x0918      ADDS     R9,R9,#+24
   \   00000040   0xE7EA             B.N      ??get_active_peripheral_0
    305          
    306          #if !BL_FEATURE_TIMEOUT
    307              uint64_t lastTicks = 0;    // Value of our last recorded ticks second marker
   \                     ??get_active_peripheral_1: (+1)
   \   00000042   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000046   0xF05F 0x0B00      MOVS     R11,#+0
    308              uint64_t timeoutTicks = 0; // The number of ticks we will wait for timeout, 0 means no timeout
   \   0000004A   0x2400             MOVS     R4,#+0
   \   0000004C   0x2500             MOVS     R5,#+0
    309          #if BL_FEATURE_POWERDOWN
    310              bool shortTimeout = false;
    311          #endif
    312              const uint64_t ticksPerMillisecond = microseconds_convert_to_ticks(1000);
   \   0000004E   0xF44F 0x707A      MOV      R0,#+1000
   \   00000052   0x.... 0x....      BL       microseconds_convert_to_ticks
   \   00000056   0xE9CD 0x0104      STRD     R0,R1,[SP, #+16]
    313          
    314              // Get the user application entry point and stack pointer.
    315              uint32_t applicationAddress, stackPointer;
    316              get_user_application_entry(&applicationAddress, &stackPointer);
   \   0000005A   0xA903             ADD      R1,SP,#+12
   \   0000005C   0xA801             ADD      R0,SP,#+4
   \   0000005E   0x.... 0x....      BL       get_user_application_entry
    317          
    318              // If the boot to rom option is not set AND there is a valid jump application determine the timeout value
    319              if (!is_boot_pin_asserted() && is_application_ready_for_executing(applicationAddress))
   \   00000062   0x.... 0x....      BL       is_boot_pin_asserted
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD129             BNE.N    ??get_active_peripheral_3
   \   0000006A   0x9801             LDR      R0,[SP, #+4]
   \   0000006C   0x.... 0x....      BL       is_application_ready_for_executing
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD024             BEQ.N    ??get_active_peripheral_3
    320              {
    321                  if (is_direct_boot())
   \   00000074   0x.... 0x....      BL       is_direct_boot
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD003             BEQ.N    ??get_active_peripheral_4
    322                  {
    323                      jump_to_application(applicationAddress, stackPointer);
   \   0000007C   0x9903             LDR      R1,[SP, #+12]
   \   0000007E   0x9801             LDR      R0,[SP, #+4]
   \   00000080   0x.... 0x....      BL       jump_to_application
    324                  }
    325          
    326                  // Calculate how many ticks we need to wait based on the bootloader config. Check to see if
    327                  // there is a valid configuration data value for the timeout. If there's not, use the
    328                  // default timeout value.
    329                  uint32_t milliseconds;
    330                  if (configurationData->peripheralDetectionTimeoutMs != 0xFFFF)
   \                     ??get_active_peripheral_4: (+1)
   \   00000084   0x9800             LDR      R0,[SP, #+0]
   \   00000086   0x8A40             LDRH     R0,[R0, #+18]
   \   00000088   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000008C   0x4288             CMP      R0,R1
   \   0000008E   0xD003             BEQ.N    ??get_active_peripheral_5
    331                  {
    332                      milliseconds = configurationData->peripheralDetectionTimeoutMs;
   \   00000090   0x9800             LDR      R0,[SP, #+0]
   \   00000092   0x8A40             LDRH     R0,[R0, #+18]
   \   00000094   0x9002             STR      R0,[SP, #+8]
   \   00000096   0xE002             B.N      ??get_active_peripheral_6
    333                  }
    334                  else
    335                  {
    336                      milliseconds = BL_DEFAULT_PERIPHERAL_DETECT_TIMEOUT;
   \                     ??get_active_peripheral_5: (+1)
   \   00000098   0xF241 0x3088      MOVW     R0,#+5000
   \   0000009C   0x9002             STR      R0,[SP, #+8]
    337                  }
    338                  timeoutTicks = milliseconds * ticksPerMillisecond;
   \                     ??get_active_peripheral_6: (+1)
   \   0000009E   0x9A02             LDR      R2,[SP, #+8]
   \   000000A0   0x2300             MOVS     R3,#+0
   \   000000A2   0xE9DD 0x0104      LDRD     R0,R1,[SP, #+16]
   \   000000A6   0xFBA0 0x6702      UMULL    R6,R7,R0,R2
   \   000000AA   0xFB00 0x7703      MLA      R7,R0,R3,R7
   \   000000AE   0xFB01 0x7702      MLA      R7,R1,R2,R7
   \   000000B2   0x0034             MOVS     R4,R6
   \   000000B4   0x003D             MOVS     R5,R7
    339          
    340                  // save how many ticks we're currently at before the detection loop starts
    341                  lastTicks = microseconds_get_ticks();
   \   000000B6   0x.... 0x....      BL       microseconds_get_ticks
   \   000000BA   0x4682             MOV      R10,R0
   \   000000BC   0x468B             MOV      R11,R1
    342          #if BL_FEATURE_POWERDOWN
    343                  shortTimeout = true;
    344          #endif
    345              }
    346          #if BL_FEATURE_POWERDOWN
    347              else
    348              {
    349                  timeoutTicks = BL_DEFAULT_POWERDOWN_TIMEOUT * ticksPerMillisecond;
    350                  lastTicks = microseconds_get_ticks();
    351              }
    352          #endif
    353          #endif // !BL_FEATURE_TIMEOUT
    354          
    355              // Wait for a peripheral to become active
    356              while (activePeripheral == NULL)
   \                     ??get_active_peripheral_3: (+1)
   \   000000BE   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000C2   0xD12C             BNE.N    ??get_active_peripheral_7
    357              {
    358          #if !BL_FEATURE_TIMEOUT
    359                  // If timeout is enabled, check to see if we've exceeded it.
    360                  if (timeoutTicks)
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x2100             MOVS     R1,#+0
   \   000000C8   0x428D             CMP      R5,R1
   \   000000CA   0xD101             BNE.N    ??get_active_peripheral_8
   \   000000CC   0x4284             CMP      R4,R0
   \   000000CE   0xD00E             BEQ.N    ??get_active_peripheral_9
    361                  {
    362                      // Note that we assume that the tick counter won't overflow and wrap back to 0.
    363                      // The timeout value is only up to 65536 milliseconds, and the tick count starts
    364                      // at zero when when inited the microseconds driver just a few moments ago.
    365                      uint64_t elapsedTicks = microseconds_get_ticks() - lastTicks;
   \                     ??get_active_peripheral_8: (+1)
   \   000000D0   0x.... 0x....      BL       microseconds_get_ticks
   \   000000D4   0xEBB0 0x060A      SUBS     R6,R0,R10
   \   000000D8   0xEB71 0x070B      SBCS     R7,R1,R11
    366          
    367                      // Check if the elapsed time is longer than the timeout.
    368                      if (elapsedTicks >= timeoutTicks)
   \   000000DC   0x42AF             CMP      R7,R5
   \   000000DE   0xD306             BCC.N    ??get_active_peripheral_9
   \   000000E0   0xD801             BHI.N    ??get_active_peripheral_10
   \   000000E2   0x42A6             CMP      R6,R4
   \   000000E4   0xD303             BCC.N    ??get_active_peripheral_9
    369                      {
    370          #if BL_FEATURE_POWERDOWN
    371                          if (shortTimeout)
    372                          {
    373          #endif
    374                              // In the case of the typical peripheral timeout, jump to the user application.
    375                              jump_to_application(applicationAddress, stackPointer);
   \                     ??get_active_peripheral_10: (+1)
   \   000000E6   0x9903             LDR      R1,[SP, #+12]
   \   000000E8   0x9801             LDR      R0,[SP, #+4]
   \   000000EA   0x.... 0x....      BL       jump_to_application
    376          #if BL_FEATURE_POWERDOWN
    377                          }
    378                          else
    379                          {
    380                              // Make sure a timeout value has been defined before shutting down.
    381                              if (BL_DEFAULT_POWERDOWN_TIMEOUT)
    382                              {
    383                                  // Shut down the bootloader and return to reset-type state prior to low
    384                                  // power entry
    385                                  shutdown_cleanup(kShutdownType_Shutdown);
    386          
    387                                  // Enter VLLS1 low power mode
    388                                  enter_vlls1();
    389                              }
    390                          }
    391          #endif
    392                      }
    393                  }
    394          #endif // !BL_FEATURE_TIMEOUT
    395                  // Traverse through all the peripherals
    396                  for (peripheral = g_peripherals; peripheral->typeMask != 0; ++peripheral)
   \                     ??get_active_peripheral_9: (+1)
   \   000000EE   0x....             LDR.N    R0,??DataTable6_5
   \   000000F0   0x4681             MOV      R9,R0
   \                     ??get_active_peripheral_11: (+1)
   \   000000F2   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000F6   0x2800             CMP      R0,#+0
   \   000000F8   0xD0E1             BEQ.N    ??get_active_peripheral_3
    397                  {
    398                      // Check that the peripheral is enabled in the user configuration data
    399                      if (configurationData->enabledPeripherals & peripheral->typeMask)
   \   000000FA   0x9800             LDR      R0,[SP, #+0]
   \   000000FC   0x7C00             LDRB     R0,[R0, #+16]
   \   000000FE   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \   00000102   0x4208             TST      R0,R1
   \   00000104   0xD008             BEQ.N    ??get_active_peripheral_12
    400                      {
    401                          assert(peripheral->controlInterface->pollForActivity);
    402          
    403                          if (peripheral->controlInterface->pollForActivity(peripheral))
   \   00000106   0x4648             MOV      R0,R9
   \   00000108   0xF8D9 0x100C      LDR      R1,[R9, #+12]
   \   0000010C   0x6809             LDR      R1,[R1, #+0]
   \   0000010E   0x4788             BLX      R1
   \   00000110   0x2800             CMP      R0,#+0
   \   00000112   0xD001             BEQ.N    ??get_active_peripheral_12
    404                          {
    405                              debug_printf("%s is active\r\n", get_peripheral_name(peripheral->typeMask));
    406          
    407                              activePeripheral = peripheral;
   \   00000114   0x46C8             MOV      R8,R9
    408                              break;
   \   00000116   0xE7D2             B.N      ??get_active_peripheral_3
    409                          }
    410                      }
    411                  }
   \                     ??get_active_peripheral_12: (+1)
   \   00000118   0xF119 0x0918      ADDS     R9,R9,#+24
   \   0000011C   0xE7E9             B.N      ??get_active_peripheral_11
    412              }
    413          
    414              // Shut down all non active peripherals
    415              for (peripheral = g_peripherals; peripheral->typeMask != 0; ++peripheral)
   \                     ??get_active_peripheral_7: (+1)
   \   0000011E   0x....             LDR.N    R0,??DataTable6_5
   \   00000120   0x4681             MOV      R9,R0
   \                     ??get_active_peripheral_13: (+1)
   \   00000122   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000126   0x2800             CMP      R0,#+0
   \   00000128   0xD00F             BEQ.N    ??get_active_peripheral_14
    416              {
    417                  // Check that the peripheral is enabled in the user configuration data
    418                  if (configurationData->enabledPeripherals & peripheral->typeMask)
   \   0000012A   0x9800             LDR      R0,[SP, #+0]
   \   0000012C   0x7C00             LDRB     R0,[R0, #+16]
   \   0000012E   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \   00000132   0x4208             TST      R0,R1
   \   00000134   0xD006             BEQ.N    ??get_active_peripheral_15
    419                  {
    420                      if (activePeripheral != peripheral)
   \   00000136   0x45C8             CMP      R8,R9
   \   00000138   0xD004             BEQ.N    ??get_active_peripheral_15
    421                      {
    422                          debug_printf("Shutting down %s\r\n", get_peripheral_name(peripheral->typeMask));
    423          
    424                          assert(peripheral->controlInterface->shutdown);
    425                          peripheral->controlInterface->shutdown(peripheral);
   \   0000013A   0x4648             MOV      R0,R9
   \   0000013C   0xF8D9 0x100C      LDR      R1,[R9, #+12]
   \   00000140   0x6889             LDR      R1,[R1, #+8]
   \   00000142   0x4788             BLX      R1
    426                      }
    427                  }
    428              }
   \                     ??get_active_peripheral_15: (+1)
   \   00000144   0xF119 0x0918      ADDS     R9,R9,#+24
   \   00000148   0xE7EB             B.N      ??get_active_peripheral_13
    429          
    430              return activePeripheral;
   \                     ??get_active_peripheral_14: (+1)
   \   0000014A   0x4640             MOV      R0,R8
   \   0000014C   0xB007             ADD      SP,SP,#+28
   \   0000014E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    431          }
    432          
    433          #if BL_FEATURE_QSPI_MODULE
    434          static void configure_quadspi_as_needed(void)
    435          {
    436              // Start the lifetime counter
    437              microseconds_init();
    438              if (qspi_need_configure())
    439              {
    440                  status_t qspiOtfadInitStatus = kStatus_QspiNotConfigured;
    441                  // Try to configure QuadSPI module based on on qspi_config_block_pointer in BCA first,
    442                  // If bootloader cannot get qspi config block from internal flash, try to configure QSPI
    443                  // based on default place (start address of QuadSPI memory).
    444                  uint32_t qspi_config_block_base =
    445                      g_bootloaderContext.propertyInterface->store->configurationData.qspi_config_block_pointer;
    446          
    447                  // Get the start address and flash size
    448                  uint32_t flashStart;
    449                  g_bootloaderContext.flashDriverInterface->flash_get_property(&g_bootloaderContext.flashState,
    450                                                                               kFLASH_PropertyPflashBlockBaseAddr, &flashStart);
    451                  uint32_t flashSize;
    452                  g_bootloaderContext.flashDriverInterface->flash_get_property(&g_bootloaderContext.flashState,
    453                                                                               kFLASH_PropertyPflashTotalSize, &flashSize);
    454          
    455                  // Check if the pointer of qspi config block is valid.
    456                  if ((qspi_config_block_base != 0xFFFFFFFF) && (qspi_config_block_base > flashStart) &&
    457                      (qspi_config_block_base <= (flashStart + flashSize - sizeof(qspi_config_t))))
    458                  {
    459          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    460                      if (!is_in_execute_only_region(qspi_config_block_base, sizeof(qspi_config_t)))
    461                      {
    462                          qspiOtfadInitStatus = quadspi_init((void *)qspi_config_block_base);
    463                      }
    464          #else
    465                      qspiOtfadInitStatus = quadspi_init((void *)qspi_config_block_base);
    466          #endif // FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    467                  }
    468          
    469                  if (qspiOtfadInitStatus == kStatus_QspiNotConfigured)
    470                  {
    471                      qspiOtfadInitStatus = quadspi_init(NULL);
    472                  }
    473                  update_qspi_otfad_init_status(qspiOtfadInitStatus);
    474              }
    475              // Shutdown the lifetime counter before configuring clock.
    476              lock_acquire();
    477              microseconds_shutdown();
    478              lock_release();
    479          }
    480          #endif
    481          

   \                                 In section .text, align 2, keep-with-next
    482          static void bootloader_flash_init(void)
    483          {
   \                     bootloader_flash_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    484              g_bootloaderContext.flashDriverInterface->flash_init(&g_bootloaderContext.flashState);
   \   00000002   0x....             LDR.N    R0,??DataTable6_6
   \   00000004   0x....             LDR.N    R1,??DataTable6
   \   00000006   0x6909             LDR      R1,[R1, #+16]
   \   00000008   0x6849             LDR      R1,[R1, #+4]
   \   0000000A   0x4788             BLX      R1
    485          
    486          #if BL_TARGET_FLASH
    487              //! @brief A static buffer used to hold flash_run_command()
    488              static uint32_t s_flashRunCommand[kFLASH_ExecuteInRamFunctionMaxSizeInWords];
    489              //! @brief A static buffer used to hold flash_cache_clear_command()
    490              static uint32_t s_flashCacheClearCommand[kFLASH_ExecuteInRamFunctionMaxSizeInWords];
    491          
    492              static flash_execute_in_ram_function_config_t s_flashExecuteInRamFunctionInfo = {
    493                  .activeFunctionCount = 0,
    494                  .flashRunCommand = s_flashRunCommand,
    495                  .flashCacheClearCommand = s_flashCacheClearCommand,
    496              };
    497          
    498              g_bootloaderContext.flashState.flashExecuteInRamFunctionInfo = &s_flashExecuteInRamFunctionInfo.activeFunctionCount;
   \   0000000C   0x....             LDR.N    R0,??DataTable6_7
   \   0000000E   0x....             LDR.N    R1,??DataTable6
   \   00000010   0x63C8             STR      R0,[R1, #+60]
    499              g_bootloaderContext.flashDriverInterface->flash_prepare_execute_in_ram_functions(&g_bootloaderContext.flashState);
   \   00000012   0x....             LDR.N    R0,??DataTable6_6
   \   00000014   0x....             LDR.N    R1,??DataTable6
   \   00000016   0x6909             LDR      R1,[R1, #+16]
   \   00000018   0x6C09             LDR      R1,[R1, #+64]
   \   0000001A   0x4788             BLX      R1
    500          #endif
    501          }
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .bss, align 4
   \                     `bootloader_flash_init::s_flashRunCommand`:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
   \                     `bootloader_flash_init::s_flashCacheClearCommand`:
   \   00000000                      DS8 64

   \                                 In section .data, align 4
   \                     `bootloader_flash_init::s_flashExecuteInRamFunctionInfo`:
   \   00000000   0x00000000         DC32 0, `bootloader_flash_init::s_flashRunCommand`
   \              0x........   
   \   00000008   0x........         DC32 `bootloader_flash_init::s_flashCacheClearCommand`
    502          
    503          //! @brief Initialize the bootloader and peripherals.
    504          //!
    505          //! This function initializes hardware and clocks, loads user configuration data, and initialzes
    506          //! a number of drivers. It then enters the active peripheral detection phase by calling
    507          //! get_active_peripheral(). Once the peripheral is detected, the packet and comand interfaces
    508          //! are initialized.
    509          //!
    510          //! Note that this routine may not return if peripheral detection times out and the bootloader
    511          //! jumps directly to the user application in flash.

   \                                 In section .text, align 2, keep-with-next
    512          static void bootloader_init(void)
    513          {
   \                     bootloader_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    514              // Init the global irq lock
    515              lock_init();
   \   00000002   0x.... 0x....      BL       lock_init
    516          
    517              // Init pinmux and other hardware setup.
    518              init_hardware();
   \   00000006   0x.... 0x....      BL       init_hardware
    519          
    520              // Init flash driver.
    521              bootloader_flash_init();
   \   0000000A   0x.... 0x....      BL       bootloader_flash_init
    522          
    523              // Load the user configuration data so that we can configure the clocks
    524              g_bootloaderContext.propertyInterface->load_user_config();
   \   0000000E   0x....             LDR.N    R0,??DataTable6
   \   00000010   0x6880             LDR      R0,[R0, #+8]
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x4780             BLX      R0
    525          
    526          // Init QSPI module if needed
    527          #if BL_FEATURE_QSPI_MODULE
    528              configure_quadspi_as_needed();
    529          #endif // BL_FEATURE_QSPI_MODULE
    530          
    531              // Configure clocks.
    532              configure_clocks(kClockOption_EnterBootloader);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      BL       configure_clocks
    533          
    534              // Start the lifetime counter
    535              microseconds_init();
   \   0000001C   0x.... 0x....      BL       microseconds_init
    536          
    537          #if BL_FEATURE_BYPASS_WATCHDOG
    538              g_bootloaderContext.flashDriverInterface->flash_register_callback(&g_bootloaderContext.flashState,
    539                                                                                bootloader_watchdog_service);
    540              bootloader_watchdog_init();
    541          #endif // BL_FEATURE_BYPASS_WATCHDOG
    542          
    543              // Init address range of flash array, SRAM_L and SRAM U.
    544              g_bootloaderContext.memoryInterface->init();
   \   00000020   0x....             LDR.N    R0,??DataTable6
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x4780             BLX      R0
    545          
    546              // Fully init the property store.
    547              g_bootloaderContext.propertyInterface->init();
   \   00000028   0x....             LDR.N    R0,??DataTable6
   \   0000002A   0x6880             LDR      R0,[R0, #+8]
   \   0000002C   0x6840             LDR      R0,[R0, #+4]
   \   0000002E   0x4780             BLX      R0
    548          
    549          #if BL_FEATURE_RELIABLE_UPDATE
    550              bootloader_reliable_update_as_requested(kReliableUpdateOption_Normal, 0);
    551          #endif // BL_FEATURE_RELIABLE_UPDATE
    552          
    553              // Message so python instantiated debugger can tell the
    554              // bootloader application is running on the target.
    555              debug_printf("\r\n\r\nRunning bootloader...\r\n");
    556          
    557          #if DEBUG && !DEBUG_PRINT_DISABLE
    558              standard_version_t version = g_bootloaderContext.propertyInterface->store->bootloaderVersion;
    559              debug_printf("Bootloader version %c%d.%d.%d\r\n", version.name, version.major, version.minor, version.bugfix);
    560          #endif
    561          
    562              // Wait for a peripheral to become active.
    563              g_bootloaderContext.activePeripheral = get_active_peripheral();
   \   00000030   0x.... 0x....      BL       get_active_peripheral
   \   00000034   0x....             LDR.N    R1,??DataTable6
   \   00000036   0x61C8             STR      R0,[R1, #+28]
    564              assert(g_bootloaderContext.activePeripheral);
    565          
    566              // Validate required active peripheral interfaces.
    567              assert(g_bootloaderContext.activePeripheral->controlInterface);
    568          
    569              // Init the active peripheral.
    570              if (g_bootloaderContext.activePeripheral->byteInterface &&
    571                  g_bootloaderContext.activePeripheral->byteInterface->init)
   \   00000038   0x....             LDR.N    R0,??DataTable6
   \   0000003A   0x69C0             LDR      R0,[R0, #+28]
   \   0000003C   0x6900             LDR      R0,[R0, #+16]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD00C             BEQ.N    ??bootloader_init_0
   \   00000042   0x....             LDR.N    R0,??DataTable6
   \   00000044   0x69C0             LDR      R0,[R0, #+28]
   \   00000046   0x6900             LDR      R0,[R0, #+16]
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD006             BEQ.N    ??bootloader_init_0
    572              {
    573                  g_bootloaderContext.activePeripheral->byteInterface->init(g_bootloaderContext.activePeripheral);
   \   0000004E   0x....             LDR.N    R0,??DataTable6
   \   00000050   0x69C0             LDR      R0,[R0, #+28]
   \   00000052   0x....             LDR.N    R1,??DataTable6
   \   00000054   0x69C9             LDR      R1,[R1, #+28]
   \   00000056   0x6909             LDR      R1,[R1, #+16]
   \   00000058   0x6809             LDR      R1,[R1, #+0]
   \   0000005A   0x4788             BLX      R1
    574              }
    575              if (g_bootloaderContext.activePeripheral->packetInterface &&
    576                  g_bootloaderContext.activePeripheral->packetInterface->init)
   \                     ??bootloader_init_0: (+1)
   \   0000005C   0x....             LDR.N    R0,??DataTable6
   \   0000005E   0x69C0             LDR      R0,[R0, #+28]
   \   00000060   0x6940             LDR      R0,[R0, #+20]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD00C             BEQ.N    ??bootloader_init_1
   \   00000066   0x....             LDR.N    R0,??DataTable6
   \   00000068   0x69C0             LDR      R0,[R0, #+28]
   \   0000006A   0x6940             LDR      R0,[R0, #+20]
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD006             BEQ.N    ??bootloader_init_1
    577              {
    578                  g_bootloaderContext.activePeripheral->packetInterface->init(g_bootloaderContext.activePeripheral);
   \   00000072   0x....             LDR.N    R0,??DataTable6
   \   00000074   0x69C0             LDR      R0,[R0, #+28]
   \   00000076   0x....             LDR.N    R1,??DataTable6
   \   00000078   0x69C9             LDR      R1,[R1, #+28]
   \   0000007A   0x6949             LDR      R1,[R1, #+20]
   \   0000007C   0x6809             LDR      R1,[R1, #+0]
   \   0000007E   0x4788             BLX      R1
    579              }
    580          
    581              // Initialize the command processor component.
    582              g_bootloaderContext.commandInterface->init();
   \                     ??bootloader_init_1: (+1)
   \   00000080   0x....             LDR.N    R0,??DataTable6
   \   00000082   0x68C0             LDR      R0,[R0, #+12]
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x4780             BLX      R0
    583          }
   \   00000088   0xBD01             POP      {R0,PC}          ;; return
    584          
    585          //! @brief Bootloader outer loop.
    586          //!
    587          //! Infinitely calls the command interface and active peripheral control interface pump routines.

   \                                 In section .text, align 2, keep-with-next
    588          static void bootloader_run(void)
    589          {
   \                     bootloader_run: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    590              const peripheral_descriptor_t *activePeripheral = g_bootloaderContext.activePeripheral;
   \   00000002   0x....             LDR.N    R0,??DataTable6
   \   00000004   0x69C4             LDR      R4,[R0, #+28]
    591          
    592              assert(g_bootloaderContext.commandInterface->pump);
    593          
    594              // Read and execute commands.
    595              while (1)
    596              {
    597                  g_bootloaderContext.commandInterface->pump();
   \                     ??bootloader_run_0: (+1)
   \   00000006   0x....             LDR.N    R0,??DataTable6
   \   00000008   0x68C0             LDR      R0,[R0, #+12]
   \   0000000A   0x6840             LDR      R0,[R0, #+4]
   \   0000000C   0x4780             BLX      R0
    598          
    599                  // Pump the active peripheral.
    600                  if (activePeripheral->controlInterface->pump)
   \   0000000E   0x68E0             LDR      R0,[R4, #+12]
   \   00000010   0x68C0             LDR      R0,[R0, #+12]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD0F7             BEQ.N    ??bootloader_run_0
    601                  {
    602                      activePeripheral->controlInterface->pump(activePeripheral);
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x68E1             LDR      R1,[R4, #+12]
   \   0000001A   0x68C9             LDR      R1,[R1, #+12]
   \   0000001C   0x4788             BLX      R1
   \   0000001E   0xE7F2             B.N      ??bootloader_run_0
    603                  }
    604              }
    605          }
    606          
    607          //! @brief Entry point for the bootloader.

   \                                 In section .text, align 2, keep-with-next
    608          int main(void)
    609          {
   \                     main: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    610              bootloader_init();
   \   00000002   0x.... 0x....      BL       bootloader_init
    611              bootloader_run();
   \   00000006   0x.... 0x....      BL       bootloader_run
    612          
    613              // Should never end up here.
    614              debug_printf("Warning: reached end of main()\r\n");
    615              return 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    616          }
    617          
    618          //! Since we never exit this gets rid of the C standard functions that cause
    619          //! extra ROM size usage.

   \                                 In section .text, align 2, keep-with-next
    620          void exit(int arg)
    621          {
    622          }
   \                     exit: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     g_bootloaderContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     `jump_to_application::s_stackPointer`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     `jump_to_application::farewellBootloader`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0xE000ED08         DC32     0xe000ed08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     Reset_Handler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     g_peripherals

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     g_bootloaderContext+0x20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     `bootloader_flash_init::s_flashExecuteInRamFunctionInfo`
    623          
    624          #if defined(__CC_ARM)
    625          #define ITM_Port8(n) (*((volatile unsigned char *)(0xE0000000 + 4 * n)))
    626          #define ITM_Port16(n) (*((volatile unsigned short *)(0xE0000000 + 4 * n)))
    627          #define ITM_Port32(n) (*((volatile unsigned long *)(0xE0000000 + 4 * n)))
    628          
    629          #define DEMCR (*((volatile unsigned long *)(0xE000EDFC)))
    630          #define TRCENA 0x01000000
    631          
    632          struct __FILE
    633          {
    634              int handle; /* Add whatever needed */
    635          };
    636          FILE __stdout;
    637          FILE __stdin;
    638          
    639          int fputc(int ch, FILE *f)
    640          {
    641              if (DEMCR & TRCENA)
    642              {
    643                  while (ITM_Port32(0) == 0)
    644                      ;
    645                  ITM_Port8(0) = ch;
    646              }
    647              return (ch);
    648          }
    649          #endif
    650          
    651          //! @}
    652          
    653          ////////////////////////////////////////////////////////////////////////////////
    654          // EOF
    655          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   bootloader_flash_init
         8   -- Indirect call
       8   bootloader_init
         8   -- Indirect call
         8   -> bootloader_flash_init
         8   -> configure_clocks
         8   -> get_active_peripheral
         8   -> init_hardware
         8   -> lock_init
         8   -> microseconds_init
       8   bootloader_run
         8   -- Indirect call
       0   exit
      64   get_active_peripheral
        64   -- Indirect call
        64   -> get_user_application_entry
        64   -> is_application_ready_for_executing
        64   -> is_boot_pin_asserted
        64   -> is_direct_boot
        64   -> jump_to_application
        64   -> microseconds_convert_to_ticks
        64   -> microseconds_get_ticks
       0   get_user_application_entry
      16   is_application_ready_for_executing
        16   -> is_application_crc_check_pass
        16   -> is_valid_application_location
       0   is_direct_boot
      24   is_valid_application_location
        24   -> find_map_entry
      16   jump_to_application
        16   -- Indirect call
        16   -> shutdown_cleanup
       8   main
         8   -> bootloader_init
         8   -> bootloader_run


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
      30  bootloader_flash_init
     138  bootloader_init
      32  bootloader_run
       2  exit
       4  farewellBootloader
     338  get_active_peripheral
      18  get_user_application_entry
      30  is_application_ready_for_executing
      18  is_direct_boot
      64  is_valid_application_location
      58  jump_to_application
      14  main
      64  s_flashCacheClearCommand
      12  s_flashExecuteInRamFunctionInfo
      64  s_flashRunCommand
       4  s_stackPointer

 
 136 bytes in section .bss
  12 bytes in section .data
 774 bytes in section .text
 
 774 bytes of CODE memory
 148 bytes of DATA memory

Errors: none
Warnings: none
