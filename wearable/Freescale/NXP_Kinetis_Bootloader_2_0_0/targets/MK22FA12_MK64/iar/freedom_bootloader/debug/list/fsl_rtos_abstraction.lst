###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:03
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\utilities\src\fsl_rtos_abstraction.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\utilities\src\fsl_rtos_abstraction.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\fsl_rtos_abstraction.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\fsl_rtos_abstraction.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\utilities\src\fsl_rtos_abstraction.c
      1          /*
      2           * Copyright (c) 2013, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "utilities/fsl_assert.h"
     32          #include "bootloader/bl_peripheral_interface.h"
     33          #include "utilities/fsl_rtos_abstraction.h"
     34          #include "fsl_device_registers.h"
     35          #include "microseconds/microseconds.h"
     36          
     37          ////////////////////////////////////////////////////////////////////////////////
     38          // Definitions
     39          ////////////////////////////////////////////////////////////////////////////////
     40          
     41          enum _sync_constants
     42          {
     43              kSyncUnlocked = 0,
     44              kSyncLocked = 1
     45          };
     46          

   \                                 In section .bss, align 4
     47          static lock_object_t lockObject;
   \                     lockObject:
   \   00000000                      DS8 4
     48          

   \                                 In section .bss, align 8
     49          static uint64_t s_ticksPerMs = 0;
   \                     s_ticksPerMs:
   \   00000000                      DS8 8
     50          
     51          ////////////////////////////////////////////////////////////////////////////////
     52          // Code
     53          ////////////////////////////////////////////////////////////////////////////////
     54          
     55          /*FUNCTION**********************************************************************
     56           *
     57           * Function Name : time_diff
     58           * Description   : This function gets the difference between two time stamp,
     59           * time overflow is considered.
     60           *
     61           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     62          static uint32_t ms_diff(uint64_t tickStart, uint64_t tickStop)
     63          {
   \                     ms_diff: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     64              return ((tickStop - tickStart) / s_ticksPerMs);
   \   00000002   0x1A10             SUBS     R0,R2,R0
   \   00000004   0xEB73 0x0101      SBCS     R1,R3,R1
   \   00000008   0x....             LDR.N    R4,??DataTable4
   \   0000000A   0xE9D4 0x2300      LDRD     R2,R3,[R4, #+0]
   \   0000000E   0x.... 0x....      BL       __aeabi_uldivmod
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
     65          }
     66          
     67          /*FUNCTION**********************************************************************
     68           *
     69           * Function Name : OSA_SemaCreate
     70           * Description   : This function is used to create a semaphore. Return
     71           * kStatus_OSA_Success if create successfully, otherwise return kStatus_OSA_Error.
     72           *
     73           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     74          osa_status_t OSA_SemaCreate(semaphore_t *pSem, uint8_t initValue)
     75          {
   \                     OSA_SemaCreate: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     76              assert(pSem);
     77          
     78              if (!s_ticksPerMs)
   \   00000006   0x....             LDR.N    R0,??DataTable4
   \   00000008   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x428B             CMP      R3,R1
   \   00000012   0xD108             BNE.N    ??OSA_SemaCreate_0
   \   00000014   0x4282             CMP      R2,R0
   \   00000016   0xD106             BNE.N    ??OSA_SemaCreate_0
     79              {
     80                  s_ticksPerMs = microseconds_convert_to_ticks(1000);
   \   00000018   0xF44F 0x707A      MOV      R0,#+1000
   \   0000001C   0x.... 0x....      BL       microseconds_convert_to_ticks
   \   00000020   0x....             LDR.N    R2,??DataTable4
   \   00000022   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
     81              }
     82          
     83              pSem->semCount = initValue;
   \                     ??OSA_SemaCreate_0: (+1)
   \   00000026   0x7065             STRB     R5,[R4, #+1]
     84              pSem->isWaiting = false;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x7020             STRB     R0,[R4, #+0]
     85              pSem->tickStart = 0u;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xE9C4 0x0102      STRD     R0,R1,[R4, #+8]
     86              pSem->timeout = 0u;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x6120             STR      R0,[R4, #+16]
     87          
     88              return kStatus_OSA_Success;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     89          }
     90          
     91          /*FUNCTION**********************************************************************
     92           *
     93           * Function Name : OSA_SemaWait
     94           * Description   : This function checks the semaphore's counting value, if it is
     95           * positive, decreases it and returns kStatus_OSA_Success, otherwise, timeout
     96           * will be used for wait. The parameter timeout indicates how long should wait
     97           * in milliseconds. Pass kSyncWaitForever to wait indefinitely, pass 0 will
     98           * return kStatus_OSA_Timeout immediately if semaphore is not positive.
     99           * This function returns kStatus_OSA_Success if the semaphore is received, returns
    100           * kStatus_OSA_Timeout if the semaphore is not received within the specified
    101           * 'timeout', returns kStatus_OSA_Error if any errors occur during waiting,
    102           * returns kStatus_OSA_Idle if the semaphore is not available and 'timeout' is
    103           * not exhausted, because wait functions should not block with bare metal.
    104           *
    105           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    106          osa_status_t OSA_SemaWait(semaphore_t *pSem, uint32_t timeout)
    107          {
   \                     OSA_SemaWait: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000F             MOVS     R7,R1
    108              uint64_t currentTicks;
    109          
    110              assert(pSem);
    111          
    112              /* Check the sem count first. Deal with timeout only if not already set */
    113              if (pSem->semCount)
   \   00000006   0x7870             LDRB     R0,[R6, #+1]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD008             BEQ.N    ??OSA_SemaWait_0
    114              {
    115                  __disable_irq();
   \   0000000C   0xB672             CPSID    I
    116                  pSem->semCount--;
   \   0000000E   0x7870             LDRB     R0,[R6, #+1]
   \   00000010   0x1E40             SUBS     R0,R0,#+1
   \   00000012   0x7070             STRB     R0,[R6, #+1]
    117                  pSem->isWaiting = false;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x7030             STRB     R0,[R6, #+0]
    118                  __enable_irq();
   \   00000018   0xB662             CPSIE    I
    119                  return kStatus_OSA_Success;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE026             B.N      ??OSA_SemaWait_1
    120              }
    121              else
    122              {
    123                  if (timeout == 0)
   \                     ??OSA_SemaWait_0: (+1)
   \   0000001E   0x2F00             CMP      R7,#+0
   \   00000020   0xD101             BNE.N    ??OSA_SemaWait_2
    124                  {
    125                      /* If timeout is 0 and semaphore is not available, return kStatus_OSA_Timeout. */
    126                      return kStatus_OSA_Timeout;
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE022             B.N      ??OSA_SemaWait_1
    127                  }
    128                  else if (pSem->isWaiting)
   \                     ??OSA_SemaWait_2: (+1)
   \   00000026   0x7830             LDRB     R0,[R6, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD012             BEQ.N    ??OSA_SemaWait_3
    129                  {
    130                      /* Check for timeout */
    131                      currentTicks = microseconds_get_ticks();
   \   0000002C   0x.... 0x....      BL       microseconds_get_ticks
   \   00000030   0x0004             MOVS     R4,R0
   \   00000032   0x000D             MOVS     R5,R1
    132                      if (pSem->timeout < ms_diff(pSem->tickStart, currentTicks))
   \   00000034   0x0022             MOVS     R2,R4
   \   00000036   0x002B             MOVS     R3,R5
   \   00000038   0xE9D6 0x0102      LDRD     R0,R1,[R6, #+8]
   \   0000003C   0x.... 0x....      BL       ms_diff
   \   00000040   0x6931             LDR      R1,[R6, #+16]
   \   00000042   0x4281             CMP      R1,R0
   \   00000044   0xD211             BCS.N    ??OSA_SemaWait_4
    133                      {
    134                          __disable_irq();
   \   00000046   0xB672             CPSID    I
    135                          pSem->isWaiting = false;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x7030             STRB     R0,[R6, #+0]
    136                          __enable_irq();
   \   0000004C   0xB662             CPSIE    I
    137                          return kStatus_OSA_Timeout;
   \   0000004E   0x2002             MOVS     R0,#+2
   \   00000050   0xE00C             B.N      ??OSA_SemaWait_1
    138                      }
    139                  }
    140                  else if (timeout != kSyncWaitForever) /* If don't wait forever, start the timer */
   \                     ??OSA_SemaWait_3: (+1)
   \   00000052   0xF117 0x0F01      CMN      R7,#+1
   \   00000056   0xD008             BEQ.N    ??OSA_SemaWait_4
    141                  {
    142                      /* Start the timeout counter */
    143                      __disable_irq();
   \   00000058   0xB672             CPSID    I
    144                      pSem->isWaiting = true;
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x7030             STRB     R0,[R6, #+0]
    145                      __enable_irq();
   \   0000005E   0xB662             CPSIE    I
    146                      pSem->tickStart = microseconds_get_ticks();
   \   00000060   0x.... 0x....      BL       microseconds_get_ticks
   \   00000064   0xE9C6 0x0102      STRD     R0,R1,[R6, #+8]
    147                      pSem->timeout = timeout;
   \   00000068   0x6137             STR      R7,[R6, #+16]
    148                  }
    149              }
    150          
    151              return kStatus_OSA_Idle;
   \                     ??OSA_SemaWait_4: (+1)
   \   0000006A   0x2003             MOVS     R0,#+3
   \                     ??OSA_SemaWait_1: (+1)
   \   0000006C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    152          }
    153          
    154          /*FUNCTION**********************************************************************
    155           *
    156           * Function Name : OSA_SemaPost
    157           * Description   : This function is used to wake up one task that wating on the
    158           * semaphore. If no task is waiting, increase the semaphore. The function returns
    159           * kStatus_OSA_Success if the semaphre is post successfully, otherwise returns
    160           * kStatus_OSA_Error.
    161           *
    162           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    163          osa_status_t OSA_SemaPost(semaphore_t *pSem)
    164          {
   \                     OSA_SemaPost: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    165              assert(pSem);
    166              /* The max value is 0xFF */
    167              if (pSem->semCount == 0xFF)
   \   00000002   0x7848             LDRB     R0,[R1, #+1]
   \   00000004   0x28FF             CMP      R0,#+255
   \   00000006   0xD101             BNE.N    ??OSA_SemaPost_0
    168              {
    169                  return kStatus_OSA_Error;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE005             B.N      ??OSA_SemaPost_1
    170              }
    171              __disable_irq();
   \                     ??OSA_SemaPost_0: (+1)
   \   0000000C   0xB672             CPSID    I
    172              ++pSem->semCount;
   \   0000000E   0x7848             LDRB     R0,[R1, #+1]
   \   00000010   0x1C40             ADDS     R0,R0,#+1
   \   00000012   0x7048             STRB     R0,[R1, #+1]
    173              __enable_irq();
   \   00000014   0xB662             CPSIE    I
    174          
    175              return kStatus_OSA_Success;
   \   00000016   0x2000             MOVS     R0,#+0
   \                     ??OSA_SemaPost_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    176          }
    177          
    178          /*FUNCTION**********************************************************************
    179           *
    180           * Function Name : OSA_SemaDestroy
    181           * Description   : This function is used to destroy a semaphore.
    182           * Return kStatus_OSA_Success if the semaphore is destroyed successfully, otherwise
    183           * return kStatus_OSA_Error.
    184           *
    185           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    186          osa_status_t OSA_SemaDestroy(semaphore_t *pSem)
    187          {
   \                     OSA_SemaDestroy: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    188              assert(pSem);
    189          
    190              return kStatus_OSA_Success;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
    191          }
    192          
    193          /*FUNCTION**********************************************************************
    194           *
    195           * Function Name : OSA_TimeDelay
    196           * Description   : This function is used to delay for a number of milliseconds.
    197           *
    198           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    199          void OSA_TimeDelay(uint32_t delay)
    200          {
   \                     OSA_TimeDelay: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    201              microseconds_delay(delay * 1000);
   \   00000004   0xF44F 0x707A      MOV      R0,#+1000
   \   00000008   0xFB00 0xF004      MUL      R0,R0,R4
   \   0000000C   0x.... 0x....      BL       microseconds_delay
    202          }
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
    203          

   \                                 In section .text, align 2, keep-with-next
    204          void sync_init(sync_object_t *obj, bool state)
    205          {
    206              *obj = state ? kSyncLocked : kSyncUnlocked;
   \                     sync_init: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x6001             STR      R1,[R0, #+0]
    207          }
   \   00000004   0x4770             BX       LR               ;; return
    208          

   \                                 In section .text, align 2, keep-with-next
    209          bool sync_wait(sync_object_t *obj, uint32_t timeout)
    210          {
   \                     sync_wait: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    211              // Increment the object so we can tell if it changes. Because the increment is not
    212              // atomic (load, add, store), we must disabled interrupts during it.
    213              __disable_irq();
   \   00000002   0xB672             CPSID    I
    214              ++(*obj);
   \   00000004   0x6810             LDR      R0,[R2, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x6010             STR      R0,[R2, #+0]
    215              __enable_irq();
   \   0000000A   0xB662             CPSIE    I
    216          
    217              // Wait for the object to be unlocked.
    218              while (*obj != 0)
   \                     ??sync_wait_0: (+1)
   \   0000000C   0x6810             LDR      R0,[R2, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD1FC             BNE.N    ??sync_wait_0
    219              {
    220                  // Spin.
    221              }
    222          
    223              return true;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x4770             BX       LR               ;; return
    224          }
    225          

   \                                 In section .text, align 2, keep-with-next
    226          void sync_signal(sync_object_t *obj)
    227          {
    228              // Atomically unlock the object.
    229              __disable_irq();
   \                     sync_signal: (+1)
   \   00000000   0xB672             CPSID    I
    230              --(*obj);
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x1E49             SUBS     R1,R1,#+1
   \   00000006   0x6001             STR      R1,[R0, #+0]
    231              __enable_irq();
   \   00000008   0xB662             CPSIE    I
    232          }
   \   0000000A   0x4770             BX       LR               ;; return
    233          

   \                                 In section .text, align 2, keep-with-next
    234          void sync_reset(sync_object_t *obj)
    235          {
    236              __disable_irq();
   \                     sync_reset: (+1)
   \   00000000   0xB672             CPSID    I
    237              (*obj) = 0;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x6001             STR      R1,[R0, #+0]
    238              __enable_irq();
   \   00000006   0xB662             CPSIE    I
    239          }
   \   00000008   0x4770             BX       LR               ;; return
    240          

   \                                 In section .text, align 2, keep-with-next
    241          void lock_init(void)
    242          {
    243              __disable_irq();
   \                     lock_init: (+1)
   \   00000000   0xB672             CPSID    I
    244              lockObject = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable4_1
   \   00000006   0x6008             STR      R0,[R1, #+0]
    245              __enable_irq();
   \   00000008   0xB662             CPSIE    I
    246          }
   \   0000000A   0x4770             BX       LR               ;; return
    247          

   \                                 In section .text, align 2, keep-with-next
    248          void lock_acquire(void)
    249          {
    250              // Disable global IRQ until lock_release() is called.
    251              __disable_irq();
   \                     lock_acquire: (+1)
   \   00000000   0xB672             CPSID    I
    252              ++lockObject;
   \   00000002   0x....             LDR.N    R0,??DataTable4_1
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x....             LDR.N    R1,??DataTable4_1
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    253          }
   \   0000000C   0x4770             BX       LR               ;; return
    254          

   \                                 In section .text, align 2, keep-with-next
    255          void lock_release(void)
    256          {
    257              // Restore previous state, enable global IRQ if all locks released.
    258              if (lockObject <= 1)
   \                     lock_release: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4_1
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2802             CMP      R0,#+2
   \   00000006   0xD204             BCS.N    ??lock_release_0
    259              {
    260                  lockObject = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             LDR.N    R1,??DataTable4_1
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    261                  __enable_irq();
   \   0000000E   0xB662             CPSIE    I
   \   00000010   0xE004             B.N      ??lock_release_1
    262              }
    263              else
    264              {
    265                  --lockObject;
   \                     ??lock_release_0: (+1)
   \   00000012   0x....             LDR.N    R0,??DataTable4_1
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0x....             LDR.N    R1,??DataTable4_1
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    266              }
    267          }
   \                     ??lock_release_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     s_ticksPerMs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     lockObject
    268          
    269          ////////////////////////////////////////////////////////////////////////////////
    270          // EOF
    271          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   OSA_SemaCreate
        16   -> microseconds_convert_to_ticks
       0   OSA_SemaDestroy
       0   OSA_SemaPost
      24   OSA_SemaWait
        24   -> microseconds_get_ticks
        24   -> ms_diff
       8   OSA_TimeDelay
         8   -> microseconds_delay
       0   lock_acquire
       0   lock_init
       0   lock_release
       8   ms_diff
         8 __aeabi_uldivmod
       0   sync_init
       0   sync_reset
       0   sync_signal
       0   sync_wait


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
      60  OSA_SemaCreate
       6  OSA_SemaDestroy
      26  OSA_SemaPost
     110  OSA_SemaWait
      18  OSA_TimeDelay
       4  lockObject
      14  lock_acquire
      12  lock_init
      30  lock_release
      20  ms_diff
       8  s_ticksPerMs
       6  sync_init
      10  sync_reset
      12  sync_signal
      22  sync_wait

 
  12 bytes in section .bss
 354 bytes in section .text
 
 354 bytes of CODE memory
  12 bytes of DATA memory

Errors: none
Warnings: none
