###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:01
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\dspi\fsl_dspi.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\dspi\fsl_dspi.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\fsl_dspi.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\fsl_dspi.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\dspi\fsl_dspi.c
      1          /*
      2          * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3          * All rights reserved.
      4          *
      5          * Redistribution and use in source and binary forms, with or without modification,
      6          * are permitted provided that the following conditions are met:
      7          *
      8          * o Redistributions of source code must retain the above copyright notice, this list
      9          *   of conditions and the following disclaimer.
     10          *
     11          * o Redistributions in binary form must reproduce the above copyright notice, this
     12          *   list of conditions and the following disclaimer in the documentation and/or
     13          *   other materials provided with the distribution.
     14          *
     15          * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16          *   contributors may be used to endorse or promote products derived from this
     17          *   software without specific prior written permission.
     18          *
     19          * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20          * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21          * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22          * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23          * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25          * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26          * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27          * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28          * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29          */
     30          
     31          #include "fsl_dspi.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable14  ;; 0xe000e100
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_EnableClock(clock_ip_name_t)
   \                     CLOCK_EnableClock: (+1)
   \   00000000   0x0C01             LSRS     R1,R0,#+16
   \   00000002   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000006   0xF511 0x218E      ADDS     R1,R1,#+290816
   \   0000000A   0x680A             LDR      R2,[R1, #+0]
   \   0000000C   0x2301             MOVS     R3,#+1
   \   0000000E   0x4083             LSLS     R3,R3,R0
   \   00000010   0x431A             ORRS     R2,R3,R2
   \   00000012   0x600A             STR      R2,[R1, #+0]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_DisableClock(clock_ip_name_t)
   \                     CLOCK_DisableClock: (+1)
   \   00000000   0x0C01             LSRS     R1,R0,#+16
   \   00000002   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000006   0xF511 0x218E      ADDS     R1,R1,#+290816
   \   0000000A   0x680A             LDR      R2,[R1, #+0]
   \   0000000C   0x2301             MOVS     R3,#+1
   \   0000000E   0x4083             LSLS     R3,R3,R0
   \   00000010   0x439A             BICS     R2,R2,R3
   \   00000012   0x600A             STR      R2,[R1, #+0]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void EnableIRQ(IRQn_Type)
   \                     EnableIRQ: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       NVIC_EnableIRQ
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void DSPI_Enable(SPI_Type *, bool)
   \                     DSPI_Enable: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??DSPI_Enable_0
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0xF432 0x4280      BICS     R2,R2,#0x4000
   \   0000000C   0x6002             STR      R2,[R0, #+0]
   \   0000000E   0xE003             B.N      ??DSPI_Enable_1
   \                     ??DSPI_Enable_0: (+1)
   \   00000010   0x6802             LDR      R2,[R0, #+0]
   \   00000012   0xF452 0x4280      ORRS     R2,R2,#0x4000
   \   00000016   0x6002             STR      R2,[R0, #+0]
   \                     ??DSPI_Enable_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t DSPI_GetStatusFlags(SPI_Type *)
   \                     DSPI_GetStatusFlags: (+1)
   \   00000000   0x6AC0             LDR      R0,[R0, #+44]
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void DSPI_ClearStatusFlags(SPI_Type *, uint32_t)
   \                     DSPI_ClearStatusFlags: (+1)
   \   00000000   0x62C1             STR      R1,[R0, #+44]
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void DSPI_DisableInterrupts(SPI_Type *, uint32_t)
   \                     DSPI_DisableInterrupts: (+1)
   \   00000000   0x6B02             LDR      R2,[R0, #+48]
   \   00000002   0x438A             BICS     R2,R2,R1
   \   00000004   0x6302             STR      R2,[R0, #+48]
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void DSPI_SetMasterSlaveMode(SPI_Type *, dspi_master_slave_mode_t)
   \                     DSPI_SetMasterSlaveMode: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0xF022 0x4200      BIC      R2,R2,#0x80000000
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0xEA52 0x72C1      ORRS     R2,R2,R1, LSL #+31
   \   0000000C   0x6002             STR      R2,[R0, #+0]
   \   0000000E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp bool DSPI_IsMaster(SPI_Type *)
   \                     DSPI_IsMaster: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x0FC0             LSRS     R0,R0,#+31
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void DSPI_StartTransfer(SPI_Type *)
   \                     DSPI_StartTransfer: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x0849             LSRS     R1,R1,#+1
   \   00000004   0x0049             LSLS     R1,R1,#+1
   \   00000006   0x6001             STR      R1,[R0, #+0]
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void DSPI_StopTransfer(SPI_Type *)
   \                     DSPI_StopTransfer: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000006   0x6001             STR      R1,[R0, #+0]
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void DSPI_FlushFifo(SPI_Type *, bool, bool)
   \                     DSPI_FlushFifo: (+1)
   \   00000000   0x6803             LDR      R3,[R0, #+0]
   \   00000002   0xF433 0x6340      BICS     R3,R3,#0xC00
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0xEA53 0x23C1      ORRS     R3,R3,R1, LSL #+11
   \   0000000C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000E   0xEA53 0x2382      ORRS     R3,R3,R2, LSL #+10
   \   00000012   0x6003             STR      R3,[R0, #+0]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t DSPI_MasterGetFormattedCommand(dspi_command_data_config_t *)
   \                     DSPI_MasterGetFormattedCommand: (+1)
   \   00000000   0x7801             LDRB     R1,[R0, #+0]
   \   00000002   0x7842             LDRB     R2,[R0, #+1]
   \   00000004   0x0712             LSLS     R2,R2,#+28
   \   00000006   0xF012 0x42E0      ANDS     R2,R2,#0x70000000
   \   0000000A   0xEA52 0x71C1      ORRS     R1,R2,R1, LSL #+31
   \   0000000E   0x7882             LDRB     R2,[R0, #+2]
   \   00000010   0x0412             LSLS     R2,R2,#+16
   \   00000012   0xF412 0x127C      ANDS     R2,R2,#0x3F0000
   \   00000016   0x4311             ORRS     R1,R2,R1
   \   00000018   0x78C2             LDRB     R2,[R0, #+3]
   \   0000001A   0xEA51 0x61C2      ORRS     R1,R1,R2, LSL #+27
   \   0000001E   0x7900             LDRB     R0,[R0, #+4]
   \   00000020   0xEA51 0x6080      ORRS     R0,R1,R0, LSL #+26
   \   00000024   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t DSPI_ReadData(SPI_Type *)
   \                     DSPI_ReadData: (+1)
   \   00000000   0x6B80             LDR      R0,[R0, #+56]
   \   00000002   0x4770             BX       LR               ;; return
     32          
     33          /*******************************************************************************
     34           * Definitions
     35           ******************************************************************************/
     36          /*! @brief Typedef for master interrupt handler. */
     37          typedef void (*dspi_master_isr_t)(SPI_Type *base, dspi_master_handle_t *handle);
     38          
     39          /*! @brief Typedef for slave interrupt handler. */
     40          typedef void (*dspi_slave_isr_t)(SPI_Type *base, dspi_slave_handle_t *handle);
     41          
     42          /*******************************************************************************
     43           * Prototypes
     44           ******************************************************************************/
     45          /*!
     46           * @brief Get instance number for DSPI module.
     47           *
     48           * @param base DSPI peripheral base address.
     49           */
     50          uint32_t DSPI_GetInstance(SPI_Type *base);
     51          
     52          /*!
     53           * @brief Configures the DSPI peripheral chip select polarity.
     54           *
     55           * This function  takes in the desired peripheral chip select (Pcs) and it's corresponding desired polarity and
     56           * configures the Pcs signal to operate with the desired characteristic.
     57           *
     58           * @param base DSPI peripheral address.
     59           * @param pcs The particular peripheral chip select (parameter value is of type dspi_which_pcs_t) for which we wish to
     60           *            apply the active high or active low characteristic.
     61           * @param activeLowOrHigh The setting for either "active high, inactive low (0)"  or "active low, inactive high(1)" of
     62           *                        type dspi_pcs_polarity_config_t.
     63           */
     64          static void DSPI_SetOnePcsPolarity(SPI_Type *base, dspi_which_pcs_t pcs, dspi_pcs_polarity_config_t activeLowOrHigh);
     65          
     66          /*!
     67           * @brief Master fill up the TX FIFO with data.
     68           * This is not a public API as it is called from other driver functions.
     69           */
     70          static void DSPI_MasterFillUpTxFifo(SPI_Type *base, dspi_master_handle_t *handle);
     71          
     72          /*!
     73           * @brief Master finish up a transfer.
     74           * It would call back if there is callback function and set the state to idle.
     75           * This is not a public API as it is called from other driver functions.
     76           */
     77          static void DSPI_MasterCompleteTransfer(SPI_Type *base, dspi_master_handle_t *handle);
     78          
     79          /*!
     80           * @brief Slave fill up the TX FIFO with data.
     81           * This is not a public API as it is called from other driver functions.
     82           */
     83          static void DSPI_SlaveFillUpTxFifo(SPI_Type *base, dspi_slave_handle_t *handle);
     84          
     85          /*!
     86           * @brief Slave finish up a transfer.
     87           * It would call back if there is callback function and set the state to idle.
     88           * This is not a public API as it is called from other driver functions.
     89           */
     90          static void DSPI_SlaveCompleteTransfer(SPI_Type *base, dspi_slave_handle_t *handle);
     91          
     92          /*!
     93           * @brief DSPI common interrupt handler.
     94           *
     95           * @param base DSPI peripheral address.
     96           * @param handle pointer to g_dspiHandle which stores the transfer state.
     97           */
     98          static void DSPI_CommonIRQHandler(SPI_Type *base, void *param);
     99          
    100          /*!
    101           * @brief Master prepare the transfer.
    102           * Basically it set up dspi_master_handle .
    103           * This is not a public API as it is called from other driver functions. fsl_dspi_edma.c also call this function.
    104           */
    105          static void DSPI_MasterPrepareTransfer(SPI_Type *base, dspi_master_handle_t *handle, dspi_transfer_t *transfer);
    106          
    107          /*******************************************************************************
    108           * Variables
    109           ******************************************************************************/
    110          
    111          /* Defines constant value arrays for the baud rate pre-scalar and scalar divider values.*/

   \                                 In section .rodata, align 4
    112          static const uint32_t s_baudratePrescaler[] = {2, 3, 5, 7};
   \                     s_baudratePrescaler:
   \   00000000   0x00000002         DC32 2, 3, 5, 7
   \              0x00000003   
   \              0x00000005   
   \              0x00000007   

   \                                 In section .rodata, align 4
    113          static const uint32_t s_baudrateScaler[] = {2,   4,   6,    8,    16,   32,   64,    128,
   \                     s_baudrateScaler:
   \   00000000   0x00000002         DC32 2, 4, 6, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192
   \              0x00000004   
   \              0x00000006   
   \              0x00000008   
   \              0x00000010   
   \              0x00000020   
   \              0x00000040   
   \              0x00000080   
   \              0x00000100   
   \              0x00000200   
   \              0x00000400   
   \              0x00000800   
   \              0x00001000   
   \              0x00002000   
   \   00000038   0x00004000         DC32 16384, 32768
   \              0x00008000   
    114                                                      256, 512, 1024, 2048, 4096, 8192, 16384, 32768};
    115          

   \                                 In section .rodata, align 4
    116          static const uint32_t s_delayPrescaler[] = {1, 3, 5, 7};
   \                     s_delayPrescaler:
   \   00000000   0x00000001         DC32 1, 3, 5, 7
   \              0x00000003   
   \              0x00000005   
   \              0x00000007   

   \                                 In section .rodata, align 4
    117          static const uint32_t s_delayScaler[] = {2,   4,    8,    16,   32,   64,    128,   256,
   \                     s_delayScaler:
   \   00000000   0x00000002         DC32 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384
   \              0x00000004   
   \              0x00000008   
   \              0x00000010   
   \              0x00000020   
   \              0x00000040   
   \              0x00000080   
   \              0x00000100   
   \              0x00000200   
   \              0x00000400   
   \              0x00000800   
   \              0x00001000   
   \              0x00002000   
   \              0x00004000   
   \   00000038   0x00008000         DC32 32768, 65536
   \              0x00010000   
    118                                                   512, 1024, 2048, 4096, 8192, 16384, 32768, 65536};
    119          
    120          /*! @brief Pointers to dspi bases for each instance. */

   \                                 In section .rodata, align 4
    121          static SPI_Type *const s_dspiBases[] = SPI_BASE_PTRS;
   \                     s_dspiBases:
   \   00000000   0x4002C000         DC32 4002C000H, 4002D000H, 400AC000H
   \              0x4002D000   
   \              0x400AC000   
    122          
    123          /*! @brief Pointers to dspi IRQ number for each instance. */

   \                                 In section .rodata, align 4
    124          static IRQn_Type const s_dspiIRQ[] = SPI_IRQS;
   \                     s_dspiIRQ:
   \   00000000   0x1A 0x1B          DC8 26, 27, 65, 0
   \              0x41 0x00    
    125          
    126          /*! @brief Pointers to dspi clocks for each instance. */

   \                                 In section .rodata, align 4
    127          static clock_ip_name_t const s_dspiClock[] = DSPI_CLOCKS;
   \                     s_dspiClock:
   \   00000000   0x103C000C         DC32 272367628, 272367629, 271581196
   \              0x103C000D   
   \              0x1030000C   
    128          
    129          /*! @brief Pointers to dspi handles for each instance. */

   \                                 In section .bss, align 4
    130          static void *g_dspiHandle[FSL_FEATURE_SOC_DSPI_COUNT];
   \                     g_dspiHandle:
   \   00000000                      DS8 12
    131          
    132          /*! @brief Pointer to master IRQ handler for each instance. */

   \                                 In section .bss, align 4
    133          static dspi_master_isr_t s_dspiMasterIsr;
   \                     s_dspiMasterIsr:
   \   00000000                      DS8 4
    134          
    135          /*! @brief Pointer to slave IRQ handler for each instance. */

   \                                 In section .bss, align 4
    136          static dspi_slave_isr_t s_dspiSlaveIsr;
   \                     s_dspiSlaveIsr:
   \   00000000                      DS8 4
    137          
    138          /**********************************************************************************************************************
    139          * Code
    140          *********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    141          uint32_t DSPI_GetInstance(SPI_Type *base)
    142          {
   \                     DSPI_GetInstance: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    143              uint32_t instance;
    144          
    145              /* Find the instance index from base address mappings. */
    146              for (instance = 0; instance < FSL_FEATURE_SOC_DSPI_COUNT; instance++)
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x0010             MOVS     R0,R2
   \                     ??DSPI_GetInstance_0: (+1)
   \   00000006   0x2803             CMP      R0,#+3
   \   00000008   0xD207             BCS.N    ??DSPI_GetInstance_1
    147              {
    148                  if (s_dspiBases[instance] == base)
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable15
   \   0000000E   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   00000012   0x428A             CMP      R2,R1
   \   00000014   0xD001             BEQ.N    ??DSPI_GetInstance_1
    149                  {
    150                      break;
    151                  }
    152              }
   \                     ??DSPI_GetInstance_2: (+1)
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0xE7F5             B.N      ??DSPI_GetInstance_0
    153          
    154              assert(instance < FSL_FEATURE_SOC_DSPI_COUNT);
    155          
    156              return instance;
   \                     ??DSPI_GetInstance_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    157          }
    158          

   \                                 In section .text, align 2, keep-with-next
    159          void DSPI_MasterInit(SPI_Type *base, const dspi_master_config_t *masterConfig, uint32_t srcClock_Hz)
    160          {
   \                     DSPI_MasterInit: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    161              uint32_t temp;
    162              /* enable DSPI clock */
    163              CLOCK_EnableClock(s_dspiClock[DSPI_GetInstance(base)]);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       DSPI_GetInstance
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \   00000012   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000016   0x.... 0x....      BL       CLOCK_EnableClock
    164          
    165              DSPI_Enable(base, true);
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       DSPI_Enable
    166              DSPI_StopTransfer(base);
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       DSPI_StopTransfer
    167          
    168              DSPI_SetMasterSlaveMode(base, kDSPI_Master);
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       DSPI_SetMasterSlaveMode
    169          
    170              temp = base->MCR & (~(SPI_MCR_CONT_SCKE_MASK | SPI_MCR_MTFE_MASK | SPI_MCR_ROOE_MASK | SPI_MCR_SMPL_PT_MASK |
    171                                    SPI_MCR_DIS_TXF_MASK | SPI_MCR_DIS_RXF_MASK));
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0xbaffccff
   \   00000036   0x4008             ANDS     R0,R1,R0
   \   00000038   0x0007             MOVS     R7,R0
    172          
    173              base->MCR = temp | SPI_MCR_CONT_SCKE(masterConfig->enableContinuousSCK) |
    174                          SPI_MCR_MTFE(masterConfig->enableModifiedTimingFormat) |
    175                          SPI_MCR_ROOE(masterConfig->enableRxFifoOverWrite) | SPI_MCR_SMPL_PT(masterConfig->samplePoint) |
    176                          SPI_MCR_DIS_TXF(false) | SPI_MCR_DIS_RXF(false);
   \   0000003A   0x7FA8             LDRB     R0,[R5, #+30]
   \   0000003C   0xEA57 0x7080      ORRS     R0,R7,R0, LSL #+30
   \   00000040   0xF895 0x1020      LDRB     R1,[R5, #+32]
   \   00000044   0xEA50 0x6081      ORRS     R0,R0,R1, LSL #+26
   \   00000048   0x7FE9             LDRB     R1,[R5, #+31]
   \   0000004A   0xEA50 0x6001      ORRS     R0,R0,R1, LSL #+24
   \   0000004E   0xF895 0x1021      LDRB     R1,[R5, #+33]
   \   00000052   0x0209             LSLS     R1,R1,#+8
   \   00000054   0xF411 0x7140      ANDS     R1,R1,#0x300
   \   00000058   0x4308             ORRS     R0,R1,R0
   \   0000005A   0x6020             STR      R0,[R4, #+0]
    177          
    178              DSPI_SetOnePcsPolarity(base, masterConfig->whichPcs, masterConfig->pcsActiveHighOrLow);
   \   0000005C   0x7F6A             LDRB     R2,[R5, #+29]
   \   0000005E   0x7F29             LDRB     R1,[R5, #+28]
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x.... 0x....      BL       DSPI_SetOnePcsPolarity
    179          
    180              if (0 == DSPI_MasterSetBaudRate(base, masterConfig->whichCtar, masterConfig->ctarConfig.baudRate, srcClock_Hz))
   \   00000066   0x0033             MOVS     R3,R6
   \   00000068   0x686A             LDR      R2,[R5, #+4]
   \   0000006A   0x7829             LDRB     R1,[R5, #+0]
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       DSPI_MasterSetBaudRate
   \   00000072   0x2800             CMP      R0,#+0
    181              {
    182                  assert(false);
    183              }
    184          
    185              temp = base->CTAR[masterConfig->whichCtar] &
    186                     ~(SPI_CTAR_FMSZ_MASK | SPI_CTAR_CPOL_MASK | SPI_CTAR_CPHA_MASK | SPI_CTAR_LSBFE_MASK);
   \                     ??DSPI_MasterInit_0: (+1)
   \   00000074   0x7828             LDRB     R0,[R5, #+0]
   \   00000076   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   0000007A   0x68C0             LDR      R0,[R0, #+12]
   \   0000007C   0xF030 0x40FE      BICS     R0,R0,#0x7F000000
   \   00000080   0x0007             MOVS     R7,R0
    187          
    188              base->CTAR[masterConfig->whichCtar] =
    189                  temp | SPI_CTAR_FMSZ(masterConfig->ctarConfig.bitsPerFrame - 1) | SPI_CTAR_CPOL(masterConfig->ctarConfig.cpol) |
    190                  SPI_CTAR_CPHA(masterConfig->ctarConfig.cpha) | SPI_CTAR_LSBFE(masterConfig->ctarConfig.direction);
   \   00000082   0x7828             LDRB     R0,[R5, #+0]
   \   00000084   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000088   0x68A9             LDR      R1,[R5, #+8]
   \   0000008A   0x1E49             SUBS     R1,R1,#+1
   \   0000008C   0x06C9             LSLS     R1,R1,#+27
   \   0000008E   0xF011 0x41F0      ANDS     R1,R1,#0x78000000
   \   00000092   0x4339             ORRS     R1,R1,R7
   \   00000094   0x7B2A             LDRB     R2,[R5, #+12]
   \   00000096   0x0692             LSLS     R2,R2,#+26
   \   00000098   0xF012 0x6280      ANDS     R2,R2,#0x4000000
   \   0000009C   0x4311             ORRS     R1,R2,R1
   \   0000009E   0x7B6A             LDRB     R2,[R5, #+13]
   \   000000A0   0x0652             LSLS     R2,R2,#+25
   \   000000A2   0xF012 0x7200      ANDS     R2,R2,#0x2000000
   \   000000A6   0x4311             ORRS     R1,R2,R1
   \   000000A8   0x7BAA             LDRB     R2,[R5, #+14]
   \   000000AA   0x0612             LSLS     R2,R2,#+24
   \   000000AC   0xF012 0x7280      ANDS     R2,R2,#0x1000000
   \   000000B0   0x4311             ORRS     R1,R2,R1
   \   000000B2   0x60C1             STR      R1,[R0, #+12]
    191          
    192              DSPI_MasterSetDelayTimes(base, masterConfig->whichCtar, kDSPI_PcsToSck, srcClock_Hz,
    193                                       masterConfig->ctarConfig.pcsToSckDelayInNanoSec);
   \   000000B4   0x6928             LDR      R0,[R5, #+16]
   \   000000B6   0x9000             STR      R0,[SP, #+0]
   \   000000B8   0x0033             MOVS     R3,R6
   \   000000BA   0x2201             MOVS     R2,#+1
   \   000000BC   0x7829             LDRB     R1,[R5, #+0]
   \   000000BE   0x0020             MOVS     R0,R4
   \   000000C0   0x.... 0x....      BL       DSPI_MasterSetDelayTimes
    194              DSPI_MasterSetDelayTimes(base, masterConfig->whichCtar, kDSPI_LastSckToPcs, srcClock_Hz,
    195                                       masterConfig->ctarConfig.lastSckToPcsDelayInNanoSec);
   \   000000C4   0x6968             LDR      R0,[R5, #+20]
   \   000000C6   0x9000             STR      R0,[SP, #+0]
   \   000000C8   0x0033             MOVS     R3,R6
   \   000000CA   0x2202             MOVS     R2,#+2
   \   000000CC   0x7829             LDRB     R1,[R5, #+0]
   \   000000CE   0x0020             MOVS     R0,R4
   \   000000D0   0x.... 0x....      BL       DSPI_MasterSetDelayTimes
    196              DSPI_MasterSetDelayTimes(base, masterConfig->whichCtar, kDSPI_BetweenTransfer, srcClock_Hz,
    197                                       masterConfig->ctarConfig.betweenTransferDelayInNanoSec);
   \   000000D4   0x69A8             LDR      R0,[R5, #+24]
   \   000000D6   0x9000             STR      R0,[SP, #+0]
   \   000000D8   0x0033             MOVS     R3,R6
   \   000000DA   0x2203             MOVS     R2,#+3
   \   000000DC   0x7829             LDRB     R1,[R5, #+0]
   \   000000DE   0x0020             MOVS     R0,R4
   \   000000E0   0x.... 0x....      BL       DSPI_MasterSetDelayTimes
    198          
    199              DSPI_StartTransfer(base);
   \   000000E4   0x0020             MOVS     R0,R4
   \   000000E6   0x.... 0x....      BL       DSPI_StartTransfer
    200          }
   \   000000EA   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    201          

   \                                 In section .text, align 2, keep-with-next
    202          void DSPI_MasterGetDefaultConfig(dspi_master_config_t *masterConfig)
    203          {
    204              masterConfig->whichCtar = kDSPI_Ctar0;
   \                     DSPI_MasterGetDefaultConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7001             STRB     R1,[R0, #+0]
    205              masterConfig->ctarConfig.baudRate = 500000;
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x7a120
   \   00000008   0x6041             STR      R1,[R0, #+4]
    206              masterConfig->ctarConfig.bitsPerFrame = 8;
   \   0000000A   0x2108             MOVS     R1,#+8
   \   0000000C   0x6081             STR      R1,[R0, #+8]
    207              masterConfig->ctarConfig.cpol = kDSPI_ClockPolarityActiveHigh;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x7301             STRB     R1,[R0, #+12]
    208              masterConfig->ctarConfig.cpha = kDSPI_ClockPhaseFirstEdge;
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x7341             STRB     R1,[R0, #+13]
    209              masterConfig->ctarConfig.direction = kDSPI_MsbFirst;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x7381             STRB     R1,[R0, #+14]
    210          
    211              masterConfig->ctarConfig.pcsToSckDelayInNanoSec = 1000;
   \   0000001A   0xF44F 0x717A      MOV      R1,#+1000
   \   0000001E   0x6101             STR      R1,[R0, #+16]
    212              masterConfig->ctarConfig.lastSckToPcsDelayInNanoSec = 1000;
   \   00000020   0xF44F 0x717A      MOV      R1,#+1000
   \   00000024   0x6141             STR      R1,[R0, #+20]
    213              masterConfig->ctarConfig.betweenTransferDelayInNanoSec = 1000;
   \   00000026   0xF44F 0x717A      MOV      R1,#+1000
   \   0000002A   0x6181             STR      R1,[R0, #+24]
    214          
    215              masterConfig->whichPcs = kDSPI_Pcs0;
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x7701             STRB     R1,[R0, #+28]
    216              masterConfig->pcsActiveHighOrLow = kDSPI_PcsActiveLow;
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0x7741             STRB     R1,[R0, #+29]
    217          
    218              masterConfig->enableContinuousSCK = false;
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x7781             STRB     R1,[R0, #+30]
    219              masterConfig->enableRxFifoOverWrite = false;
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x77C1             STRB     R1,[R0, #+31]
    220              masterConfig->enableModifiedTimingFormat = false;
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0xF880 0x1020      STRB     R1,[R0, #+32]
    221              masterConfig->samplePoint = kDSPI_SckToSin0Clock;
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0xF880 0x1021      STRB     R1,[R0, #+33]
    222          }
   \   00000048   0x4770             BX       LR               ;; return
    223          

   \                                 In section .text, align 2, keep-with-next
    224          void DSPI_SlaveInit(SPI_Type *base, const dspi_slave_config_t *slaveConfig)
    225          {
   \                     DSPI_SlaveInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    226              uint32_t temp = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    227          
    228              /* enable DSPI clock */
    229              CLOCK_EnableClock(s_dspiClock[DSPI_GetInstance(base)]);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       DSPI_GetInstance
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \   00000012   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000016   0x.... 0x....      BL       CLOCK_EnableClock
    230          
    231              DSPI_Enable(base, true);
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       DSPI_Enable
    232              DSPI_StopTransfer(base);
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       DSPI_StopTransfer
    233          
    234              DSPI_SetMasterSlaveMode(base, kDSPI_Slave);
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       DSPI_SetMasterSlaveMode
    235          
    236              temp = base->MCR & (~(SPI_MCR_CONT_SCKE_MASK | SPI_MCR_MTFE_MASK | SPI_MCR_ROOE_MASK | SPI_MCR_SMPL_PT_MASK |
    237                                    SPI_MCR_DIS_TXF_MASK | SPI_MCR_DIS_RXF_MASK));
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0xbaffccff
   \   00000036   0x4008             ANDS     R0,R1,R0
   \   00000038   0x0006             MOVS     R6,R0
    238          
    239              base->MCR = temp | SPI_MCR_CONT_SCKE(slaveConfig->enableContinuousSCK) |
    240                          SPI_MCR_MTFE(slaveConfig->enableModifiedTimingFormat) |
    241                          SPI_MCR_ROOE(slaveConfig->enableRxFifoOverWrite) | SPI_MCR_SMPL_PT(slaveConfig->samplePoint) |
    242                          SPI_MCR_DIS_TXF(false) | SPI_MCR_DIS_RXF(false);
   \   0000003A   0x7B28             LDRB     R0,[R5, #+12]
   \   0000003C   0xEA56 0x7080      ORRS     R0,R6,R0, LSL #+30
   \   00000040   0x7BA9             LDRB     R1,[R5, #+14]
   \   00000042   0xEA50 0x6081      ORRS     R0,R0,R1, LSL #+26
   \   00000046   0x7B69             LDRB     R1,[R5, #+13]
   \   00000048   0xEA50 0x6001      ORRS     R0,R0,R1, LSL #+24
   \   0000004C   0x7BE9             LDRB     R1,[R5, #+15]
   \   0000004E   0x0209             LSLS     R1,R1,#+8
   \   00000050   0xF411 0x7140      ANDS     R1,R1,#0x300
   \   00000054   0x4308             ORRS     R0,R1,R0
   \   00000056   0x6020             STR      R0,[R4, #+0]
    243          
    244              DSPI_SetOnePcsPolarity(base, kDSPI_Pcs0, kDSPI_PcsActiveLow);
   \   00000058   0x2201             MOVS     R2,#+1
   \   0000005A   0x2101             MOVS     R1,#+1
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0x.... 0x....      BL       DSPI_SetOnePcsPolarity
    245          
    246              temp = base->CTAR[slaveConfig->whichCtar] &
    247                     ~(SPI_CTAR_FMSZ_MASK | SPI_CTAR_CPOL_MASK | SPI_CTAR_CPHA_MASK | SPI_CTAR_LSBFE_MASK);
   \   00000062   0x7828             LDRB     R0,[R5, #+0]
   \   00000064   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000068   0x68C0             LDR      R0,[R0, #+12]
   \   0000006A   0xF030 0x40FE      BICS     R0,R0,#0x7F000000
   \   0000006E   0x0006             MOVS     R6,R0
    248          
    249              base->CTAR[slaveConfig->whichCtar] = temp | SPI_CTAR_SLAVE_FMSZ(slaveConfig->ctarConfig.bitsPerFrame - 1) |
    250                                                   SPI_CTAR_SLAVE_CPOL(slaveConfig->ctarConfig.cpol) |
    251                                                   SPI_CTAR_SLAVE_CPHA(slaveConfig->ctarConfig.cpha);
   \   00000070   0x7828             LDRB     R0,[R5, #+0]
   \   00000072   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000076   0x6869             LDR      R1,[R5, #+4]
   \   00000078   0x1E49             SUBS     R1,R1,#+1
   \   0000007A   0x06C9             LSLS     R1,R1,#+27
   \   0000007C   0xF011 0x41F0      ANDS     R1,R1,#0x78000000
   \   00000080   0x4331             ORRS     R1,R1,R6
   \   00000082   0x7A2A             LDRB     R2,[R5, #+8]
   \   00000084   0x0692             LSLS     R2,R2,#+26
   \   00000086   0xF012 0x6280      ANDS     R2,R2,#0x4000000
   \   0000008A   0x4311             ORRS     R1,R2,R1
   \   0000008C   0x7A6A             LDRB     R2,[R5, #+9]
   \   0000008E   0x0652             LSLS     R2,R2,#+25
   \   00000090   0xF012 0x7200      ANDS     R2,R2,#0x2000000
   \   00000094   0x4311             ORRS     R1,R2,R1
   \   00000096   0x60C1             STR      R1,[R0, #+12]
    252          
    253              DSPI_StartTransfer(base);
   \   00000098   0x0020             MOVS     R0,R4
   \   0000009A   0x.... 0x....      BL       DSPI_StartTransfer
    254          }
   \   0000009E   0xBD70             POP      {R4-R6,PC}       ;; return
    255          

   \                                 In section .text, align 2, keep-with-next
    256          void DSPI_SlaveGetDefaultConfig(dspi_slave_config_t *slaveConfig)
    257          {
    258              slaveConfig->whichCtar = kDSPI_Ctar0;
   \                     DSPI_SlaveGetDefaultConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7001             STRB     R1,[R0, #+0]
    259              slaveConfig->ctarConfig.bitsPerFrame = 8;
   \   00000004   0x2108             MOVS     R1,#+8
   \   00000006   0x6041             STR      R1,[R0, #+4]
    260              slaveConfig->ctarConfig.cpol = kDSPI_ClockPolarityActiveHigh;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7201             STRB     R1,[R0, #+8]
    261              slaveConfig->ctarConfig.cpha = kDSPI_ClockPhaseFirstEdge;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x7241             STRB     R1,[R0, #+9]
    262          
    263              slaveConfig->enableContinuousSCK = false;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x7301             STRB     R1,[R0, #+12]
    264              slaveConfig->enableRxFifoOverWrite = false;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x7341             STRB     R1,[R0, #+13]
    265              slaveConfig->enableModifiedTimingFormat = false;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x7381             STRB     R1,[R0, #+14]
    266              slaveConfig->samplePoint = kDSPI_SckToSin0Clock;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x73C1             STRB     R1,[R0, #+15]
    267          }
   \   00000020   0x4770             BX       LR               ;; return
    268          

   \                                 In section .text, align 2, keep-with-next
    269          void DSPI_Deinit(SPI_Type *base)
    270          {
   \                     DSPI_Deinit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    271              DSPI_StopTransfer(base);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       DSPI_StopTransfer
    272              DSPI_Enable(base, false);
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       DSPI_Enable
    273          
    274              /* disable DSPI clock */
    275              CLOCK_DisableClock(s_dspiClock[DSPI_GetInstance(base)]);
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       DSPI_GetInstance
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \   0000001C   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000020   0x.... 0x....      BL       CLOCK_DisableClock
    276          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    277          

   \                                 In section .text, align 2, keep-with-next
    278          static void DSPI_SetOnePcsPolarity(SPI_Type *base, dspi_which_pcs_t pcs, dspi_pcs_polarity_config_t activeLowOrHigh)
    279          {
   \                     DSPI_SetOnePcsPolarity: (+1)
   \   00000000   0xB410             PUSH     {R4}
    280              uint32_t temp;
    281          
    282              temp = base->MCR;
   \   00000002   0x6804             LDR      R4,[R0, #+0]
   \   00000004   0x0023             MOVS     R3,R4
    283          
    284              if (activeLowOrHigh == kDSPI_PcsActiveLow)
   \   00000006   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0x2A01             CMP      R2,#+1
   \   0000000A   0xD105             BNE.N    ??DSPI_SetOnePcsPolarity_0
    285              {
    286                  temp |= SPI_MCR_PCSIS(pcs);
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0x040C             LSLS     R4,R1,#+16
   \   00000010   0xF414 0x147C      ANDS     R4,R4,#0x3F0000
   \   00000014   0x4323             ORRS     R3,R4,R3
   \   00000016   0xE004             B.N      ??DSPI_SetOnePcsPolarity_1
    287              }
    288              else
    289              {
    290                  temp &= ~SPI_MCR_PCSIS(pcs);
   \                     ??DSPI_SetOnePcsPolarity_0: (+1)
   \   00000018   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0x040C             LSLS     R4,R1,#+16
   \   0000001C   0xF414 0x147C      ANDS     R4,R4,#0x3F0000
   \   00000020   0x43A3             BICS     R3,R3,R4
    291              }
    292          
    293              base->MCR = temp;
   \                     ??DSPI_SetOnePcsPolarity_1: (+1)
   \   00000022   0x6003             STR      R3,[R0, #+0]
    294          }
   \   00000024   0xBC10             POP      {R4}
   \   00000026   0x4770             BX       LR               ;; return
    295          

   \                                 In section .text, align 2, keep-with-next
    296          uint32_t DSPI_MasterSetBaudRate(SPI_Type *base,
    297                                          dspi_ctar_selection_t whichCtar,
    298                                          uint32_t baudRate_Bps,
    299                                          uint32_t srcClock_Hz)
    300          {
   \                     DSPI_MasterSetBaudRate: (+1)
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x001C             MOVS     R4,R3
    301              /* for master mode configuration, if slave mode detected, return 0*/
    302              if (!DSPI_IsMaster(base))
   \   00000008   0x9802             LDR      R0,[SP, #+8]
   \   0000000A   0x.... 0x....      BL       DSPI_IsMaster
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??DSPI_MasterSetBaudRate_0
    303              {
    304                  return 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE06C             B.N      ??DSPI_MasterSetBaudRate_1
    305              }
    306              uint32_t temp;
    307              uint32_t prescaler, bestPrescaler;
    308              uint32_t scaler, bestScaler;
    309              uint32_t dbr, bestDbr;
    310              uint32_t realBaudrate, bestBaudrate;
    311              uint32_t diff, min_diff;
    312              uint32_t baudrate = baudRate_Bps;
   \                     ??DSPI_MasterSetBaudRate_0: (+1)
   \   00000016   0xF8DD 0x9010      LDR      R9,[SP, #+16]
    313          
    314              /* find combination of prescaler and scaler resulting in baudrate closest to the requested value */
    315              min_diff = 0xFFFFFFFFU;
   \   0000001A   0xF05F 0x3CFF      MOVS     R12,#-1
   \   0000001E   0x46E0             MOV      R8,R12
    316              bestPrescaler = 0;
   \   00000020   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000024   0xF8CD 0xA000      STR      R10,[SP, #+0]
    317              bestScaler = 0;
   \   00000028   0xF05F 0x0C00      MOVS     R12,#+0
   \   0000002C   0x4663             MOV      R3,R12
    318              bestDbr = 1;
   \   0000002E   0xF05F 0x0C01      MOVS     R12,#+1
   \   00000032   0x4666             MOV      R6,R12
    319              bestBaudrate = 0; /* required to avoid compilation warning */
   \   00000034   0xF05F 0x0C00      MOVS     R12,#+0
   \   00000038   0x4660             MOV      R0,R12
    320          
    321              /* In all for loops, if min_diff = 0, the exit for loop*/
    322              for (prescaler = 0; (prescaler < 4) && min_diff; prescaler++)
   \   0000003A   0xF05F 0x0C00      MOVS     R12,#+0
   \   0000003E   0x4661             MOV      R1,R12
   \                     ??DSPI_MasterSetBaudRate_2: (+1)
   \   00000040   0x2904             CMP      R1,#+4
   \   00000042   0xD233             BCS.N    ??DSPI_MasterSetBaudRate_3
   \   00000044   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000048   0xD030             BEQ.N    ??DSPI_MasterSetBaudRate_3
    323              {
    324                  for (scaler = 0; (scaler < 16) && min_diff; scaler++)
   \   0000004A   0xF05F 0x0C00      MOVS     R12,#+0
   \   0000004E   0x4662             MOV      R2,R12
   \                     ??DSPI_MasterSetBaudRate_4: (+1)
   \   00000050   0x2A10             CMP      R2,#+16
   \   00000052   0xD229             BCS.N    ??DSPI_MasterSetBaudRate_5
   \   00000054   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000058   0xD026             BEQ.N    ??DSPI_MasterSetBaudRate_5
    325                  {
    326                      for (dbr = 1; (dbr < 3) && min_diff; dbr++)
   \   0000005A   0xF05F 0x0C01      MOVS     R12,#+1
   \   0000005E   0x4665             MOV      R5,R12
   \                     ??DSPI_MasterSetBaudRate_6: (+1)
   \   00000060   0x2D03             CMP      R5,#+3
   \   00000062   0xD21F             BCS.N    ??DSPI_MasterSetBaudRate_7
   \   00000064   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000068   0xD01C             BEQ.N    ??DSPI_MasterSetBaudRate_7
    327                      {
    328                          realBaudrate = ((srcClock_Hz * dbr) / (s_baudratePrescaler[prescaler] * (s_baudrateScaler[scaler])));
   \   0000006A   0xFB05 0xFC04      MUL      R12,R5,R4
   \   0000006E   0x.... 0x....      LDR.W    R10,??DataTable18
   \   00000072   0xF85A 0xA021      LDR      R10,[R10, R1, LSL #+2]
   \   00000076   0x.... 0x....      LDR.W    R11,??DataTable18_1
   \   0000007A   0xF85B 0xB022      LDR      R11,[R11, R2, LSL #+2]
   \   0000007E   0xFB0B 0xFA0A      MUL      R10,R11,R10
   \   00000082   0xFBBC 0xFCFA      UDIV     R12,R12,R10
   \   00000086   0x4667             MOV      R7,R12
    329          
    330                          /* calculate the baud rate difference based on the conditional statement that states that the calculated
    331                          * baud rate must not exceed the desired baud rate.
    332                          */
    333                          if (baudrate >= realBaudrate)
   \   00000088   0x45B9             CMP      R9,R7
   \   0000008A   0xD309             BCC.N    ??DSPI_MasterSetBaudRate_8
    334                          {
    335                              diff = baudrate - realBaudrate;
   \   0000008C   0xEBB9 0x0C07      SUBS     R12,R9,R7
   \   00000090   0x46E6             MOV      LR,R12
    336                              if (min_diff > diff)
   \   00000092   0x45C6             CMP      LR,R8
   \   00000094   0xD204             BCS.N    ??DSPI_MasterSetBaudRate_8
    337                              {
    338                                  /* a better match found */
    339                                  min_diff = diff;
   \   00000096   0x46F0             MOV      R8,LR
    340                                  bestPrescaler = prescaler;
   \   00000098   0x9100             STR      R1,[SP, #+0]
    341                                  bestScaler = scaler;
   \   0000009A   0x0013             MOVS     R3,R2
    342                                  bestBaudrate = realBaudrate;
   \   0000009C   0x0038             MOVS     R0,R7
    343                                  bestDbr = dbr;
   \   0000009E   0x002E             MOVS     R6,R5
    344                              }
    345                          }
    346                      }
   \                     ??DSPI_MasterSetBaudRate_8: (+1)
   \   000000A0   0x1C6D             ADDS     R5,R5,#+1
   \   000000A2   0xE7DD             B.N      ??DSPI_MasterSetBaudRate_6
    347                  }
   \                     ??DSPI_MasterSetBaudRate_7: (+1)
   \   000000A4   0x1C52             ADDS     R2,R2,#+1
   \   000000A6   0xE7D3             B.N      ??DSPI_MasterSetBaudRate_4
    348              }
   \                     ??DSPI_MasterSetBaudRate_5: (+1)
   \   000000A8   0x1C49             ADDS     R1,R1,#+1
   \   000000AA   0xE7C9             B.N      ??DSPI_MasterSetBaudRate_2
    349          
    350              /* write the best dbr, prescalar, and baud rate scalar to the CTAR */
    351              temp = base->CTAR[whichCtar] & ~(SPI_CTAR_DBR_MASK | SPI_CTAR_PBR_MASK | SPI_CTAR_BR_MASK);
   \                     ??DSPI_MasterSetBaudRate_3: (+1)
   \   000000AC   0xF8DD 0xC008      LDR      R12,[SP, #+8]
   \   000000B0   0xF89D 0xA00C      LDRB     R10,[SP, #+12]
   \   000000B4   0xEB0C 0x0C8A      ADD      R12,R12,R10, LSL #+2
   \   000000B8   0xF8DC 0xC00C      LDR      R12,[R12, #+12]
   \   000000BC   0x.... 0x....      LDR.W    R10,??DataTable18_2  ;; 0x7ffcfff0
   \   000000C0   0xEA1A 0x0A0C      ANDS     R10,R10,R12
   \   000000C4   0xF8CD 0xA004      STR      R10,[SP, #+4]
    352          
    353              base->CTAR[whichCtar] = temp | ((bestDbr - 1) << SPI_CTAR_DBR_SHIFT) | (bestPrescaler << SPI_CTAR_PBR_SHIFT) |
    354                                      (bestScaler << SPI_CTAR_BR_SHIFT);
   \   000000C8   0xF8DD 0xC004      LDR      R12,[SP, #+4]
   \   000000CC   0xF1B6 0x0A01      SUBS     R10,R6,#+1
   \   000000D0   0xEA5C 0x7CCA      ORRS     R12,R12,R10, LSL #+31
   \   000000D4   0xF8DD 0xA000      LDR      R10,[SP, #+0]
   \   000000D8   0xEA5C 0x4C0A      ORRS     R12,R12,R10, LSL #+16
   \   000000DC   0xEA53 0x0C0C      ORRS     R12,R3,R12
   \   000000E0   0xF8DD 0xA008      LDR      R10,[SP, #+8]
   \   000000E4   0xF89D 0xB00C      LDRB     R11,[SP, #+12]
   \   000000E8   0xEB0A 0x0A8B      ADD      R10,R10,R11, LSL #+2
   \   000000EC   0xF8CA 0xC00C      STR      R12,[R10, #+12]
    355          
    356              /* return the actual calculated baud rate */
    357              return bestBaudrate;
   \                     ??DSPI_MasterSetBaudRate_1: (+1)
   \   000000F0   0xB005             ADD      SP,SP,#+20
   \   000000F2   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    358          }
    359          

   \                                 In section .text, align 2, keep-with-next
    360          void DSPI_MasterSetDelayScaler(
    361              SPI_Type *base, dspi_ctar_selection_t whichCtar, uint32_t prescaler, uint32_t scaler, dspi_delay_type_t whichDelay)
    362          {
   \                     DSPI_MasterSetDelayScaler: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x4698             MOV      R8,R3
   \   0000000C   0x9C06             LDR      R4,[SP, #+24]
    363              /* these settings are only relevant in master mode */
    364              if (DSPI_IsMaster(base))
   \   0000000E   0x0028             MOVS     R0,R5
   \   00000010   0x.... 0x....      BL       DSPI_IsMaster
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD046             BEQ.N    ??DSPI_MasterSetDelayScaler_0
    365              {
    366                  switch (whichDelay)
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x2C01             CMP      R4,#+1
   \   0000001C   0xD004             BEQ.N    ??DSPI_MasterSetDelayScaler_1
   \   0000001E   0xD342             BCC.N    ??DSPI_MasterSetDelayScaler_2
   \   00000020   0x2C03             CMP      R4,#+3
   \   00000022   0xD02B             BEQ.N    ??DSPI_MasterSetDelayScaler_3
   \   00000024   0xD315             BCC.N    ??DSPI_MasterSetDelayScaler_4
   \   00000026   0xE03E             B.N      ??DSPI_MasterSetDelayScaler_2
    367                  {
    368                      case kDSPI_PcsToSck:
    369                          base->CTAR[whichCtar] = (base->CTAR[whichCtar] & (~SPI_CTAR_PCSSCK_MASK) & (~SPI_CTAR_CSSCK_MASK)) |
    370                                                  SPI_CTAR_PCSSCK(prescaler) | SPI_CTAR_CSSCK(scaler);
   \                     ??DSPI_MasterSetDelayScaler_1: (+1)
   \   00000028   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002A   0xEB05 0x0086      ADD      R0,R5,R6, LSL #+2
   \   0000002E   0x68C0             LDR      R0,[R0, #+12]
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable18_3  ;; 0xff3f0fff
   \   00000034   0x4008             ANDS     R0,R1,R0
   \   00000036   0x05B9             LSLS     R1,R7,#+22
   \   00000038   0xF411 0x0140      ANDS     R1,R1,#0xC00000
   \   0000003C   0x4308             ORRS     R0,R1,R0
   \   0000003E   0xEA5F 0x3108      LSLS     R1,R8,#+12
   \   00000042   0xF411 0x4170      ANDS     R1,R1,#0xF000
   \   00000046   0x4308             ORRS     R0,R1,R0
   \   00000048   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004A   0xEB05 0x0186      ADD      R1,R5,R6, LSL #+2
   \   0000004E   0x60C8             STR      R0,[R1, #+12]
    371                          break;
   \   00000050   0xE029             B.N      ??DSPI_MasterSetDelayScaler_0
    372                      case kDSPI_LastSckToPcs:
    373                          base->CTAR[whichCtar] = (base->CTAR[whichCtar] & (~SPI_CTAR_PASC_MASK) & (~SPI_CTAR_ASC_MASK)) |
    374                                                  SPI_CTAR_PASC(prescaler) | SPI_CTAR_ASC(scaler);
   \                     ??DSPI_MasterSetDelayScaler_4: (+1)
   \   00000052   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000054   0xEB05 0x0086      ADD      R0,R5,R6, LSL #+2
   \   00000058   0x68C0             LDR      R0,[R0, #+12]
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable18_4  ;; 0xffcff0ff
   \   0000005E   0x4008             ANDS     R0,R1,R0
   \   00000060   0x0539             LSLS     R1,R7,#+20
   \   00000062   0xF411 0x1140      ANDS     R1,R1,#0x300000
   \   00000066   0x4308             ORRS     R0,R1,R0
   \   00000068   0xEA5F 0x2108      LSLS     R1,R8,#+8
   \   0000006C   0xF411 0x6170      ANDS     R1,R1,#0xF00
   \   00000070   0x4308             ORRS     R0,R1,R0
   \   00000072   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000074   0xEB05 0x0186      ADD      R1,R5,R6, LSL #+2
   \   00000078   0x60C8             STR      R0,[R1, #+12]
    375                          break;
   \   0000007A   0xE014             B.N      ??DSPI_MasterSetDelayScaler_0
    376                      case kDSPI_BetweenTransfer:
    377                          base->CTAR[whichCtar] = (base->CTAR[whichCtar] & (~SPI_CTAR_PDT_MASK) & (~SPI_CTAR_DT_MASK)) |
    378                                                  SPI_CTAR_PDT(prescaler) | SPI_CTAR_DT(scaler);
   \                     ??DSPI_MasterSetDelayScaler_3: (+1)
   \   0000007C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007E   0xEB05 0x0086      ADD      R0,R5,R6, LSL #+2
   \   00000082   0x68C0             LDR      R0,[R0, #+12]
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable18_5  ;; 0xfff3ff0f
   \   00000088   0x4008             ANDS     R0,R1,R0
   \   0000008A   0x04B9             LSLS     R1,R7,#+18
   \   0000008C   0xF411 0x2140      ANDS     R1,R1,#0xC0000
   \   00000090   0x4308             ORRS     R0,R1,R0
   \   00000092   0xEA5F 0x1108      LSLS     R1,R8,#+4
   \   00000096   0xF011 0x01F0      ANDS     R1,R1,#0xF0
   \   0000009A   0x4308             ORRS     R0,R1,R0
   \   0000009C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009E   0xEB05 0x0186      ADD      R1,R5,R6, LSL #+2
   \   000000A2   0x60C8             STR      R0,[R1, #+12]
    379                          break;
   \   000000A4   0xE7FF             B.N      ??DSPI_MasterSetDelayScaler_0
    380                      default:
    381                          break;
    382                  }
    383              }
    384          }
   \                     ??DSPI_MasterSetDelayScaler_2: (+1)
   \                     ??DSPI_MasterSetDelayScaler_0: (+1)
   \   000000A6   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    385          

   \                                 In section .text, align 2, keep-with-next
    386          uint32_t DSPI_MasterSetDelayTimes(SPI_Type *base,
    387                                            dspi_ctar_selection_t whichCtar,
    388                                            dspi_delay_type_t whichDelay,
    389                                            uint32_t srcClock_Hz,
    390                                            uint32_t delayTimeInNanoSec)
    391          {
   \                     DSPI_MasterSetDelayTimes: (+1)
   \   00000000   0xE92D 0x4FF6      PUSH     {R1,R2,R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x001D             MOVS     R5,R3
   \   0000000A   0x9E10             LDR      R6,[SP, #+64]
    392              /* for master mode configuration, if slave mode detected, return 0 */
    393              if (!DSPI_IsMaster(base))
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       DSPI_IsMaster
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD101             BNE.N    ??DSPI_MasterSetDelayTimes_0
    394              {
    395                  return 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE069             B.N      ??DSPI_MasterSetDelayTimes_1
    396              }
    397          
    398              uint32_t prescaler, bestPrescaler;
    399              uint32_t scaler, bestScaler;
    400              uint32_t realDelay, bestDelay;
    401              uint32_t diff, min_diff;
    402              uint32_t initialDelayNanoSec;
    403          
    404              /* find combination of prescaler and scaler resulting in the delay closest to the
    405              * requested value
    406              */
    407              min_diff = 0xFFFFFFFFU;
   \                     ??DSPI_MasterSetDelayTimes_0: (+1)
   \   0000001A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000001E   0x4683             MOV      R11,R0
    408              /* Initialize prescaler and scaler to their max values to generate the max delay */
    409              bestPrescaler = 0x3;
   \   00000020   0x2003             MOVS     R0,#+3
   \   00000022   0x9002             STR      R0,[SP, #+8]
    410              bestScaler = 0xF;
   \   00000024   0x200F             MOVS     R0,#+15
   \   00000026   0x9001             STR      R0,[SP, #+4]
    411              bestDelay = (((1000000000U * 4) / srcClock_Hz) * s_delayPrescaler[bestPrescaler] * s_delayScaler[bestScaler]) / 4;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0xee6b2800
   \   0000002C   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable19_1
   \   00000034   0x9A02             LDR      R2,[SP, #+8]
   \   00000036   0xF851 0x1022      LDR      R1,[R1, R2, LSL #+2]
   \   0000003A   0x4348             MULS     R0,R1,R0
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable21
   \   00000040   0x9A01             LDR      R2,[SP, #+4]
   \   00000042   0xF851 0x1022      LDR      R1,[R1, R2, LSL #+2]
   \   00000046   0x4348             MULS     R0,R1,R0
   \   00000048   0x0880             LSRS     R0,R0,#+2
   \   0000004A   0x9004             STR      R0,[SP, #+16]
    412          
    413              /* First calculate the initial, default delay */
    414              initialDelayNanoSec = 1000000000U / srcClock_Hz * 2;
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x3b9aca00
   \   00000050   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \   00000054   0x0040             LSLS     R0,R0,#+1
   \   00000056   0x9003             STR      R0,[SP, #+12]
    415          
    416              /* If the initial, default delay is already greater than the desired delay, then
    417              * set the delays to their initial value (0) and return the delay. In other words,
    418              * there is no way to decrease the delay value further.
    419              */
    420              if (initialDelayNanoSec >= delayTimeInNanoSec)
   \   00000058   0x9803             LDR      R0,[SP, #+12]
   \   0000005A   0x42B0             CMP      R0,R6
   \   0000005C   0xD30B             BCC.N    ??DSPI_MasterSetDelayTimes_2
    421              {
    422                  DSPI_MasterSetDelayScaler(base, whichCtar, 0, 0, whichDelay);
   \   0000005E   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   00000062   0x9000             STR      R0,[SP, #+0]
   \   00000064   0x2300             MOVS     R3,#+0
   \   00000066   0x2200             MOVS     R2,#+0
   \   00000068   0xF89D 0x1014      LDRB     R1,[SP, #+20]
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       DSPI_MasterSetDelayScaler
    423                  return initialDelayNanoSec;
   \   00000072   0x9803             LDR      R0,[SP, #+12]
   \   00000074   0xE03B             B.N      ??DSPI_MasterSetDelayTimes_1
    424              }
    425          
    426              /* In all for loops, if min_diff = 0, the exit for loop */
    427              for (prescaler = 0; (prescaler < 4) && min_diff; prescaler++)
   \                     ??DSPI_MasterSetDelayTimes_2: (+1)
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x0007             MOVS     R7,R0
   \                     ??DSPI_MasterSetDelayTimes_3: (+1)
   \   0000007A   0x2F04             CMP      R7,#+4
   \   0000007C   0xD22C             BCS.N    ??DSPI_MasterSetDelayTimes_4
   \   0000007E   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000082   0xD029             BEQ.N    ??DSPI_MasterSetDelayTimes_4
    428              {
    429                  for (scaler = 0; (scaler < 16) && min_diff; scaler++)
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x4680             MOV      R8,R0
   \                     ??DSPI_MasterSetDelayTimes_5: (+1)
   \   00000088   0xF1B8 0x0F10      CMP      R8,#+16
   \   0000008C   0xD222             BCS.N    ??DSPI_MasterSetDelayTimes_6
   \   0000008E   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000092   0xD01F             BEQ.N    ??DSPI_MasterSetDelayTimes_6
    430                  {
    431                      realDelay = ((4000000000U / srcClock_Hz) * s_delayPrescaler[prescaler] * s_delayScaler[scaler]) / 4;
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0xee6b2800
   \   00000098   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable19_1
   \   000000A0   0xF851 0x1027      LDR      R1,[R1, R7, LSL #+2]
   \   000000A4   0x4348             MULS     R0,R1,R0
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable21
   \   000000AA   0xF851 0x1028      LDR      R1,[R1, R8, LSL #+2]
   \   000000AE   0x4348             MULS     R0,R1,R0
   \   000000B0   0x0880             LSRS     R0,R0,#+2
   \   000000B2   0x4681             MOV      R9,R0
    432          
    433                      /* calculate the delay difference based on the conditional statement
    434                      * that states that the calculated delay must not be less then the desired delay
    435                      */
    436                      if (realDelay >= delayTimeInNanoSec)
   \   000000B4   0x45B1             CMP      R9,R6
   \   000000B6   0xD30A             BCC.N    ??DSPI_MasterSetDelayTimes_7
    437                      {
    438                          diff = realDelay - delayTimeInNanoSec;
   \   000000B8   0xEBB9 0x0006      SUBS     R0,R9,R6
   \   000000BC   0x4682             MOV      R10,R0
    439                          if (min_diff > diff)
   \   000000BE   0x45DA             CMP      R10,R11
   \   000000C0   0xD205             BCS.N    ??DSPI_MasterSetDelayTimes_7
    440                          {
    441                              /* a better match found */
    442                              min_diff = diff;
   \   000000C2   0x46D3             MOV      R11,R10
    443                              bestPrescaler = prescaler;
   \   000000C4   0x9702             STR      R7,[SP, #+8]
    444                              bestScaler = scaler;
   \   000000C6   0xF8CD 0x8004      STR      R8,[SP, #+4]
    445                              bestDelay = realDelay;
   \   000000CA   0xF8CD 0x9010      STR      R9,[SP, #+16]
    446                          }
    447                      }
    448                  }
   \                     ??DSPI_MasterSetDelayTimes_7: (+1)
   \   000000CE   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000D2   0xE7D9             B.N      ??DSPI_MasterSetDelayTimes_5
    449              }
   \                     ??DSPI_MasterSetDelayTimes_6: (+1)
   \   000000D4   0x1C7F             ADDS     R7,R7,#+1
   \   000000D6   0xE7D0             B.N      ??DSPI_MasterSetDelayTimes_3
    450          
    451              /* write the best dbr, prescalar, and baud rate scalar to the CTAR */
    452              DSPI_MasterSetDelayScaler(base, whichCtar, bestPrescaler, bestScaler, whichDelay);
   \                     ??DSPI_MasterSetDelayTimes_4: (+1)
   \   000000D8   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   000000DC   0x9000             STR      R0,[SP, #+0]
   \   000000DE   0x9B01             LDR      R3,[SP, #+4]
   \   000000E0   0x9A02             LDR      R2,[SP, #+8]
   \   000000E2   0xF89D 0x1014      LDRB     R1,[SP, #+20]
   \   000000E6   0x0020             MOVS     R0,R4
   \   000000E8   0x.... 0x....      BL       DSPI_MasterSetDelayScaler
    453          
    454              /* return the actual calculated baud rate */
    455              return bestDelay;
   \   000000EC   0x9804             LDR      R0,[SP, #+16]
   \                     ??DSPI_MasterSetDelayTimes_1: (+1)
   \   000000EE   0xB007             ADD      SP,SP,#+28
   \   000000F0   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    456          }
    457          

   \                                 In section .text, align 2, keep-with-next
    458          void DSPI_GetDefaultDataCommandConfig(dspi_command_data_config_t *command)
    459          {
    460              command->isPcsContinuous = false;
   \                     DSPI_GetDefaultDataCommandConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7001             STRB     R1,[R0, #+0]
    461              command->whichCtar = kDSPI_Ctar0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7041             STRB     R1,[R0, #+1]
    462              command->whichPcs = kDSPI_Pcs0;
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x7081             STRB     R1,[R0, #+2]
    463              command->isEndOfQueue = false;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x70C1             STRB     R1,[R0, #+3]
    464              command->clearTransferCount = false;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x7101             STRB     R1,[R0, #+4]
    465          }
   \   00000014   0x4770             BX       LR               ;; return
    466          

   \                                 In section .text, align 2, keep-with-next
    467          void DSPI_MasterWriteDataBlocking(SPI_Type *base, dspi_command_data_config_t *command, uint16_t data)
    468          {
   \                     DSPI_MasterWriteDataBlocking: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    469              /* First, clear Transmit Complete Flag (TCF) */
    470              DSPI_ClearStatusFlags(base, kDSPI_TxCompleteFlag);
   \   00000008   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       DSPI_ClearStatusFlags
    471          
    472              while (!(DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag))
   \                     ??DSPI_MasterWriteDataBlocking_0: (+1)
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   00000018   0x0180             LSLS     R0,R0,#+6
   \   0000001A   0xD405             BMI.N    ??DSPI_MasterWriteDataBlocking_1
    473              {
    474                  DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \   0000001C   0xF05F 0x7100      MOVS     R1,#+33554432
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       DSPI_ClearStatusFlags
   \   00000026   0xE7F4             B.N      ??DSPI_MasterWriteDataBlocking_0
    475              }
    476          
    477              base->PUSHR = SPI_PUSHR_CONT(command->isPcsContinuous) | SPI_PUSHR_CTAS(command->whichCtar) |
    478                            SPI_PUSHR_PCS(command->whichPcs) | SPI_PUSHR_EOQ(command->isEndOfQueue) |
    479                            SPI_PUSHR_CTCNT(command->clearTransferCount) | SPI_PUSHR_TXDATA(data);
   \                     ??DSPI_MasterWriteDataBlocking_1: (+1)
   \   00000028   0x7828             LDRB     R0,[R5, #+0]
   \   0000002A   0x7869             LDRB     R1,[R5, #+1]
   \   0000002C   0x0709             LSLS     R1,R1,#+28
   \   0000002E   0xF011 0x41E0      ANDS     R1,R1,#0x70000000
   \   00000032   0xEA51 0x70C0      ORRS     R0,R1,R0, LSL #+31
   \   00000036   0x78A9             LDRB     R1,[R5, #+2]
   \   00000038   0x0409             LSLS     R1,R1,#+16
   \   0000003A   0xF411 0x117C      ANDS     R1,R1,#0x3F0000
   \   0000003E   0x4308             ORRS     R0,R1,R0
   \   00000040   0x78E9             LDRB     R1,[R5, #+3]
   \   00000042   0xEA50 0x60C1      ORRS     R0,R0,R1, LSL #+27
   \   00000046   0x7929             LDRB     R1,[R5, #+4]
   \   00000048   0xEA50 0x6081      ORRS     R0,R0,R1, LSL #+26
   \   0000004C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000004E   0x4330             ORRS     R0,R6,R0
   \   00000050   0x6360             STR      R0,[R4, #+52]
    480              DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \   00000052   0xF05F 0x7100      MOVS     R1,#+33554432
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      BL       DSPI_ClearStatusFlags
    481          
    482              /* Wait till TCF sets */
    483              while (!(DSPI_GetStatusFlags(base) & kDSPI_TxCompleteFlag))
   \                     ??DSPI_MasterWriteDataBlocking_2: (+1)
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD5FA             BPL.N    ??DSPI_MasterWriteDataBlocking_2
    484              {
    485              }
    486          }
   \   00000066   0xBD70             POP      {R4-R6,PC}       ;; return
    487          

   \                                 In section .text, align 2, keep-with-next
    488          void DSPI_MasterWriteCommandDataBlocking(SPI_Type *base, uint32_t data)
    489          {
   \                     DSPI_MasterWriteCommandDataBlocking: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    490              /* First, clear Transmit Complete Flag (TCF) */
    491              DSPI_ClearStatusFlags(base, kDSPI_TxCompleteFlag);
   \   00000006   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       DSPI_ClearStatusFlags
    492          
    493              while (!(DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag))
   \                     ??DSPI_MasterWriteCommandDataBlocking_0: (+1)
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   00000016   0x0180             LSLS     R0,R0,#+6
   \   00000018   0xD405             BMI.N    ??DSPI_MasterWriteCommandDataBlocking_1
    494              {
    495                  DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \   0000001A   0xF05F 0x7100      MOVS     R1,#+33554432
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       DSPI_ClearStatusFlags
   \   00000024   0xE7F4             B.N      ??DSPI_MasterWriteCommandDataBlocking_0
    496              }
    497          
    498              base->PUSHR = data;
   \                     ??DSPI_MasterWriteCommandDataBlocking_1: (+1)
   \   00000026   0x6365             STR      R5,[R4, #+52]
    499          
    500              DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \   00000028   0xF05F 0x7100      MOVS     R1,#+33554432
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       DSPI_ClearStatusFlags
    501          
    502              /* Wait till TCF sets */
    503              while (!(DSPI_GetStatusFlags(base) & kDSPI_TxCompleteFlag))
   \                     ??DSPI_MasterWriteCommandDataBlocking_2: (+1)
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD5FA             BPL.N    ??DSPI_MasterWriteCommandDataBlocking_2
    504              {
    505              }
    506          }
   \   0000003C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    507          

   \                                 In section .text, align 2, keep-with-next
    508          void DSPI_SlaveWriteDataBlocking(SPI_Type *base, uint32_t data)
    509          {
   \                     DSPI_SlaveWriteDataBlocking: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    510              /* First, clear Transmit Complete Flag (TCF) */
    511              DSPI_ClearStatusFlags(base, kDSPI_TxCompleteFlag);
   \   00000006   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       DSPI_ClearStatusFlags
    512          
    513              while (!(DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag))
   \                     ??DSPI_SlaveWriteDataBlocking_0: (+1)
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   00000016   0x0180             LSLS     R0,R0,#+6
   \   00000018   0xD405             BMI.N    ??DSPI_SlaveWriteDataBlocking_1
    514              {
    515                  DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \   0000001A   0xF05F 0x7100      MOVS     R1,#+33554432
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       DSPI_ClearStatusFlags
   \   00000024   0xE7F4             B.N      ??DSPI_SlaveWriteDataBlocking_0
    516              }
    517          
    518              base->PUSHR_SLAVE = data;
   \                     ??DSPI_SlaveWriteDataBlocking_1: (+1)
   \   00000026   0x6365             STR      R5,[R4, #+52]
    519          
    520              DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \   00000028   0xF05F 0x7100      MOVS     R1,#+33554432
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       DSPI_ClearStatusFlags
    521          
    522              /* Wait till TCF sets */
    523              while (!(DSPI_GetStatusFlags(base) & kDSPI_TxCompleteFlag))
   \                     ??DSPI_SlaveWriteDataBlocking_2: (+1)
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD5FA             BPL.N    ??DSPI_SlaveWriteDataBlocking_2
    524              {
    525              }
    526          }
   \   0000003C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    527          

   \                                 In section .text, align 2, keep-with-next
    528          void DSPI_EnableInterrupts(SPI_Type *base, uint32_t mask)
    529          {
    530              if (mask & SPI_RSER_TFFF_RE_MASK)
   \                     DSPI_EnableInterrupts: (+1)
   \   00000000   0x018A             LSLS     R2,R1,#+6
   \   00000002   0xD503             BPL.N    ??DSPI_EnableInterrupts_0
    531              {
    532                  base->RSER &= ~SPI_RSER_TFFF_DIRS_MASK;
   \   00000004   0x6B02             LDR      R2,[R0, #+48]
   \   00000006   0xF032 0x7280      BICS     R2,R2,#0x1000000
   \   0000000A   0x6302             STR      R2,[R0, #+48]
    533              }
    534              if (mask & SPI_RSER_RFDF_RE_MASK)
   \                     ??DSPI_EnableInterrupts_0: (+1)
   \   0000000C   0x038A             LSLS     R2,R1,#+14
   \   0000000E   0xD503             BPL.N    ??DSPI_EnableInterrupts_1
    535              {
    536                  base->RSER &= ~SPI_RSER_RFDF_DIRS_MASK;
   \   00000010   0x6B02             LDR      R2,[R0, #+48]
   \   00000012   0xF432 0x3280      BICS     R2,R2,#0x10000
   \   00000016   0x6302             STR      R2,[R0, #+48]
    537              }
    538              base->RSER |= mask;
   \                     ??DSPI_EnableInterrupts_1: (+1)
   \   00000018   0x6B02             LDR      R2,[R0, #+48]
   \   0000001A   0x430A             ORRS     R2,R1,R2
   \   0000001C   0x6302             STR      R2,[R0, #+48]
    539          }
   \   0000001E   0x4770             BX       LR               ;; return
    540          
    541          /*Transactional APIs -- Master*/
    542          

   \                                 In section .text, align 2, keep-with-next
    543          void DSPI_MasterTransferCreateHandle(SPI_Type *base,
    544                                               dspi_master_handle_t *handle,
    545                                               dspi_master_transfer_callback_t callback,
    546                                               void *userData)
    547          {
   \                     DSPI_MasterTransferCreateHandle: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    548              assert(handle);
    549          
    550              /* Zero the handle. */
    551              memset(handle, 0, sizeof(*handle));
   \   0000000C   0xF05F 0x0830      MOVS     R8,#+48
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
   \   00000014   0x464A             MOV      R2,R9
   \   00000016   0x4641             MOV      R1,R8
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       __aeabi_memset
    552          
    553              g_dspiHandle[DSPI_GetInstance(base)] = handle;
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       DSPI_GetInstance
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable22
   \   00000028   0xF841 0x5020      STR      R5,[R1, R0, LSL #+2]
    554          
    555              handle->callback = callback;
   \   0000002C   0x62AE             STR      R6,[R5, #+40]
    556              handle->userData = userData;
   \   0000002E   0x62EF             STR      R7,[R5, #+44]
    557          }
   \   00000030   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    558          

   \                                 In section .text, align 2, keep-with-next
    559          status_t DSPI_MasterTransferBlocking(SPI_Type *base, dspi_transfer_t *transfer)
    560          {
   \                     DSPI_MasterTransferBlocking: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    561              assert(transfer);
    562          
    563              uint16_t wordToSend = 0;
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
    564              uint16_t wordReceived = 0;
   \   0000000E   0xF05F 0x0B00      MOVS     R11,#+0
    565              uint8_t dummyData = DSPI_MASTER_DUMMY_DATA;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF88D 0x0000      STRB     R0,[SP, #+0]
    566              uint8_t bitsPerFrame;
    567          
    568              uint32_t command;
    569              uint32_t lastCommand;
    570          
    571              uint8_t *txData;
    572              uint8_t *rxData;
    573              uint32_t remainingSendByteCount;
    574              uint32_t remainingReceiveByteCount;
    575          
    576              uint32_t fifoSize;
    577              dspi_command_data_config_t commandStruct;
    578          
    579              /* If the transfer count is zero, then return immediately.*/
    580              if (transfer->dataSize == 0)
   \   00000018   0x68A8             LDR      R0,[R5, #+8]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD101             BNE.N    ??DSPI_MasterTransferBlocking_0
    581              {
    582                  return kStatus_InvalidArgument;
   \   0000001E   0x2004             MOVS     R0,#+4
   \   00000020   0xE1C3             B.N      ??DSPI_MasterTransferBlocking_1
    583              }
    584          
    585              DSPI_StopTransfer(base);
   \                     ??DSPI_MasterTransferBlocking_0: (+1)
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       DSPI_StopTransfer
    586              DSPI_DisableInterrupts(base, kDSPI_AllInterruptEnable);
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable22_1  ;; 0x9a0a0000
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       DSPI_DisableInterrupts
    587              DSPI_FlushFifo(base, true, true);
   \   00000032   0x2201             MOVS     R2,#+1
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       DSPI_FlushFifo
    588              DSPI_ClearStatusFlags(base, kDSPI_AllStatusFlag);
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable22_2  ;; 0xda0a0000
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       DSPI_ClearStatusFlags
    589          
    590              /*Calculate the command and lastCommand*/
    591              commandStruct.whichPcs =
    592                  (dspi_which_pcs_t)(1U << ((transfer->configFlags & DSPI_MASTER_PCS_MASK) >> DSPI_MASTER_PCS_SHIFT));
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x68E9             LDR      R1,[R5, #+12]
   \   0000004A   0xF3C1 0x1103      UBFX     R1,R1,#+4,#+4
   \   0000004E   0x4088             LSLS     R0,R0,R1
   \   00000050   0xF88D 0x0006      STRB     R0,[SP, #+6]
    593              commandStruct.isEndOfQueue = false;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF88D 0x0007      STRB     R0,[SP, #+7]
    594              commandStruct.clearTransferCount = false;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF88D 0x0008      STRB     R0,[SP, #+8]
    595              commandStruct.whichCtar =
    596                  (dspi_ctar_selection_t)((transfer->configFlags & DSPI_MASTER_CTAR_MASK) >> DSPI_MASTER_CTAR_SHIFT);
   \   00000060   0x7B28             LDRB     R0,[R5, #+12]
   \   00000062   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000066   0xF88D 0x0005      STRB     R0,[SP, #+5]
    597              commandStruct.isPcsContinuous = (bool)(transfer->configFlags & kDSPI_MasterPcsContinuous);
   \   0000006A   0x68E8             LDR      R0,[R5, #+12]
   \   0000006C   0x0D00             LSRS     R0,R0,#+20
   \   0000006E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000072   0xF88D 0x0004      STRB     R0,[SP, #+4]
    598          
    599              command = DSPI_MasterGetFormattedCommand(&(commandStruct));
   \   00000076   0xA801             ADD      R0,SP,#+4
   \   00000078   0x.... 0x....      BL       DSPI_MasterGetFormattedCommand
   \   0000007C   0x9005             STR      R0,[SP, #+20]
    600          
    601              commandStruct.isPcsContinuous = (bool)(transfer->configFlags & kDSPI_MasterActiveAfterTransfer);
   \   0000007E   0x68E8             LDR      R0,[R5, #+12]
   \   00000080   0x0D40             LSRS     R0,R0,#+21
   \   00000082   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000086   0xF88D 0x0004      STRB     R0,[SP, #+4]
    602              lastCommand = DSPI_MasterGetFormattedCommand(&(commandStruct));
   \   0000008A   0xA801             ADD      R0,SP,#+4
   \   0000008C   0x.... 0x....      BL       DSPI_MasterGetFormattedCommand
   \   00000090   0x9004             STR      R0,[SP, #+16]
    603          
    604              /*Calculate the bitsPerFrame*/
    605              bitsPerFrame = ((base->CTAR[commandStruct.whichCtar] & SPI_CTAR_FMSZ_MASK) >> SPI_CTAR_FMSZ_SHIFT) + 1;
   \   00000092   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   00000096   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   0000009A   0x68C0             LDR      R0,[R0, #+12]
   \   0000009C   0x0EC0             LSRS     R0,R0,#+27
   \   0000009E   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   000000A2   0x1C40             ADDS     R0,R0,#+1
   \   000000A4   0xF88D 0x0001      STRB     R0,[SP, #+1]
    606          
    607              txData = transfer->txData;
   \   000000A8   0x6828             LDR      R0,[R5, #+0]
   \   000000AA   0x4681             MOV      R9,R0
    608              rxData = transfer->rxData;
   \   000000AC   0x6868             LDR      R0,[R5, #+4]
   \   000000AE   0x4682             MOV      R10,R0
    609              remainingSendByteCount = transfer->dataSize;
   \   000000B0   0x68A8             LDR      R0,[R5, #+8]
   \   000000B2   0x0006             MOVS     R6,R0
    610              remainingReceiveByteCount = transfer->dataSize;
   \   000000B4   0x68A8             LDR      R0,[R5, #+8]
   \   000000B6   0x0007             MOVS     R7,R0
    611          
    612              if ((base->MCR & SPI_MCR_DIS_RXF_MASK) || (base->MCR & SPI_MCR_DIS_TXF_MASK))
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x04C0             LSLS     R0,R0,#+19
   \   000000BC   0xD402             BMI.N    ??DSPI_MasterTransferBlocking_2
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x0480             LSLS     R0,R0,#+18
   \   000000C2   0xD502             BPL.N    ??DSPI_MasterTransferBlocking_3
    613              {
    614                  fifoSize = 1;
   \                     ??DSPI_MasterTransferBlocking_2: (+1)
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0x9003             STR      R0,[SP, #+12]
   \   000000C8   0xE003             B.N      ??DSPI_MasterTransferBlocking_4
    615              }
    616              else
    617              {
    618                  fifoSize = FSL_FEATURE_DSPI_FIFO_SIZEn(base);
                                    ^
Warning[Pe223]: function "FSL_FEATURE_DSPI_FIFO_SIZEn" declared implicitly
   \                     ??DSPI_MasterTransferBlocking_3: (+1)
   \   000000CA   0x0020             MOVS     R0,R4
   \   000000CC   0x.... 0x....      BL       FSL_FEATURE_DSPI_FIFO_SIZEn
   \   000000D0   0x9003             STR      R0,[SP, #+12]
    619              }
    620          
    621              DSPI_StartTransfer(base);
   \                     ??DSPI_MasterTransferBlocking_4: (+1)
   \   000000D2   0x0020             MOVS     R0,R4
   \   000000D4   0x.... 0x....      BL       DSPI_StartTransfer
    622          
    623              if (bitsPerFrame <= 8)
   \   000000D8   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000000DC   0x2809             CMP      R0,#+9
   \   000000DE   0xF280 0x809C      BGE.W    ??DSPI_MasterTransferBlocking_5
    624              {
    625                  while (remainingSendByteCount > 0)
   \                     ??DSPI_MasterTransferBlocking_6: (+1)
   \   000000E2   0x2E00             CMP      R6,#+0
   \   000000E4   0xF000 0x8160      BEQ.W    ??DSPI_MasterTransferBlocking_7
    626                  {
    627                      if (remainingSendByteCount == 1)
   \   000000E8   0x2E01             CMP      R6,#+1
   \   000000EA   0xD15A             BNE.N    ??DSPI_MasterTransferBlocking_8
    628                      {
    629                          while ((remainingReceiveByteCount - remainingSendByteCount) >= fifoSize)
   \                     ??DSPI_MasterTransferBlocking_9: (+1)
   \   000000EC   0x1BB8             SUBS     R0,R7,R6
   \   000000EE   0x9903             LDR      R1,[SP, #+12]
   \   000000F0   0x4288             CMP      R0,R1
   \   000000F2   0xD319             BCC.N    ??DSPI_MasterTransferBlocking_10
    630                          {
    631                              if (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
   \   000000F4   0x0020             MOVS     R0,R4
   \   000000F6   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   000000FA   0x0380             LSLS     R0,R0,#+14
   \   000000FC   0xD5F6             BPL.N    ??DSPI_MasterTransferBlocking_9
    632                              {
    633                                  if (rxData != NULL)
   \   000000FE   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000102   0xD007             BEQ.N    ??DSPI_MasterTransferBlocking_11
    634                                  {
    635                                      *(rxData) = DSPI_ReadData(base);
   \   00000104   0x0020             MOVS     R0,R4
   \   00000106   0x.... 0x....      BL       DSPI_ReadData
   \   0000010A   0xF88A 0x0000      STRB     R0,[R10, #+0]
    636                                      rxData++;
   \   0000010E   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   00000112   0xE002             B.N      ??DSPI_MasterTransferBlocking_12
    637                                  }
    638                                  else
    639                                  {
    640                                      DSPI_ReadData(base);
   \                     ??DSPI_MasterTransferBlocking_11: (+1)
   \   00000114   0x0020             MOVS     R0,R4
   \   00000116   0x.... 0x....      BL       DSPI_ReadData
    641                                  }
    642                                  remainingReceiveByteCount--;
   \                     ??DSPI_MasterTransferBlocking_12: (+1)
   \   0000011A   0x1E7F             SUBS     R7,R7,#+1
    643          
    644                                  DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
   \   0000011C   0xF45F 0x3100      MOVS     R1,#+131072
   \   00000120   0x0020             MOVS     R0,R4
   \   00000122   0x.... 0x....      BL       DSPI_ClearStatusFlags
   \   00000126   0xE7E1             B.N      ??DSPI_MasterTransferBlocking_9
    645                              }
    646                          }
    647          
    648                          while (!(DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag))
   \                     ??DSPI_MasterTransferBlocking_10: (+1)
   \   00000128   0x0020             MOVS     R0,R4
   \   0000012A   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   0000012E   0x0180             LSLS     R0,R0,#+6
   \   00000130   0xD405             BMI.N    ??DSPI_MasterTransferBlocking_13
    649                          {
    650                              DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \   00000132   0xF05F 0x7100      MOVS     R1,#+33554432
   \   00000136   0x0020             MOVS     R0,R4
   \   00000138   0x.... 0x....      BL       DSPI_ClearStatusFlags
   \   0000013C   0xE7F4             B.N      ??DSPI_MasterTransferBlocking_10
    651                          }
    652          
    653                          if (txData != NULL)
   \                     ??DSPI_MasterTransferBlocking_13: (+1)
   \   0000013E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000142   0xD007             BEQ.N    ??DSPI_MasterTransferBlocking_14
    654                          {
    655                              base->PUSHR = (*txData) | (lastCommand);
   \   00000144   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000148   0x9904             LDR      R1,[SP, #+16]
   \   0000014A   0x4308             ORRS     R0,R1,R0
   \   0000014C   0x6360             STR      R0,[R4, #+52]
    656                              txData++;
   \   0000014E   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000152   0xE004             B.N      ??DSPI_MasterTransferBlocking_15
    657                          }
    658                          else
    659                          {
    660                              base->PUSHR = (lastCommand) | (dummyData);
   \                     ??DSPI_MasterTransferBlocking_14: (+1)
   \   00000154   0x9804             LDR      R0,[SP, #+16]
   \   00000156   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000015A   0x4308             ORRS     R0,R1,R0
   \   0000015C   0x6360             STR      R0,[R4, #+52]
    661                          }
    662                          DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \                     ??DSPI_MasterTransferBlocking_15: (+1)
   \   0000015E   0xF05F 0x7100      MOVS     R1,#+33554432
   \   00000162   0x0020             MOVS     R0,R4
   \   00000164   0x.... 0x....      BL       DSPI_ClearStatusFlags
    663                          remainingSendByteCount--;
   \   00000168   0x1E76             SUBS     R6,R6,#+1
    664          
    665                          while (remainingReceiveByteCount > 0)
   \                     ??DSPI_MasterTransferBlocking_16: (+1)
   \   0000016A   0x2F00             CMP      R7,#+0
   \   0000016C   0xD0B9             BEQ.N    ??DSPI_MasterTransferBlocking_6
    666                          {
    667                              if (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
   \   0000016E   0x0020             MOVS     R0,R4
   \   00000170   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   00000174   0x0380             LSLS     R0,R0,#+14
   \   00000176   0xD5F8             BPL.N    ??DSPI_MasterTransferBlocking_16
    668                              {
    669                                  if (rxData != NULL)
   \   00000178   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000017C   0xD007             BEQ.N    ??DSPI_MasterTransferBlocking_17
    670                                  {
    671                                      /* Read data from POPR*/
    672                                      *(rxData) = DSPI_ReadData(base);
   \   0000017E   0x0020             MOVS     R0,R4
   \   00000180   0x.... 0x....      BL       DSPI_ReadData
   \   00000184   0xF88A 0x0000      STRB     R0,[R10, #+0]
    673                                      rxData++;
   \   00000188   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   0000018C   0xE002             B.N      ??DSPI_MasterTransferBlocking_18
    674                                  }
    675                                  else
    676                                  {
    677                                      DSPI_ReadData(base);
   \                     ??DSPI_MasterTransferBlocking_17: (+1)
   \   0000018E   0x0020             MOVS     R0,R4
   \   00000190   0x.... 0x....      BL       DSPI_ReadData
    678                                  }
    679                                  remainingReceiveByteCount--;
   \                     ??DSPI_MasterTransferBlocking_18: (+1)
   \   00000194   0x1E7F             SUBS     R7,R7,#+1
    680          
    681                                  DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
   \   00000196   0xF45F 0x3100      MOVS     R1,#+131072
   \   0000019A   0x0020             MOVS     R0,R4
   \   0000019C   0x.... 0x....      BL       DSPI_ClearStatusFlags
   \   000001A0   0xE7E3             B.N      ??DSPI_MasterTransferBlocking_16
    682                              }
    683                          }
    684                      }
    685                      else
    686                      {
    687                          /*Wait until Tx Fifo is not full*/
    688                          while (!(DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag))
   \                     ??DSPI_MasterTransferBlocking_8: (+1)
   \   000001A2   0x0020             MOVS     R0,R4
   \   000001A4   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   000001A8   0x0180             LSLS     R0,R0,#+6
   \   000001AA   0xD405             BMI.N    ??DSPI_MasterTransferBlocking_19
    689                          {
    690                              DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \   000001AC   0xF05F 0x7100      MOVS     R1,#+33554432
   \   000001B0   0x0020             MOVS     R0,R4
   \   000001B2   0x.... 0x....      BL       DSPI_ClearStatusFlags
   \   000001B6   0xE7F4             B.N      ??DSPI_MasterTransferBlocking_8
    691                          }
    692                          if (txData != NULL)
   \                     ??DSPI_MasterTransferBlocking_19: (+1)
   \   000001B8   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001BC   0xD007             BEQ.N    ??DSPI_MasterTransferBlocking_20
    693                          {
    694                              base->PUSHR = command | (uint16_t)(*txData);
   \   000001BE   0x9805             LDR      R0,[SP, #+20]
   \   000001C0   0xF899 0x1000      LDRB     R1,[R9, #+0]
   \   000001C4   0x4308             ORRS     R0,R1,R0
   \   000001C6   0x6360             STR      R0,[R4, #+52]
    695                              txData++;
   \   000001C8   0xF119 0x0901      ADDS     R9,R9,#+1
   \   000001CC   0xE004             B.N      ??DSPI_MasterTransferBlocking_21
    696                          }
    697                          else
    698                          {
    699                              base->PUSHR = command | dummyData;
   \                     ??DSPI_MasterTransferBlocking_20: (+1)
   \   000001CE   0x9805             LDR      R0,[SP, #+20]
   \   000001D0   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000001D4   0x4308             ORRS     R0,R1,R0
   \   000001D6   0x6360             STR      R0,[R4, #+52]
    700                          }
    701                          remainingSendByteCount--;
   \                     ??DSPI_MasterTransferBlocking_21: (+1)
   \   000001D8   0x1E76             SUBS     R6,R6,#+1
    702          
    703                          DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \   000001DA   0xF05F 0x7100      MOVS     R1,#+33554432
   \   000001DE   0x0020             MOVS     R0,R4
   \   000001E0   0x.... 0x....      BL       DSPI_ClearStatusFlags
    704          
    705                          if (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
   \   000001E4   0x0020             MOVS     R0,R4
   \   000001E6   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   000001EA   0x0380             LSLS     R0,R0,#+14
   \   000001EC   0xF57F 0xAF79      BPL.W    ??DSPI_MasterTransferBlocking_6
    706                          {
    707                              if (rxData != NULL)
   \   000001F0   0xF1BA 0x0F00      CMP      R10,#+0
   \   000001F4   0xD007             BEQ.N    ??DSPI_MasterTransferBlocking_22
    708                              {
    709                                  *(rxData) = DSPI_ReadData(base);
   \   000001F6   0x0020             MOVS     R0,R4
   \   000001F8   0x.... 0x....      BL       DSPI_ReadData
   \   000001FC   0xF88A 0x0000      STRB     R0,[R10, #+0]
    710                                  rxData++;
   \   00000200   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   00000204   0xE002             B.N      ??DSPI_MasterTransferBlocking_23
    711                              }
    712                              else
    713                              {
    714                                  DSPI_ReadData(base);
   \                     ??DSPI_MasterTransferBlocking_22: (+1)
   \   00000206   0x0020             MOVS     R0,R4
   \   00000208   0x.... 0x....      BL       DSPI_ReadData
    715                              }
    716                              remainingReceiveByteCount--;
   \                     ??DSPI_MasterTransferBlocking_23: (+1)
   \   0000020C   0x1E7F             SUBS     R7,R7,#+1
    717          
    718                              DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
   \   0000020E   0xF45F 0x3100      MOVS     R1,#+131072
   \   00000212   0x0020             MOVS     R0,R4
   \   00000214   0x.... 0x....      BL       DSPI_ClearStatusFlags
   \   00000218   0xE763             B.N      ??DSPI_MasterTransferBlocking_6
    719                          }
    720                      }
    721                  }
    722              }
    723              else
    724              {
    725                  while (remainingSendByteCount > 0)
   \                     ??DSPI_MasterTransferBlocking_5: (+1)
   \   0000021A   0x2E00             CMP      R6,#+0
   \   0000021C   0xF000 0x80C4      BEQ.W    ??DSPI_MasterTransferBlocking_7
    726                  {
    727                      if (remainingSendByteCount <= 2)
   \   00000220   0x2E03             CMP      R6,#+3
   \   00000222   0xD279             BCS.N    ??DSPI_MasterTransferBlocking_24
    728                      {
    729                          while (((remainingReceiveByteCount - remainingSendByteCount) / 2) >= fifoSize)
   \                     ??DSPI_MasterTransferBlocking_25: (+1)
   \   00000224   0x1BB8             SUBS     R0,R7,R6
   \   00000226   0x0840             LSRS     R0,R0,#+1
   \   00000228   0x9903             LDR      R1,[SP, #+12]
   \   0000022A   0x4288             CMP      R0,R1
   \   0000022C   0xD31D             BCC.N    ??DSPI_MasterTransferBlocking_26
    730                          {
    731                              if (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
   \   0000022E   0x0020             MOVS     R0,R4
   \   00000230   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   00000234   0x0380             LSLS     R0,R0,#+14
   \   00000236   0xD5F5             BPL.N    ??DSPI_MasterTransferBlocking_25
    732                              {
    733                                  wordReceived = DSPI_ReadData(base);
   \   00000238   0x0020             MOVS     R0,R4
   \   0000023A   0x.... 0x....      BL       DSPI_ReadData
   \   0000023E   0x4683             MOV      R11,R0
    734          
    735                                  if (rxData != NULL)
   \   00000240   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000244   0xD00A             BEQ.N    ??DSPI_MasterTransferBlocking_27
    736                                  {
    737                                      *rxData = wordReceived;
   \   00000246   0xF88A 0xB000      STRB     R11,[R10, #+0]
    738                                      ++rxData;
   \   0000024A   0xF11A 0x0A01      ADDS     R10,R10,#+1
    739                                      *rxData = wordReceived >> 8;
   \   0000024E   0x4658             MOV      R0,R11
   \   00000250   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000252   0x0A00             LSRS     R0,R0,#+8
   \   00000254   0xF88A 0x0000      STRB     R0,[R10, #+0]
    740                                      ++rxData;
   \   00000258   0xF11A 0x0A01      ADDS     R10,R10,#+1
    741                                  }
    742                                  remainingReceiveByteCount -= 2;
   \                     ??DSPI_MasterTransferBlocking_27: (+1)
   \   0000025C   0x1EBF             SUBS     R7,R7,#+2
    743          
    744                                  DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
   \   0000025E   0xF45F 0x3100      MOVS     R1,#+131072
   \   00000262   0x0020             MOVS     R0,R4
   \   00000264   0x.... 0x....      BL       DSPI_ClearStatusFlags
   \   00000268   0xE7DC             B.N      ??DSPI_MasterTransferBlocking_25
    745                              }
    746                          }
    747          
    748                          while (!(DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag))
   \                     ??DSPI_MasterTransferBlocking_26: (+1)
   \   0000026A   0x0020             MOVS     R0,R4
   \   0000026C   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   00000270   0x0180             LSLS     R0,R0,#+6
   \   00000272   0xD405             BMI.N    ??DSPI_MasterTransferBlocking_28
    749                          {
    750                              DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \   00000274   0xF05F 0x7100      MOVS     R1,#+33554432
   \   00000278   0x0020             MOVS     R0,R4
   \   0000027A   0x.... 0x....      BL       DSPI_ClearStatusFlags
   \   0000027E   0xE7F4             B.N      ??DSPI_MasterTransferBlocking_26
    751                          }
    752          
    753                          if (txData != NULL)
   \                     ??DSPI_MasterTransferBlocking_28: (+1)
   \   00000280   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000284   0xD00D             BEQ.N    ??DSPI_MasterTransferBlocking_29
    754                          {
    755                              wordToSend = *(txData);
   \   00000286   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   0000028A   0x4680             MOV      R8,R0
    756                              ++txData;
   \   0000028C   0xF119 0x0901      ADDS     R9,R9,#+1
    757          
    758                              if (remainingSendByteCount > 1)
   \   00000290   0x2E02             CMP      R6,#+2
   \   00000292   0xD309             BCC.N    ??DSPI_MasterTransferBlocking_30
    759                              {
    760                                  wordToSend |= (unsigned)(*(txData)) << 8U;
   \   00000294   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000298   0xEA58 0x2800      ORRS     R8,R8,R0, LSL #+8
    761                                  ++txData;
   \   0000029C   0xF119 0x0901      ADDS     R9,R9,#+1
   \   000002A0   0xE002             B.N      ??DSPI_MasterTransferBlocking_30
    762                              }
    763                          }
    764                          else
    765                          {
    766                              wordToSend = dummyData;
   \                     ??DSPI_MasterTransferBlocking_29: (+1)
   \   000002A2   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000002A6   0x4680             MOV      R8,R0
    767                          }
    768          
    769                          base->PUSHR = lastCommand | wordToSend;
   \                     ??DSPI_MasterTransferBlocking_30: (+1)
   \   000002A8   0x9804             LDR      R0,[SP, #+16]
   \   000002AA   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000002AE   0xEA58 0x0000      ORRS     R0,R8,R0
   \   000002B2   0x6360             STR      R0,[R4, #+52]
    770          
    771                          DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \   000002B4   0xF05F 0x7100      MOVS     R1,#+33554432
   \   000002B8   0x0020             MOVS     R0,R4
   \   000002BA   0x.... 0x....      BL       DSPI_ClearStatusFlags
    772                          remainingSendByteCount = 0;
   \   000002BE   0x2000             MOVS     R0,#+0
   \   000002C0   0x0006             MOVS     R6,R0
    773          
    774                          while (remainingReceiveByteCount > 0)
   \                     ??DSPI_MasterTransferBlocking_31: (+1)
   \   000002C2   0x2F00             CMP      R7,#+0
   \   000002C4   0xD0A9             BEQ.N    ??DSPI_MasterTransferBlocking_5
    775                          {
    776                              if (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
   \   000002C6   0x0020             MOVS     R0,R4
   \   000002C8   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   000002CC   0x0380             LSLS     R0,R0,#+14
   \   000002CE   0xD5F8             BPL.N    ??DSPI_MasterTransferBlocking_31
    777                              {
    778                                  wordReceived = DSPI_ReadData(base);
   \   000002D0   0x0020             MOVS     R0,R4
   \   000002D2   0x.... 0x....      BL       DSPI_ReadData
   \   000002D6   0x4683             MOV      R11,R0
    779          
    780                                  if (remainingReceiveByteCount != 1)
   \   000002D8   0x2F01             CMP      R7,#+1
   \   000002DA   0xD00F             BEQ.N    ??DSPI_MasterTransferBlocking_32
    781                                  {
    782                                      if (rxData != NULL)
   \   000002DC   0xF1BA 0x0F00      CMP      R10,#+0
   \   000002E0   0xD00A             BEQ.N    ??DSPI_MasterTransferBlocking_33
    783                                      {
    784                                          *(rxData) = wordReceived;
   \   000002E2   0xF88A 0xB000      STRB     R11,[R10, #+0]
    785                                          ++rxData;
   \   000002E6   0xF11A 0x0A01      ADDS     R10,R10,#+1
    786                                          *(rxData) = wordReceived >> 8;
   \   000002EA   0x4658             MOV      R0,R11
   \   000002EC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000002EE   0x0A00             LSRS     R0,R0,#+8
   \   000002F0   0xF88A 0x0000      STRB     R0,[R10, #+0]
    787                                          ++rxData;
   \   000002F4   0xF11A 0x0A01      ADDS     R10,R10,#+1
    788                                      }
    789                                      remainingReceiveByteCount -= 2;
   \                     ??DSPI_MasterTransferBlocking_33: (+1)
   \   000002F8   0x1EBF             SUBS     R7,R7,#+2
   \   000002FA   0xE007             B.N      ??DSPI_MasterTransferBlocking_34
    790                                  }
    791                                  else
    792                                  {
    793                                      if (rxData != NULL)
   \                     ??DSPI_MasterTransferBlocking_32: (+1)
   \   000002FC   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000300   0xD003             BEQ.N    ??DSPI_MasterTransferBlocking_35
    794                                      {
    795                                          *(rxData) = wordReceived;
   \   00000302   0xF88A 0xB000      STRB     R11,[R10, #+0]
    796                                          ++rxData;
   \   00000306   0xF11A 0x0A01      ADDS     R10,R10,#+1
    797                                      }
    798                                      remainingReceiveByteCount--;
   \                     ??DSPI_MasterTransferBlocking_35: (+1)
   \   0000030A   0x1E7F             SUBS     R7,R7,#+1
    799                                  }
    800                                  DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
   \                     ??DSPI_MasterTransferBlocking_34: (+1)
   \   0000030C   0xF45F 0x3100      MOVS     R1,#+131072
   \   00000310   0x0020             MOVS     R0,R4
   \   00000312   0x.... 0x....      BL       DSPI_ClearStatusFlags
   \   00000316   0xE7D4             B.N      ??DSPI_MasterTransferBlocking_31
    801                              }
    802                          }
    803                      }
    804                      else
    805                      {
    806                          /*Wait until Tx Fifo is not full*/
    807                          while (!(DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag))
   \                     ??DSPI_MasterTransferBlocking_24: (+1)
   \   00000318   0x0020             MOVS     R0,R4
   \   0000031A   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   0000031E   0x0180             LSLS     R0,R0,#+6
   \   00000320   0xD405             BMI.N    ??DSPI_MasterTransferBlocking_36
    808                          {
    809                              DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \   00000322   0xF05F 0x7100      MOVS     R1,#+33554432
   \   00000326   0x0020             MOVS     R0,R4
   \   00000328   0x.... 0x....      BL       DSPI_ClearStatusFlags
   \   0000032C   0xE7F4             B.N      ??DSPI_MasterTransferBlocking_24
    810                          }
    811          
    812                          if (txData != NULL)
   \                     ??DSPI_MasterTransferBlocking_36: (+1)
   \   0000032E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000332   0xD00B             BEQ.N    ??DSPI_MasterTransferBlocking_37
    813                          {
    814                              wordToSend = *(txData);
   \   00000334   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000338   0x4680             MOV      R8,R0
    815                              ++txData;
   \   0000033A   0xF119 0x0901      ADDS     R9,R9,#+1
    816                              wordToSend |= (unsigned)(*(txData)) << 8U;
   \   0000033E   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000342   0xEA58 0x2800      ORRS     R8,R8,R0, LSL #+8
    817                              ++txData;
   \   00000346   0xF119 0x0901      ADDS     R9,R9,#+1
   \   0000034A   0xE002             B.N      ??DSPI_MasterTransferBlocking_38
    818                          }
    819                          else
    820                          {
    821                              wordToSend = dummyData;
   \                     ??DSPI_MasterTransferBlocking_37: (+1)
   \   0000034C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000350   0x4680             MOV      R8,R0
    822                          }
    823                          base->PUSHR = command | wordToSend;
   \                     ??DSPI_MasterTransferBlocking_38: (+1)
   \   00000352   0x9805             LDR      R0,[SP, #+20]
   \   00000354   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000358   0xEA58 0x0000      ORRS     R0,R8,R0
   \   0000035C   0x6360             STR      R0,[R4, #+52]
    824                          remainingSendByteCount -= 2;
   \   0000035E   0x1EB6             SUBS     R6,R6,#+2
    825          
    826                          DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \   00000360   0xF05F 0x7100      MOVS     R1,#+33554432
   \   00000364   0x0020             MOVS     R0,R4
   \   00000366   0x.... 0x....      BL       DSPI_ClearStatusFlags
    827          
    828                          if (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
   \   0000036A   0x0020             MOVS     R0,R4
   \   0000036C   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   00000370   0x0380             LSLS     R0,R0,#+14
   \   00000372   0xF57F 0xAF52      BPL.W    ??DSPI_MasterTransferBlocking_5
    829                          {
    830                              wordReceived = DSPI_ReadData(base);
   \   00000376   0x0020             MOVS     R0,R4
   \   00000378   0x.... 0x....      BL       DSPI_ReadData
   \   0000037C   0x4683             MOV      R11,R0
    831          
    832                              if (rxData != NULL)
   \   0000037E   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000382   0xD00A             BEQ.N    ??DSPI_MasterTransferBlocking_39
    833                              {
    834                                  *rxData = wordReceived;
   \   00000384   0xF88A 0xB000      STRB     R11,[R10, #+0]
    835                                  ++rxData;
   \   00000388   0xF11A 0x0A01      ADDS     R10,R10,#+1
    836                                  *rxData = wordReceived >> 8;
   \   0000038C   0x4658             MOV      R0,R11
   \   0000038E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000390   0x0A00             LSRS     R0,R0,#+8
   \   00000392   0xF88A 0x0000      STRB     R0,[R10, #+0]
    837                                  ++rxData;
   \   00000396   0xF11A 0x0A01      ADDS     R10,R10,#+1
    838                              }
    839                              remainingReceiveByteCount -= 2;
   \                     ??DSPI_MasterTransferBlocking_39: (+1)
   \   0000039A   0x1EBF             SUBS     R7,R7,#+2
    840          
    841                              DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
   \   0000039C   0xF45F 0x3100      MOVS     R1,#+131072
   \   000003A0   0x0020             MOVS     R0,R4
   \   000003A2   0x.... 0x....      BL       DSPI_ClearStatusFlags
   \   000003A6   0xE738             B.N      ??DSPI_MasterTransferBlocking_5
    842                          }
    843                      }
    844                  }
    845              }
    846          
    847              return kStatus_Success;
   \                     ??DSPI_MasterTransferBlocking_7: (+1)
   \   000003A8   0x2000             MOVS     R0,#+0
   \                     ??DSPI_MasterTransferBlocking_1: (+1)
   \   000003AA   0xB007             ADD      SP,SP,#+28
   \   000003AC   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    848          }
    849          

   \                                 In section .text, align 2, keep-with-next
    850          static void DSPI_MasterPrepareTransfer(SPI_Type *base, dspi_master_handle_t *handle, dspi_transfer_t *transfer)
    851          {
   \                     DSPI_MasterPrepareTransfer: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    852              dspi_command_data_config_t commandStruct;
    853          
    854              DSPI_StopTransfer(base);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       DSPI_StopTransfer
    855              DSPI_FlushFifo(base, true, true);
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       DSPI_FlushFifo
    856              DSPI_ClearStatusFlags(base, kDSPI_AllStatusFlag);
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable22_2  ;; 0xda0a0000
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       DSPI_ClearStatusFlags
    857          
    858              commandStruct.whichPcs =
    859                  (dspi_which_pcs_t)(1U << ((transfer->configFlags & DSPI_MASTER_PCS_MASK) >> DSPI_MASTER_PCS_SHIFT));
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x68F1             LDR      R1,[R6, #+12]
   \   00000026   0xF3C1 0x1103      UBFX     R1,R1,#+4,#+4
   \   0000002A   0x4088             LSLS     R0,R0,R1
   \   0000002C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    860              commandStruct.isEndOfQueue = false;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF88D 0x0003      STRB     R0,[SP, #+3]
    861              commandStruct.clearTransferCount = false;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xF88D 0x0004      STRB     R0,[SP, #+4]
    862              commandStruct.whichCtar =
    863                  (dspi_ctar_selection_t)((transfer->configFlags & DSPI_MASTER_CTAR_MASK) >> DSPI_MASTER_CTAR_SHIFT);
   \   0000003C   0x7B30             LDRB     R0,[R6, #+12]
   \   0000003E   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000042   0xF88D 0x0001      STRB     R0,[SP, #+1]
    864              commandStruct.isPcsContinuous = (bool)(transfer->configFlags & kDSPI_MasterPcsContinuous);
   \   00000046   0x68F0             LDR      R0,[R6, #+12]
   \   00000048   0x0D00             LSRS     R0,R0,#+20
   \   0000004A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000004E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    865              handle->command = DSPI_MasterGetFormattedCommand(&(commandStruct));
   \   00000052   0x4668             MOV      R0,SP
   \   00000054   0x.... 0x....      BL       DSPI_MasterGetFormattedCommand
   \   00000058   0x6068             STR      R0,[R5, #+4]
    866          
    867              commandStruct.isPcsContinuous = (bool)(transfer->configFlags & kDSPI_MasterActiveAfterTransfer);
   \   0000005A   0x68F0             LDR      R0,[R6, #+12]
   \   0000005C   0x0D40             LSRS     R0,R0,#+21
   \   0000005E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000062   0xF88D 0x0000      STRB     R0,[SP, #+0]
    868              handle->lastCommand = DSPI_MasterGetFormattedCommand(&(commandStruct));
   \   00000066   0x4668             MOV      R0,SP
   \   00000068   0x.... 0x....      BL       DSPI_MasterGetFormattedCommand
   \   0000006C   0x60A8             STR      R0,[R5, #+8]
    869          
    870              handle->bitsPerFrame = ((base->CTAR[commandStruct.whichCtar] & SPI_CTAR_FMSZ_MASK) >> SPI_CTAR_FMSZ_SHIFT) + 1;
   \   0000006E   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000072   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000076   0x68C0             LDR      R0,[R0, #+12]
   \   00000078   0xF3C0 0x60C3      UBFX     R0,R0,#+27,#+4
   \   0000007C   0x1C40             ADDS     R0,R0,#+1
   \   0000007E   0x6028             STR      R0,[R5, #+0]
    871          
    872              if ((base->MCR & SPI_MCR_DIS_RXF_MASK) || (base->MCR & SPI_MCR_DIS_TXF_MASK))
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x04C0             LSLS     R0,R0,#+19
   \   00000084   0xD402             BMI.N    ??DSPI_MasterPrepareTransfer_0
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x0480             LSLS     R0,R0,#+18
   \   0000008A   0xD502             BPL.N    ??DSPI_MasterPrepareTransfer_1
    873              {
    874                  handle->fifoSize = 1;
   \                     ??DSPI_MasterPrepareTransfer_0: (+1)
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0x7328             STRB     R0,[R5, #+12]
   \   00000090   0xE003             B.N      ??DSPI_MasterPrepareTransfer_2
    875              }
    876              else
    877              {
    878                  handle->fifoSize = FSL_FEATURE_DSPI_FIFO_SIZEn(base);
                                            ^
Warning[Pe223]: function "FSL_FEATURE_DSPI_FIFO_SIZEn" declared implicitly
   \                     ??DSPI_MasterPrepareTransfer_1: (+1)
   \   00000092   0x0020             MOVS     R0,R4
   \   00000094   0x.... 0x....      BL       FSL_FEATURE_DSPI_FIFO_SIZEn
   \   00000098   0x7328             STRB     R0,[R5, #+12]
    879              }
    880              handle->txData = transfer->txData;
   \                     ??DSPI_MasterPrepareTransfer_2: (+1)
   \   0000009A   0x6830             LDR      R0,[R6, #+0]
   \   0000009C   0x6128             STR      R0,[R5, #+16]
    881              handle->rxData = transfer->rxData;
   \   0000009E   0x6870             LDR      R0,[R6, #+4]
   \   000000A0   0x6168             STR      R0,[R5, #+20]
    882              handle->remainingSendByteCount = transfer->dataSize;
   \   000000A2   0x68B0             LDR      R0,[R6, #+8]
   \   000000A4   0x61A8             STR      R0,[R5, #+24]
    883              handle->remainingReceiveByteCount = transfer->dataSize;
   \   000000A6   0x68B0             LDR      R0,[R6, #+8]
   \   000000A8   0x61E8             STR      R0,[R5, #+28]
    884              handle->totalByteCount = transfer->dataSize;
   \   000000AA   0x68B0             LDR      R0,[R6, #+8]
   \   000000AC   0x6228             STR      R0,[R5, #+32]
    885          }
   \   000000AE   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    886          

   \                                 In section .text, align 2, keep-with-next
    887          status_t DSPI_MasterTransferNonBlocking(SPI_Type *base, dspi_master_handle_t *handle, dspi_transfer_t *transfer)
    888          {
   \                     DSPI_MasterTransferNonBlocking: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    889              assert(handle && transfer);
    890          
    891              /* If the transfer count is zero, then return immediately.*/
    892              if (transfer->dataSize == 0)
   \   00000008   0x68B0             LDR      R0,[R6, #+8]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??DSPI_MasterTransferNonBlocking_0
    893              {
    894                  return kStatus_InvalidArgument;
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0xE028             B.N      ??DSPI_MasterTransferNonBlocking_1
    895              }
    896          
    897              /* Check that we're not busy.*/
    898              if (handle->state == kDSPI_Busy)
   \                     ??DSPI_MasterTransferNonBlocking_0: (+1)
   \   00000012   0xF895 0x0024      LDRB     R0,[R5, #+36]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD102             BNE.N    ??DSPI_MasterTransferNonBlocking_2
    899              {
    900                  return kStatus_DSPI_Busy;
   \   0000001A   0xF44F 0x7016      MOV      R0,#+600
   \   0000001E   0xE021             B.N      ??DSPI_MasterTransferNonBlocking_1
    901              }
    902          
    903              handle->state = kDSPI_Busy;
   \                     ??DSPI_MasterTransferNonBlocking_2: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xF885 0x0024      STRB     R0,[R5, #+36]
    904          
    905              DSPI_MasterPrepareTransfer(base, handle, transfer);
   \   00000026   0x0032             MOVS     R2,R6
   \   00000028   0x0029             MOVS     R1,R5
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       DSPI_MasterPrepareTransfer
    906              DSPI_StartTransfer(base);
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       DSPI_StartTransfer
    907          
    908              /* Enable the NVIC for DSPI peripheral. */
    909              EnableIRQ(s_dspiIRQ[DSPI_GetInstance(base)]);
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       DSPI_GetInstance
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable22_3
   \   00000040   0x5608             LDRSB    R0,[R1, R0]
   \   00000042   0x.... 0x....      BL       EnableIRQ
    910          
    911              DSPI_MasterFillUpTxFifo(base, handle);
   \   00000046   0x0029             MOVS     R1,R5
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       DSPI_MasterFillUpTxFifo
    912          
    913              /* RX FIFO Drain request: RFDF_RE to enable RFDF interrupt
    914              * Since SPI is a synchronous interface, we only need to enable the RX interrupt.
    915              * The IRQ handler will get the status of RX and TX interrupt flags.
    916              */
    917              s_dspiMasterIsr = DSPI_MasterTransferHandleIRQ;
   \   0000004E   0x.... 0x....      ADR.W    R0,DSPI_MasterTransferHandleIRQ
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable22_4
   \   00000056   0x6008             STR      R0,[R1, #+0]
    918          
    919              DSPI_EnableInterrupts(base, kDSPI_RxFifoDrainRequestInterruptEnable);
   \   00000058   0xF45F 0x3100      MOVS     R1,#+131072
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0x.... 0x....      BL       DSPI_EnableInterrupts
    920          
    921              return kStatus_Success;
   \   00000062   0x2000             MOVS     R0,#+0
   \                     ??DSPI_MasterTransferNonBlocking_1: (+1)
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
    922          }
    923          

   \                                 In section .text, align 2, keep-with-next
    924          status_t DSPI_MasterTransferGetCount(SPI_Type *base, dspi_master_handle_t *handle, size_t *count)
    925          {
   \                     DSPI_MasterTransferGetCount: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0003             MOVS     R3,R0
    926              assert(handle);
    927          
    928              if (!count)
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD101             BNE.N    ??DSPI_MasterTransferGetCount_0
    929              {
    930                  return kStatus_InvalidArgument;
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0xE00C             B.N      ??DSPI_MasterTransferGetCount_1
    931              }
    932          
    933              /* Catch when there is not an active transfer. */
    934              if (handle->state != kDSPI_Busy)
   \                     ??DSPI_MasterTransferGetCount_0: (+1)
   \   0000000C   0xF891 0x0024      LDRB     R0,[R1, #+36]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD003             BEQ.N    ??DSPI_MasterTransferGetCount_2
    935              {
    936                  *count = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x6010             STR      R0,[R2, #+0]
    937                  return kStatus_NoTransferInProgress;
   \   00000018   0x2006             MOVS     R0,#+6
   \   0000001A   0xE004             B.N      ??DSPI_MasterTransferGetCount_1
    938              }
    939          
    940              *count = handle->totalByteCount - handle->remainingReceiveByteCount;
   \                     ??DSPI_MasterTransferGetCount_2: (+1)
   \   0000001C   0x6A08             LDR      R0,[R1, #+32]
   \   0000001E   0x69CC             LDR      R4,[R1, #+28]
   \   00000020   0x1B00             SUBS     R0,R0,R4
   \   00000022   0x6010             STR      R0,[R2, #+0]
    941              return kStatus_Success;
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??DSPI_MasterTransferGetCount_1: (+1)
   \   00000026   0xBC10             POP      {R4}
   \   00000028   0x4770             BX       LR               ;; return
    942          }
    943          

   \                                 In section .text, align 2, keep-with-next
    944          static void DSPI_MasterCompleteTransfer(SPI_Type *base, dspi_master_handle_t *handle)
    945          {
   \                     DSPI_MasterCompleteTransfer: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    946              /* Disable interrupt requests*/
    947              DSPI_DisableInterrupts(base, kDSPI_RxFifoDrainRequestInterruptEnable | kDSPI_TxFifoFillRequestInterruptEnable);
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable22_5  ;; 0x2020000
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       DSPI_DisableInterrupts
    948          
    949              status_t status = 0;
   \   00000010   0x2600             MOVS     R6,#+0
    950              if (handle->state == kDSPI_Error)
   \   00000012   0xF895 0x0024      LDRB     R0,[R5, #+36]
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD103             BNE.N    ??DSPI_MasterCompleteTransfer_0
    951              {
    952                  status = kStatus_DSPI_Error;
   \   0000001A   0xF240 0x2059      MOVW     R0,#+601
   \   0000001E   0x0006             MOVS     R6,R0
   \   00000020   0xE001             B.N      ??DSPI_MasterCompleteTransfer_1
    953              }
    954              else
    955              {
    956                  status = kStatus_Success;
   \                     ??DSPI_MasterCompleteTransfer_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x0006             MOVS     R6,R0
    957              }
    958          
    959              if (handle->callback)
   \                     ??DSPI_MasterCompleteTransfer_1: (+1)
   \   00000026   0x6AA8             LDR      R0,[R5, #+40]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD005             BEQ.N    ??DSPI_MasterCompleteTransfer_2
    960              {
    961                  handle->callback(base, handle, status, handle->userData);
   \   0000002C   0x6AEB             LDR      R3,[R5, #+44]
   \   0000002E   0x0032             MOVS     R2,R6
   \   00000030   0x0029             MOVS     R1,R5
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x6AAF             LDR      R7,[R5, #+40]
   \   00000036   0x47B8             BLX      R7
    962              }
    963          
    964              /* The transfer is complete.*/
    965              handle->state = kDSPI_Idle;
   \                     ??DSPI_MasterCompleteTransfer_2: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xF885 0x0024      STRB     R0,[R5, #+36]
    966          }
   \   0000003E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    967          

   \                                 In section .text, align 2, keep-with-next
    968          static void DSPI_MasterFillUpTxFifo(SPI_Type *base, dspi_master_handle_t *handle)
    969          {
   \                     DSPI_MasterFillUpTxFifo: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    970              uint16_t wordToSend = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    971              uint8_t dummyData = DSPI_MASTER_DUMMY_DATA;
   \   00000008   0x2700             MOVS     R7,#+0
    972          
    973              /* If bits/frame is greater than one byte */
    974              if (handle->bitsPerFrame > 8)
   \   0000000A   0x6828             LDR      R0,[R5, #+0]
   \   0000000C   0x2809             CMP      R0,#+9
   \   0000000E   0xD34F             BCC.N    ??DSPI_MasterFillUpTxFifo_0
    975              {
    976                  /* Fill the fifo until it is full or until the send word count is 0 or until the difference
    977                  * between the remainingReceiveByteCount and remainingSendByteCount equals the FIFO depth.
    978                  * The reason for checking the difference is to ensure we only send as much as the
    979                  * RX FIFO can receive.
    980                  * For this case where bitsPerFrame > 8, each entry in the FIFO contains 2 bytes of the
    981                  * send data, hence the difference between the remainingReceiveByteCount and
    982                  * remainingSendByteCount must be divided by 2 to convert this difference into a
    983                  * 16-bit (2 byte) value.
    984                  */
    985                  while ((DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag) &&
    986                         ((handle->remainingReceiveByteCount - handle->remainingSendByteCount) / 2 < handle->fifoSize))
   \                     ??DSPI_MasterFillUpTxFifo_1: (+1)
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   00000016   0x0180             LSLS     R0,R0,#+6
   \   00000018   0xD578             BPL.N    ??DSPI_MasterFillUpTxFifo_2
   \   0000001A   0x69E8             LDR      R0,[R5, #+28]
   \   0000001C   0x69A9             LDR      R1,[R5, #+24]
   \   0000001E   0x1A40             SUBS     R0,R0,R1
   \   00000020   0x0840             LSRS     R0,R0,#+1
   \   00000022   0x7B29             LDRB     R1,[R5, #+12]
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD271             BCS.N    ??DSPI_MasterFillUpTxFifo_2
    987                  {
    988                      if (handle->remainingSendByteCount <= 2)
   \   00000028   0x69A8             LDR      R0,[R5, #+24]
   \   0000002A   0x2803             CMP      R0,#+3
   \   0000002C   0xD21D             BCS.N    ??DSPI_MasterFillUpTxFifo_3
    989                      {
    990                          if (handle->txData)
   \   0000002E   0x6928             LDR      R0,[R5, #+16]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD011             BEQ.N    ??DSPI_MasterFillUpTxFifo_4
    991                          {
    992                              if (handle->remainingSendByteCount == 1)
   \   00000034   0x69A8             LDR      R0,[R5, #+24]
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD103             BNE.N    ??DSPI_MasterFillUpTxFifo_5
    993                              {
    994                                  wordToSend = *(handle->txData);
   \   0000003A   0x6928             LDR      R0,[R5, #+16]
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x0006             MOVS     R6,R0
   \   00000040   0xE00C             B.N      ??DSPI_MasterFillUpTxFifo_6
    995                              }
    996                              else
    997                              {
    998                                  wordToSend = *(handle->txData);
   \                     ??DSPI_MasterFillUpTxFifo_5: (+1)
   \   00000042   0x6928             LDR      R0,[R5, #+16]
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0x0006             MOVS     R6,R0
    999                                  ++handle->txData; /* increment to next data byte */
   \   00000048   0x6928             LDR      R0,[R5, #+16]
   \   0000004A   0x1C40             ADDS     R0,R0,#+1
   \   0000004C   0x6128             STR      R0,[R5, #+16]
   1000                                  wordToSend |= (unsigned)(*(handle->txData)) << 8U;
   \   0000004E   0x6928             LDR      R0,[R5, #+16]
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0xEA56 0x2600      ORRS     R6,R6,R0, LSL #+8
   \   00000056   0xE001             B.N      ??DSPI_MasterFillUpTxFifo_6
   1001                              }
   1002                          }
   1003                          else
   1004                          {
   1005                              wordToSend = dummyData;
   \                     ??DSPI_MasterFillUpTxFifo_4: (+1)
   \   00000058   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005A   0x003E             MOVS     R6,R7
   1006                          }
   1007                          handle->remainingSendByteCount = 0;
   \                     ??DSPI_MasterFillUpTxFifo_6: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x61A8             STR      R0,[R5, #+24]
   1008                          base->PUSHR = handle->lastCommand | wordToSend;
   \   00000060   0x68A8             LDR      R0,[R5, #+8]
   \   00000062   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000064   0x4330             ORRS     R0,R6,R0
   \   00000066   0x6360             STR      R0,[R4, #+52]
   \   00000068   0xE019             B.N      ??DSPI_MasterFillUpTxFifo_7
   1009                      }
   1010                      /* For all words except the last word */
   1011                      else
   1012                      {
   1013                          if (handle->txData)
   \                     ??DSPI_MasterFillUpTxFifo_3: (+1)
   \   0000006A   0x6928             LDR      R0,[R5, #+16]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD00D             BEQ.N    ??DSPI_MasterFillUpTxFifo_8
   1014                          {
   1015                              wordToSend = *(handle->txData);
   \   00000070   0x6928             LDR      R0,[R5, #+16]
   \   00000072   0x7800             LDRB     R0,[R0, #+0]
   \   00000074   0x0006             MOVS     R6,R0
   1016                              ++handle->txData; /* increment to next data byte */
   \   00000076   0x6928             LDR      R0,[R5, #+16]
   \   00000078   0x1C40             ADDS     R0,R0,#+1
   \   0000007A   0x6128             STR      R0,[R5, #+16]
   1017                              wordToSend |= (unsigned)(*(handle->txData)) << 8U;
   \   0000007C   0x6928             LDR      R0,[R5, #+16]
   \   0000007E   0x7800             LDRB     R0,[R0, #+0]
   \   00000080   0xEA56 0x2600      ORRS     R6,R6,R0, LSL #+8
   1018                              ++handle->txData; /* increment to next data byte */
   \   00000084   0x6928             LDR      R0,[R5, #+16]
   \   00000086   0x1C40             ADDS     R0,R0,#+1
   \   00000088   0x6128             STR      R0,[R5, #+16]
   \   0000008A   0xE001             B.N      ??DSPI_MasterFillUpTxFifo_9
   1019                          }
   1020                          else
   1021                          {
   1022                              wordToSend = dummyData;
   \                     ??DSPI_MasterFillUpTxFifo_8: (+1)
   \   0000008C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000008E   0x003E             MOVS     R6,R7
   1023                          }
   1024                          handle->remainingSendByteCount -= 2; /* decrement remainingSendByteCount by 2 */
   \                     ??DSPI_MasterFillUpTxFifo_9: (+1)
   \   00000090   0x69A8             LDR      R0,[R5, #+24]
   \   00000092   0x1E80             SUBS     R0,R0,#+2
   \   00000094   0x61A8             STR      R0,[R5, #+24]
   1025                          base->PUSHR = handle->command | wordToSend;
   \   00000096   0x6868             LDR      R0,[R5, #+4]
   \   00000098   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000009A   0x4330             ORRS     R0,R6,R0
   \   0000009C   0x6360             STR      R0,[R4, #+52]
   1026                      }
   1027          
   1028                      /* Try to clear the TFFF; if the TX FIFO is full this will clear */
   1029                      DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \                     ??DSPI_MasterFillUpTxFifo_7: (+1)
   \   0000009E   0xF05F 0x7100      MOVS     R1,#+33554432
   \   000000A2   0x0020             MOVS     R0,R4
   \   000000A4   0x.... 0x....      BL       DSPI_ClearStatusFlags
   1030          
   1031                      /* exit loop if send count is zero, else update local variables for next loop */
   1032                      if (handle->remainingSendByteCount == 0)
   \   000000A8   0x69A8             LDR      R0,[R5, #+24]
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD1B0             BNE.N    ??DSPI_MasterFillUpTxFifo_1
   1033                      {
   1034                          break;
   \   000000AE   0xE02D             B.N      ??DSPI_MasterFillUpTxFifo_2
   1035                      }
   1036                  } /* End of TX FIFO fill while loop */
   1037              }
   1038              /* Optimized for bits/frame less than or equal to one byte. */
   1039              else
   1040              {
   1041                  /* Fill the fifo until it is full or until the send word count is 0 or until the difference
   1042                  * between the remainingReceiveByteCount and remainingSendByteCount equals the FIFO depth.
   1043                  * The reason for checking the difference is to ensure we only send as much as the
   1044                  * RX FIFO can receive.
   1045                  */
   1046                  while ((DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag) &&
   1047                         ((handle->remainingReceiveByteCount - handle->remainingSendByteCount) < handle->fifoSize))
   \                     ??DSPI_MasterFillUpTxFifo_0: (+1)
   \   000000B0   0x0020             MOVS     R0,R4
   \   000000B2   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   000000B6   0x0180             LSLS     R0,R0,#+6
   \   000000B8   0xD528             BPL.N    ??DSPI_MasterFillUpTxFifo_2
   \   000000BA   0x69E8             LDR      R0,[R5, #+28]
   \   000000BC   0x69A9             LDR      R1,[R5, #+24]
   \   000000BE   0x1A40             SUBS     R0,R0,R1
   \   000000C0   0x7B29             LDRB     R1,[R5, #+12]
   \   000000C2   0x4288             CMP      R0,R1
   \   000000C4   0xD222             BCS.N    ??DSPI_MasterFillUpTxFifo_2
   1048                  {
   1049                      if (handle->txData)
   \   000000C6   0x6928             LDR      R0,[R5, #+16]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD006             BEQ.N    ??DSPI_MasterFillUpTxFifo_10
   1050                      {
   1051                          wordToSend = *(handle->txData);
   \   000000CC   0x6928             LDR      R0,[R5, #+16]
   \   000000CE   0x7800             LDRB     R0,[R0, #+0]
   \   000000D0   0x0006             MOVS     R6,R0
   1052                          ++handle->txData;
   \   000000D2   0x6928             LDR      R0,[R5, #+16]
   \   000000D4   0x1C40             ADDS     R0,R0,#+1
   \   000000D6   0x6128             STR      R0,[R5, #+16]
   \   000000D8   0xE001             B.N      ??DSPI_MasterFillUpTxFifo_11
   1053                      }
   1054                      else
   1055                      {
   1056                          wordToSend = dummyData;
   \                     ??DSPI_MasterFillUpTxFifo_10: (+1)
   \   000000DA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000DC   0x003E             MOVS     R6,R7
   1057                      }
   1058          
   1059                      if (handle->remainingSendByteCount == 1)
   \                     ??DSPI_MasterFillUpTxFifo_11: (+1)
   \   000000DE   0x69A8             LDR      R0,[R5, #+24]
   \   000000E0   0x2801             CMP      R0,#+1
   \   000000E2   0xD104             BNE.N    ??DSPI_MasterFillUpTxFifo_12
   1060                      {
   1061                          base->PUSHR = handle->lastCommand | wordToSend;
   \   000000E4   0x68A8             LDR      R0,[R5, #+8]
   \   000000E6   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000E8   0x4330             ORRS     R0,R6,R0
   \   000000EA   0x6360             STR      R0,[R4, #+52]
   \   000000EC   0xE003             B.N      ??DSPI_MasterFillUpTxFifo_13
   1062                      }
   1063                      else
   1064                      {
   1065                          base->PUSHR = handle->command | wordToSend;
   \                     ??DSPI_MasterFillUpTxFifo_12: (+1)
   \   000000EE   0x6868             LDR      R0,[R5, #+4]
   \   000000F0   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000F2   0x4330             ORRS     R0,R6,R0
   \   000000F4   0x6360             STR      R0,[R4, #+52]
   1066                      }
   1067          
   1068                      /* Try to clear the TFFF; if the TX FIFO is full this will clear */
   1069                      DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \                     ??DSPI_MasterFillUpTxFifo_13: (+1)
   \   000000F6   0xF05F 0x7100      MOVS     R1,#+33554432
   \   000000FA   0x0020             MOVS     R0,R4
   \   000000FC   0x.... 0x....      BL       DSPI_ClearStatusFlags
   1070          
   1071                      --handle->remainingSendByteCount;
   \   00000100   0x69A8             LDR      R0,[R5, #+24]
   \   00000102   0x1E40             SUBS     R0,R0,#+1
   \   00000104   0x61A8             STR      R0,[R5, #+24]
   1072          
   1073                      /* exit loop if send count is zero, else update local variables for next loop */
   1074                      if (handle->remainingSendByteCount == 0)
   \   00000106   0x69A8             LDR      R0,[R5, #+24]
   \   00000108   0x2800             CMP      R0,#+0
   \   0000010A   0xD1D1             BNE.N    ??DSPI_MasterFillUpTxFifo_0
   1075                      {
   1076                          break;
   1077                      }
   1078                  }
   1079              }
   1080          }
   \                     ??DSPI_MasterFillUpTxFifo_2: (+1)
   \   0000010C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1081          

   \                                 In section .text, align 2, keep-with-next
   1082          void DSPI_MasterTransferAbort(SPI_Type *base, dspi_master_handle_t *handle)
   1083          {
   \                     DSPI_MasterTransferAbort: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1084              DSPI_StopTransfer(base);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       DSPI_StopTransfer
   1085          
   1086              /* Disable interrupt requests*/
   1087              DSPI_DisableInterrupts(base, kDSPI_RxFifoDrainRequestInterruptEnable | kDSPI_TxFifoFillRequestInterruptEnable);
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable22_5  ;; 0x2020000
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       DSPI_DisableInterrupts
   1088          
   1089              handle->state = kDSPI_Idle;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF885 0x0024      STRB     R0,[R5, #+36]
   1090          }
   \   0000001C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1091          

   \                                 In section .text, align 4, keep-with-next
   1092          void DSPI_MasterTransferHandleIRQ(SPI_Type *base, dspi_master_handle_t *handle)
   1093          {
   \                     DSPI_MasterTransferHandleIRQ: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1094              /* RECEIVE IRQ handler: Check read buffer only if there are remaining bytes to read. */
   1095              if (handle->remainingReceiveByteCount)
   \   00000006   0x69E8             LDR      R0,[R5, #+28]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD057             BEQ.N    ??DSPI_MasterTransferHandleIRQ_0
   1096              {
   1097                  /* Check read buffer.*/
   1098                  uint16_t wordReceived; /* Maximum supported data bit length in master mode is 16-bits */
   1099          
   1100                  /* If bits/frame is greater than one byte */
   1101                  if (handle->bitsPerFrame > 8)
   \   0000000C   0x6828             LDR      R0,[R5, #+0]
   \   0000000E   0x2809             CMP      R0,#+9
   \   00000010   0xD338             BCC.N    ??DSPI_MasterTransferHandleIRQ_1
   1102                  {
   1103                      while (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
   \                     ??DSPI_MasterTransferHandleIRQ_2: (+1)
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   00000018   0x0380             LSLS     R0,R0,#+14
   \   0000001A   0xD54F             BPL.N    ??DSPI_MasterTransferHandleIRQ_0
   1104                      {
   1105                          wordReceived = DSPI_ReadData(base);
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       DSPI_ReadData
   \   00000022   0x0006             MOVS     R6,R0
   1106                          /* clear the rx fifo drain request, needed for non-DMA applications as this flag
   1107                          * will remain set even if the rx fifo is empty. By manually clearing this flag, it
   1108                          * either remain clear if no more data is in the fifo, or it will set if there is
   1109                          * more data in the fifo.
   1110                          */
   1111                          DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
   \   00000024   0xF45F 0x3100      MOVS     R1,#+131072
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       DSPI_ClearStatusFlags
   1112          
   1113                          /* Store read bytes into rx buffer only if a buffer pointer was provided */
   1114                          if (handle->rxData)
   \   0000002E   0x6968             LDR      R0,[R5, #+20]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD019             BEQ.N    ??DSPI_MasterTransferHandleIRQ_3
   1115                          {
   1116                              /* For the last word received, if there is an extra byte due to the odd transfer
   1117                              * byte count, only save the the last byte and discard the upper byte
   1118                              */
   1119                              if (handle->remainingReceiveByteCount == 1)
   \   00000034   0x69E8             LDR      R0,[R5, #+28]
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD105             BNE.N    ??DSPI_MasterTransferHandleIRQ_4
   1120                              {
   1121                                  *handle->rxData = wordReceived; /* Write first data byte */
   \   0000003A   0x6968             LDR      R0,[R5, #+20]
   \   0000003C   0x7006             STRB     R6,[R0, #+0]
   1122                                  --handle->remainingReceiveByteCount;
   \   0000003E   0x69E8             LDR      R0,[R5, #+28]
   \   00000040   0x1E40             SUBS     R0,R0,#+1
   \   00000042   0x61E8             STR      R0,[R5, #+28]
   \   00000044   0xE01A             B.N      ??DSPI_MasterTransferHandleIRQ_5
   1123                              }
   1124                              else
   1125                              {
   1126                                  *handle->rxData = wordReceived;      /* Write first data byte */
   \                     ??DSPI_MasterTransferHandleIRQ_4: (+1)
   \   00000046   0x6968             LDR      R0,[R5, #+20]
   \   00000048   0x7006             STRB     R6,[R0, #+0]
   1127                                  ++handle->rxData;                    /* increment to next data byte */
   \   0000004A   0x6968             LDR      R0,[R5, #+20]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0x6168             STR      R0,[R5, #+20]
   1128                                  *handle->rxData = wordReceived >> 8; /* Write second data byte */
   \   00000050   0x0030             MOVS     R0,R6
   \   00000052   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000054   0x0A00             LSRS     R0,R0,#+8
   \   00000056   0x6969             LDR      R1,[R5, #+20]
   \   00000058   0x7008             STRB     R0,[R1, #+0]
   1129                                  ++handle->rxData;                    /* increment to next data byte */
   \   0000005A   0x6968             LDR      R0,[R5, #+20]
   \   0000005C   0x1C40             ADDS     R0,R0,#+1
   \   0000005E   0x6168             STR      R0,[R5, #+20]
   1130                                  handle->remainingReceiveByteCount -= 2;
   \   00000060   0x69E8             LDR      R0,[R5, #+28]
   \   00000062   0x1E80             SUBS     R0,R0,#+2
   \   00000064   0x61E8             STR      R0,[R5, #+28]
   \   00000066   0xE009             B.N      ??DSPI_MasterTransferHandleIRQ_5
   1131                              }
   1132                          }
   1133                          else
   1134                          {
   1135                              if (handle->remainingReceiveByteCount == 1)
   \                     ??DSPI_MasterTransferHandleIRQ_3: (+1)
   \   00000068   0x69E8             LDR      R0,[R5, #+28]
   \   0000006A   0x2801             CMP      R0,#+1
   \   0000006C   0xD103             BNE.N    ??DSPI_MasterTransferHandleIRQ_6
   1136                              {
   1137                                  --handle->remainingReceiveByteCount;
   \   0000006E   0x69E8             LDR      R0,[R5, #+28]
   \   00000070   0x1E40             SUBS     R0,R0,#+1
   \   00000072   0x61E8             STR      R0,[R5, #+28]
   \   00000074   0xE002             B.N      ??DSPI_MasterTransferHandleIRQ_5
   1138                              }
   1139                              else
   1140                              {
   1141                                  handle->remainingReceiveByteCount -= 2;
   \                     ??DSPI_MasterTransferHandleIRQ_6: (+1)
   \   00000076   0x69E8             LDR      R0,[R5, #+28]
   \   00000078   0x1E80             SUBS     R0,R0,#+2
   \   0000007A   0x61E8             STR      R0,[R5, #+28]
   1142                              }
   1143                          }
   1144                          if (handle->remainingReceiveByteCount == 0)
   \                     ??DSPI_MasterTransferHandleIRQ_5: (+1)
   \   0000007C   0x69E8             LDR      R0,[R5, #+28]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD1C7             BNE.N    ??DSPI_MasterTransferHandleIRQ_2
   1145                          {
   1146                              break;
   \   00000082   0xE01B             B.N      ??DSPI_MasterTransferHandleIRQ_0
   1147                          }
   1148                      } /* End of RX FIFO drain while loop */
   1149                  }
   1150                  /* Optimized for bits/frame less than or equal to one byte. */
   1151                  else
   1152                  {
   1153                      while (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
   \                     ??DSPI_MasterTransferHandleIRQ_1: (+1)
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   0000008A   0x0380             LSLS     R0,R0,#+14
   \   0000008C   0xD516             BPL.N    ??DSPI_MasterTransferHandleIRQ_0
   1154                      {
   1155                          wordReceived = DSPI_ReadData(base);
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0x.... 0x....      BL       DSPI_ReadData
   \   00000094   0x0006             MOVS     R6,R0
   1156                          /* clear the rx fifo drain request, needed for non-DMA applications as this flag
   1157                          * will remain set even if the rx fifo is empty. By manually clearing this flag, it
   1158                          * either remain clear if no more data is in the fifo, or it will set if there is
   1159                          * more data in the fifo.
   1160                          */
   1161                          DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
   \   00000096   0xF45F 0x3100      MOVS     R1,#+131072
   \   0000009A   0x0020             MOVS     R0,R4
   \   0000009C   0x.... 0x....      BL       DSPI_ClearStatusFlags
   1162          
   1163                          /* Store read bytes into rx buffer only if a buffer pointer was provided */
   1164                          if (handle->rxData)
   \   000000A0   0x6968             LDR      R0,[R5, #+20]
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD004             BEQ.N    ??DSPI_MasterTransferHandleIRQ_7
   1165                          {
   1166                              *handle->rxData = wordReceived;
   \   000000A6   0x6968             LDR      R0,[R5, #+20]
   \   000000A8   0x7006             STRB     R6,[R0, #+0]
   1167                              ++handle->rxData;
   \   000000AA   0x6968             LDR      R0,[R5, #+20]
   \   000000AC   0x1C40             ADDS     R0,R0,#+1
   \   000000AE   0x6168             STR      R0,[R5, #+20]
   1168                          }
   1169          
   1170                          --handle->remainingReceiveByteCount;
   \                     ??DSPI_MasterTransferHandleIRQ_7: (+1)
   \   000000B0   0x69E8             LDR      R0,[R5, #+28]
   \   000000B2   0x1E40             SUBS     R0,R0,#+1
   \   000000B4   0x61E8             STR      R0,[R5, #+28]
   1171          
   1172                          if (handle->remainingReceiveByteCount == 0)
   \   000000B6   0x69E8             LDR      R0,[R5, #+28]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD1E3             BNE.N    ??DSPI_MasterTransferHandleIRQ_1
   1173                          {
   1174                              break;
   1175                          }
   1176                      } /* End of RX FIFO drain while loop */
   1177                  }
   1178              }
   1179          
   1180              /* Check write buffer. We always have to send a word in order to keep the transfer
   1181              * moving. So if the caller didn't provide a send buffer, we just send a zero.
   1182              */
   1183              if (handle->remainingSendByteCount)
   \                     ??DSPI_MasterTransferHandleIRQ_0: (+1)
   \   000000BC   0x69A8             LDR      R0,[R5, #+24]
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD003             BEQ.N    ??DSPI_MasterTransferHandleIRQ_8
   1184              {
   1185                  DSPI_MasterFillUpTxFifo(base, handle);
   \   000000C2   0x0029             MOVS     R1,R5
   \   000000C4   0x0020             MOVS     R0,R4
   \   000000C6   0x.... 0x....      BL       DSPI_MasterFillUpTxFifo
   1186              }
   1187          
   1188              /* Check if we're done with this transfer.*/
   1189              if ((handle->remainingSendByteCount == 0) && (handle->remainingReceiveByteCount == 0))
   \                     ??DSPI_MasterTransferHandleIRQ_8: (+1)
   \   000000CA   0x69A8             LDR      R0,[R5, #+24]
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD106             BNE.N    ??DSPI_MasterTransferHandleIRQ_9
   \   000000D0   0x69E8             LDR      R0,[R5, #+28]
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD103             BNE.N    ??DSPI_MasterTransferHandleIRQ_9
   1190              {
   1191                  /* Complete the transfer and disable the interrupts */
   1192                  DSPI_MasterCompleteTransfer(base, handle);
   \   000000D6   0x0029             MOVS     R1,R5
   \   000000D8   0x0020             MOVS     R0,R4
   \   000000DA   0x.... 0x....      BL       DSPI_MasterCompleteTransfer
   1193              }
   1194          }
   \                     ??DSPI_MasterTransferHandleIRQ_9: (+1)
   \   000000DE   0xBD70             POP      {R4-R6,PC}       ;; return
   1195          
   1196          /*Transactional APIs -- Slave*/

   \                                 In section .text, align 2, keep-with-next
   1197          void DSPI_SlaveTransferCreateHandle(SPI_Type *base,
   1198                                              dspi_slave_handle_t *handle,
   1199                                              dspi_slave_transfer_callback_t callback,
   1200                                              void *userData)
   1201          {
   \                     DSPI_SlaveTransferCreateHandle: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1202              assert(handle);
   1203          
   1204              /* Zero the handle. */
   1205              memset(handle, 0, sizeof(*handle));
   \   0000000C   0xF05F 0x082C      MOVS     R8,#+44
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
   \   00000014   0x464A             MOV      R2,R9
   \   00000016   0x4641             MOV      R1,R8
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       __aeabi_memset
   1206          
   1207              g_dspiHandle[DSPI_GetInstance(base)] = handle;
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       DSPI_GetInstance
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable22
   \   00000028   0xF841 0x5020      STR      R5,[R1, R0, LSL #+2]
   1208          
   1209              handle->callback = callback;
   \   0000002C   0x626E             STR      R6,[R5, #+36]
   1210              handle->userData = userData;
   \   0000002E   0x62AF             STR      R7,[R5, #+40]
   1211          }
   \   00000030   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   1212          

   \                                 In section .text, align 2, keep-with-next
   1213          status_t DSPI_SlaveTransferNonBlocking(SPI_Type *base, dspi_slave_handle_t *handle, dspi_transfer_t *transfer)
   1214          {
   \                     DSPI_SlaveTransferNonBlocking: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1215              assert(handle && transfer);
   1216          
   1217              /* If receive length is zero */
   1218              if (transfer->dataSize == 0)
   \   00000008   0x68B0             LDR      R0,[R6, #+8]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??DSPI_SlaveTransferNonBlocking_0
   1219              {
   1220                  return kStatus_InvalidArgument;
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0xE05D             B.N      ??DSPI_SlaveTransferNonBlocking_1
   1221              }
   1222          
   1223              /* If both send buffer and receive buffer is null */
   1224              if ((!(transfer->txData)) && (!(transfer->rxData)))
   \                     ??DSPI_SlaveTransferNonBlocking_0: (+1)
   \   00000012   0x6830             LDR      R0,[R6, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD104             BNE.N    ??DSPI_SlaveTransferNonBlocking_2
   \   00000018   0x6870             LDR      R0,[R6, #+4]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD101             BNE.N    ??DSPI_SlaveTransferNonBlocking_2
   1225              {
   1226                  return kStatus_InvalidArgument;
   \   0000001E   0x2004             MOVS     R0,#+4
   \   00000020   0xE055             B.N      ??DSPI_SlaveTransferNonBlocking_1
   1227              }
   1228          
   1229              /* Check that we're not busy.*/
   1230              if (handle->state == kDSPI_Busy)
   \                     ??DSPI_SlaveTransferNonBlocking_2: (+1)
   \   00000022   0x7F28             LDRB     R0,[R5, #+28]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD102             BNE.N    ??DSPI_SlaveTransferNonBlocking_3
   1231              {
   1232                  return kStatus_DSPI_Busy;
   \   00000028   0xF44F 0x7016      MOV      R0,#+600
   \   0000002C   0xE04F             B.N      ??DSPI_SlaveTransferNonBlocking_1
   1233              }
   1234              handle->state = kDSPI_Busy;
   \                     ??DSPI_SlaveTransferNonBlocking_3: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x7728             STRB     R0,[R5, #+28]
   1235          
   1236              /* Enable the NVIC for DSPI peripheral. */
   1237              EnableIRQ(s_dspiIRQ[DSPI_GetInstance(base)]);
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       DSPI_GetInstance
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable22_3
   \   0000003C   0x5608             LDRSB    R0,[R1, R0]
   \   0000003E   0x.... 0x....      BL       EnableIRQ
   1238          
   1239              /* Store transfer information */
   1240              handle->txData = transfer->txData;
   \   00000042   0x6830             LDR      R0,[R6, #+0]
   \   00000044   0x60A8             STR      R0,[R5, #+8]
   1241              handle->rxData = transfer->rxData;
   \   00000046   0x6870             LDR      R0,[R6, #+4]
   \   00000048   0x60E8             STR      R0,[R5, #+12]
   1242              handle->remainingSendByteCount = transfer->dataSize;
   \   0000004A   0x68B0             LDR      R0,[R6, #+8]
   \   0000004C   0x6128             STR      R0,[R5, #+16]
   1243              handle->remainingReceiveByteCount = transfer->dataSize;
   \   0000004E   0x68B0             LDR      R0,[R6, #+8]
   \   00000050   0x6168             STR      R0,[R5, #+20]
   1244              handle->totalByteCount = transfer->dataSize;
   \   00000052   0x68B0             LDR      R0,[R6, #+8]
   \   00000054   0x61A8             STR      R0,[R5, #+24]
   1245          
   1246              handle->errorCount = 0;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x6228             STR      R0,[R5, #+32]
   1247          
   1248              uint8_t whichCtar = (transfer->configFlags & DSPI_SLAVE_CTAR_MASK) >> DSPI_SLAVE_CTAR_SHIFT;
   \   0000005A   0x7B30             LDRB     R0,[R6, #+12]
   \   0000005C   0xF010 0x0707      ANDS     R7,R0,#0x7
   1249              handle->bitsPerFrame =
   1250                  (((base->CTAR_SLAVE[whichCtar]) & SPI_CTAR_SLAVE_FMSZ_MASK) >> SPI_CTAR_SLAVE_FMSZ_SHIFT) + 1;
   \   00000060   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000062   0xEB04 0x0087      ADD      R0,R4,R7, LSL #+2
   \   00000066   0x68C0             LDR      R0,[R0, #+12]
   \   00000068   0xF3C0 0x60C3      UBFX     R0,R0,#+27,#+4
   \   0000006C   0x1C40             ADDS     R0,R0,#+1
   \   0000006E   0x6028             STR      R0,[R5, #+0]
   1251          
   1252              DSPI_StopTransfer(base);
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0x.... 0x....      BL       DSPI_StopTransfer
   1253          
   1254              DSPI_FlushFifo(base, true, true);
   \   00000076   0x2201             MOVS     R2,#+1
   \   00000078   0x2101             MOVS     R1,#+1
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x.... 0x....      BL       DSPI_FlushFifo
   1255              DSPI_ClearStatusFlags(base, kDSPI_AllStatusFlag);
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable22_2  ;; 0xda0a0000
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       DSPI_ClearStatusFlags
   1256          
   1257              DSPI_StartTransfer(base);
   \   0000008A   0x0020             MOVS     R0,R4
   \   0000008C   0x.... 0x....      BL       DSPI_StartTransfer
   1258          
   1259              /* Prepare data to transmit */
   1260              DSPI_SlaveFillUpTxFifo(base, handle);
   \   00000090   0x0029             MOVS     R1,R5
   \   00000092   0x0020             MOVS     R0,R4
   \   00000094   0x.... 0x....      BL       DSPI_SlaveFillUpTxFifo
   1261          
   1262              s_dspiSlaveIsr = DSPI_SlaveTransferHandleIRQ;
   \   00000098   0x.... 0x....      ADR.W    R0,DSPI_SlaveTransferHandleIRQ
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable22_6
   \   000000A0   0x6008             STR      R0,[R1, #+0]
   1263          
   1264              /* Enable RX FIFO drain request, the slave only use this interrupt */
   1265              DSPI_EnableInterrupts(base, kDSPI_RxFifoDrainRequestInterruptEnable);
   \   000000A2   0xF45F 0x3100      MOVS     R1,#+131072
   \   000000A6   0x0020             MOVS     R0,R4
   \   000000A8   0x.... 0x....      BL       DSPI_EnableInterrupts
   1266          
   1267              if (handle->rxData)
   \   000000AC   0x68E8             LDR      R0,[R5, #+12]
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD004             BEQ.N    ??DSPI_SlaveTransferNonBlocking_4
   1268              {
   1269                  /* RX FIFO overflow request enable */
   1270                  DSPI_EnableInterrupts(base, kDSPI_RxFifoOverflowInterruptEnable);
   \   000000B2   0xF45F 0x2100      MOVS     R1,#+524288
   \   000000B6   0x0020             MOVS     R0,R4
   \   000000B8   0x.... 0x....      BL       DSPI_EnableInterrupts
   1271              }
   1272              if (handle->txData)
   \                     ??DSPI_SlaveTransferNonBlocking_4: (+1)
   \   000000BC   0x68A8             LDR      R0,[R5, #+8]
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD004             BEQ.N    ??DSPI_SlaveTransferNonBlocking_5
   1273              {
   1274                  /* TX FIFO underflow request enable */
   1275                  DSPI_EnableInterrupts(base, kDSPI_TxFifoUnderflowInterruptEnable);
   \   000000C2   0xF05F 0x6100      MOVS     R1,#+134217728
   \   000000C6   0x0020             MOVS     R0,R4
   \   000000C8   0x.... 0x....      BL       DSPI_EnableInterrupts
   1276              }
   1277          
   1278              return kStatus_Success;
   \                     ??DSPI_SlaveTransferNonBlocking_5: (+1)
   \   000000CC   0x2000             MOVS     R0,#+0
   \                     ??DSPI_SlaveTransferNonBlocking_1: (+1)
   \   000000CE   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1279          }
   1280          

   \                                 In section .text, align 2, keep-with-next
   1281          status_t DSPI_SlaveTransferGetCount(SPI_Type *base, dspi_slave_handle_t *handle, size_t *count)
   1282          {
   \                     DSPI_SlaveTransferGetCount: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0003             MOVS     R3,R0
   1283              assert(handle);
   1284          
   1285              if (!count)
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD101             BNE.N    ??DSPI_SlaveTransferGetCount_0
   1286              {
   1287                  return kStatus_InvalidArgument;
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0xE00B             B.N      ??DSPI_SlaveTransferGetCount_1
   1288              }
   1289          
   1290              /* Catch when there is not an active transfer. */
   1291              if (handle->state != kDSPI_Busy)
   \                     ??DSPI_SlaveTransferGetCount_0: (+1)
   \   0000000C   0x7F08             LDRB     R0,[R1, #+28]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD003             BEQ.N    ??DSPI_SlaveTransferGetCount_2
   1292              {
   1293                  *count = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x6010             STR      R0,[R2, #+0]
   1294                  return kStatus_NoTransferInProgress;
   \   00000016   0x2006             MOVS     R0,#+6
   \   00000018   0xE004             B.N      ??DSPI_SlaveTransferGetCount_1
   1295              }
   1296          
   1297              *count = handle->totalByteCount - handle->remainingReceiveByteCount;
   \                     ??DSPI_SlaveTransferGetCount_2: (+1)
   \   0000001A   0x6988             LDR      R0,[R1, #+24]
   \   0000001C   0x694C             LDR      R4,[R1, #+20]
   \   0000001E   0x1B00             SUBS     R0,R0,R4
   \   00000020   0x6010             STR      R0,[R2, #+0]
   1298              return kStatus_Success;
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??DSPI_SlaveTransferGetCount_1: (+1)
   \   00000024   0xBC10             POP      {R4}
   \   00000026   0x4770             BX       LR               ;; return
   1299          }
   1300          

   \                                 In section .text, align 2, keep-with-next
   1301          static void DSPI_SlaveFillUpTxFifo(SPI_Type *base, dspi_slave_handle_t *handle)
   1302          {
   \                     DSPI_SlaveFillUpTxFifo: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1303              uint16_t transmitData = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1304              uint8_t dummyPattern = DSPI_SLAVE_DUMMY_DATA;
   \   00000008   0x2700             MOVS     R7,#+0
   1305          
   1306              /* Service the transmitter, if transmit buffer provided, transmit the data,
   1307              * else transmit dummy pattern
   1308              */
   1309              while (DSPI_GetStatusFlags(base) & kDSPI_TxFifoFillRequestFlag)
   \                     ??DSPI_SlaveFillUpTxFifo_0: (+1)
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   00000010   0x0180             LSLS     R0,R0,#+6
   \   00000012   0xD54A             BPL.N    ??DSPI_SlaveFillUpTxFifo_1
   1310              {
   1311                  /* Transmit data */
   1312                  if (handle->remainingSendByteCount > 0)
   \   00000014   0x6928             LDR      R0,[R5, #+16]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD047             BEQ.N    ??DSPI_SlaveFillUpTxFifo_2
   1313                  {
   1314                      /* Have data to transmit, update the transmit data and push to FIFO */
   1315                      if (handle->bitsPerFrame <= 8)
   \   0000001A   0x6828             LDR      R0,[R5, #+0]
   \   0000001C   0x2809             CMP      R0,#+9
   \   0000001E   0xD20F             BCS.N    ??DSPI_SlaveFillUpTxFifo_3
   1316                      {
   1317                          /* bits/frame is 1 byte */
   1318                          if (handle->txData)
   \   00000020   0x68A8             LDR      R0,[R5, #+8]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD006             BEQ.N    ??DSPI_SlaveFillUpTxFifo_4
   1319                          {
   1320                              /* Update transmit data and transmit pointer */
   1321                              transmitData = *handle->txData;
   \   00000026   0x68A8             LDR      R0,[R5, #+8]
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x0006             MOVS     R6,R0
   1322                              handle->txData++;
   \   0000002C   0x68A8             LDR      R0,[R5, #+8]
   \   0000002E   0x1C40             ADDS     R0,R0,#+1
   \   00000030   0x60A8             STR      R0,[R5, #+8]
   \   00000032   0xE001             B.N      ??DSPI_SlaveFillUpTxFifo_5
   1323                          }
   1324                          else
   1325                          {
   1326                              transmitData = dummyPattern;
   \                     ??DSPI_SlaveFillUpTxFifo_4: (+1)
   \   00000034   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000036   0x003E             MOVS     R6,R7
   1327                          }
   1328          
   1329                          /* Decrease remaining dataSize */
   1330                          --handle->remainingSendByteCount;
   \                     ??DSPI_SlaveFillUpTxFifo_5: (+1)
   \   00000038   0x6928             LDR      R0,[R5, #+16]
   \   0000003A   0x1E40             SUBS     R0,R0,#+1
   \   0000003C   0x6128             STR      R0,[R5, #+16]
   \   0000003E   0xE02C             B.N      ??DSPI_SlaveFillUpTxFifo_6
   1331                      }
   1332                      /* bits/frame is 2 bytes */
   1333                      else
   1334                      {
   1335                          /* With multibytes per frame transmission, the transmit frame contains data from
   1336                          * transmit buffer until sent dataSize matches user request. Other bytes will set to
   1337                          * dummy pattern value.
   1338                          */
   1339                          if (handle->txData)
   \                     ??DSPI_SlaveFillUpTxFifo_3: (+1)
   \   00000040   0x68A8             LDR      R0,[R5, #+8]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD01A             BEQ.N    ??DSPI_SlaveFillUpTxFifo_7
   1340                          {
   1341                              /* Update first byte of transmit data and transmit pointer */
   1342                              transmitData = *handle->txData;
   \   00000046   0x68A8             LDR      R0,[R5, #+8]
   \   00000048   0x7800             LDRB     R0,[R0, #+0]
   \   0000004A   0x0006             MOVS     R6,R0
   1343                              handle->txData++;
   \   0000004C   0x68A8             LDR      R0,[R5, #+8]
   \   0000004E   0x1C40             ADDS     R0,R0,#+1
   \   00000050   0x60A8             STR      R0,[R5, #+8]
   1344          
   1345                              if (handle->remainingSendByteCount == 1)
   \   00000052   0x6928             LDR      R0,[R5, #+16]
   \   00000054   0x2801             CMP      R0,#+1
   \   00000056   0xD106             BNE.N    ??DSPI_SlaveFillUpTxFifo_8
   1346                              {
   1347                                  /* Decrease remaining dataSize */
   1348                                  --handle->remainingSendByteCount;
   \   00000058   0x6928             LDR      R0,[R5, #+16]
   \   0000005A   0x1E40             SUBS     R0,R0,#+1
   \   0000005C   0x6128             STR      R0,[R5, #+16]
   1349                                  /* Update second byte of transmit data to second byte of dummy pattern */
   1350                                  transmitData = transmitData | (uint16_t)(((uint16_t)dummyPattern) << 8);
   \   0000005E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000060   0xEA56 0x2607      ORRS     R6,R6,R7, LSL #+8
   \   00000064   0xE019             B.N      ??DSPI_SlaveFillUpTxFifo_6
   1351                              }
   1352                              else
   1353                              {
   1354                                  /* Update second byte of transmit data and transmit pointer */
   1355                                  transmitData = transmitData | (uint16_t)((uint16_t)(*handle->txData) << 8);
   \                     ??DSPI_SlaveFillUpTxFifo_8: (+1)
   \   00000066   0x68A8             LDR      R0,[R5, #+8]
   \   00000068   0x7800             LDRB     R0,[R0, #+0]
   \   0000006A   0xEA56 0x2600      ORRS     R6,R6,R0, LSL #+8
   1356                                  handle->txData++;
   \   0000006E   0x68A8             LDR      R0,[R5, #+8]
   \   00000070   0x1C40             ADDS     R0,R0,#+1
   \   00000072   0x60A8             STR      R0,[R5, #+8]
   1357                                  handle->remainingSendByteCount -= 2;
   \   00000074   0x6928             LDR      R0,[R5, #+16]
   \   00000076   0x1E80             SUBS     R0,R0,#+2
   \   00000078   0x6128             STR      R0,[R5, #+16]
   \   0000007A   0xE00E             B.N      ??DSPI_SlaveFillUpTxFifo_6
   1358                              }
   1359                          }
   1360                          else
   1361                          {
   1362                              if (handle->remainingSendByteCount == 1)
   \                     ??DSPI_SlaveFillUpTxFifo_7: (+1)
   \   0000007C   0x6928             LDR      R0,[R5, #+16]
   \   0000007E   0x2801             CMP      R0,#+1
   \   00000080   0xD103             BNE.N    ??DSPI_SlaveFillUpTxFifo_9
   1363                              {
   1364                                  --handle->remainingSendByteCount;
   \   00000082   0x6928             LDR      R0,[R5, #+16]
   \   00000084   0x1E40             SUBS     R0,R0,#+1
   \   00000086   0x6128             STR      R0,[R5, #+16]
   \   00000088   0xE002             B.N      ??DSPI_SlaveFillUpTxFifo_10
   1365                              }
   1366                              else
   1367                              {
   1368                                  handle->remainingSendByteCount -= 2;
   \                     ??DSPI_SlaveFillUpTxFifo_9: (+1)
   \   0000008A   0x6928             LDR      R0,[R5, #+16]
   \   0000008C   0x1E80             SUBS     R0,R0,#+2
   \   0000008E   0x6128             STR      R0,[R5, #+16]
   1369                              }
   1370                              transmitData = (uint16_t)((uint16_t)(dummyPattern) << 8) | dummyPattern;
   \                     ??DSPI_SlaveFillUpTxFifo_10: (+1)
   \   00000090   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000092   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000094   0xEA57 0x2007      ORRS     R0,R7,R7, LSL #+8
   \   00000098   0x0006             MOVS     R6,R0
   1371                          }
   1372                      }
   1373                  }
   1374                  else
   1375                  {
   1376                      break;
   1377                  }
   1378          
   1379                  /* Write the data to the DSPI data register */
   1380                  base->PUSHR_SLAVE = transmitData;
   \                     ??DSPI_SlaveFillUpTxFifo_6: (+1)
   \   0000009A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000009C   0x6366             STR      R6,[R4, #+52]
   1381          
   1382                  /* Try to clear TFFF by writing a one to it; it will not clear if TX FIFO not full */
   1383                  DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \   0000009E   0xF05F 0x7100      MOVS     R1,#+33554432
   \   000000A2   0x0020             MOVS     R0,R4
   \   000000A4   0x.... 0x....      BL       DSPI_ClearStatusFlags
   \   000000A8   0xE7AF             B.N      ??DSPI_SlaveFillUpTxFifo_0
   1384              }
   1385          }
   \                     ??DSPI_SlaveFillUpTxFifo_2: (+1)
   \                     ??DSPI_SlaveFillUpTxFifo_1: (+1)
   \   000000AA   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1386          

   \                                 In section .text, align 2, keep-with-next
   1387          static void DSPI_SlaveCompleteTransfer(SPI_Type *base, dspi_slave_handle_t *handle)
   1388          {
   \                     DSPI_SlaveCompleteTransfer: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1389              /* Disable interrupt requests */
   1390              DSPI_DisableInterrupts(base, kDSPI_TxFifoUnderflowInterruptEnable | kDSPI_TxFifoFillRequestInterruptEnable |
   1391                                               kDSPI_RxFifoOverflowInterruptEnable | kDSPI_RxFifoDrainRequestInterruptEnable);
   \   00000006   0x....             LDR.N    R1,??DataTable22_7  ;; 0xa0a0000
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       DSPI_DisableInterrupts
   1392          
   1393              /* The transfer is complete. */
   1394              handle->txData = NULL;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x60A8             STR      R0,[R5, #+8]
   1395              handle->rxData = NULL;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x60E8             STR      R0,[R5, #+12]
   1396              handle->remainingReceiveByteCount = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x6168             STR      R0,[R5, #+20]
   1397              handle->remainingSendByteCount = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x6128             STR      R0,[R5, #+16]
   1398          
   1399              status_t status = 0;
   \   0000001E   0x2600             MOVS     R6,#+0
   1400              if (handle->state == kDSPI_Error)
   \   00000020   0x7F28             LDRB     R0,[R5, #+28]
   \   00000022   0x2802             CMP      R0,#+2
   \   00000024   0xD103             BNE.N    ??DSPI_SlaveCompleteTransfer_0
   1401              {
   1402                  status = kStatus_DSPI_Error;
   \   00000026   0xF240 0x2059      MOVW     R0,#+601
   \   0000002A   0x0006             MOVS     R6,R0
   \   0000002C   0xE001             B.N      ??DSPI_SlaveCompleteTransfer_1
   1403              }
   1404              else
   1405              {
   1406                  status = kStatus_Success;
   \                     ??DSPI_SlaveCompleteTransfer_0: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x0006             MOVS     R6,R0
   1407              }
   1408          
   1409              if (handle->callback)
   \                     ??DSPI_SlaveCompleteTransfer_1: (+1)
   \   00000032   0x6A68             LDR      R0,[R5, #+36]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD005             BEQ.N    ??DSPI_SlaveCompleteTransfer_2
   1410              {
   1411                  handle->callback(base, handle, status, handle->userData);
   \   00000038   0x6AAB             LDR      R3,[R5, #+40]
   \   0000003A   0x0032             MOVS     R2,R6
   \   0000003C   0x0029             MOVS     R1,R5
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x6A6F             LDR      R7,[R5, #+36]
   \   00000042   0x47B8             BLX      R7
   1412              }
   1413          
   1414              handle->state = kDSPI_Idle;
   \                     ??DSPI_SlaveCompleteTransfer_2: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x7728             STRB     R0,[R5, #+28]
   1415          }
   \   00000048   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1416          

   \                                 In section .text, align 2, keep-with-next
   1417          void DSPI_SlaveTransferAbort(SPI_Type *base, dspi_slave_handle_t *handle)
   1418          {
   \                     DSPI_SlaveTransferAbort: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1419              DSPI_StopTransfer(base);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       DSPI_StopTransfer
   1420          
   1421              /* Disable interrupt requests */
   1422              DSPI_DisableInterrupts(base, kDSPI_TxFifoUnderflowInterruptEnable | kDSPI_TxFifoFillRequestInterruptEnable |
   1423                                               kDSPI_RxFifoOverflowInterruptEnable | kDSPI_RxFifoDrainRequestInterruptEnable);
   \   0000000C   0x....             LDR.N    R1,??DataTable22_7  ;; 0xa0a0000
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       DSPI_DisableInterrupts
   1424          
   1425              handle->state = kDSPI_Idle;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x7728             STRB     R0,[R5, #+28]
   1426              handle->remainingSendByteCount = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6128             STR      R0,[R5, #+16]
   1427              handle->remainingReceiveByteCount = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x6168             STR      R0,[R5, #+20]
   1428          }
   \   00000020   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1429          

   \                                 In section .text, align 4, keep-with-next
   1430          void DSPI_SlaveTransferHandleIRQ(SPI_Type *base, dspi_slave_handle_t *handle)
   1431          {
   \                     DSPI_SlaveTransferHandleIRQ: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1432              uint8_t dummyPattern = DSPI_SLAVE_DUMMY_DATA;
   \   00000008   0x2600             MOVS     R6,#+0
   1433              uint32_t dataReceived;
   1434              uint32_t dataSend = 0;
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
   1435          
   1436              /* Because SPI protocol is synchronous, the number of bytes that that slave received from the
   1437              * master is the actual number of bytes that the slave transmitted to the master. So we only
   1438              * monitor the received dataSize to know when the transfer is complete.
   1439              */
   1440              if (handle->remainingReceiveByteCount > 0)
   \   0000000E   0x6968             LDR      R0,[R5, #+20]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xF000 0x8091      BEQ.W    ??DSPI_SlaveTransferHandleIRQ_0
   1441              {
   1442                  while (DSPI_GetStatusFlags(base) & kDSPI_RxFifoDrainRequestFlag)
   \                     ??DSPI_SlaveTransferHandleIRQ_1: (+1)
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   0000001C   0x0380             LSLS     R0,R0,#+14
   \   0000001E   0xF140 0x808B      BPL.W    ??DSPI_SlaveTransferHandleIRQ_0
   1443                  {
   1444                      /* Have received data in the buffer. */
   1445                      dataReceived = base->POPR;
   \   00000022   0x6BA0             LDR      R0,[R4, #+56]
   \   00000024   0x0007             MOVS     R7,R0
   1446                      /*Clear the rx fifo drain request, needed for non-DMA applications as this flag
   1447                      * will remain set even if the rx fifo is empty. By manually clearing this flag, it
   1448                      * either remain clear if no more data is in the fifo, or it will set if there is
   1449                      * more data in the fifo.
   1450                      */
   1451                      DSPI_ClearStatusFlags(base, kDSPI_RxFifoDrainRequestFlag);
   \   00000026   0xF45F 0x3100      MOVS     R1,#+131072
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       DSPI_ClearStatusFlags
   1452          
   1453                      /* If bits/frame is one byte */
   1454                      if (handle->bitsPerFrame <= 8)
   \   00000030   0x6828             LDR      R0,[R5, #+0]
   \   00000032   0x2809             CMP      R0,#+9
   \   00000034   0xD21F             BCS.N    ??DSPI_SlaveTransferHandleIRQ_2
   1455                      {
   1456                          if (handle->rxData)
   \   00000036   0x68E8             LDR      R0,[R5, #+12]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD004             BEQ.N    ??DSPI_SlaveTransferHandleIRQ_3
   1457                          {
   1458                              /* Receive buffer is not null, store data into it */
   1459                              *handle->rxData = dataReceived;
   \   0000003C   0x68E8             LDR      R0,[R5, #+12]
   \   0000003E   0x7007             STRB     R7,[R0, #+0]
   1460                              ++handle->rxData;
   \   00000040   0x68E8             LDR      R0,[R5, #+12]
   \   00000042   0x1C40             ADDS     R0,R0,#+1
   \   00000044   0x60E8             STR      R0,[R5, #+12]
   1461                          }
   1462                          /* Descrease remaining receive byte count */
   1463                          --handle->remainingReceiveByteCount;
   \                     ??DSPI_SlaveTransferHandleIRQ_3: (+1)
   \   00000046   0x6968             LDR      R0,[R5, #+20]
   \   00000048   0x1E40             SUBS     R0,R0,#+1
   \   0000004A   0x6168             STR      R0,[R5, #+20]
   1464          
   1465                          if (handle->remainingSendByteCount > 0)
   \   0000004C   0x6928             LDR      R0,[R5, #+16]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD069             BEQ.N    ??DSPI_SlaveTransferHandleIRQ_4
   1466                          {
   1467                              if (handle->txData)
   \   00000052   0x68A8             LDR      R0,[R5, #+8]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD006             BEQ.N    ??DSPI_SlaveTransferHandleIRQ_5
   1468                              {
   1469                                  dataSend = *handle->txData;
   \   00000058   0x68A8             LDR      R0,[R5, #+8]
   \   0000005A   0x7800             LDRB     R0,[R0, #+0]
   \   0000005C   0x4680             MOV      R8,R0
   1470                                  ++handle->txData;
   \   0000005E   0x68A8             LDR      R0,[R5, #+8]
   \   00000060   0x1C40             ADDS     R0,R0,#+1
   \   00000062   0x60A8             STR      R0,[R5, #+8]
   \   00000064   0xE001             B.N      ??DSPI_SlaveTransferHandleIRQ_6
   1471                              }
   1472                              else
   1473                              {
   1474                                  dataSend = dummyPattern;
   \                     ??DSPI_SlaveTransferHandleIRQ_5: (+1)
   \   00000066   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000068   0x46B0             MOV      R8,R6
   1475                              }
   1476          
   1477                              --handle->remainingSendByteCount;
   \                     ??DSPI_SlaveTransferHandleIRQ_6: (+1)
   \   0000006A   0x6928             LDR      R0,[R5, #+16]
   \   0000006C   0x1E40             SUBS     R0,R0,#+1
   \   0000006E   0x6128             STR      R0,[R5, #+16]
   1478                              /* Write the data to the DSPI data register */
   1479                              base->PUSHR_SLAVE = dataSend;
   \   00000070   0xF8C4 0x8034      STR      R8,[R4, #+52]
   \   00000074   0xE057             B.N      ??DSPI_SlaveTransferHandleIRQ_4
   1480                          }
   1481                      }
   1482                      else /* If bits/frame is 2 bytes */
   1483                      {
   1484                          /* With multibytes frame receiving, we only receive till the received dataSize
   1485                          * matches user request. Other bytes will be ignored.
   1486                          */
   1487                          if (handle->rxData)
   \                     ??DSPI_SlaveTransferHandleIRQ_2: (+1)
   \   00000076   0x68E8             LDR      R0,[R5, #+12]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD015             BEQ.N    ??DSPI_SlaveTransferHandleIRQ_7
   1488                          {
   1489                              /* Receive buffer is not null, store first byte into it */
   1490                              *handle->rxData = dataReceived;
   \   0000007C   0x68E8             LDR      R0,[R5, #+12]
   \   0000007E   0x7007             STRB     R7,[R0, #+0]
   1491                              ++handle->rxData;
   \   00000080   0x68E8             LDR      R0,[R5, #+12]
   \   00000082   0x1C40             ADDS     R0,R0,#+1
   \   00000084   0x60E8             STR      R0,[R5, #+12]
   1492          
   1493                              if (handle->remainingReceiveByteCount == 1)
   \   00000086   0x6968             LDR      R0,[R5, #+20]
   \   00000088   0x2801             CMP      R0,#+1
   \   0000008A   0xD103             BNE.N    ??DSPI_SlaveTransferHandleIRQ_8
   1494                              {
   1495                                  /* Decrease remaining receive byte count */
   1496                                  --handle->remainingReceiveByteCount;
   \   0000008C   0x6968             LDR      R0,[R5, #+20]
   \   0000008E   0x1E40             SUBS     R0,R0,#+1
   \   00000090   0x6168             STR      R0,[R5, #+20]
   \   00000092   0xE013             B.N      ??DSPI_SlaveTransferHandleIRQ_9
   1497                              }
   1498                              else
   1499                              {
   1500                                  /* Receive buffer is not null, store second byte into it */
   1501                                  *handle->rxData = dataReceived >> 8;
   \                     ??DSPI_SlaveTransferHandleIRQ_8: (+1)
   \   00000094   0x0A38             LSRS     R0,R7,#+8
   \   00000096   0x68E9             LDR      R1,[R5, #+12]
   \   00000098   0x7008             STRB     R0,[R1, #+0]
   1502                                  ++handle->rxData;
   \   0000009A   0x68E8             LDR      R0,[R5, #+12]
   \   0000009C   0x1C40             ADDS     R0,R0,#+1
   \   0000009E   0x60E8             STR      R0,[R5, #+12]
   1503                                  handle->remainingReceiveByteCount -= 2;
   \   000000A0   0x6968             LDR      R0,[R5, #+20]
   \   000000A2   0x1E80             SUBS     R0,R0,#+2
   \   000000A4   0x6168             STR      R0,[R5, #+20]
   \   000000A6   0xE009             B.N      ??DSPI_SlaveTransferHandleIRQ_9
   1504                              }
   1505                          }
   1506                          /* If no handle->rxData*/
   1507                          else
   1508                          {
   1509                              if (handle->remainingReceiveByteCount == 1)
   \                     ??DSPI_SlaveTransferHandleIRQ_7: (+1)
   \   000000A8   0x6968             LDR      R0,[R5, #+20]
   \   000000AA   0x2801             CMP      R0,#+1
   \   000000AC   0xD103             BNE.N    ??DSPI_SlaveTransferHandleIRQ_10
   1510                              {
   1511                                  /* Decrease remaining receive byte count */
   1512                                  --handle->remainingReceiveByteCount;
   \   000000AE   0x6968             LDR      R0,[R5, #+20]
   \   000000B0   0x1E40             SUBS     R0,R0,#+1
   \   000000B2   0x6168             STR      R0,[R5, #+20]
   \   000000B4   0xE002             B.N      ??DSPI_SlaveTransferHandleIRQ_9
   1513                              }
   1514                              else
   1515                              {
   1516                                  handle->remainingReceiveByteCount -= 2;
   \                     ??DSPI_SlaveTransferHandleIRQ_10: (+1)
   \   000000B6   0x6968             LDR      R0,[R5, #+20]
   \   000000B8   0x1E80             SUBS     R0,R0,#+2
   \   000000BA   0x6168             STR      R0,[R5, #+20]
   1517                              }
   1518                          }
   1519          
   1520                          if (handle->remainingSendByteCount > 0)
   \                     ??DSPI_SlaveTransferHandleIRQ_9: (+1)
   \   000000BC   0x6928             LDR      R0,[R5, #+16]
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD031             BEQ.N    ??DSPI_SlaveTransferHandleIRQ_4
   1521                          {
   1522                              if (handle->txData)
   \   000000C2   0x68A8             LDR      R0,[R5, #+8]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD01C             BEQ.N    ??DSPI_SlaveTransferHandleIRQ_11
   1523                              {
   1524                                  dataSend = *handle->txData;
   \   000000C8   0x68A8             LDR      R0,[R5, #+8]
   \   000000CA   0x7800             LDRB     R0,[R0, #+0]
   \   000000CC   0x4680             MOV      R8,R0
   1525                                  ++handle->txData;
   \   000000CE   0x68A8             LDR      R0,[R5, #+8]
   \   000000D0   0x1C40             ADDS     R0,R0,#+1
   \   000000D2   0x60A8             STR      R0,[R5, #+8]
   1526          
   1527                                  if (handle->remainingSendByteCount == 1)
   \   000000D4   0x6928             LDR      R0,[R5, #+16]
   \   000000D6   0x2801             CMP      R0,#+1
   \   000000D8   0xD108             BNE.N    ??DSPI_SlaveTransferHandleIRQ_12
   1528                                  {
   1529                                      --handle->remainingSendByteCount;
   \   000000DA   0x6928             LDR      R0,[R5, #+16]
   \   000000DC   0x1E40             SUBS     R0,R0,#+1
   \   000000DE   0x6128             STR      R0,[R5, #+16]
   1530                                      dataSend |= (uint16_t)((uint16_t)(dummyPattern) << 8);
   \   000000E0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000E2   0x0230             LSLS     R0,R6,#+8
   \   000000E4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000E6   0xEA50 0x0808      ORRS     R8,R0,R8
   \   000000EA   0xE01A             B.N      ??DSPI_SlaveTransferHandleIRQ_13
   1531                                  }
   1532                                  else
   1533                                  {
   1534                                      dataSend |= (uint32_t)(*handle->txData) << 8;
   \                     ??DSPI_SlaveTransferHandleIRQ_12: (+1)
   \   000000EC   0x68A8             LDR      R0,[R5, #+8]
   \   000000EE   0x7800             LDRB     R0,[R0, #+0]
   \   000000F0   0xEA58 0x2800      ORRS     R8,R8,R0, LSL #+8
   1535                                      ++handle->txData;
   \   000000F4   0x68A8             LDR      R0,[R5, #+8]
   \   000000F6   0x1C40             ADDS     R0,R0,#+1
   \   000000F8   0x60A8             STR      R0,[R5, #+8]
   1536                                      handle->remainingSendByteCount -= 2;
   \   000000FA   0x6928             LDR      R0,[R5, #+16]
   \   000000FC   0x1E80             SUBS     R0,R0,#+2
   \   000000FE   0x6128             STR      R0,[R5, #+16]
   \   00000100   0xE00F             B.N      ??DSPI_SlaveTransferHandleIRQ_13
   1537                                  }
   1538                              }
   1539                              /* If no handle->txData*/
   1540                              else
   1541                              {
   1542                                  if (handle->remainingSendByteCount == 1)
   \                     ??DSPI_SlaveTransferHandleIRQ_11: (+1)
   \   00000102   0x6928             LDR      R0,[R5, #+16]
   \   00000104   0x2801             CMP      R0,#+1
   \   00000106   0xD103             BNE.N    ??DSPI_SlaveTransferHandleIRQ_14
   1543                                  {
   1544                                      --handle->remainingSendByteCount;
   \   00000108   0x6928             LDR      R0,[R5, #+16]
   \   0000010A   0x1E40             SUBS     R0,R0,#+1
   \   0000010C   0x6128             STR      R0,[R5, #+16]
   \   0000010E   0xE002             B.N      ??DSPI_SlaveTransferHandleIRQ_15
   1545                                  }
   1546                                  else
   1547                                  {
   1548                                      handle->remainingSendByteCount -= 2;
   \                     ??DSPI_SlaveTransferHandleIRQ_14: (+1)
   \   00000110   0x6928             LDR      R0,[R5, #+16]
   \   00000112   0x1E80             SUBS     R0,R0,#+2
   \   00000114   0x6128             STR      R0,[R5, #+16]
   1549                                  }
   1550                                  dataSend = (uint16_t)((uint16_t)(dummyPattern) << 8) | dummyPattern;
   \                     ??DSPI_SlaveTransferHandleIRQ_15: (+1)
   \   00000116   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000118   0x0230             LSLS     R0,R6,#+8
   \   0000011A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000011C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000011E   0x4330             ORRS     R0,R6,R0
   \   00000120   0x4680             MOV      R8,R0
   1551                              }
   1552                              /* Write the data to the DSPI data register */
   1553                              base->PUSHR_SLAVE = dataSend;
   \                     ??DSPI_SlaveTransferHandleIRQ_13: (+1)
   \   00000122   0xF8C4 0x8034      STR      R8,[R4, #+52]
   1554                          }
   1555                      }
   1556                      /* Try to clear TFFF by writing a one to it; it will not clear if TX FIFO not full */
   1557                      DSPI_ClearStatusFlags(base, kDSPI_TxFifoFillRequestFlag);
   \                     ??DSPI_SlaveTransferHandleIRQ_4: (+1)
   \   00000126   0xF05F 0x7100      MOVS     R1,#+33554432
   \   0000012A   0x0020             MOVS     R0,R4
   \   0000012C   0x.... 0x....      BL       DSPI_ClearStatusFlags
   1558          
   1559                      if (handle->remainingReceiveByteCount == 0)
   \   00000130   0x6968             LDR      R0,[R5, #+20]
   \   00000132   0x2800             CMP      R0,#+0
   \   00000134   0xF47F 0xAF6F      BNE.W    ??DSPI_SlaveTransferHandleIRQ_1
   1560                      {
   1561                          break;
   1562                      }
   1563                  }
   1564              }
   1565              /* Check if remaining receive byte count matches user request */
   1566              if ((handle->remainingReceiveByteCount == 0) || (handle->state == kDSPI_Error))
   \                     ??DSPI_SlaveTransferHandleIRQ_0: (+1)
   \   00000138   0x6968             LDR      R0,[R5, #+20]
   \   0000013A   0x2800             CMP      R0,#+0
   \   0000013C   0xD002             BEQ.N    ??DSPI_SlaveTransferHandleIRQ_16
   \   0000013E   0x7F28             LDRB     R0,[R5, #+28]
   \   00000140   0x2802             CMP      R0,#+2
   \   00000142   0xD104             BNE.N    ??DSPI_SlaveTransferHandleIRQ_17
   1567              {
   1568                  /* Other cases, stop the transfer. */
   1569                  DSPI_SlaveCompleteTransfer(base, handle);
   \                     ??DSPI_SlaveTransferHandleIRQ_16: (+1)
   \   00000144   0x0029             MOVS     R1,R5
   \   00000146   0x0020             MOVS     R0,R4
   \   00000148   0x.... 0x....      BL       DSPI_SlaveCompleteTransfer
   1570                  return;
   \   0000014C   0xE029             B.N      ??DSPI_SlaveTransferHandleIRQ_18
   1571              }
   1572          
   1573              /* Catch tx fifo underflow conditions, service only if tx under flow interrupt enabled */
   1574              if ((DSPI_GetStatusFlags(base) & kDSPI_TxFifoUnderflowFlag) && (base->RSER & SPI_RSER_TFUF_RE_MASK))
   \                     ??DSPI_SlaveTransferHandleIRQ_17: (+1)
   \   0000014E   0x0020             MOVS     R0,R4
   \   00000150   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   00000154   0x0100             LSLS     R0,R0,#+4
   \   00000156   0xD50F             BPL.N    ??DSPI_SlaveTransferHandleIRQ_19
   \   00000158   0x6B20             LDR      R0,[R4, #+48]
   \   0000015A   0x0100             LSLS     R0,R0,#+4
   \   0000015C   0xD50C             BPL.N    ??DSPI_SlaveTransferHandleIRQ_19
   1575              {
   1576                  DSPI_ClearStatusFlags(base, kDSPI_TxFifoUnderflowFlag);
   \   0000015E   0xF05F 0x6100      MOVS     R1,#+134217728
   \   00000162   0x0020             MOVS     R0,R4
   \   00000164   0x.... 0x....      BL       DSPI_ClearStatusFlags
   1577                  /* Change state to error and clear flag */
   1578                  if (handle->txData)
   \   00000168   0x68A8             LDR      R0,[R5, #+8]
   \   0000016A   0x2800             CMP      R0,#+0
   \   0000016C   0xD001             BEQ.N    ??DSPI_SlaveTransferHandleIRQ_20
   1579                  {
   1580                      handle->state = kDSPI_Error;
   \   0000016E   0x2002             MOVS     R0,#+2
   \   00000170   0x7728             STRB     R0,[R5, #+28]
   1581                  }
   1582                  handle->errorCount++;
   \                     ??DSPI_SlaveTransferHandleIRQ_20: (+1)
   \   00000172   0x6A28             LDR      R0,[R5, #+32]
   \   00000174   0x1C40             ADDS     R0,R0,#+1
   \   00000176   0x6228             STR      R0,[R5, #+32]
   1583              }
   1584              /* Catch rx fifo overflow conditions, service only if rx over flow interrupt enabled */
   1585              if ((DSPI_GetStatusFlags(base) & kDSPI_RxFifoOverflowFlag) && (base->RSER & SPI_RSER_RFOF_RE_MASK))
   \                     ??DSPI_SlaveTransferHandleIRQ_19: (+1)
   \   00000178   0x0020             MOVS     R0,R4
   \   0000017A   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   0000017E   0x0300             LSLS     R0,R0,#+12
   \   00000180   0xD50F             BPL.N    ??DSPI_SlaveTransferHandleIRQ_21
   \   00000182   0x6B20             LDR      R0,[R4, #+48]
   \   00000184   0x0300             LSLS     R0,R0,#+12
   \   00000186   0xD50C             BPL.N    ??DSPI_SlaveTransferHandleIRQ_21
   1586              {
   1587                  DSPI_ClearStatusFlags(base, kDSPI_RxFifoOverflowFlag);
   \   00000188   0xF45F 0x2100      MOVS     R1,#+524288
   \   0000018C   0x0020             MOVS     R0,R4
   \   0000018E   0x.... 0x....      BL       DSPI_ClearStatusFlags
   1588                  /* Change state to error and clear flag */
   1589                  if (handle->txData)
   \   00000192   0x68A8             LDR      R0,[R5, #+8]
   \   00000194   0x2800             CMP      R0,#+0
   \   00000196   0xD001             BEQ.N    ??DSPI_SlaveTransferHandleIRQ_22
   1590                  {
   1591                      handle->state = kDSPI_Error;
   \   00000198   0x2002             MOVS     R0,#+2
   \   0000019A   0x7728             STRB     R0,[R5, #+28]
   1592                  }
   1593                  handle->errorCount++;
   \                     ??DSPI_SlaveTransferHandleIRQ_22: (+1)
   \   0000019C   0x6A28             LDR      R0,[R5, #+32]
   \   0000019E   0x1C40             ADDS     R0,R0,#+1
   \   000001A0   0x6228             STR      R0,[R5, #+32]
   1594              }
   1595          }
   \                     ??DSPI_SlaveTransferHandleIRQ_21: (+1)
   \                     ??DSPI_SlaveTransferHandleIRQ_18: (+1)
   \   000001A2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1596          

   \                                 In section .text, align 2, keep-with-next
   1597          static void DSPI_CommonIRQHandler(SPI_Type *base, void *param)
   1598          {
   \                     DSPI_CommonIRQHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1599              if (DSPI_IsMaster(base))
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       DSPI_IsMaster
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD005             BEQ.N    ??DSPI_CommonIRQHandler_0
   1600              {
   1601                  s_dspiMasterIsr(base, (dspi_master_handle_t *)param);
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x....             LDR.N    R2,??DataTable22_4
   \   00000016   0x6812             LDR      R2,[R2, #+0]
   \   00000018   0x4790             BLX      R2
   \   0000001A   0xE004             B.N      ??DSPI_CommonIRQHandler_1
   1602              }
   1603              else
   1604              {
   1605                  s_dspiSlaveIsr(base, (dspi_slave_handle_t *)param);
   \                     ??DSPI_CommonIRQHandler_0: (+1)
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x....             LDR.N    R2,??DataTable22_6
   \   00000022   0x6812             LDR      R2,[R2, #+0]
   \   00000024   0x4790             BLX      R2
   1606              }
   1607          }
   \                     ??DSPI_CommonIRQHandler_1: (+1)
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1608          
   1609          #if defined(SPI0)

   \                                 In section .text, align 2, keep-with-next
   1610          void SPI0_DriverIRQHandler(void)
   1611          {
   \                     SPI0_DriverIRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1612              assert(g_dspiHandle[0]);
   1613              DSPI_CommonIRQHandler(SPI0, g_dspiHandle[0]);
   \   00000002   0x....             LDR.N    R0,??DataTable22
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x....             LDR.N    R0,??DataTable22_8  ;; 0x4002c000
   \   00000008   0x.... 0x....      BL       DSPI_CommonIRQHandler
   1614          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return
   1615          #endif
   1616          
   1617          #if defined(SPI1)

   \                                 In section .text, align 2, keep-with-next
   1618          void SPI1_DriverIRQHandler(void)
   1619          {
   \                     SPI1_DriverIRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1620              assert(g_dspiHandle[1]);
   1621              DSPI_CommonIRQHandler(SPI1, g_dspiHandle[1]);
   \   00000002   0x....             LDR.N    R0,??DataTable22
   \   00000004   0x6841             LDR      R1,[R0, #+4]
   \   00000006   0x....             LDR.N    R0,??DataTable22_9  ;; 0x4002d000
   \   00000008   0x.... 0x....      BL       DSPI_CommonIRQHandler
   1622          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return
   1623          #endif
   1624          
   1625          #if defined(SPI2)

   \                                 In section .text, align 2, keep-with-next
   1626          void SPI2_DriverIRQHandler(void)
   1627          {
   \                     SPI2_DriverIRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1628              assert(g_dspiHandle[2]);
   1629              DSPI_CommonIRQHandler(SPI2, g_dspiHandle[2]);
   \   00000002   0x....             LDR.N    R0,??DataTable22
   \   00000004   0x6881             LDR      R1,[R0, #+8]
   \   00000006   0x....             LDR.N    R0,??DataTable22_10  ;; 0x400ac000
   \   00000008   0x.... 0x....      BL       DSPI_CommonIRQHandler
   1630          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     s_dspiBases

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     s_dspiClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0xBAFFCCFF         DC32     0xbaffccff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x0007A120         DC32     0x7a120

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     s_baudratePrescaler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     s_baudrateScaler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x7FFCFFF0         DC32     0x7ffcfff0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0xFF3F0FFF         DC32     0xff3f0fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \   00000000   0xFFCFF0FF         DC32     0xffcff0ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \   00000000   0xFFF3FF0F         DC32     0xfff3ff0f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0xEE6B2800         DC32     0xee6b2800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x........         DC32     s_delayPrescaler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x3B9ACA00         DC32     0x3b9aca00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     s_delayScaler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0x........         DC32     g_dspiHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0x9A0A0000         DC32     0x9a0a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \   00000000   0xDA0A0000         DC32     0xda0a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \   00000000   0x........         DC32     s_dspiIRQ

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_4:
   \   00000000   0x........         DC32     s_dspiMasterIsr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_5:
   \   00000000   0x02020000         DC32     0x2020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_6:
   \   00000000   0x........         DC32     s_dspiSlaveIsr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_7:
   \   00000000   0x0A0A0000         DC32     0xa0a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_8:
   \   00000000   0x4002C000         DC32     0x4002c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_9:
   \   00000000   0x4002D000         DC32     0x4002d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_10:
   \   00000000   0x400AC000         DC32     0x400ac000
   1631          #endif
   1632          
   1633          #if defined(SPI3)
   1634          void SPI3_DriverIRQHandler(void)
   1635          {
   1636              assert(g_dspiHandle[3]);
   1637              DSPI_CommonIRQHandler(SPI3, g_dspiHandle[3]);
   1638          }
   1639          #endif
   1640          
   1641          #if defined(SPI4)
   1642          void SPI4_DriverIRQHandler(void)
   1643          {
   1644              assert(g_dspiHandle[4]);
   1645              DSPI_CommonIRQHandler(SPI4, g_dspiHandle[4]);
   1646          }
   1647          #endif
   1648          
   1649          #if defined(SPI5)
   1650          void SPI5_DriverIRQHandler(void)
   1651          {
   1652              assert(g_dspiHandle[5]);
   1653              DSPI_CommonIRQHandler(SPI5, g_dspiHandle[5]);
   1654          }
   1655          #endif
   1656          
   1657          #if (FSL_FEATURE_SOC_DSPI_COUNT > 6)
   1658          #error "Should write the SPIx_DriverIRQHandler function that instance greater than 5 !"
   1659          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CLOCK_DisableClock
       0   CLOCK_EnableClock
       0   DSPI_ClearStatusFlags
      16   DSPI_CommonIRQHandler
        16   -- Indirect call
        16   -> DSPI_IsMaster
       8   DSPI_Deinit
         8   -> CLOCK_DisableClock
         8   -> DSPI_Enable
         8   -> DSPI_GetInstance
         8   -> DSPI_StopTransfer
       0   DSPI_DisableInterrupts
       0   DSPI_Enable
       0   DSPI_EnableInterrupts
       0   DSPI_FlushFifo
       0   DSPI_GetDefaultDataCommandConfig
       0   DSPI_GetInstance
       0   DSPI_GetStatusFlags
       0   DSPI_IsMaster
      24   DSPI_MasterCompleteTransfer
        24   -- Indirect call
        24   -> DSPI_DisableInterrupts
      24   DSPI_MasterFillUpTxFifo
        24   -> DSPI_ClearStatusFlags
        24   -> DSPI_GetStatusFlags
       0   DSPI_MasterGetDefaultConfig
       0   DSPI_MasterGetFormattedCommand
      24   DSPI_MasterInit
        24   -> CLOCK_EnableClock
        24   -> DSPI_Enable
        24   -> DSPI_GetInstance
        24   -> DSPI_MasterSetBaudRate
        24   -> DSPI_MasterSetDelayTimes
        24   -> DSPI_SetMasterSlaveMode
        24   -> DSPI_SetOnePcsPolarity
        24   -> DSPI_StartTransfer
        24   -> DSPI_StopTransfer
      24   DSPI_MasterPrepareTransfer
        24   -> DSPI_ClearStatusFlags
        24   -> DSPI_FlushFifo
        24   -> DSPI_MasterGetFormattedCommand
        24   -> DSPI_StopTransfer
        24   -> FSL_FEATURE_DSPI_FIFO_SIZEn
      56   DSPI_MasterSetBaudRate
        56   -> DSPI_IsMaster
      24   DSPI_MasterSetDelayScaler
        24   -> DSPI_IsMaster
      64   DSPI_MasterSetDelayTimes
        64   -> DSPI_IsMaster
        64   -> DSPI_MasterSetDelayScaler
      16   DSPI_MasterTransferAbort
        16   -> DSPI_DisableInterrupts
        16   -> DSPI_StopTransfer
      64   DSPI_MasterTransferBlocking
        64   -> DSPI_ClearStatusFlags
        64   -> DSPI_DisableInterrupts
        64   -> DSPI_FlushFifo
        64   -> DSPI_GetStatusFlags
        64   -> DSPI_MasterGetFormattedCommand
        64   -> DSPI_ReadData
        64   -> DSPI_StartTransfer
        64   -> DSPI_StopTransfer
        64   -> FSL_FEATURE_DSPI_FIFO_SIZEn
      32   DSPI_MasterTransferCreateHandle
        32   -> DSPI_GetInstance
        32   -> __aeabi_memset
       4   DSPI_MasterTransferGetCount
      16   DSPI_MasterTransferHandleIRQ
        16   -> DSPI_ClearStatusFlags
        16   -> DSPI_GetStatusFlags
        16   -> DSPI_MasterCompleteTransfer
        16   -> DSPI_MasterFillUpTxFifo
        16   -> DSPI_ReadData
      16   DSPI_MasterTransferNonBlocking
        16   -> DSPI_EnableInterrupts
        16   -> DSPI_GetInstance
        16   -> DSPI_MasterFillUpTxFifo
        16   -> DSPI_MasterPrepareTransfer
        16   -> DSPI_StartTransfer
        16   -> EnableIRQ
      16   DSPI_MasterWriteCommandDataBlocking
        16   -> DSPI_ClearStatusFlags
        16   -> DSPI_GetStatusFlags
      16   DSPI_MasterWriteDataBlocking
        16   -> DSPI_ClearStatusFlags
        16   -> DSPI_GetStatusFlags
       0   DSPI_ReadData
       0   DSPI_SetMasterSlaveMode
       4   DSPI_SetOnePcsPolarity
      24   DSPI_SlaveCompleteTransfer
        24   -- Indirect call
        24   -> DSPI_DisableInterrupts
      24   DSPI_SlaveFillUpTxFifo
        24   -> DSPI_ClearStatusFlags
        24   -> DSPI_GetStatusFlags
       0   DSPI_SlaveGetDefaultConfig
      16   DSPI_SlaveInit
        16   -> CLOCK_EnableClock
        16   -> DSPI_Enable
        16   -> DSPI_GetInstance
        16   -> DSPI_SetMasterSlaveMode
        16   -> DSPI_SetOnePcsPolarity
        16   -> DSPI_StartTransfer
        16   -> DSPI_StopTransfer
      16   DSPI_SlaveTransferAbort
        16   -> DSPI_DisableInterrupts
        16   -> DSPI_StopTransfer
      32   DSPI_SlaveTransferCreateHandle
        32   -> DSPI_GetInstance
        32   -> __aeabi_memset
       4   DSPI_SlaveTransferGetCount
      24   DSPI_SlaveTransferHandleIRQ
        24   -> DSPI_ClearStatusFlags
        24   -> DSPI_GetStatusFlags
        24   -> DSPI_SlaveCompleteTransfer
      24   DSPI_SlaveTransferNonBlocking
        24   -> DSPI_ClearStatusFlags
        24   -> DSPI_EnableInterrupts
        24   -> DSPI_FlushFifo
        24   -> DSPI_GetInstance
        24   -> DSPI_SlaveFillUpTxFifo
        24   -> DSPI_StartTransfer
        24   -> DSPI_StopTransfer
        24   -> EnableIRQ
      16   DSPI_SlaveWriteDataBlocking
        16   -> DSPI_ClearStatusFlags
        16   -> DSPI_GetStatusFlags
       0   DSPI_StartTransfer
       0   DSPI_StopTransfer
       8   EnableIRQ
         8   -> NVIC_EnableIRQ
       0   NVIC_EnableIRQ
       8   SPI0_DriverIRQHandler
         8   -> DSPI_CommonIRQHandler
       8   SPI1_DriverIRQHandler
         8   -> DSPI_CommonIRQHandler
       8   SPI2_DriverIRQHandler
         8   -> DSPI_CommonIRQHandler


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable16
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable20
       4  ??DataTable21
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_10
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable22_9
      22  CLOCK_DisableClock
      22  CLOCK_EnableClock
       4  DSPI_ClearStatusFlags
      40  DSPI_CommonIRQHandler
      38  DSPI_Deinit
       8  DSPI_DisableInterrupts
      26  DSPI_Enable
      32  DSPI_EnableInterrupts
      22  DSPI_FlushFifo
      22  DSPI_GetDefaultDataCommandConfig
      28  DSPI_GetInstance
       4  DSPI_GetStatusFlags
       8  DSPI_IsMaster
      64  DSPI_MasterCompleteTransfer
     270  DSPI_MasterFillUpTxFifo
      74  DSPI_MasterGetDefaultConfig
      38  DSPI_MasterGetFormattedCommand
     236  DSPI_MasterInit
     176  DSPI_MasterPrepareTransfer
     246  DSPI_MasterSetBaudRate
     170  DSPI_MasterSetDelayScaler
     244  DSPI_MasterSetDelayTimes
      30  DSPI_MasterTransferAbort
     944  DSPI_MasterTransferBlocking
      52  DSPI_MasterTransferCreateHandle
      42  DSPI_MasterTransferGetCount
     224  DSPI_MasterTransferHandleIRQ
     102  DSPI_MasterTransferNonBlocking
      62  DSPI_MasterWriteCommandDataBlocking
     104  DSPI_MasterWriteDataBlocking
       4  DSPI_ReadData
      16  DSPI_SetMasterSlaveMode
      40  DSPI_SetOnePcsPolarity
      74  DSPI_SlaveCompleteTransfer
     172  DSPI_SlaveFillUpTxFifo
      34  DSPI_SlaveGetDefaultConfig
     160  DSPI_SlaveInit
      34  DSPI_SlaveTransferAbort
      52  DSPI_SlaveTransferCreateHandle
      40  DSPI_SlaveTransferGetCount
     422  DSPI_SlaveTransferHandleIRQ
     208  DSPI_SlaveTransferNonBlocking
      62  DSPI_SlaveWriteDataBlocking
      10  DSPI_StartTransfer
      10  DSPI_StopTransfer
      14  EnableIRQ
      22  NVIC_EnableIRQ
      14  SPI0_DriverIRQHandler
      14  SPI1_DriverIRQHandler
      14  SPI2_DriverIRQHandler
      12  g_dspiHandle
      16  s_baudratePrescaler
      64  s_baudrateScaler
      16  s_delayPrescaler
      64  s_delayScaler
      12  s_dspiBases
      12  s_dspiClock
       4  s_dspiIRQ
       4  s_dspiMasterIsr
       4  s_dspiSlaveIsr

 
    20 bytes in section .bss
   188 bytes in section .rodata
 4 874 bytes in section .text
 
 4 874 bytes of CODE  memory
   188 bytes of CONST memory
    20 bytes of DATA  memory

Errors: none
Warnings: 2
