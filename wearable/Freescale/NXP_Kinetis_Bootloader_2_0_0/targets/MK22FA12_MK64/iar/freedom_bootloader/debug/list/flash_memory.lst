###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:00
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\memory\src\flash_memory.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\memory\src\flash_memory.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\flash_memory.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\flash_memory.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\memory\src\flash_memory.c
      1          /*
      2           * Copyright (c) 2013-2016, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "bootloader_common.h"
     32          #include "memory/memory.h"
     33          #include "flash_memory.h"
     34          #include "normal_memory.h"
     35          #include "flash/fsl_flash.h"
     36          #include "bootloader/bl_context.h"
     37          #include "fsl_device_registers.h"
     38          #include "utilities/fsl_rtos_abstraction.h"
     39          #include "utilities/fsl_assert.h"
     40          #include <string.h>
     41          
     42          ////////////////////////////////////////////////////////////////////////////////
     43          // Definitions
     44          ////////////////////////////////////////////////////////////////////////////////
     45          
     46          // If the bootloader is running from flash, then we need to make sure that all
     47          // interrupts are disabled during the execution of a flash operation, so that
     48          // no code is unexpectedly run from flash (which would cause a hard fault).
     49          //
     50          // If we're running from ROM or RAM, then we neither need to nor want to disable
     51          // interrupts during flash operations.
     52          #if !BL_TARGET_FLASH
     53          #define flash_lock_release() (void)sizeof(0)
     54          #define flash_lock_acquire() (void)sizeof(0)
     55          #endif // BL_TARGET_FLASH
     56          
     57          //! @brief Flash Memory constants.
     58          enum _flash_memory_constants
     59          {
     60              kFlashMemory_ErasedValue = ~0
     61          };
     62          
     63          #if BL_IS_FLASH_SECTION_PROGRAMMING_ENABLED
     64          //! @brief FLASH section program memory context
     65          //!
     66          //! An instance is maintained in this file, will is used to keep key information for write and flush
     67          //! operatations.
     68          typedef struct _flash_section_program_info
     69          {
     70              uint32_t startAddress;                      //!< This address is used to record the address which is used
     71                                                          //!< to write the whole section into flash memory
     72              uint32_t storedBytes;                       //!< A variable which is used to indicate if the buffer is full.
     73              uint8_t buffer[kFLASH_AccelerationRamSize]; //!< A buffer which is used to buffer a full section of data
     74          } flash_section_program_info_t;
     75          

   \                                 In section .bss, align 4
     76          flash_section_program_info_t s_flash_section_program_info = { 0 };
   \                     s_flash_section_program_info:
   \   00000000                      DS8 1032
     77          #endif
     78          
     79          ////////////////////////////////////////////////////////////////////////////////
     80          // Variables
     81          ////////////////////////////////////////////////////////////////////////////////
     82          
     83          //! @brief Interface to flash memory operations.

   \                                 In section .rodata, align 4
     84          const memory_region_interface_t g_flashMemoryInterface = {
   \                     g_flashMemoryInterface:
   \   00000000   0x........         DC32 flash_mem_init, flash_mem_read, flash_mem_write, flash_mem_fill
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000010   0x........         DC32 flash_mem_flush, flash_mem_erase
   \              0x........   
     85              .init = &flash_mem_init,
     86              .read = &flash_mem_read,
     87              .write = &flash_mem_write,
     88          #if !BL_FEATURE_MIN_PROFILE || BL_FEATURE_FILL_MEMORY
     89              .fill = &flash_mem_fill,
     90          #endif // !BL_FEATURE_MIN_PROFILE
     91          #if BL_IS_FLASH_SECTION_PROGRAMMING_ENABLED
     92              .flush = flash_mem_flush,
     93          #else
     94              .flush = NULL,
     95          #endif
     96              .erase = flash_mem_erase,
     97          };
     98          
     99          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    100          //! @brief It is used for indicating if an XA controlled region is unlocked to program state
    101          bool isFlashRegionUnlocked = false;
    102          #endif // FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    103          
    104          #if BL_TARGET_FLASH

   \                                 In section .bss, align 4
    105          static uint32_t s_regPrimask = 0U;
   \                     s_regPrimask:
   \   00000000                      DS8 4
    106          #endif
    107          
    108          ////////////////////////////////////////////////////////////////////////////////
    109          // Prototypes
    110          ////////////////////////////////////////////////////////////////////////////////
    111          //! @brief check if a flash region is in an XA controlled region or contains an XA controlled region.
    112          //         and try to open flash program state by calling verify_erase_all command if needed.
    113          status_t flash_preprocess_execute_only_region(uint32_t address,
    114                                                        uint32_t length,
    115                                                        flash_execute_only_access_state_t *state);
    116          
    117          status_t flash_check_access_before_programming(uint32_t address, uint32_t length, bool *verifyWrites);
    118          
    119          ////////////////////////////////////////////////////////////////////////////////
    120          // Code
    121          ////////////////////////////////////////////////////////////////////////////////
    122          
    123          #if BL_TARGET_FLASH

   \                                 In section .text, align 2, keep-with-next
    124          static void flash_lock_acquire(void)
    125          {
    126              // Ensure that the program operation cannots be interrupted.
    127              s_regPrimask = __get_PRIMASK();
   \                     flash_lock_acquire: (+1)
   \   00000000   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable9
   \   00000008   0x6008             STR      R0,[R1, #+0]
    128              __disable_irq();
   \   0000000A   0xB672             CPSID    I
    129          }
   \   0000000C   0x4770             BX       LR               ;; return
    130          

   \                                 In section .text, align 2, keep-with-next
    131          static void flash_lock_release(void)
    132          {
    133              // Release lock after the write operation completes.
    134              __set_PRIMASK(s_regPrimask);
   \                     flash_lock_release: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF380 0x8810      MSR      PRIMASK,R0
    135          }
   \   0000000A   0x4770             BX       LR               ;; return
    136          #endif
    137          
    138          // See flash_memory.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    139          status_t flash_mem_init(void)
    140          {
   \                     flash_mem_init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    141              // Update address range of flash
    142              memory_map_entry_t *map = (memory_map_entry_t *)&g_bootloaderContext.memoryMap[kIndexFlashArray];
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \   00000008   0x6844             LDR      R4,[R0, #+4]
    143              g_bootloaderContext.flashDriverInterface->flash_get_property(
    144                  &g_bootloaderContext.flashState, kFLASH_PropertyPflashBlockBaseAddr, &map->startAddress);
   \   0000000A   0x0022             MOVS     R2,R4
   \   0000000C   0x2104             MOVS     R1,#+4
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable9_2
   \   00000012   0x.... 0x....      LDR.W    R3,??DataTable9_1
   \   00000016   0x691B             LDR      R3,[R3, #+16]
   \   00000018   0x6ADB             LDR      R3,[R3, #+44]
   \   0000001A   0x4798             BLX      R3
    145              uint32_t tmp;
    146              g_bootloaderContext.flashDriverInterface->flash_get_property(&g_bootloaderContext.flashState,
    147                                                                           kFLASH_PropertyPflashTotalSize, &tmp);
   \   0000001C   0x466A             MOV      R2,SP
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable9_2
   \   00000024   0x.... 0x....      LDR.W    R3,??DataTable9_1
   \   00000028   0x691B             LDR      R3,[R3, #+16]
   \   0000002A   0x6ADB             LDR      R3,[R3, #+44]
   \   0000002C   0x4798             BLX      R3
    148              map->endAddress = map->startAddress + tmp - 1;
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x9900             LDR      R1,[SP, #+0]
   \   00000032   0x1808             ADDS     R0,R1,R0
   \   00000034   0x1E40             SUBS     R0,R0,#+1
   \   00000036   0x6060             STR      R0,[R4, #+4]
    149          
    150          #if BL_IS_FLASH_SECTION_PROGRAMMING_ENABLED
    151              s_flash_section_program_info.storedBytes = 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \   0000003E   0x6048             STR      R0,[R1, #+4]
    152          #endif
    153          
    154              return kStatus_Success;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    155          }
    156          
    157          // See flash_memory.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    158          status_t flash_mem_read(uint32_t address, uint32_t length, uint8_t *restrict buffer)
    159          {
   \                     flash_mem_read: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    160          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    161              flash_execute_only_access_state_t access_state;
    162              uint32_t alignedAddress = ALIGN_DOWN(address, g_bootloaderContext.flashState.PFlashAccessSegmentSize);
    163              uint32_t updatedLength = address - alignedAddress + length;
    164              uint32_t alignedLength = ALIGN_UP(updatedLength, g_bootloaderContext.flashState.PFlashAccessSegmentSize);
    165              status_t status = g_bootloaderContext.flashDriverInterface->flash_is_execute_only(
    166                  &g_bootloaderContext.flashState, alignedAddress, alignedLength, &access_state);
    167              if (status != kStatus_Success)
    168              {
    169                  return status;
    170              }
    171          
    172              if (access_state != kFLASH_AccessStateUnLimited)
    173              {
    174                  return kStatus_FLASH_RegionExecuteOnly;
    175              }
    176          #endif // FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    177          
    178              return normal_mem_read(address, length, buffer);
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       normal_mem_read
   \   00000012   0xBD70             POP      {R4-R6,PC}       ;; return
    179          }
    180          
    181          #if !BL_IS_FLASH_SECTION_PROGRAMMING_ENABLED
    182          // See flash_memory.h for documentation on this function.
    183          status_t flash_mem_write(uint32_t address, uint32_t length, const uint8_t *buffer)
    184          {
    185              // Note: the check for "length != 0" and "range not in reserved region" is done in mem_write().
    186              assert(length);
    187              assert(buffer);
    188          
    189              status_t status = kStatus_Success;
    190              uint32_t alignedLength;
    191              uint32_t extraBytes;
    192              uint32_t extraData[2];
    193          
    194              assert(sizeof(extraData) >= sizeof(uint8_t) * FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
    195          
    196              bool verifyWrites;
    197              status = flash_check_access_before_programming(address, length, &verifyWrites);
    198              if (status != kStatus_Success)
    199              {
    200                  return status;
    201              }
    202          
    203              // Align length to whole words.
    204              alignedLength = ALIGN_DOWN(length, sizeof(uint8_t) * FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
    205              extraBytes = length - alignedLength;
    206              assert(extraBytes < sizeof(uint8_t) * FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
    207          
    208              // Pre-fill word buffer with flash erased value.
    209              extraData[0] = (uint32_t)kFlashMemory_ErasedValue;
    210              extraData[1] = (uint32_t)kFlashMemory_ErasedValue;
    211              if (extraBytes)
    212              {
    213                  // Copy extra bytes to word buffer.
    214                  memcpy((uint8_t *)extraData, &buffer[alignedLength], extraBytes);
    215              }
    216          
    217              flash_lock_acquire();
    218              // Program whole words from the user's buffer.
    219              if (alignedLength)
    220              {
    221                  status = g_bootloaderContext.flashDriverInterface->flash_program(&g_bootloaderContext.flashState, address,
    222                                                                                   (uint32_t *)buffer, alignedLength);
    223              }
    224              if ((status == kStatus_Success) && extraBytes)
    225              {
    226                  // Program trailing word.
    227                  status = g_bootloaderContext.flashDriverInterface->flash_program(
    228                      &g_bootloaderContext.flashState, address + alignedLength, extraData,
    229                      (uint32_t)FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
    230              }
    231              flash_lock_release();
    232              if (status != kStatus_Success)
    233              {
    234                  return status;
    235              }
    236          
    237          #if !BL_FEATURE_FLASH_VERIFY_DISABLE
    238              if (verifyWrites)
    239              {
    240                  uint32_t failedAddress;
    241                  uint32_t failedData;
    242          
    243                  flash_lock_acquire();
    244                  if (alignedLength)
    245                  {
    246                      status = g_bootloaderContext.flashDriverInterface->flash_verify_program(
    247                          &g_bootloaderContext.flashState, address, alignedLength, (uint32_t *)buffer,
    248                          (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin, &failedAddress,
    249                          &failedData);
    250                  }
    251                  if ((status == kStatus_Success) && extraBytes)
    252                  {
    253                      status = g_bootloaderContext.flashDriverInterface->flash_verify_program(
    254                          &g_bootloaderContext.flashState, address + alignedLength, sizeof(extraData), extraData,
    255                          (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin, &failedAddress,
    256                          &failedData);
    257                  }
    258                  flash_lock_release();
    259                  if (status != kStatus_Success)
    260                  {
    261                      debug_printf("Error: flash verify failed at address: 0x%x\r\n", failedAddress);
    262                      return status;
    263                  }
    264              }
    265          #endif // !BL_FEATURE_FLASH_VERIFY_DISABLE
    266          
    267              return kStatus_Success;
    268          }
    269          
    270          // See flash_memory.h for documentation on this function.
    271          status_t flash_mem_fill(uint32_t address, uint32_t length, uint32_t pattern)
    272          {
    273              // Note: the check for "length != 0"
    274              assert(length);
    275          
    276              status_t status = kStatus_Success;
    277              uint32_t patternBuffer[8];
    278          
    279              // Pre-fill pattern buffer with pattern.
    280              for (uint32_t i = 0; i < 8; i++)
    281              {
    282                  patternBuffer[i] = pattern;
    283              }
    284          
    285              // Program patterns from the pattern buffer.
    286              while (length)
    287              {
    288                  uint32_t bytes;
    289                  if (length < sizeof(patternBuffer))
    290                  {
    291                      bytes = length;
    292                  }
    293                  else
    294                  {
    295                      bytes = sizeof(patternBuffer);
    296                  }
    297          
    298                  status = flash_mem_write(address, bytes, (uint8_t *)patternBuffer);
    299                  if (status != kStatus_Success)
    300                  {
    301                      return status;
    302                  }
    303          
    304                  address += bytes;
    305                  length -= bytes;
    306              }
    307          
    308              return kStatus_Success;
    309          }
    310          
    311          #else // BL_IS_FLASH_SECTION_PROGRAMMING_ENABLED
    312          
    313          // See flash_memory.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    314          status_t flash_mem_write(uint32_t address, uint32_t length, const uint8_t *buffer)
    315          {
   \                     flash_mem_write: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    316              // Note: the check for "length != 0" and "range not in reserved region" is done in mem_write().
    317              assert(length);
    318              assert(buffer);
    319          
    320              status_t status = kStatus_Success;
   \   0000000A   0x2700             MOVS     R7,#+0
    321          
    322              while (length)
   \                     ??flash_mem_write_0: (+1)
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xD05E             BEQ.N    ??flash_mem_write_1
    323              {
    324                  // Set start address when storing first byte into section program buffer
    325                  if ((!s_flash_section_program_info.storedBytes) && (!s_flash_section_program_info.startAddress))
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   00000014   0x6840             LDR      R0,[R0, #+4]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD10D             BNE.N    ??flash_mem_write_2
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD108             BNE.N    ??flash_mem_write_2
    326                  {
    327                      // Check address alignment
    328                      if (address & (FSL_FEATURE_FLASH_PFLASH_SECTION_CMD_ADDRESS_ALIGMENT - 1))
   \   00000024   0xF014 0x0F0F      TST      R4,#0xF
   \   00000028   0xD001             BEQ.N    ??flash_mem_write_3
    329                      {
    330                          return kStatus_FLASH_AlignmentError;
   \   0000002A   0x2065             MOVS     R0,#+101
   \   0000002C   0xE050             B.N      ??flash_mem_write_4
    331                      }
    332                      s_flash_section_program_info.startAddress = address;
   \                     ??flash_mem_write_3: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   00000032   0x6004             STR      R4,[R0, #+0]
   \   00000034   0xE010             B.N      ??flash_mem_write_5
    333                  }
    334                  else
    335                  {
    336                      // Start section programming operation when meet discontinuous address
    337                      if ((s_flash_section_program_info.startAddress + s_flash_section_program_info.storedBytes) != address)
   \                     ??flash_mem_write_2: (+1)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \   00000040   0x6849             LDR      R1,[R1, #+4]
   \   00000042   0x1808             ADDS     R0,R1,R0
   \   00000044   0x42A0             CMP      R0,R4
   \   00000046   0xD007             BEQ.N    ??flash_mem_write_5
    338                      {
    339                          // flush cached data into target memory,
    340                          status = flash_mem_flush();
   \   00000048   0x.... 0x....      BL       flash_mem_flush
   \   0000004C   0x0007             MOVS     R7,R0
    341                          if (status != kStatus_Success)
   \   0000004E   0x2F00             CMP      R7,#+0
   \   00000050   0xD001             BEQ.N    ??flash_mem_write_6
    342                          {
    343                              return status;
   \   00000052   0x0038             MOVS     R0,R7
   \   00000054   0xE03C             B.N      ??flash_mem_write_4
    344                          }
    345                          continue;
   \                     ??flash_mem_write_6: (+1)
   \   00000056   0xE7D9             B.N      ??flash_mem_write_0
    346                      }
    347                  }
    348          
    349                  uint32_t storeBytes;
    350                  // Check to see if section program buffer will be filled with current data packet
    351                  if ((s_flash_section_program_info.storedBytes + length) <= sizeof(s_flash_section_program_info.buffer))
   \                     ??flash_mem_write_5: (+1)
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   0000005C   0x6840             LDR      R0,[R0, #+4]
   \   0000005E   0x1828             ADDS     R0,R5,R0
   \   00000060   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000064   0xD801             BHI.N    ??flash_mem_write_7
    352                  {
    353                      storeBytes = length;
   \   00000066   0x46A8             MOV      R8,R5
   \   00000068   0xE005             B.N      ??flash_mem_write_8
    354                  }
    355                  else
    356                  {
    357                      storeBytes = sizeof(s_flash_section_program_info.buffer) - s_flash_section_program_info.storedBytes;
   \                     ??flash_mem_write_7: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   0000006E   0x6840             LDR      R0,[R0, #+4]
   \   00000070   0xF5D0 0x6080      RSBS     R0,R0,#+1024
   \   00000074   0x4680             MOV      R8,R0
    358                  }
    359          
    360                  // Copy data to section program buffer
    361                  if (buffer != &s_flash_section_program_info.buffer[s_flash_section_program_info.storedBytes])
   \                     ??flash_mem_write_8: (+1)
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \   0000007E   0x6849             LDR      R1,[R1, #+4]
   \   00000080   0x4408             ADD      R0,R0,R1
   \   00000082   0x3008             ADDS     R0,R0,#+8
   \   00000084   0x4286             CMP      R6,R0
   \   00000086   0xD00B             BEQ.N    ??flash_mem_write_9
    362                  {
    363                      memcpy(&s_flash_section_program_info.buffer[s_flash_section_program_info.storedBytes], buffer, storeBytes);
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   0000008C   0x....             LDR.N    R1,??DataTable9_3
   \   0000008E   0x6849             LDR      R1,[R1, #+4]
   \   00000090   0x4408             ADD      R0,R0,R1
   \   00000092   0xF110 0x0908      ADDS     R9,R0,#+8
   \   00000096   0x4642             MOV      R2,R8
   \   00000098   0x0031             MOVS     R1,R6
   \   0000009A   0x4648             MOV      R0,R9
   \   0000009C   0x.... 0x....      BL       __aeabi_memcpy
    364                  }
    365          
    366                  s_flash_section_program_info.storedBytes += storeBytes;
   \                     ??flash_mem_write_9: (+1)
   \   000000A0   0x....             LDR.N    R0,??DataTable9_3
   \   000000A2   0x6840             LDR      R0,[R0, #+4]
   \   000000A4   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000000A8   0x....             LDR.N    R1,??DataTable9_3
   \   000000AA   0x6048             STR      R0,[R1, #+4]
    367                  buffer += storeBytes;
   \   000000AC   0x4446             ADD      R6,R6,R8
    368                  address += storeBytes;
   \   000000AE   0xEB18 0x0404      ADDS     R4,R8,R4
    369                  length -= storeBytes;
   \   000000B2   0xEBB5 0x0508      SUBS     R5,R5,R8
    370          
    371                  // Start section programming operation when section program buffer is full
    372                  if (s_flash_section_program_info.storedBytes == sizeof(s_flash_section_program_info.buffer))
   \   000000B6   0x....             LDR.N    R0,??DataTable9_3
   \   000000B8   0x6840             LDR      R0,[R0, #+4]
   \   000000BA   0xF5B0 0x6F80      CMP      R0,#+1024
   \   000000BE   0xD1A5             BNE.N    ??flash_mem_write_0
    373                  {
    374                      // flush cached data into target memory,
    375                      status = flash_mem_flush();
   \   000000C0   0x.... 0x....      BL       flash_mem_flush
   \   000000C4   0x0007             MOVS     R7,R0
    376                      if (status != kStatus_Success)
   \   000000C6   0x2F00             CMP      R7,#+0
   \   000000C8   0xD0A0             BEQ.N    ??flash_mem_write_0
    377                      {
    378                          return status;
   \   000000CA   0x0038             MOVS     R0,R7
   \   000000CC   0xE000             B.N      ??flash_mem_write_4
    379                      }
    380                  }
    381              }
    382          
    383              return kStatus_Success;
   \                     ??flash_mem_write_1: (+1)
   \   000000CE   0x2000             MOVS     R0,#+0
   \                     ??flash_mem_write_4: (+1)
   \   000000D0   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    384          }
    385          
    386          // See flash_memory.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    387          status_t flash_mem_fill(uint32_t address, uint32_t length, uint32_t pattern)
    388          {
   \                     flash_mem_fill: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    389              // Note: the check for "length != 0" and "range not in reserved region" is done in mem_fill().
    390              assert(length);
    391          
    392              status_t status;
    393          
    394              // Pre-fill section program buffer with pattern
    395              uint32_t *buffer = (uint32_t *)s_flash_section_program_info.buffer;
   \   0000000A   0x.... 0x....      LDR.W    R9,??DataTable9_4
    396              uint32_t maxPatterns = sizeof(s_flash_section_program_info.buffer) >> 2;
   \   0000000E   0xF44F 0x7880      MOV      R8,#+256
    397              for (uint32_t i = 0; i < maxPatterns; i++)
   \   00000012   0x2000             MOVS     R0,#+0
   \                     ??flash_mem_fill_0: (+1)
   \   00000014   0x4540             CMP      R0,R8
   \   00000016   0xD205             BCS.N    ??flash_mem_fill_1
    398              {
    399                  *buffer++ = pattern;
   \   00000018   0xF8C9 0x6000      STR      R6,[R9, #+0]
   \   0000001C   0xF119 0x0904      ADDS     R9,R9,#+4
    400              }
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0xE7F7             B.N      ??flash_mem_fill_0
    401          
    402              while (length)
   \                     ??flash_mem_fill_1: (+1)
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD019             BEQ.N    ??flash_mem_fill_2
    403              {
    404                  uint32_t bytes;
    405          
    406                  s_flash_section_program_info.storedBytes = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x....             LDR.N    R1,??DataTable9_3
   \   0000002C   0x6048             STR      R0,[R1, #+4]
    407          
    408                  // Check to see if remaining address range can hold whole section program buffer
    409                  if (length < sizeof(s_flash_section_program_info.buffer))
   \   0000002E   0xF5B5 0x6F80      CMP      R5,#+1024
   \   00000032   0xD201             BCS.N    ??flash_mem_fill_3
    410                  {
    411                      bytes = length;
   \   00000034   0x46AA             MOV      R10,R5
   \   00000036   0xE002             B.N      ??flash_mem_fill_4
    412                  }
    413                  else
    414                  {
    415                      bytes = sizeof(s_flash_section_program_info.buffer);
   \                     ??flash_mem_fill_3: (+1)
   \   00000038   0xF44F 0x6080      MOV      R0,#+1024
   \   0000003C   0x4682             MOV      R10,R0
    416                  }
    417          
    418                  // flush cached data into target memory,
    419                  status = flash_mem_write(address, bytes, s_flash_section_program_info.buffer);
   \                     ??flash_mem_fill_4: (+1)
   \   0000003E   0x....             LDR.N    R2,??DataTable9_4
   \   00000040   0x4651             MOV      R1,R10
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       flash_mem_write
   \   00000048   0x0007             MOVS     R7,R0
    420                  if (status != kStatus_Success)
   \   0000004A   0x2F00             CMP      R7,#+0
   \   0000004C   0xD001             BEQ.N    ??flash_mem_fill_5
    421                  {
    422                      return status;
   \   0000004E   0x0038             MOVS     R0,R7
   \   00000050   0xE00C             B.N      ??flash_mem_fill_6
    423                  }
    424          
    425                  address += bytes;
   \                     ??flash_mem_fill_5: (+1)
   \   00000052   0xEB1A 0x0404      ADDS     R4,R10,R4
    426                  length -= bytes;
   \   00000056   0xEBB5 0x050A      SUBS     R5,R5,R10
   \   0000005A   0xE7E3             B.N      ??flash_mem_fill_1
    427              }
    428          
    429              // flush cached data into target memory,
    430              status = flash_mem_flush();
   \                     ??flash_mem_fill_2: (+1)
   \   0000005C   0x.... 0x....      BL       flash_mem_flush
   \   00000060   0x0007             MOVS     R7,R0
    431              if (status != kStatus_Success)
   \   00000062   0x2F00             CMP      R7,#+0
   \   00000064   0xD001             BEQ.N    ??flash_mem_fill_7
    432              {
    433                  return status;
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0xE000             B.N      ??flash_mem_fill_6
    434              }
    435          
    436              return kStatus_Success;
   \                     ??flash_mem_fill_7: (+1)
   \   0000006A   0x2000             MOVS     R0,#+0
   \                     ??flash_mem_fill_6: (+1)
   \   0000006C   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    437          }
    438          
    439          // See memory.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    440          status_t flash_mem_flush(void)
    441          {
   \                     flash_mem_flush: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
    442              status_t status = kStatus_Success;
   \   00000006   0x2400             MOVS     R4,#+0
    443          
    444              if (s_flash_section_program_info.storedBytes)
   \   00000008   0x....             LDR.N    R0,??DataTable9_3
   \   0000000A   0x6840             LDR      R0,[R0, #+4]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD057             BEQ.N    ??flash_mem_flush_0
    445              {
    446                  uint32_t address = s_flash_section_program_info.startAddress;
   \   00000010   0x....             LDR.N    R0,??DataTable9_3
   \   00000012   0x6805             LDR      R5,[R0, #+0]
    447                  uint32_t length = s_flash_section_program_info.storedBytes;
   \   00000014   0x....             LDR.N    R0,??DataTable9_3
   \   00000016   0x6846             LDR      R6,[R0, #+4]
    448          
    449                  // Clear related states no matter following operations are executed successfully or not.
    450                  s_flash_section_program_info.startAddress = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x....             LDR.N    R1,??DataTable9_3
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    451                  s_flash_section_program_info.storedBytes = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x....             LDR.N    R1,??DataTable9_3
   \   00000022   0x6048             STR      R0,[R1, #+4]
    452          
    453                  // Align length to section program unit
    454                  uint32_t alignedLength = ALIGN_UP(length, (uint32_t)FSL_FEATURE_FLASH_PFLASH_SECTION_CMD_ADDRESS_ALIGMENT);
   \   00000024   0x4270             RSBS     R0,R6,#+0
   \   00000026   0x0900             LSRS     R0,R0,#+4
   \   00000028   0x0100             LSLS     R0,R0,#+4
   \   0000002A   0x4247             RSBS     R7,R0,#+0
    455          
    456                  bool verifyWrites;
    457                  status = flash_check_access_before_programming(address, length, &verifyWrites);
   \   0000002C   0xAA03             ADD      R2,SP,#+12
   \   0000002E   0x0031             MOVS     R1,R6
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0x.... 0x....      BL       flash_check_access_before_programming
   \   00000036   0x0004             MOVS     R4,R0
    458                  if (status != kStatus_Success)
   \   00000038   0x2C00             CMP      R4,#+0
   \   0000003A   0xD001             BEQ.N    ??flash_mem_flush_1
    459                  {
    460                      return status;
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0xE040             B.N      ??flash_mem_flush_2
    461                  }
    462          
    463                  // Fill unused region with oxFFs.
    464                  assert(length <= sizeof(s_flash_section_program_info.buffer));
    465                  if (length < alignedLength)
   \                     ??flash_mem_flush_1: (+1)
   \   00000040   0x42BE             CMP      R6,R7
   \   00000042   0xD20C             BCS.N    ??flash_mem_flush_3
    466                  {
    467                      memset(&s_flash_section_program_info.buffer[length], 0xFF, alignedLength - length);
   \   00000044   0xEBB7 0x0806      SUBS     R8,R7,R6
   \   00000048   0xF04F 0x09FF      MOV      R9,#+255
   \   0000004C   0x....             LDR.N    R0,??DataTable9_3
   \   0000004E   0x4430             ADD      R0,R0,R6
   \   00000050   0xF110 0x0A08      ADDS     R10,R0,#+8
   \   00000054   0x464A             MOV      R2,R9
   \   00000056   0x4641             MOV      R1,R8
   \   00000058   0x4650             MOV      R0,R10
   \   0000005A   0x.... 0x....      BL       __aeabi_memset
    468                  }
    469          
    470                  flash_lock_acquire();
   \                     ??flash_mem_flush_3: (+1)
   \   0000005E   0x.... 0x....      BL       flash_lock_acquire
    471                  // Write data of aligned length to flash
    472                  status = FLASH_ProgramSection(&g_bootloaderContext.flashState, address,
    473                                                (uint32_t *)s_flash_section_program_info.buffer, alignedLength);
   \   00000062   0x003B             MOVS     R3,R7
   \   00000064   0x....             LDR.N    R2,??DataTable9_4
   \   00000066   0x0029             MOVS     R1,R5
   \   00000068   0x....             LDR.N    R0,??DataTable9_2
   \   0000006A   0x.... 0x....      BL       FLASH_ProgramSection
   \   0000006E   0x0004             MOVS     R4,R0
    474                  flash_lock_release();
   \   00000070   0x.... 0x....      BL       flash_lock_release
    475          
    476                  if (status != kStatus_Success)
   \   00000074   0x2C00             CMP      R4,#+0
   \   00000076   0xD001             BEQ.N    ??flash_mem_flush_4
    477                  {
    478                      return status;
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0xE022             B.N      ??flash_mem_flush_2
    479                  }
    480          
    481          // Verify wether the data has been programmed to flash successfully.
    482          #if !BL_FEATURE_FLASH_VERIFY_DISABLE
    483                  // Verify flash program
    484                  if (verifyWrites)
   \                     ??flash_mem_flush_4: (+1)
   \   0000007C   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD01D             BEQ.N    ??flash_mem_flush_0
    485                  {
    486                      uint32_t failedAddress;
    487                      uint32_t failedData;
    488          
    489                      flash_lock_acquire();
   \   00000084   0x.... 0x....      BL       flash_lock_acquire
    490                      status = g_bootloaderContext.flashDriverInterface->flash_verify_program(
    491                          &g_bootloaderContext.flashState, address, alignedLength,
    492                          (uint32_t *)&s_flash_section_program_info.buffer,
    493                          (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin, &failedAddress,
    494                          &failedData);
   \   00000088   0xA804             ADD      R0,SP,#+16
   \   0000008A   0x9002             STR      R0,[SP, #+8]
   \   0000008C   0xA805             ADD      R0,SP,#+20
   \   0000008E   0x9001             STR      R0,[SP, #+4]
   \   00000090   0x....             LDR.N    R0,??DataTable9_1
   \   00000092   0x6880             LDR      R0,[R0, #+8]
   \   00000094   0x6900             LDR      R0,[R0, #+16]
   \   00000096   0x6D40             LDR      R0,[R0, #+84]
   \   00000098   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009A   0x9000             STR      R0,[SP, #+0]
   \   0000009C   0x....             LDR.N    R3,??DataTable9_4
   \   0000009E   0x003A             MOVS     R2,R7
   \   000000A0   0x0029             MOVS     R1,R5
   \   000000A2   0x....             LDR.N    R0,??DataTable9_2
   \   000000A4   0x.... 0x....      LDR.W    R12,??DataTable9_1
   \   000000A8   0xF8DC 0xC010      LDR      R12,[R12, #+16]
   \   000000AC   0xF8DC 0xC028      LDR      R12,[R12, #+40]
   \   000000B0   0x47E0             BLX      R12
   \   000000B2   0x0004             MOVS     R4,R0
    495                      flash_lock_release();
   \   000000B4   0x.... 0x....      BL       flash_lock_release
    496                      if (status != kStatus_Success)
   \   000000B8   0x2C00             CMP      R4,#+0
   \   000000BA   0xD001             BEQ.N    ??flash_mem_flush_0
    497                      {
    498                          debug_printf("Error: flash verify failed at address: 0x%x\r\n", failedAddress);
    499                          return status;
   \   000000BC   0x0020             MOVS     R0,R4
   \   000000BE   0xE000             B.N      ??flash_mem_flush_2
    500                      }
    501                  }
    502          #endif // !BL_FEATURE_FLASH_VERIFY_DISABLE
    503              }
    504          
    505              return status;
   \                     ??flash_mem_flush_0: (+1)
   \   000000C0   0x0020             MOVS     R0,R4
   \                     ??flash_mem_flush_2: (+1)
   \   000000C2   0xB006             ADD      SP,SP,#+24
   \   000000C4   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    506          }
    507          #endif // !BL_IS_FLASH_SECTION_PROGRAMMING_ENABLED
    508          
    509          // See memory.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    510          status_t flash_mem_erase(uint32_t address, uint32_t length)
    511          {
   \                     flash_mem_erase: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    512              status_t status;
    513          
    514              flash_lock_acquire();
   \   00000006   0x.... 0x....      BL       flash_lock_acquire
    515              status = g_bootloaderContext.flashDriverInterface->flash_erase(&g_bootloaderContext.flashState, address, length,
    516                                                                             kFLASH_ApiEraseKey);
   \   0000000A   0x....             LDR.N    R3,??DataTable9_5  ;; 0x6b65666b
   \   0000000C   0x002A             MOVS     R2,R5
   \   0000000E   0x0021             MOVS     R1,R4
   \   00000010   0x....             LDR.N    R0,??DataTable9_2
   \   00000012   0x....             LDR.N    R7,??DataTable9_1
   \   00000014   0x693F             LDR      R7,[R7, #+16]
   \   00000016   0x693F             LDR      R7,[R7, #+16]
   \   00000018   0x47B8             BLX      R7
   \   0000001A   0x0006             MOVS     R6,R0
    517              flash_lock_release();
   \   0000001C   0x.... 0x....      BL       flash_lock_release
    518          
    519          #if !BL_FEATURE_FLASH_VERIFY_DISABLE
    520              if ((status == kStatus_Success) && (g_bootloaderContext.propertyInterface->store->verifyWrites))
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD11A             BNE.N    ??flash_mem_erase_0
   \   00000024   0x....             LDR.N    R0,??DataTable9_1
   \   00000026   0x6880             LDR      R0,[R0, #+8]
   \   00000028   0x6900             LDR      R0,[R0, #+16]
   \   0000002A   0x6B00             LDR      R0,[R0, #+48]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD014             BEQ.N    ??flash_mem_erase_0
    521              {
    522                  flash_lock_acquire();
   \   00000030   0x.... 0x....      BL       flash_lock_acquire
    523                  status = g_bootloaderContext.flashDriverInterface->flash_verify_erase(
    524                      &g_bootloaderContext.flashState, address, length,
    525                      (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin);
   \   00000034   0x....             LDR.N    R0,??DataTable9_1
   \   00000036   0x6880             LDR      R0,[R0, #+8]
   \   00000038   0x6900             LDR      R0,[R0, #+16]
   \   0000003A   0x6D43             LDR      R3,[R0, #+84]
   \   0000003C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000003E   0x002A             MOVS     R2,R5
   \   00000040   0x0021             MOVS     R1,R4
   \   00000042   0x....             LDR.N    R0,??DataTable9_2
   \   00000044   0x....             LDR.N    R7,??DataTable9_1
   \   00000046   0x693F             LDR      R7,[R7, #+16]
   \   00000048   0x6A7F             LDR      R7,[R7, #+36]
   \   0000004A   0x47B8             BLX      R7
   \   0000004C   0x0006             MOVS     R6,R0
    526                  flash_lock_release();
   \   0000004E   0x.... 0x....      BL       flash_lock_release
    527                  if (status != kStatus_Success)
   \   00000052   0x2E00             CMP      R6,#+0
   \   00000054   0xD001             BEQ.N    ??flash_mem_erase_0
    528                  {
    529                      debug_printf("Error: flash_verify_erase failed\r\n");
    530                      return status;
   \   00000056   0x0030             MOVS     R0,R6
   \   00000058   0xE000             B.N      ??flash_mem_erase_1
    531                  }
    532              }
    533          #endif // !BL_FEATURE_FLASH_VERIFY_DISABLE
    534          
    535              return status;
   \                     ??flash_mem_erase_0: (+1)
   \   0000005A   0x0030             MOVS     R0,R6
   \                     ??flash_mem_erase_1: (+1)
   \   0000005C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    536          }
    537          
    538          // See memory.h for documentation on this function.
    539          #if BL_FEATURE_FAC_ERASE
    540          status_t flash_mem_erase_all(flash_erase_all_option_t eraseOption)
    541          #else

   \                                 In section .text, align 2, keep-with-next
    542          status_t flash_mem_erase_all(void)
    543          #endif
    544          {
   \                     flash_mem_erase_all: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
    545              status_t status = kStatus_Success;
   \   00000004   0x2400             MOVS     R4,#+0
    546          
    547          // Decompose the the flash erase all into two region erases.
    548          #if BL_TARGET_FLASH
    549              reserved_region_t *reservedRegion =
    550                  &g_bootloaderContext.propertyInterface->store->reservedRegions[kProperty_FlashReservedRegionIndex];
   \   00000006   0x....             LDR.N    R0,??DataTable9_1
   \   00000008   0x6880             LDR      R0,[R0, #+8]
   \   0000000A   0x6900             LDR      R0,[R0, #+16]
   \   0000000C   0xF110 0x055C      ADDS     R5,R0,#+92
    551              const uint32_t eraseSize = g_bootloaderContext.propertyInterface->store->flashSectorSize;
   \   00000010   0x....             LDR.N    R0,??DataTable9_1
   \   00000012   0x6880             LDR      R0,[R0, #+8]
   \   00000014   0x6900             LDR      R0,[R0, #+16]
   \   00000016   0x6986             LDR      R6,[R0, #+24]
    552          
    553          #if BL_FEATURE_FAC_ERASE
    554              if (eraseOption == kFlashEraseAllOption_ExecuteOnlySegments)
    555              {
    556                  uint32_t address = ALIGN_DOWN(reservedRegion->startAddress, eraseSize);
    557                  uint32_t length = ALIGN_UP(reservedRegion->endAddress, eraseSize) - address;
    558                  flash_execute_only_access_state_t access_state;
    559          
    560                  // If the reserved flash region is in an execute-only protected segment, then FAC erase command is not
    561                  // allowed
    562                  flash_lock_acquire();
    563                  status = flash_preprocess_execute_only_region(address, length, &access_state);
    564                  if (status != kStatus_Success)
    565                  {
    566                      flash_lock_release();
    567                      return status;
    568                  }
    569                  flash_lock_release();
    570          
    571                  if (access_state != kFLASH_AccessStateUnLimited)
    572                  {
    573                      return kStatusMemoryAppOverlapWithExecuteOnlyRegion;
    574                  }
    575              }
    576              else if (eraseOption == kFlashEraseAllOption_Blocks)
    577          #endif
    578              {
    579                  memory_map_entry_t *map = (memory_map_entry_t *)&g_bootloaderContext.memoryMap[kIndexFlashArray];
   \   00000018   0x....             LDR.N    R0,??DataTable9_1
   \   0000001A   0x6847             LDR      R7,[R0, #+4]
    580                  bool isReservedRegionEmpty =
    581                      (reservedRegion->startAddress == map->startAddress) && (reservedRegion->endAddress == map->startAddress);
   \   0000001C   0x6828             LDR      R0,[R5, #+0]
   \   0000001E   0x6839             LDR      R1,[R7, #+0]
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD106             BNE.N    ??flash_mem_erase_all_0
   \   00000024   0x6868             LDR      R0,[R5, #+4]
   \   00000026   0x6839             LDR      R1,[R7, #+0]
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xD102             BNE.N    ??flash_mem_erase_all_0
   \   0000002C   0xF05F 0x0801      MOVS     R8,#+1
   \   00000030   0xE001             B.N      ??flash_mem_erase_all_1
   \                     ??flash_mem_erase_all_0: (+1)
   \   00000032   0xF05F 0x0800      MOVS     R8,#+0
    582                  if (!isReservedRegionEmpty)
   \                     ??flash_mem_erase_all_1: (+1)
   \   00000036   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000003A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000003E   0xD124             BNE.N    ??flash_mem_erase_all_2
    583                  {
    584                      // Erase the initial unreserved region, if any.
    585                      if (reservedRegion->startAddress > map->startAddress)
   \   00000040   0x6838             LDR      R0,[R7, #+0]
   \   00000042   0x6829             LDR      R1,[R5, #+0]
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD20B             BCS.N    ??flash_mem_erase_all_3
    586                      {
    587                          uint32_t length = ALIGN_DOWN(reservedRegion->startAddress, eraseSize);
   \   00000048   0x6828             LDR      R0,[R5, #+0]
   \   0000004A   0x4271             RSBS     R1,R6,#+0
   \   0000004C   0xEA11 0x0900      ANDS     R9,R1,R0
    588                          if (length > 0)
   \   00000050   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000054   0xD004             BEQ.N    ??flash_mem_erase_all_3
    589                          {
    590                              status = flash_mem_erase(map->startAddress, length);
   \   00000056   0x4649             MOV      R1,R9
   \   00000058   0x6838             LDR      R0,[R7, #+0]
   \   0000005A   0x.... 0x....      BL       flash_mem_erase
   \   0000005E   0x0004             MOVS     R4,R0
    591                          }
    592                      }
    593          
    594                      // Erase the final unreserved region, if any.
    595                      if (status == kStatus_Success)
   \                     ??flash_mem_erase_all_3: (+1)
   \   00000060   0x2C00             CMP      R4,#+0
   \   00000062   0xD110             BNE.N    ??flash_mem_erase_all_4
    596                      {
    597                          uint32_t start = ALIGN_UP(reservedRegion->endAddress, eraseSize);
   \   00000064   0x6868             LDR      R0,[R5, #+4]
   \   00000066   0x4240             RSBS     R0,R0,#+0
   \   00000068   0x4271             RSBS     R1,R6,#+0
   \   0000006A   0x4008             ANDS     R0,R1,R0
   \   0000006C   0xF1D0 0x0900      RSBS     R9,R0,#+0
    598                          if (start < map->endAddress)
   \   00000070   0x6878             LDR      R0,[R7, #+4]
   \   00000072   0x4581             CMP      R9,R0
   \   00000074   0xD207             BCS.N    ??flash_mem_erase_all_4
    599                          {
    600                              status = flash_mem_erase(start, (map->endAddress + 1) - start);
   \   00000076   0x6878             LDR      R0,[R7, #+4]
   \   00000078   0x1C40             ADDS     R0,R0,#+1
   \   0000007A   0xEBB0 0x0109      SUBS     R1,R0,R9
   \   0000007E   0x4648             MOV      R0,R9
   \   00000080   0x.... 0x....      BL       flash_mem_erase
   \   00000084   0x0004             MOVS     R4,R0
    601                          }
    602                      }
    603          
    604                      return status;
   \                     ??flash_mem_erase_all_4: (+1)
   \   00000086   0x0020             MOVS     R0,R4
   \   00000088   0xE026             B.N      ??flash_mem_erase_all_5
    605                  }
    606              }
    607          
    608          #endif // BL_TARGET_FLASH
    609          
    610              // Do full erase and verify.
    611          
    612              flash_lock_acquire();
   \                     ??flash_mem_erase_all_2: (+1)
   \   0000008A   0x.... 0x....      BL       flash_lock_acquire
    613          #if BL_FEATURE_FAC_ERASE
    614              if (eraseOption == kFlashEraseAllOption_ExecuteOnlySegments)
    615              {
    616                  status = g_bootloaderContext.flashDriverInterface->flash_erase_all_execute_only_segments(
    617                      &g_bootloaderContext.flashState, kFLASH_ApiEraseKey);
    618              }
    619              else if (eraseOption == kFlashEraseAllOption_Blocks)
    620          #endif
    621              {
    622                  status = g_bootloaderContext.flashDriverInterface->flash_erase_all(&g_bootloaderContext.flashState,
    623                                                                                     kFLASH_ApiEraseKey);
   \   0000008E   0x....             LDR.N    R1,??DataTable9_5  ;; 0x6b65666b
   \   00000090   0x....             LDR.N    R0,??DataTable9_2
   \   00000092   0x....             LDR.N    R2,??DataTable9_1
   \   00000094   0x6912             LDR      R2,[R2, #+16]
   \   00000096   0x6892             LDR      R2,[R2, #+8]
   \   00000098   0x4790             BLX      R2
   \   0000009A   0x0004             MOVS     R4,R0
    624              }
    625              flash_lock_release();
   \   0000009C   0x.... 0x....      BL       flash_lock_release
    626          
    627          #if !BL_FEATURE_FLASH_VERIFY_DISABLE
    628              if ((status == kStatus_Success) && (g_bootloaderContext.propertyInterface->store->verifyWrites))
   \   000000A0   0x2C00             CMP      R4,#+0
   \   000000A2   0xD118             BNE.N    ??flash_mem_erase_all_6
   \   000000A4   0x....             LDR.N    R0,??DataTable9_1
   \   000000A6   0x6880             LDR      R0,[R0, #+8]
   \   000000A8   0x6900             LDR      R0,[R0, #+16]
   \   000000AA   0x6B00             LDR      R0,[R0, #+48]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD012             BEQ.N    ??flash_mem_erase_all_6
    629              {
    630                  flash_lock_acquire();
   \   000000B0   0x.... 0x....      BL       flash_lock_acquire
    631          #if BL_FEATURE_FAC_ERASE
    632                  if (eraseOption == kFlashEraseAllOption_ExecuteOnlySegments)
    633                  {
    634                      status = g_bootloaderContext.flashDriverInterface->flash_verify_erase_all_execute_only_segments(
    635                          &g_bootloaderContext.flashState,
    636                          (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin);
    637                  }
    638                  else if (eraseOption == kFlashEraseAllOption_Blocks)
    639          #endif
    640                  {
    641                      status = g_bootloaderContext.flashDriverInterface->flash_verify_erase_all(
    642                          &g_bootloaderContext.flashState,
    643                          (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin);
   \   000000B4   0x....             LDR.N    R0,??DataTable9_1
   \   000000B6   0x6880             LDR      R0,[R0, #+8]
   \   000000B8   0x6900             LDR      R0,[R0, #+16]
   \   000000BA   0x6D41             LDR      R1,[R0, #+84]
   \   000000BC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000BE   0x....             LDR.N    R0,??DataTable9_2
   \   000000C0   0x....             LDR.N    R2,??DataTable9_1
   \   000000C2   0x6912             LDR      R2,[R2, #+16]
   \   000000C4   0x6A12             LDR      R2,[R2, #+32]
   \   000000C6   0x4790             BLX      R2
   \   000000C8   0x0004             MOVS     R4,R0
    644                  }
    645                  flash_lock_release();
   \   000000CA   0x.... 0x....      BL       flash_lock_release
    646                  if (status != kStatus_Success)
   \   000000CE   0x2C00             CMP      R4,#+0
   \   000000D0   0xD001             BEQ.N    ??flash_mem_erase_all_6
    647                  {
    648                      debug_printf("Error: flash_verify_erase_all/all_execute_only_segments failed\r\n");
    649                      return status;
   \   000000D2   0x0020             MOVS     R0,R4
   \   000000D4   0xE000             B.N      ??flash_mem_erase_all_5
    650                  }
    651              }
    652          #endif // !BL_FEATURE_FLASH_VERIFY_DISABLE
    653          
    654          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    655              if (status == kStatus_Success)
    656              {
    657                  isFlashRegionUnlocked = true;
    658              }
    659          #endif // FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    660          
    661              return status;
   \                     ??flash_mem_erase_all_6: (+1)
   \   000000D6   0x0020             MOVS     R0,R4
   \                     ??flash_mem_erase_all_5: (+1)
   \   000000D8   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    662          }
    663          
    664          // See memory.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    665          status_t flash_mem_erase_all_unsecure(void)
    666          {
   \                     flash_mem_erase_all_unsecure: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    667              status_t status;
    668          
    669              flash_lock_acquire();
   \   00000002   0x.... 0x....      BL       flash_lock_acquire
    670              status = g_bootloaderContext.flashDriverInterface->flash_erase_all_unsecure(&g_bootloaderContext.flashState,
    671                                                                                          kFLASH_ApiEraseKey);
   \   00000006   0x....             LDR.N    R1,??DataTable9_5  ;; 0x6b65666b
   \   00000008   0x....             LDR.N    R0,??DataTable9_2
   \   0000000A   0x....             LDR.N    R2,??DataTable9_1
   \   0000000C   0x6912             LDR      R2,[R2, #+16]
   \   0000000E   0x68D2             LDR      R2,[R2, #+12]
   \   00000010   0x4790             BLX      R2
   \   00000012   0x0004             MOVS     R4,R0
    672              flash_lock_release();
   \   00000014   0x.... 0x....      BL       flash_lock_release
    673          
    674              return status;
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    675          }
    676          
    677          //! @brief check if a flash region is in an XA controlled region or contains an XA controlled region.
    678          //         and try to open flash program state by calling verify_erase_all command if needed.

   \                                 In section .text, align 2, keep-with-next
    679          status_t flash_preprocess_execute_only_region(uint32_t address,
    680                                                        uint32_t length,
    681                                                        flash_execute_only_access_state_t *state)
    682          {
   \                     flash_preprocess_execute_only_region: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0003             MOVS     R3,R0
    683              status_t status = kStatus_Success;
   \   00000004   0x2000             MOVS     R0,#+0
    684              *state = kFLASH_AccessStateUnLimited;
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x7014             STRB     R4,[R2, #+0]
    685          
    686          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    687              // If a target flash location is in an execute-only protected segment, these program commands are not
    688              // allowed unless a Read 1s All Blocks command is executed and returns with a pass code
    689              flash_execute_only_access_state_t access_state;
    690          
    691              status = g_bootloaderContext.flashDriverInterface->flash_is_execute_only(&g_bootloaderContext.flashState, address,
    692                                                                                       length, &access_state);
    693              if (status != kStatus_Success)
    694              {
    695                  return status;
    696              }
    697          
    698              *state = access_state;
    699          
    700              if ((access_state != kFLASH_AccessStateUnLimited) && (!isFlashRegionUnlocked))
    701              {
    702          #if BL_FEATURE_FAC_ERASE
    703                  status = g_bootloaderContext.flashDriverInterface->flash_verify_erase_all_execute_only_segments(
    704                      &g_bootloaderContext.flashState,
    705                      (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin);
    706          #else
    707                  status = g_bootloaderContext.flashDriverInterface->flash_verify_erase_all(
    708                      &g_bootloaderContext.flashState,
    709                      (flash_margin_value_t)g_bootloaderContext.propertyInterface->store->flashReadMargin);
    710          #endif
    711                  if (status != kStatus_Success)
    712                  {
    713                      return kStatus_FLASH_RegionExecuteOnly;
    714                  }
    715          
    716                  isFlashRegionUnlocked = true;
    717              }
    718          #endif // FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    719              return status;
   \   0000000A   0xBC10             POP      {R4}
   \   0000000C   0x4770             BX       LR               ;; return
    720          }
    721          

   \                                 In section .text, align 2, keep-with-next
    722          status_t flash_check_access_before_programming(uint32_t address, uint32_t length, bool *verifyWrites)
    723          {
   \                     flash_check_access_before_programming: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    724              status_t status = kStatus_Success;
   \   0000000A   0x2700             MOVS     R7,#+0
    725          
    726          #if !BL_FEATURE_FLASH_VERIFY_DISABLE
    727              *verifyWrites = g_bootloaderContext.propertyInterface->store->verifyWrites;
   \   0000000C   0x....             LDR.N    R0,??DataTable9_1
   \   0000000E   0x6880             LDR      R0,[R0, #+8]
   \   00000010   0x6900             LDR      R0,[R0, #+16]
   \   00000012   0x6B00             LDR      R0,[R0, #+48]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ.N    ??flash_check_access_before_programming_0
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE000             B.N      ??flash_check_access_before_programming_1
   \                     ??flash_check_access_before_programming_0: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \                     ??flash_check_access_before_programming_1: (+1)
   \   0000001E   0x7030             STRB     R0,[R6, #+0]
    728          #endif // BL_FEATURE_FLASH_VERIFY_DISABLE
    729          
    730          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    731              // If a target flash location is in an execute-only protected segment, these program commands are not
    732              // allowed unless a Read 1s All Blocks command is executed and returns with a pass code
    733              flash_execute_only_access_state_t access_state;
    734          
    735              uint32_t actualLength = ALIGN_UP(length, (uint32_t)FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
    736              flash_lock_acquire();
    737              status = flash_preprocess_execute_only_region(address, actualLength, &access_state);
    738              if (status != kStatus_Success)
    739              {
    740                  flash_lock_release();
    741                  return status;
    742              }
    743              flash_lock_release();
    744          
    745          #if !BL_FEATURE_FLASH_VERIFY_DISABLE
    746              if (access_state != kFLASH_AccessStateUnLimited)
    747              {
    748                  *verifyWrites = false;
    749              }
    750          #endif // BL_FEATURE_FLASH_VERIFY_DISABLE
    751          
    752          #endif // FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    753          
    754          // Do cumulative write check
    755          #if BL_FEATURE_FLASH_CHECK_CUMULATIVE_WRITE || FSL_FEATURE_SOC_FTFE_COUNT
    756              bool isCumulativeCheckNeeded = true;
   \   00000020   0xF05F 0x0801      MOVS     R8,#+1
    757          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    758              if (access_state != kFLASH_AccessStateUnLimited)
    759              {
    760                  isCumulativeCheckNeeded = false;
    761              }
    762          #endif // FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    763              if (isCumulativeCheckNeeded)
   \   00000024   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000028   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000002C   0xD00D             BEQ.N    ??flash_check_access_before_programming_2
    764              {
    765                  uint32_t actualLength = ALIGN_UP(length, (uint32_t)FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
   \   0000002E   0x4268             RSBS     R0,R5,#+0
   \   00000030   0x08C0             LSRS     R0,R0,#+3
   \   00000032   0x00C0             LSLS     R0,R0,#+3
   \   00000034   0xF1D0 0x0900      RSBS     R9,R0,#+0
    766                  if (!mem_is_erased(address, actualLength))
   \   00000038   0x4649             MOV      R1,R9
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       mem_is_erased
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD102             BNE.N    ??flash_check_access_before_programming_2
    767                  {
    768                      return kStatusMemoryCumulativeWrite;
   \   00000044   0xF242 0x70DB      MOVW     R0,#+10203
   \   00000048   0xE000             B.N      ??flash_check_access_before_programming_3
    769                  }
    770              }
    771          #endif // BL_FEATURE_FLASH_CHECK_CUMULATIVE_WRITE || FSL_FEATURE_SOC_FTFE_COUNT
    772          
    773              return status;
   \                     ??flash_check_access_before_programming_2: (+1)
   \   0000004A   0x0038             MOVS     R0,R7
   \                     ??flash_check_access_before_programming_3: (+1)
   \   0000004C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    774          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     s_regPrimask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     g_bootloaderContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     g_bootloaderContext+0x20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     s_flash_section_program_info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     s_flash_section_program_info+0x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x6B65666B         DC32     0x6b65666b
    775          
    776          ////////////////////////////////////////////////////////////////////////////////
    777          // EOF
    778          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   flash_check_access_before_programming
        32   -> mem_is_erased
       0   flash_lock_acquire
       0   flash_lock_release
      24   flash_mem_erase
        24   -- Indirect call
        24   -> flash_lock_acquire
        24   -> flash_lock_release
      32   flash_mem_erase_all
        32   -- Indirect call
        32   -> flash_lock_acquire
        32   -> flash_lock_release
        32   -> flash_mem_erase
       8   flash_mem_erase_all_unsecure
         8   -- Indirect call
         8   -> flash_lock_acquire
         8   -> flash_lock_release
      32   flash_mem_fill
        32   -> flash_mem_flush
        32   -> flash_mem_write
      56   flash_mem_flush
        56   -- Indirect call
        56   -> FLASH_ProgramSection
        56   -> __aeabi_memset
        56   -> flash_check_access_before_programming
        56   -> flash_lock_acquire
        56   -> flash_lock_release
      16   flash_mem_init
        16   -- Indirect call
      16   flash_mem_read
        16   -> normal_mem_read
      32   flash_mem_write
        32   -> __aeabi_memcpy
        32   -> flash_mem_flush
       4   flash_preprocess_execute_only_region


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
      80  flash_check_access_before_programming
      14  flash_lock_acquire
      12  flash_lock_release
      94  flash_mem_erase
     220  flash_mem_erase_all
      28  flash_mem_erase_all_unsecure
     112  flash_mem_fill
     200  flash_mem_flush
      68  flash_mem_init
      20  flash_mem_read
     212  flash_mem_write
      14  flash_preprocess_execute_only_region
      24  g_flashMemoryInterface
    1032  s_flash_section_program_info
       4  s_regPrimask

 
 1 036 bytes in section .bss
    24 bytes in section .rodata
 1 098 bytes in section .text
 
 1 098 bytes of CODE  memory
    24 bytes of CONST memory
 1 036 bytes of DATA  memory

Errors: none
Warnings: none
