###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:15
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_msc.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_msc.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\usb_device_msc.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\usb_device_msc.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_msc.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "usb_device_config.h"
     32          #include "usb.h"
     33          #include "usb_device.h"
     34          
     35          #include "usb_device_class.h"
     36          
     37          #if ((defined(USB_DEVICE_CONFIG_MSC)) && (USB_DEVICE_CONFIG_MSC > 0U))
     38          #include "usb_device_msc.h"
     39          /*******************************************************************************
     40           * Definitions
     41           ******************************************************************************/
     42          
     43          /*******************************************************************************
     44           * Prototypes
     45           ******************************************************************************/
     46          usb_status_t USB_DeviceMscRecv(usb_device_msc_struct_t *mscHandle);
     47          usb_status_t USB_DeviceMscSend(usb_device_msc_struct_t *mscHandle);
     48          /*******************************************************************************
     49           * Variables
     50           ******************************************************************************/
     51          

   \                                 In section m_usb_global, align 4
     52          USB_GLOBAL usb_device_msc_struct_t g_msc_handle[USB_DEVICE_CONFIG_MSC_MAX_INSTANCE];
   \                     g_msc_handle:
   \   00000000                      DS8 256
     53          /*******************************************************************************
     54           * Code
     55           ******************************************************************************/
     56          
     57          /*!
     58           * @brief Allocate a device msc class handle.
     59           *
     60           * This function allocates a device msc class handle.
     61           *
     62           * @param handle          It is out parameter, is used to return pointer of the device msc class handle to the caller.
     63           *
     64           * @retval kStatus_USB_Success              Get a device msc class handle successfully.
     65           * @retval kStatus_USB_Busy                 Cannot allocate a device msc class handle.
     66           */
     67          

   \                                 In section .text, align 2, keep-with-next
     68          static usb_status_t USB_DeviceMscAllocateHandle(usb_device_msc_struct_t **handle)
     69          {
   \                     USB_DeviceMscAllocateHandle: (+1)
   \   00000000   0x0001             MOVS     R1,R0
     70              uint32_t count;
     71              for (count = 0; count < USB_DEVICE_CONFIG_MSC_MAX_INSTANCE; count++)
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x0002             MOVS     R2,R0
   \                     ??USB_DeviceMscAllocateHandle_0: (+1)
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD114             BNE.N    ??USB_DeviceMscAllocateHandle_1
     72              {
     73                  if (NULL == g_msc_handle[count].handle)
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable3
   \   0000000E   0xF44F 0x7380      MOV      R3,#+256
   \   00000012   0xFB03 0xF302      MUL      R3,R3,R2
   \   00000016   0x58C0             LDR      R0,[R0, R3]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD109             BNE.N    ??USB_DeviceMscAllocateHandle_2
     74                  {
     75                      *handle = &g_msc_handle[count];
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable3
   \   00000020   0xF44F 0x7380      MOV      R3,#+256
   \   00000024   0xFB03 0xF302      MUL      R3,R3,R2
   \   00000028   0x4418             ADD      R0,R0,R3
   \   0000002A   0x6008             STR      R0,[R1, #+0]
     76                      return kStatus_USB_Success;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE002             B.N      ??USB_DeviceMscAllocateHandle_3
     77                  }
     78              }
   \                     ??USB_DeviceMscAllocateHandle_2: (+1)
   \   00000030   0x1C52             ADDS     R2,R2,#+1
   \   00000032   0xE7E8             B.N      ??USB_DeviceMscAllocateHandle_0
     79          
     80              return kStatus_USB_Busy;
   \                     ??USB_DeviceMscAllocateHandle_1: (+1)
   \   00000034   0x2002             MOVS     R0,#+2
   \                     ??USB_DeviceMscAllocateHandle_3: (+1)
   \   00000036   0x4770             BX       LR               ;; return
     81          }
     82          
     83          /*!
     84           * @brief Free a device msc class hanlde.
     85           *
     86           * This function frees a device msc class hanlde.
     87           *
     88           * @param handle          The device msc class hanlde.
     89           *
     90           * @retval kStatus_USB_Success              Free device msc class hanlde successfully.
     91           */

   \                                 In section .text, align 2, keep-with-next
     92          static usb_status_t USB_DeviceMscFreeHandle(usb_device_msc_struct_t *handle)
     93          {
   \                     USB_DeviceMscFreeHandle: (+1)
   \   00000000   0x0001             MOVS     R1,R0
     94              handle->handle = NULL;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x6008             STR      R0,[R1, #+0]
     95              handle->configurationStruct = (usb_device_class_config_struct_t *)NULL;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x6048             STR      R0,[R1, #+4]
     96              handle->configuration = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF881 0x00FC      STRB     R0,[R1, #+252]
     97              handle->alternate = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF881 0x00FB      STRB     R0,[R1, #+251]
     98              return kStatus_USB_Success;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR               ;; return
     99          }
    100          
    101          /*!
    102           * @brief Process usb msc ufi command.
    103           *
    104           * This function analyse the cbw , get the command code.
    105           *
    106           * @param handle          The device msc class hanlde.
    107           *
    108           * @retval kStatus_USB_Success              Free device msc class hanlde successfully.
    109           */

   \                                 In section .text, align 2, keep-with-next
    110          usb_status_t USB_DeviceMscProcessUfiCommand(usb_device_msc_struct_t *mscHandle)
    111          {
   \                     USB_DeviceMscProcessUfiCommand: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    112              usb_status_t error = kStatus_USB_Error;
   \   00000004   0x2501             MOVS     R5,#+1
    113              usb_device_msc_ufi_struct_t *ufi = NULL;
   \   00000006   0x2600             MOVS     R6,#+0
    114          
    115              ufi = &mscHandle->mscUfi;
   \   00000008   0xF114 0x0058      ADDS     R0,R4,#+88
   \   0000000C   0x0006             MOVS     R6,R0
    116          
    117              ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_NO_SENSE;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x70B0             STRB     R0,[R6, #+2]
    118              ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_NO_SENSE;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x7330             STRB     R0,[R6, #+12]
    119              ufi->requestSense.additionalSenseQualifer = USB_DEVICE_MSC_UFI_NO_SENSE;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x7370             STRB     R0,[R6, #+13]
    120              ufi->thirteenCase.hostExpectedDataLength = mscHandle->mscCbw.dataTransferLength;
   \   0000001A   0x6B20             LDR      R0,[R4, #+48]
   \   0000001C   0x6170             STR      R0,[R6, #+20]
    121              ufi->thirteenCase.hostExpectedDirection = (uint8_t)(mscHandle->mscCbw.flags >> USB_DEVICE_MSC_CBW_DIRECTION_SHIFT);
   \   0000001E   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0x09C0             LSRS     R0,R0,#+7
   \   00000026   0xF886 0x0029      STRB     R0,[R6, #+41]
    122              /*The first byte of all ufi command blocks shall contain an Operation Code, refer to ufi spec*/
    123              switch (mscHandle->mscCbw.cbwcb[0])
   \   0000002A   0xF894 0x0037      LDRB     R0,[R4, #+55]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD033             BEQ.N    ??USB_DeviceMscProcessUfiCommand_0
   \   00000032   0x2803             CMP      R0,#+3
   \   00000034   0xD02C             BEQ.N    ??USB_DeviceMscProcessUfiCommand_1
   \   00000036   0x2804             CMP      R0,#+4
   \   00000038   0xD03E             BEQ.N    ??USB_DeviceMscProcessUfiCommand_2
   \   0000003A   0x2812             CMP      R0,#+18
   \   0000003C   0xD01E             BEQ.N    ??USB_DeviceMscProcessUfiCommand_3
   \   0000003E   0x2815             CMP      R0,#+21
   \   00000040   0xD049             BEQ.N    ??USB_DeviceMscProcessUfiCommand_4
   \   00000042   0x281A             CMP      R0,#+26
   \   00000044   0xD042             BEQ.N    ??USB_DeviceMscProcessUfiCommand_5
   \   00000046   0x281B             CMP      R0,#+27
   \   00000048   0xD059             BEQ.N    ??USB_DeviceMscProcessUfiCommand_6
   \   0000004A   0x281D             CMP      R0,#+29
   \   0000004C   0xD04D             BEQ.N    ??USB_DeviceMscProcessUfiCommand_7
   \   0000004E   0x281E             CMP      R0,#+30
   \   00000050   0xD02D             BEQ.N    ??USB_DeviceMscProcessUfiCommand_8
   \   00000052   0x2823             CMP      R0,#+35
   \   00000054   0xD044             BEQ.N    ??USB_DeviceMscProcessUfiCommand_9
   \   00000056   0x2825             CMP      R0,#+37
   \   00000058   0xD033             BEQ.N    ??USB_DeviceMscProcessUfiCommand_10
   \   0000005A   0x2828             CMP      R0,#+40
   \   0000005C   0xD013             BEQ.N    ??USB_DeviceMscProcessUfiCommand_11
   \   0000005E   0x282A             CMP      R0,#+42
   \   00000060   0xD020             BEQ.N    ??USB_DeviceMscProcessUfiCommand_12
   \   00000062   0x282F             CMP      R0,#+47
   \   00000064   0xD046             BEQ.N    ??USB_DeviceMscProcessUfiCommand_13
   \   00000066   0x2855             CMP      R0,#+85
   \   00000068   0xD035             BEQ.N    ??USB_DeviceMscProcessUfiCommand_4
   \   0000006A   0x285A             CMP      R0,#+90
   \   0000006C   0xD02E             BEQ.N    ??USB_DeviceMscProcessUfiCommand_5
   \   0000006E   0x289E             CMP      R0,#+158
   \   00000070   0xD027             BEQ.N    ??USB_DeviceMscProcessUfiCommand_10
   \   00000072   0x28A8             CMP      R0,#+168
   \   00000074   0xD007             BEQ.N    ??USB_DeviceMscProcessUfiCommand_11
   \   00000076   0x28AA             CMP      R0,#+170
   \   00000078   0xD014             BEQ.N    ??USB_DeviceMscProcessUfiCommand_12
   \   0000007A   0xE045             B.N      ??USB_DeviceMscProcessUfiCommand_14
    124              {
    125                  /* ufi commmand operation code*/
    126                  case USB_DEVICE_MSC_INQUIRY_COMMAND: /*operation code : 0x12*/
    127                      error = USB_DeviceMscUfiInquiryCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_3: (+1)
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0x.... 0x....      BL       USB_DeviceMscUfiInquiryCommand
   \   00000082   0x0005             MOVS     R5,R0
    128                      break;
   \   00000084   0xE056             B.N      ??USB_DeviceMscProcessUfiCommand_15
    129                  case USB_DEVICE_MSC_READ_10_COMMAND: /*operation code : 0x28 */
    130                  case USB_DEVICE_MSC_READ_12_COMMAND: /*operation code : 0xA8 */
    131                      error = USB_DeviceMscUfiReadCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_11: (+1)
   \   00000086   0x0020             MOVS     R0,R4
   \   00000088   0x.... 0x....      BL       USB_DeviceMscUfiReadCommand
   \   0000008C   0x0005             MOVS     R5,R0
    132                      break;
   \   0000008E   0xE051             B.N      ??USB_DeviceMscProcessUfiCommand_15
    133                  case USB_DEVICE_MSC_REQUEST_SENSE_COMMAND: /*operation code : 0x03*/
    134                      error = USB_DeviceMscUfiRequestSenseCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_1: (+1)
   \   00000090   0x0020             MOVS     R0,R4
   \   00000092   0x.... 0x....      BL       USB_DeviceMscUfiRequestSenseCommand
   \   00000096   0x0005             MOVS     R5,R0
    135                      break;
   \   00000098   0xE04C             B.N      ??USB_DeviceMscProcessUfiCommand_15
    136                  case USB_DEVICE_MSC_TEST_UNIT_READY_COMMAND: /*operation code : 0x00 */
    137                      error = USB_DeviceMscUfiTestUnitReadyCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_0: (+1)
   \   0000009A   0x0020             MOVS     R0,R4
   \   0000009C   0x.... 0x....      BL       USB_DeviceMscUfiTestUnitReadyCommand
   \   000000A0   0x0005             MOVS     R5,R0
    138                      break;
   \   000000A2   0xE047             B.N      ??USB_DeviceMscProcessUfiCommand_15
    139                  case USB_DEVICE_MSC_WRITE_10_COMMAND: /*operation code : 0x2A */
    140                  case USB_DEVICE_MSC_WRITE_12_COMMAND: /*operation code : 0xAA */
    141                      error = USB_DeviceMscUfiWriteCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_12: (+1)
   \   000000A4   0x0020             MOVS     R0,R4
   \   000000A6   0x.... 0x....      BL       USB_DeviceMscUfiWriteCommand
   \   000000AA   0x0005             MOVS     R5,R0
    142                      break;
   \   000000AC   0xE042             B.N      ??USB_DeviceMscProcessUfiCommand_15
    143                  case USB_DEVICE_MSC_PREVENT_ALLOW_MEDIUM_REM_COMMAND: /*operation code :0x1E */
    144                      error = USB_DeviceMscUfiPreventAllowMediumCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_8: (+1)
   \   000000AE   0x0020             MOVS     R0,R4
   \   000000B0   0x.... 0x....      BL       USB_DeviceMscUfiPreventAllowMediumCommand
   \   000000B4   0x0005             MOVS     R5,R0
    145                      break;
   \   000000B6   0xE03D             B.N      ??USB_DeviceMscProcessUfiCommand_15
    146                  case USB_DEVICE_MSC_FORMAT_UNIT_COMMAND: /*operation code : 0x04*/
    147                      error = USB_DeviceMscUfiFormatUnitCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_2: (+1)
   \   000000B8   0x0020             MOVS     R0,R4
   \   000000BA   0x.... 0x....      BL       USB_DeviceMscUfiFormatUnitCommand
   \   000000BE   0x0005             MOVS     R5,R0
    148                      break;
   \   000000C0   0xE038             B.N      ??USB_DeviceMscProcessUfiCommand_15
    149                  case USB_DEVICE_MSC_READ_CAPACITY_10_COMMAND: /*operation code : 0x25*/
    150                  case USB_DEVICE_MSC_READ_CAPACITY_16_COMMAND: /*operation code : 0x9E*/
    151                      error = USB_DeviceMscUfiReadCapacityCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_10: (+1)
   \   000000C2   0x0020             MOVS     R0,R4
   \   000000C4   0x.... 0x....      BL       USB_DeviceMscUfiReadCapacityCommand
   \   000000C8   0x0005             MOVS     R5,R0
    152                      break;
   \   000000CA   0xE033             B.N      ??USB_DeviceMscProcessUfiCommand_15
    153                  case USB_DEVICE_MSC_MODE_SENSE_10_COMMAND: /* operation code :0x5A*/
    154                  case USB_DEVICE_MSC_MODE_SENSE_6_COMMAND:  /* operation code : 0x1A */
    155                      error = USB_DeviceMscUfiModeSenseCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_5: (+1)
   \   000000CC   0x0020             MOVS     R0,R4
   \   000000CE   0x.... 0x....      BL       USB_DeviceMscUfiModeSenseCommand
   \   000000D2   0x0005             MOVS     R5,R0
    156                      break;
   \   000000D4   0xE02E             B.N      ??USB_DeviceMscProcessUfiCommand_15
    157                  case USB_DEVICE_MSC_MODE_SELECT_10_COMMAND: /*operation code : 0x55 */
    158                  case USB_DEVICE_MSC_MODE_SELECT_6_COMMAND:  /*operation code : 0x15 */
    159                      error = USB_DeviceMscUfiModeSelectCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_4: (+1)
   \   000000D6   0x0020             MOVS     R0,R4
   \   000000D8   0x.... 0x....      BL       USB_DeviceMscUfiModeSelectCommand
   \   000000DC   0x0005             MOVS     R5,R0
    160                      break;
   \   000000DE   0xE029             B.N      ??USB_DeviceMscProcessUfiCommand_15
    161                  case USB_DEVICE_MSC_READ_FORMAT_CAPACITIES_COMMAND: /*operation code : 0x23 */
    162                      error = USB_DeviceMscUfiReadFormatCapacityCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_9: (+1)
   \   000000E0   0x0020             MOVS     R0,R4
   \   000000E2   0x.... 0x....      BL       USB_DeviceMscUfiReadFormatCapacityCommand
   \   000000E6   0x0005             MOVS     R5,R0
    163                      break;
   \   000000E8   0xE024             B.N      ??USB_DeviceMscProcessUfiCommand_15
    164                  case USB_DEVICE_MSC_SEND_DIAGNOSTIC_COMMAND: /*operation code : 0x1D*/
    165                      error = USB_DeviceMscUfiSendDiagnosticCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_7: (+1)
   \   000000EA   0x0020             MOVS     R0,R4
   \   000000EC   0x.... 0x....      BL       USB_DeviceMscUfiSendDiagnosticCommand
   \   000000F0   0x0005             MOVS     R5,R0
    166                      break;
   \   000000F2   0xE01F             B.N      ??USB_DeviceMscProcessUfiCommand_15
    167                  case USB_DEVICE_MSC_VERIFY_COMMAND: /*operation code : 0x2F*/
    168                      error = USB_DeviceMscUfiVerifyCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_13: (+1)
   \   000000F4   0x0020             MOVS     R0,R4
   \   000000F6   0x.... 0x....      BL       USB_DeviceMscUfiVerifyCommand
   \   000000FA   0x0005             MOVS     R5,R0
    169                      break;
   \   000000FC   0xE01A             B.N      ??USB_DeviceMscProcessUfiCommand_15
    170                  case USB_DEVICE_MSC_START_STOP_UNIT_COMMAND: /*operation code : 0x1B*/
    171                      error = USB_DeviceMscUfiStartStopUnitCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_6: (+1)
   \   000000FE   0x0020             MOVS     R0,R4
   \   00000100   0x.... 0x....      BL       USB_DeviceMscUfiStartStopUnitCommand
   \   00000104   0x0005             MOVS     R5,R0
    172                      break;
   \   00000106   0xE015             B.N      ??USB_DeviceMscProcessUfiCommand_15
    173                  default:
    174                      error = USB_DeviceMscUfiUnsupportCommand(mscHandle);
   \                     ??USB_DeviceMscProcessUfiCommand_14: (+1)
   \   00000108   0x0020             MOVS     R0,R4
   \   0000010A   0x.... 0x....      BL       USB_DeviceMscUfiUnsupportCommand
   \   0000010E   0x0005             MOVS     R5,R0
    175                      mscHandle->dataOutFlag = 0;
   \   00000110   0x2000             MOVS     R0,#+0
   \   00000112   0xF884 0x00EC      STRB     R0,[R4, #+236]
    176                      mscHandle->dataInFlag = 0;
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0xF884 0x00ED      STRB     R0,[R4, #+237]
    177                      mscHandle->outEndpointStallFlag = 0;
   \   0000011C   0x2000             MOVS     R0,#+0
   \   0000011E   0xF884 0x00EF      STRB     R0,[R4, #+239]
    178                      mscHandle->inEndpointStallFlag = 0;
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0xF884 0x00EE      STRB     R0,[R4, #+238]
    179                      mscHandle->needOutStallFlag = 0;
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0xF884 0x00F4      STRB     R0,[R4, #+244]
    180                      mscHandle->needInStallFlag = 0;
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0xF884 0x00F3      STRB     R0,[R4, #+243]
    181                      break;
    182              }
    183              return error;
   \                     ??USB_DeviceMscProcessUfiCommand_15: (+1)
   \   00000134   0x0028             MOVS     R0,R5
   \   00000136   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000138   0xBD70             POP      {R4-R6,PC}       ;; return
    184          }
    185          
    186          /*!
    187           * @brief Bulk IN endpoint callback function.
    188           *
    189           * This callback function is used to notify uplayer the tranfser result of a transfer.
    190           * This callback pointer is passed when the Bulk IN pipe initialized.
    191           *
    192           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    193           * @param message         The result of the Bulk IN pipe transfer.
    194           * @param callbackParam  The paramter for this callback. It is same with
    195           * usb_device_endpoint_callback_struct_t::callbackParam. In the class, the value is the MSC class handle.
    196           *
    197           * @return A USB error code or kStatus_USB_Success.
    198           */

   \                                 In section .text, align 2, keep-with-next
    199          static usb_status_t USB_DeviceMscBulkIn(usb_device_handle handle,
    200                                                  usb_device_endpoint_callback_message_struct_t *message,
    201                                                  void *callbackParam)
    202          {
   \                     USB_DeviceMscBulkIn: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    203              usb_device_msc_struct_t *mscHandle = (usb_device_msc_struct_t *)callbackParam;
   \   0000000C   0x0037             MOVS     R7,R6
    204              usb_device_msc_csw_t *csw;
    205              usb_status_t error = kStatus_USB_Error;
   \   0000000E   0xF05F 0x0901      MOVS     R9,#+1
    206          
    207              if (message->length == USB_UNINITIALIZED_VAL_32)
   \   00000012   0x6868             LDR      R0,[R5, #+4]
   \   00000014   0xF110 0x0F01      CMN      R0,#+1
   \   00000018   0xD11E             BNE.N    ??USB_DeviceMscBulkIn_0
    208              {
    209                  if ((mscHandle->dataInFlag) && (mscHandle->configurationStruct->classCallback != NULL) &&
    210                      ((USB_DEVICE_MSC_READ_10_COMMAND == mscHandle->mscCbw.cbwcb[0]) ||
    211                       (USB_DEVICE_MSC_READ_12_COMMAND == mscHandle->mscCbw.cbwcb[0])))
   \   0000001A   0xF897 0x00ED      LDRB     R0,[R7, #+237]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD017             BEQ.N    ??USB_DeviceMscBulkIn_1
   \   00000022   0x6878             LDR      R0,[R7, #+4]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD013             BEQ.N    ??USB_DeviceMscBulkIn_1
   \   0000002A   0xF897 0x0037      LDRB     R0,[R7, #+55]
   \   0000002E   0x2828             CMP      R0,#+40
   \   00000030   0xD003             BEQ.N    ??USB_DeviceMscBulkIn_2
   \   00000032   0xF897 0x0037      LDRB     R0,[R7, #+55]
   \   00000036   0x28A8             CMP      R0,#+168
   \   00000038   0xD10B             BNE.N    ??USB_DeviceMscBulkIn_1
    212                  {
    213                      usb_device_lba_app_struct_t lbaData;
    214          
    215                      lbaData.size = 0;
   \                     ??USB_DeviceMscBulkIn_2: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x9004             STR      R0,[SP, #+16]
    216                      lbaData.buffer = message->buffer;
   \   0000003E   0x6828             LDR      R0,[R5, #+0]
   \   00000040   0x9005             STR      R0,[SP, #+20]
    217                      lbaData.offset = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x9003             STR      R0,[SP, #+12]
    218                      mscHandle->configurationStruct->classCallback((class_handle_t)mscHandle, kUSB_DeviceMscEventReadResponse,
    219                                                                    (void *)&lbaData);
   \   00000046   0xAA03             ADD      R2,SP,#+12
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0x0038             MOVS     R0,R7
   \   0000004C   0x687B             LDR      R3,[R7, #+4]
   \   0000004E   0x681B             LDR      R3,[R3, #+0]
   \   00000050   0x4798             BLX      R3
    220                  }
    221                  return error;
   \                     ??USB_DeviceMscBulkIn_1: (+1)
   \   00000052   0x4648             MOV      R0,R9
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0xE074             B.N      ??USB_DeviceMscBulkIn_3
    222              }
    223              if (mscHandle->transferRemaining >= message->length)
   \                     ??USB_DeviceMscBulkIn_0: (+1)
   \   00000058   0x68F8             LDR      R0,[R7, #+12]
   \   0000005A   0x6869             LDR      R1,[R5, #+4]
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD303             BCC.N    ??USB_DeviceMscBulkIn_4
    224              {
    225                  mscHandle->transferRemaining -= message->length;
   \   00000060   0x68F8             LDR      R0,[R7, #+12]
   \   00000062   0x6869             LDR      R1,[R5, #+4]
   \   00000064   0x1A40             SUBS     R0,R0,R1
   \   00000066   0x60F8             STR      R0,[R7, #+12]
    226              }
    227          
    228              if (mscHandle->needInStallFlag == 1)
   \                     ??USB_DeviceMscBulkIn_4: (+1)
   \   00000068   0xF897 0x00F3      LDRB     R0,[R7, #+243]
   \   0000006C   0x2801             CMP      R0,#+1
   \   0000006E   0xD110             BNE.N    ??USB_DeviceMscBulkIn_5
    229              {
    230                  mscHandle->needInStallFlag = 0;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xF887 0x00F3      STRB     R0,[R7, #+243]
    231                  mscHandle->inEndpointStallFlag = 1;
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0xF887 0x00EE      STRB     R0,[R7, #+238]
    232                  mscHandle->dataInFlag = 0;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xF887 0x00ED      STRB     R0,[R7, #+237]
    233                  USB_DeviceStallEndpoint(mscHandle->handle, mscHandle->bulkInEndpoint);
   \   00000082   0xF897 0x10F9      LDRB     R1,[R7, #+249]
   \   00000086   0x6838             LDR      R0,[R7, #+0]
   \   00000088   0x.... 0x....      BL       USB_DeviceStallEndpoint
    234                  return error;
   \   0000008C   0x4648             MOV      R0,R9
   \   0000008E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000090   0xE057             B.N      ??USB_DeviceMscBulkIn_3
    235              }
    236              if ((!mscHandle->dataInFlag) && (message->length == USB_DEVICE_MSC_CSW_LENGTH))
   \                     ??USB_DeviceMscBulkIn_5: (+1)
   \   00000092   0xF897 0x00ED      LDRB     R0,[R7, #+237]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD104             BNE.N    ??USB_DeviceMscBulkIn_6
   \   0000009A   0x6868             LDR      R0,[R5, #+4]
   \   0000009C   0x280D             CMP      R0,#+13
   \   0000009E   0xD101             BNE.N    ??USB_DeviceMscBulkIn_6
    237              {
    238                  csw = (usb_device_msc_csw_t *)(message->buffer);
   \   000000A0   0x6828             LDR      R0,[R5, #+0]
   \   000000A2   0x4680             MOV      R8,R0
    239              }
    240          
    241              if (mscHandle->dataInFlag)
   \                     ??USB_DeviceMscBulkIn_6: (+1)
   \   000000A4   0xF897 0x00ED      LDRB     R0,[R7, #+237]
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD031             BEQ.N    ??USB_DeviceMscBulkIn_7
    242              {
    243                  if ((mscHandle->configurationStruct->classCallback != NULL))
   \   000000AC   0x6878             LDR      R0,[R7, #+4]
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD044             BEQ.N    ??USB_DeviceMscBulkIn_8
    244                  {
    245                      usb_device_lba_app_struct_t lbaData;
    246          
    247                      lbaData.size = message->length;
   \   000000B4   0x6868             LDR      R0,[R5, #+4]
   \   000000B6   0x9001             STR      R0,[SP, #+4]
    248                      lbaData.buffer = message->buffer;
   \   000000B8   0x6828             LDR      R0,[R5, #+0]
   \   000000BA   0x9002             STR      R0,[SP, #+8]
    249                      lbaData.offset = mscHandle->currentOffset;
   \   000000BC   0x6938             LDR      R0,[R7, #+16]
   \   000000BE   0x9000             STR      R0,[SP, #+0]
    250          
    251                      if ((USB_DEVICE_MSC_READ_10_COMMAND == mscHandle->mscCbw.cbwcb[0]) ||
    252                          (USB_DEVICE_MSC_READ_12_COMMAND == mscHandle->mscCbw.cbwcb[0]))
   \   000000C0   0xF897 0x0037      LDRB     R0,[R7, #+55]
   \   000000C4   0x2828             CMP      R0,#+40
   \   000000C6   0xD003             BEQ.N    ??USB_DeviceMscBulkIn_9
   \   000000C8   0xF897 0x0037      LDRB     R0,[R7, #+55]
   \   000000CC   0x28A8             CMP      R0,#+168
   \   000000CE   0xD105             BNE.N    ??USB_DeviceMscBulkIn_10
    253                      {
    254                          mscHandle->configurationStruct->classCallback((class_handle_t)mscHandle,
    255                                                                        kUSB_DeviceMscEventReadResponse, (void *)&lbaData);
   \                     ??USB_DeviceMscBulkIn_9: (+1)
   \   000000D0   0x466A             MOV      R2,SP
   \   000000D2   0x2101             MOVS     R1,#+1
   \   000000D4   0x0038             MOVS     R0,R7
   \   000000D6   0x687B             LDR      R3,[R7, #+4]
   \   000000D8   0x681B             LDR      R3,[R3, #+0]
   \   000000DA   0x4798             BLX      R3
    256                      }
    257          
    258                      if (mscHandle->transferRemaining)
   \                     ??USB_DeviceMscBulkIn_10: (+1)
   \   000000DC   0x68F8             LDR      R0,[R7, #+12]
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD007             BEQ.N    ??USB_DeviceMscBulkIn_11
    259                      {
    260                          mscHandle->currentOffset += message->length;
   \   000000E2   0x6938             LDR      R0,[R7, #+16]
   \   000000E4   0x6869             LDR      R1,[R5, #+4]
   \   000000E6   0x1808             ADDS     R0,R1,R0
   \   000000E8   0x6138             STR      R0,[R7, #+16]
    261                          error = USB_DeviceMscSend(mscHandle);
   \   000000EA   0x0038             MOVS     R0,R7
   \   000000EC   0x.... 0x....      BL       USB_DeviceMscSend
   \   000000F0   0x4681             MOV      R9,R0
    262                      }
    263                      if (!mscHandle->transferRemaining)
   \                     ??USB_DeviceMscBulkIn_11: (+1)
   \   000000F2   0x68F8             LDR      R0,[R7, #+12]
   \   000000F4   0x2800             CMP      R0,#+0
   \   000000F6   0xD122             BNE.N    ??USB_DeviceMscBulkIn_8
    264                      {
    265                          mscHandle->dataInFlag = 0;
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xF887 0x00ED      STRB     R0,[R7, #+237]
    266                          /*data transfer has been done, send the csw to host */
    267                          USB_DeviceSendRequest(mscHandle->handle, mscHandle->bulkInEndpoint, (uint8_t *)&mscHandle->mscCsw,
    268                                                USB_DEVICE_MSC_CSW_LENGTH);
   \   000000FE   0x230D             MOVS     R3,#+13
   \   00000100   0xF117 0x0248      ADDS     R2,R7,#+72
   \   00000104   0xF897 0x10F9      LDRB     R1,[R7, #+249]
   \   00000108   0x6838             LDR      R0,[R7, #+0]
   \   0000010A   0x.... 0x....      BL       USB_DeviceSendRequest
   \   0000010E   0xE016             B.N      ??USB_DeviceMscBulkIn_8
    269                      }
    270                  }
    271              }
    272              else if ((message->length == USB_DEVICE_MSC_CSW_LENGTH) && (csw->signature == USB_DEVICE_MSC_DCSWSIGNATURE))
   \                     ??USB_DeviceMscBulkIn_7: (+1)
   \   00000110   0x6868             LDR      R0,[R5, #+4]
   \   00000112   0x280D             CMP      R0,#+13
   \   00000114   0xD113             BNE.N    ??USB_DeviceMscBulkIn_8
   \   00000116   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000011A   0x.... 0x....      LDR.W    R1,??DataTable3_1  ;; 0x53425355
   \   0000011E   0x4288             CMP      R0,R1
   \   00000120   0xD10D             BNE.N    ??USB_DeviceMscBulkIn_8
    273              {
    274                  mscHandle->cbwValidFlag = 1;
   \   00000122   0x2001             MOVS     R0,#+1
   \   00000124   0xF887 0x00F0      STRB     R0,[R7, #+240]
    275          
    276                  (void)USB_DeviceRecvRequest(mscHandle->handle, mscHandle->bulkOutEndpoint, (uint8_t *)&mscHandle->mscCbw,
    277                                              USB_DEVICE_MSC_CBW_LENGTH);
   \   00000128   0x231F             MOVS     R3,#+31
   \   0000012A   0xF117 0x0228      ADDS     R2,R7,#+40
   \   0000012E   0xF897 0x10FA      LDRB     R1,[R7, #+250]
   \   00000132   0x6838             LDR      R0,[R7, #+0]
   \   00000134   0x.... 0x....      BL       USB_DeviceRecvRequest
    278                  mscHandle->cbwPrimeFlag = 1;
   \   00000138   0x2001             MOVS     R0,#+1
   \   0000013A   0xF887 0x00F5      STRB     R0,[R7, #+245]
    279              }
    280              else
    281              {
    282              }
    283              return error;
   \                     ??USB_DeviceMscBulkIn_8: (+1)
   \   0000013E   0x4648             MOV      R0,R9
   \   00000140   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceMscBulkIn_3: (+1)
   \   00000142   0xB007             ADD      SP,SP,#+28
   \   00000144   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    284          }
    285          
    286          /*!
    287           * @brief Bulk OUT endpoint callback function.
    288           *
    289           * This callback function is used to notify uplayer the tranfser result of a transfer.
    290           * This callback pointer is passed when the Bulk OUT pipe initialized.
    291           *
    292           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    293           * @param message         The result of the Bulk OUT pipe transfer.
    294           * @param callbackParam  The paramter for this callback. It is same with
    295           * usb_device_endpoint_callback_struct_t::callbackParam. In the class, the value is the MSC class handle.
    296           *
    297           * @return A USB error code or kStatus_USB_Success.
    298           */

   \                                 In section .text, align 2, keep-with-next
    299          usb_status_t USB_DeviceMscBulkOut(usb_device_handle handle,
    300                                            usb_device_endpoint_callback_message_struct_t *message,
    301                                            void *callbackParam)
    302          {
   \                     USB_DeviceMscBulkOut: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    303              usb_device_msc_struct_t *mscHandle = (usb_device_msc_struct_t *)callbackParam;
   \   0000000C   0x0037             MOVS     R7,R6
    304              usb_status_t error = kStatus_USB_Success;
   \   0000000E   0xF05F 0x0800      MOVS     R8,#+0
    305              if (message->length == USB_UNINITIALIZED_VAL_32)
   \   00000012   0x6868             LDR      R0,[R5, #+4]
   \   00000014   0xF110 0x0F01      CMN      R0,#+1
   \   00000018   0xD11E             BNE.N    ??USB_DeviceMscBulkOut_0
    306              {
    307                  if ((mscHandle->dataInFlag) && (mscHandle->configurationStruct->classCallback != NULL) &&
    308                      ((USB_DEVICE_MSC_WRITE_10_COMMAND == mscHandle->mscCbw.cbwcb[0]) ||
    309                       (USB_DEVICE_MSC_WRITE_12_COMMAND == mscHandle->mscCbw.cbwcb[0])))
   \   0000001A   0xF897 0x00ED      LDRB     R0,[R7, #+237]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD017             BEQ.N    ??USB_DeviceMscBulkOut_1
   \   00000022   0x6878             LDR      R0,[R7, #+4]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD013             BEQ.N    ??USB_DeviceMscBulkOut_1
   \   0000002A   0xF897 0x0037      LDRB     R0,[R7, #+55]
   \   0000002E   0x282A             CMP      R0,#+42
   \   00000030   0xD003             BEQ.N    ??USB_DeviceMscBulkOut_2
   \   00000032   0xF897 0x0037      LDRB     R0,[R7, #+55]
   \   00000036   0x28AA             CMP      R0,#+170
   \   00000038   0xD10B             BNE.N    ??USB_DeviceMscBulkOut_1
    310                  {
    311                      usb_device_lba_app_struct_t lbaData;
    312          
    313                      lbaData.size = 0;
   \                     ??USB_DeviceMscBulkOut_2: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x9004             STR      R0,[SP, #+16]
    314                      lbaData.buffer = message->buffer;
   \   0000003E   0x6828             LDR      R0,[R5, #+0]
   \   00000040   0x9005             STR      R0,[SP, #+20]
    315                      lbaData.offset = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x9003             STR      R0,[SP, #+12]
    316                      mscHandle->configurationStruct->classCallback((class_handle_t)mscHandle, kUSB_DeviceMscEventWriteResponse,
    317                                                                    (void *)&lbaData);
   \   00000046   0xAA03             ADD      R2,SP,#+12
   \   00000048   0x2102             MOVS     R1,#+2
   \   0000004A   0x0038             MOVS     R0,R7
   \   0000004C   0x687B             LDR      R3,[R7, #+4]
   \   0000004E   0x681B             LDR      R3,[R3, #+0]
   \   00000050   0x4798             BLX      R3
    318                  }
    319                  return error;
   \                     ??USB_DeviceMscBulkOut_1: (+1)
   \   00000052   0x4640             MOV      R0,R8
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0xE113             B.N      ??USB_DeviceMscBulkOut_3
    320              }
    321          
    322              if (mscHandle->transferRemaining >= message->length)
   \                     ??USB_DeviceMscBulkOut_0: (+1)
   \   00000058   0x68F8             LDR      R0,[R7, #+12]
   \   0000005A   0x6869             LDR      R1,[R5, #+4]
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD303             BCC.N    ??USB_DeviceMscBulkOut_4
    323              {
    324                  mscHandle->transferRemaining -= message->length;
   \   00000060   0x68F8             LDR      R0,[R7, #+12]
   \   00000062   0x6869             LDR      R1,[R5, #+4]
   \   00000064   0x1A40             SUBS     R0,R0,R1
   \   00000066   0x60F8             STR      R0,[R7, #+12]
    325              }
    326          
    327              if (mscHandle->needOutStallFlag == 1)
   \                     ??USB_DeviceMscBulkOut_4: (+1)
   \   00000068   0xF897 0x00F4      LDRB     R0,[R7, #+244]
   \   0000006C   0x2801             CMP      R0,#+1
   \   0000006E   0xD113             BNE.N    ??USB_DeviceMscBulkOut_5
    328              {
    329                  mscHandle->needOutStallFlag = 0;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xF887 0x00F4      STRB     R0,[R7, #+244]
    330                  mscHandle->outEndpointStallFlag = 1;
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0xF887 0x00EF      STRB     R0,[R7, #+239]
    331                  mscHandle->dataOutFlag = 0;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xF887 0x00EC      STRB     R0,[R7, #+236]
    332                  mscHandle->cbwPrimeFlag = 0;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF887 0x00F5      STRB     R0,[R7, #+245]
    333                  USB_DeviceStallEndpoint(mscHandle->handle, mscHandle->bulkOutEndpoint);
   \   00000088   0xF897 0x10FA      LDRB     R1,[R7, #+250]
   \   0000008C   0x6838             LDR      R0,[R7, #+0]
   \   0000008E   0x.... 0x....      BL       USB_DeviceStallEndpoint
    334                  return error;
   \   00000092   0x4640             MOV      R0,R8
   \   00000094   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000096   0xE0F3             B.N      ??USB_DeviceMscBulkOut_3
    335              }
    336          
    337              if (mscHandle->dataOutFlag)
   \                     ??USB_DeviceMscBulkOut_5: (+1)
   \   00000098   0xF897 0x00EC      LDRB     R0,[R7, #+236]
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD035             BEQ.N    ??USB_DeviceMscBulkOut_6
    338              {
    339                  usb_device_lba_app_struct_t lbaData;
    340          
    341                  lbaData.size = message->length;
   \   000000A0   0x6868             LDR      R0,[R5, #+4]
   \   000000A2   0x9001             STR      R0,[SP, #+4]
    342                  lbaData.buffer = message->buffer;
   \   000000A4   0x6828             LDR      R0,[R5, #+0]
   \   000000A6   0x9002             STR      R0,[SP, #+8]
    343                  lbaData.offset = mscHandle->currentOffset;
   \   000000A8   0x6938             LDR      R0,[R7, #+16]
   \   000000AA   0x9000             STR      R0,[SP, #+0]
    344          
    345                  if ((mscHandle->configurationStruct->classCallback != NULL))
   \   000000AC   0x6878             LDR      R0,[R7, #+4]
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD018             BEQ.N    ??USB_DeviceMscBulkOut_7
    346                  {
    347                      if ((USB_DEVICE_MSC_WRITE_10_COMMAND == mscHandle->mscCbw.cbwcb[0]) ||
    348                          (USB_DEVICE_MSC_WRITE_12_COMMAND == mscHandle->mscCbw.cbwcb[0]))
   \   000000B4   0xF897 0x0037      LDRB     R0,[R7, #+55]
   \   000000B8   0x282A             CMP      R0,#+42
   \   000000BA   0xD003             BEQ.N    ??USB_DeviceMscBulkOut_8
   \   000000BC   0xF897 0x0037      LDRB     R0,[R7, #+55]
   \   000000C0   0x28AA             CMP      R0,#+170
   \   000000C2   0xD105             BNE.N    ??USB_DeviceMscBulkOut_9
    349                      {
    350                          mscHandle->configurationStruct->classCallback((class_handle_t)mscHandle,
    351                                                                        kUSB_DeviceMscEventWriteResponse, (void *)&lbaData);
   \                     ??USB_DeviceMscBulkOut_8: (+1)
   \   000000C4   0x466A             MOV      R2,SP
   \   000000C6   0x2102             MOVS     R1,#+2
   \   000000C8   0x0038             MOVS     R0,R7
   \   000000CA   0x687B             LDR      R3,[R7, #+4]
   \   000000CC   0x681B             LDR      R3,[R3, #+0]
   \   000000CE   0x4798             BLX      R3
    352                      }
    353          
    354                      if (mscHandle->transferRemaining)
   \                     ??USB_DeviceMscBulkOut_9: (+1)
   \   000000D0   0x68F8             LDR      R0,[R7, #+12]
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD007             BEQ.N    ??USB_DeviceMscBulkOut_7
    355                      {
    356                          mscHandle->currentOffset += message->length;
   \   000000D6   0x6938             LDR      R0,[R7, #+16]
   \   000000D8   0x6869             LDR      R1,[R5, #+4]
   \   000000DA   0x1808             ADDS     R0,R1,R0
   \   000000DC   0x6138             STR      R0,[R7, #+16]
    357                          error = USB_DeviceMscRecv(mscHandle);
   \   000000DE   0x0038             MOVS     R0,R7
   \   000000E0   0x.... 0x....      BL       USB_DeviceMscRecv
   \   000000E4   0x4680             MOV      R8,R0
    358                      }
    359                  }
    360          
    361                  if (!mscHandle->transferRemaining)
   \                     ??USB_DeviceMscBulkOut_7: (+1)
   \   000000E6   0x68F8             LDR      R0,[R7, #+12]
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xF040 0x80C7      BNE.W    ??USB_DeviceMscBulkOut_10
    362                  {
    363                      mscHandle->dataOutFlag = 0;
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0xF887 0x00EC      STRB     R0,[R7, #+236]
    364                      {
    365                          USB_DeviceSendRequest(mscHandle->handle, mscHandle->bulkInEndpoint, (uint8_t *)&mscHandle->mscCsw,
    366                                                USB_DEVICE_MSC_CSW_LENGTH);
   \   000000F4   0x230D             MOVS     R3,#+13
   \   000000F6   0xF117 0x0248      ADDS     R2,R7,#+72
   \   000000FA   0xF897 0x10F9      LDRB     R1,[R7, #+249]
   \   000000FE   0x6838             LDR      R0,[R7, #+0]
   \   00000100   0x.... 0x....      BL       USB_DeviceSendRequest
    367                          mscHandle->cswPrimeFlag = 1;
   \   00000104   0x2001             MOVS     R0,#+1
   \   00000106   0xF887 0x00F6      STRB     R0,[R7, #+246]
   \   0000010A   0xE0B7             B.N      ??USB_DeviceMscBulkOut_10
    368                      }
    369                  }
    370              }
    371              else if ((mscHandle->cbwValidFlag) && (message->length == USB_DEVICE_MSC_CBW_LENGTH) &&
    372                       (mscHandle->mscCbw.signature == USB_DEVICE_MSC_DCBWSIGNATURE) &&
    373                       (!((mscHandle->mscCbw.logicalUnitNumber & 0xF0) || (mscHandle->mscCbw.cbLength & 0xE0))) &&
    374                       (mscHandle->mscCbw.logicalUnitNumber < (mscHandle->logicalUnitNumber + 1)) &&
    375                       ((mscHandle->mscCbw.cbLength >= 0x01) && (mscHandle->mscCbw.cbLength <= 0x10)))
   \                     ??USB_DeviceMscBulkOut_6: (+1)
   \   0000010C   0xF897 0x00F0      LDRB     R0,[R7, #+240]
   \   00000110   0x2800             CMP      R0,#+0
   \   00000112   0xF000 0x809A      BEQ.W    ??USB_DeviceMscBulkOut_11
   \   00000116   0x6868             LDR      R0,[R5, #+4]
   \   00000118   0x281F             CMP      R0,#+31
   \   0000011A   0xF040 0x8096      BNE.W    ??USB_DeviceMscBulkOut_11
   \   0000011E   0x6AB8             LDR      R0,[R7, #+40]
   \   00000120   0x....             LDR.N    R1,??DataTable3_2  ;; 0x43425355
   \   00000122   0x4288             CMP      R0,R1
   \   00000124   0xF040 0x8091      BNE.W    ??USB_DeviceMscBulkOut_11
   \   00000128   0xF897 0x0035      LDRB     R0,[R7, #+53]
   \   0000012C   0x21F0             MOVS     R1,#+240
   \   0000012E   0x4208             TST      R0,R1
   \   00000130   0xF040 0x808B      BNE.W    ??USB_DeviceMscBulkOut_11
   \   00000134   0xF897 0x0036      LDRB     R0,[R7, #+54]
   \   00000138   0x21E0             MOVS     R1,#+224
   \   0000013A   0x4208             TST      R0,R1
   \   0000013C   0xF040 0x8085      BNE.W    ??USB_DeviceMscBulkOut_11
   \   00000140   0xF897 0x0035      LDRB     R0,[R7, #+53]
   \   00000144   0xF897 0x10F8      LDRB     R1,[R7, #+248]
   \   00000148   0x1C49             ADDS     R1,R1,#+1
   \   0000014A   0x4288             CMP      R0,R1
   \   0000014C   0xDA7D             BGE.N    ??USB_DeviceMscBulkOut_11
   \   0000014E   0xF897 0x0036      LDRB     R0,[R7, #+54]
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xD079             BEQ.N    ??USB_DeviceMscBulkOut_11
   \   00000156   0xF897 0x0036      LDRB     R0,[R7, #+54]
   \   0000015A   0x2811             CMP      R0,#+17
   \   0000015C   0xDA75             BGE.N    ??USB_DeviceMscBulkOut_11
    376              {
    377                  mscHandle->cbwPrimeFlag = 0;
   \   0000015E   0x2000             MOVS     R0,#+0
   \   00000160   0xF887 0x00F5      STRB     R0,[R7, #+245]
    378                  mscHandle->transferRemaining = 0;
   \   00000164   0x2000             MOVS     R0,#+0
   \   00000166   0x60F8             STR      R0,[R7, #+12]
    379          
    380                  mscHandle->mscCsw.signature = USB_DEVICE_MSC_DCSWSIGNATURE;
   \   00000168   0x....             LDR.N    R0,??DataTable3_1  ;; 0x53425355
   \   0000016A   0x64B8             STR      R0,[R7, #+72]
    381                  mscHandle->mscCsw.dataResidue = 0;
   \   0000016C   0x2000             MOVS     R0,#+0
   \   0000016E   0x6538             STR      R0,[R7, #+80]
    382                  mscHandle->mscCsw.tag = mscHandle->mscCbw.tag;
   \   00000170   0x6AF8             LDR      R0,[R7, #+44]
   \   00000172   0x64F8             STR      R0,[R7, #+76]
    383          
    384                  mscHandle->cbwValidFlag = 0;
   \   00000174   0x2000             MOVS     R0,#+0
   \   00000176   0xF887 0x00F0      STRB     R0,[R7, #+240]
    385          
    386                  mscHandle->mscCbw.dataTransferLength = USB_LONG_TO_LITTLE_ENDIAN(mscHandle->mscCbw.dataTransferLength);
   \   0000017A   0x6B38             LDR      R0,[R7, #+48]
   \   0000017C   0x6338             STR      R0,[R7, #+48]
    387          
    388                  mscHandle->dataOutFlag = (uint8_t)(((!(mscHandle->mscCbw.flags & USB_DEVICE_MSC_CBW_DIRECTION_BIT)) &&
    389                                                      (mscHandle->mscCbw.dataTransferLength)) ?
    390                                                         1 :
    391                                                         0);
   \   0000017E   0xF897 0x0034      LDRB     R0,[R7, #+52]
   \   00000182   0x0600             LSLS     R0,R0,#+24
   \   00000184   0xD404             BMI.N    ??USB_DeviceMscBulkOut_12
   \   00000186   0x6B38             LDR      R0,[R7, #+48]
   \   00000188   0x2800             CMP      R0,#+0
   \   0000018A   0xD001             BEQ.N    ??USB_DeviceMscBulkOut_12
   \   0000018C   0x2001             MOVS     R0,#+1
   \   0000018E   0xE000             B.N      ??USB_DeviceMscBulkOut_13
   \                     ??USB_DeviceMscBulkOut_12: (+1)
   \   00000190   0x2000             MOVS     R0,#+0
   \                     ??USB_DeviceMscBulkOut_13: (+1)
   \   00000192   0xF887 0x00EC      STRB     R0,[R7, #+236]
    392          
    393                  mscHandle->dataInFlag = (uint8_t)(
    394                      ((mscHandle->mscCbw.flags & USB_DEVICE_MSC_CBW_DIRECTION_BIT) && (mscHandle->mscCbw.dataTransferLength)) ?
    395                          1 :
    396                          0);
   \   00000196   0xF897 0x0034      LDRB     R0,[R7, #+52]
   \   0000019A   0x0600             LSLS     R0,R0,#+24
   \   0000019C   0xD504             BPL.N    ??USB_DeviceMscBulkOut_14
   \   0000019E   0x6B38             LDR      R0,[R7, #+48]
   \   000001A0   0x2800             CMP      R0,#+0
   \   000001A2   0xD001             BEQ.N    ??USB_DeviceMscBulkOut_14
   \   000001A4   0x2001             MOVS     R0,#+1
   \   000001A6   0xE000             B.N      ??USB_DeviceMscBulkOut_15
   \                     ??USB_DeviceMscBulkOut_14: (+1)
   \   000001A8   0x2000             MOVS     R0,#+0
   \                     ??USB_DeviceMscBulkOut_15: (+1)
   \   000001AA   0xF887 0x00ED      STRB     R0,[R7, #+237]
    397          
    398                  if ((0 != mscHandle->dataInFlag) && (0 != mscHandle->inEndpointStallFlag))
   \   000001AE   0xF897 0x00ED      LDRB     R0,[R7, #+237]
   \   000001B2   0x2800             CMP      R0,#+0
   \   000001B4   0xD008             BEQ.N    ??USB_DeviceMscBulkOut_16
   \   000001B6   0xF897 0x00EE      LDRB     R0,[R7, #+238]
   \   000001BA   0x2800             CMP      R0,#+0
   \   000001BC   0xD004             BEQ.N    ??USB_DeviceMscBulkOut_16
    399                  {
    400                      error = kStatus_USB_Error;
   \   000001BE   0x2001             MOVS     R0,#+1
   \   000001C0   0x4680             MOV      R8,R0
    401                      return error;
   \   000001C2   0x4640             MOV      R0,R8
   \   000001C4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001C6   0xE05B             B.N      ??USB_DeviceMscBulkOut_3
    402                  }
    403                  error = USB_DeviceMscProcessUfiCommand(mscHandle);
   \                     ??USB_DeviceMscBulkOut_16: (+1)
   \   000001C8   0x0038             MOVS     R0,R7
   \   000001CA   0x.... 0x....      BL       USB_DeviceMscProcessUfiCommand
   \   000001CE   0x4680             MOV      R8,R0
    404                  if (error == kStatus_USB_InvalidRequest)
   \   000001D0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001D4   0xF1B8 0x0F05      CMP      R8,#+5
   \   000001D8   0xD11F             BNE.N    ??USB_DeviceMscBulkOut_17
    405                  {
    406                      if (mscHandle->dataOutFlag == 1)
   \   000001DA   0xF897 0x00EC      LDRB     R0,[R7, #+236]
   \   000001DE   0x2801             CMP      R0,#+1
   \   000001E0   0xD10A             BNE.N    ??USB_DeviceMscBulkOut_18
    407                      {
    408                          if (mscHandle->outEndpointStallFlag == 0)
   \   000001E2   0xF897 0x00EF      LDRB     R0,[R7, #+239]
   \   000001E6   0x2800             CMP      R0,#+0
   \   000001E8   0xD102             BNE.N    ??USB_DeviceMscBulkOut_19
    409                          {
    410                              mscHandle->needOutStallFlag = 1;
   \   000001EA   0x2001             MOVS     R0,#+1
   \   000001EC   0xF887 0x00F4      STRB     R0,[R7, #+244]
    411                          }
    412                          mscHandle->dataOutFlag = 0;
   \                     ??USB_DeviceMscBulkOut_19: (+1)
   \   000001F0   0x2000             MOVS     R0,#+0
   \   000001F2   0xF887 0x00EC      STRB     R0,[R7, #+236]
   \   000001F6   0xE00D             B.N      ??USB_DeviceMscBulkOut_20
    413                      }
    414                      else if (mscHandle->dataInFlag == 1)
   \                     ??USB_DeviceMscBulkOut_18: (+1)
   \   000001F8   0xF897 0x00ED      LDRB     R0,[R7, #+237]
   \   000001FC   0x2801             CMP      R0,#+1
   \   000001FE   0xD109             BNE.N    ??USB_DeviceMscBulkOut_20
    415                      {
    416                          if (mscHandle->inEndpointStallFlag == 0)
   \   00000200   0xF897 0x00EE      LDRB     R0,[R7, #+238]
   \   00000204   0x2800             CMP      R0,#+0
   \   00000206   0xD102             BNE.N    ??USB_DeviceMscBulkOut_21
    417                          {
    418                              mscHandle->needInStallFlag = 1;
   \   00000208   0x2001             MOVS     R0,#+1
   \   0000020A   0xF887 0x00F3      STRB     R0,[R7, #+243]
    419                          }
    420                          mscHandle->dataInFlag = 0;
   \                     ??USB_DeviceMscBulkOut_21: (+1)
   \   0000020E   0x2000             MOVS     R0,#+0
   \   00000210   0xF887 0x00ED      STRB     R0,[R7, #+237]
    421                      }
    422                      else
    423                      {
    424                      }
    425                      mscHandle->stallStatus = (uint8_t)USB_DEVICE_MSC_STALL_IN_DATA;
   \                     ??USB_DeviceMscBulkOut_20: (+1)
   \   00000214   0x2002             MOVS     R0,#+2
   \   00000216   0xF887 0x00F7      STRB     R0,[R7, #+247]
    426                  }
    427          
    428                  if (!((mscHandle->dataOutFlag) || ((mscHandle->dataInFlag) || (mscHandle->needInStallFlag))))
   \                     ??USB_DeviceMscBulkOut_17: (+1)
   \   0000021A   0xF897 0x00EC      LDRB     R0,[R7, #+236]
   \   0000021E   0x2800             CMP      R0,#+0
   \   00000220   0xD12C             BNE.N    ??USB_DeviceMscBulkOut_10
   \   00000222   0xF897 0x00ED      LDRB     R0,[R7, #+237]
   \   00000226   0x2800             CMP      R0,#+0
   \   00000228   0xD128             BNE.N    ??USB_DeviceMscBulkOut_10
   \   0000022A   0xF897 0x00F3      LDRB     R0,[R7, #+243]
   \   0000022E   0x2800             CMP      R0,#+0
   \   00000230   0xD124             BNE.N    ??USB_DeviceMscBulkOut_10
    429                  {
    430                      USB_DeviceSendRequest(mscHandle->handle, mscHandle->bulkInEndpoint, (uint8_t *)&mscHandle->mscCsw,
    431                                            USB_DEVICE_MSC_CSW_LENGTH);
   \   00000232   0x230D             MOVS     R3,#+13
   \   00000234   0xF117 0x0248      ADDS     R2,R7,#+72
   \   00000238   0xF897 0x10F9      LDRB     R1,[R7, #+249]
   \   0000023C   0x6838             LDR      R0,[R7, #+0]
   \   0000023E   0x.... 0x....      BL       USB_DeviceSendRequest
    432                      mscHandle->cswPrimeFlag = 1;
   \   00000242   0x2001             MOVS     R0,#+1
   \   00000244   0xF887 0x00F6      STRB     R0,[R7, #+246]
   \   00000248   0xE018             B.N      ??USB_DeviceMscBulkOut_10
    433                  }
    434              }
    435              else
    436              {
    437                  USB_DeviceStallEndpoint(mscHandle->handle, mscHandle->bulkOutEndpoint);
   \                     ??USB_DeviceMscBulkOut_11: (+1)
   \   0000024A   0xF897 0x10FA      LDRB     R1,[R7, #+250]
   \   0000024E   0x6838             LDR      R0,[R7, #+0]
   \   00000250   0x.... 0x....      BL       USB_DeviceStallEndpoint
    438                  USB_DeviceStallEndpoint(mscHandle->handle, mscHandle->bulkInEndpoint);
   \   00000254   0xF897 0x10F9      LDRB     R1,[R7, #+249]
   \   00000258   0x6838             LDR      R0,[R7, #+0]
   \   0000025A   0x.... 0x....      BL       USB_DeviceStallEndpoint
    439                  mscHandle->cbwValidFlag = 0;
   \   0000025E   0x2000             MOVS     R0,#+0
   \   00000260   0xF887 0x00F0      STRB     R0,[R7, #+240]
    440                  mscHandle->outEndpointStallFlag = 1;
   \   00000264   0x2001             MOVS     R0,#+1
   \   00000266   0xF887 0x00EF      STRB     R0,[R7, #+239]
    441                  mscHandle->inEndpointStallFlag = 1;
   \   0000026A   0x2001             MOVS     R0,#+1
   \   0000026C   0xF887 0x00EE      STRB     R0,[R7, #+238]
    442                  mscHandle->stallStatus = (uint8_t)USB_DEVICE_MSC_STALL_IN_CBW;
   \   00000270   0x2001             MOVS     R0,#+1
   \   00000272   0xF887 0x00F7      STRB     R0,[R7, #+247]
    443                  mscHandle->performResetRecover = 1;
   \   00000276   0x2001             MOVS     R0,#+1
   \   00000278   0xF887 0x00F1      STRB     R0,[R7, #+241]
    444              }
    445              return error;
   \                     ??USB_DeviceMscBulkOut_10: (+1)
   \   0000027C   0x4640             MOV      R0,R8
   \   0000027E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceMscBulkOut_3: (+1)
   \   00000280   0xB006             ADD      SP,SP,#+24
   \   00000282   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    446          }
    447          
    448          /*!
    449           * @brief Initialize the endpoints of the msc class.
    450           *
    451           * This callback function is used to initialize the endpoints of the msc class.
    452           *
    453           * @param mscHandle          The device msc class handle. It equals the value returned from
    454           * usb_device_class_config_struct_t::classHandle.
    455           *
    456           * @return A USB error code or kStatus_USB_Success.
    457           */

   \                                 In section .text, align 2, keep-with-next
    458          usb_status_t USB_DeviceMscEndpointsInit(usb_device_msc_struct_t *mscHandle)
    459          {
   \                     USB_DeviceMscEndpointsInit: (+1)
   \   00000000   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    460              usb_device_interface_list_t *interfaceList;
    461              usb_device_interface_struct_t *interface = (usb_device_interface_struct_t *)NULL;
   \   00000006   0x2600             MOVS     R6,#+0
    462              usb_status_t error = kStatus_USB_Error;
   \   00000008   0x2701             MOVS     R7,#+1
    463          
    464              /* Check the configuration is valid or not. */
    465              if (mscHandle->configuration > mscHandle->configurationStruct->classInfomation->configurations)
   \   0000000A   0x6860             LDR      R0,[R4, #+4]
   \   0000000C   0x6880             LDR      R0,[R0, #+8]
   \   0000000E   0x7940             LDRB     R0,[R0, #+5]
   \   00000010   0xF894 0x10FC      LDRB     R1,[R4, #+252]
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD202             BCS.N    ??USB_DeviceMscEndpointsInit_0
    466              {
    467                  return error;
   \   00000018   0x0038             MOVS     R0,R7
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xE0B7             B.N      ??USB_DeviceMscEndpointsInit_1
    468              }
    469          
    470              /* Get the interface list of the new configuration. */
    471              /* Check the interface list is valid or not. */
    472              if (NULL == mscHandle->configurationStruct->classInfomation->interfaceList)
   \                     ??USB_DeviceMscEndpointsInit_0: (+1)
   \   0000001E   0x6860             LDR      R0,[R4, #+4]
   \   00000020   0x6880             LDR      R0,[R0, #+8]
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD102             BNE.N    ??USB_DeviceMscEndpointsInit_2
    473              {
    474                  return error;
   \   00000028   0x0038             MOVS     R0,R7
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0xE0AF             B.N      ??USB_DeviceMscEndpointsInit_1
    475              }
    476              interfaceList = &mscHandle->configurationStruct->classInfomation->interfaceList[mscHandle->configuration - 1];
   \                     ??USB_DeviceMscEndpointsInit_2: (+1)
   \   0000002E   0x6860             LDR      R0,[R4, #+4]
   \   00000030   0x6880             LDR      R0,[R0, #+8]
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xF894 0x10FC      LDRB     R1,[R4, #+252]
   \   00000038   0xEB00 0x00C1      ADD      R0,R0,R1, LSL #+3
   \   0000003C   0x3808             SUBS     R0,R0,#+8
   \   0000003E   0x0005             MOVS     R5,R0
    477          
    478              /* Find interface by using the alternate setting of the interface. */
    479              for (int count = 0; count < interfaceList->count; count++)
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??USB_DeviceMscEndpointsInit_3: (+1)
   \   00000042   0x7829             LDRB     R1,[R5, #+0]
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xDA31             BGE.N    ??USB_DeviceMscEndpointsInit_4
    480              {
    481                  if (USB_DEVICE_CONFIG_MSC_CLASS_CODE == interfaceList->interfaces[count].classCode)
   \   00000048   0x6869             LDR      R1,[R5, #+4]
   \   0000004A   0x220C             MOVS     R2,#+12
   \   0000004C   0xFB02 0xF200      MUL      R2,R2,R0
   \   00000050   0x5C89             LDRB     R1,[R1, R2]
   \   00000052   0x2908             CMP      R1,#+8
   \   00000054   0xD128             BNE.N    ??USB_DeviceMscEndpointsInit_5
    482                  {
    483                      for (int index = 0; index < interfaceList->interfaces[count].count; index++)
   \   00000056   0x2100             MOVS     R1,#+0
   \                     ??USB_DeviceMscEndpointsInit_6: (+1)
   \   00000058   0x686A             LDR      R2,[R5, #+4]
   \   0000005A   0x230C             MOVS     R3,#+12
   \   0000005C   0xFB03 0xF300      MUL      R3,R3,R0
   \   00000060   0x441A             ADD      R2,R2,R3
   \   00000062   0x7A12             LDRB     R2,[R2, #+8]
   \   00000064   0x4291             CMP      R1,R2
   \   00000066   0xDA17             BGE.N    ??USB_DeviceMscEndpointsInit_7
    484                      {
    485                          if (interfaceList->interfaces[count].interface[index].alternateSetting == mscHandle->alternate)
   \   00000068   0x686A             LDR      R2,[R5, #+4]
   \   0000006A   0x230C             MOVS     R3,#+12
   \   0000006C   0xFB03 0xF300      MUL      R3,R3,R0
   \   00000070   0x441A             ADD      R2,R2,R3
   \   00000072   0x6852             LDR      R2,[R2, #+4]
   \   00000074   0x010B             LSLS     R3,R1,#+4
   \   00000076   0x5CD2             LDRB     R2,[R2, R3]
   \   00000078   0xF894 0x30FB      LDRB     R3,[R4, #+251]
   \   0000007C   0x429A             CMP      R2,R3
   \   0000007E   0xD109             BNE.N    ??USB_DeviceMscEndpointsInit_8
    486                          {
    487                              interface = &interfaceList->interfaces[count].interface[index];
   \   00000080   0x686A             LDR      R2,[R5, #+4]
   \   00000082   0x230C             MOVS     R3,#+12
   \   00000084   0xFB03 0xF300      MUL      R3,R3,R0
   \   00000088   0x441A             ADD      R2,R2,R3
   \   0000008A   0x6852             LDR      R2,[R2, #+4]
   \   0000008C   0x0109             LSLS     R1,R1,#+4
   \   0000008E   0x4411             ADD      R1,R2,R1
   \   00000090   0x000E             MOVS     R6,R1
    488                              break;
   \   00000092   0xE001             B.N      ??USB_DeviceMscEndpointsInit_7
    489                          }
    490                      }
   \                     ??USB_DeviceMscEndpointsInit_8: (+1)
   \   00000094   0x1C49             ADDS     R1,R1,#+1
   \   00000096   0xE7DF             B.N      ??USB_DeviceMscEndpointsInit_6
    491                      mscHandle->interfaceNumber = interfaceList->interfaces[count].interfaceNumber;
   \                     ??USB_DeviceMscEndpointsInit_7: (+1)
   \   00000098   0x6869             LDR      R1,[R5, #+4]
   \   0000009A   0x220C             MOVS     R2,#+12
   \   0000009C   0x4350             MULS     R0,R2,R0
   \   0000009E   0x4408             ADD      R0,R1,R0
   \   000000A0   0x78C0             LDRB     R0,[R0, #+3]
   \   000000A2   0xF884 0x00FD      STRB     R0,[R4, #+253]
    492                      break;
   \   000000A6   0xE001             B.N      ??USB_DeviceMscEndpointsInit_4
    493                  }
    494              }
   \                     ??USB_DeviceMscEndpointsInit_5: (+1)
   \   000000A8   0x1C40             ADDS     R0,R0,#+1
   \   000000AA   0xE7CA             B.N      ??USB_DeviceMscEndpointsInit_3
    495              if (!interface)
   \                     ??USB_DeviceMscEndpointsInit_4: (+1)
   \   000000AC   0x2E00             CMP      R6,#+0
   \   000000AE   0xD102             BNE.N    ??USB_DeviceMscEndpointsInit_9
    496              {
    497                  /* Return error if the interface is not found. */
    498                  return error;
   \   000000B0   0x0038             MOVS     R0,R7
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B4   0xE06B             B.N      ??USB_DeviceMscEndpointsInit_1
    499              }
    500          
    501              /* Keep new interface handle. */
    502              mscHandle->interfaceHandle = interface;
   \                     ??USB_DeviceMscEndpointsInit_9: (+1)
   \   000000B6   0x60A6             STR      R6,[R4, #+8]
    503              /* Initialize the endpoints of the new interface. */
    504              for (int count = 0; count < interface->endpointList.count; count++)
   \   000000B8   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??USB_DeviceMscEndpointsInit_10: (+1)
   \   000000BC   0x7930             LDRB     R0,[R6, #+4]
   \   000000BE   0x4580             CMP      R8,R0
   \   000000C0   0xDA2F             BGE.N    ??USB_DeviceMscEndpointsInit_11
    505              {
    506                  usb_device_endpoint_init_struct_t epInitStruct;
    507                  usb_device_endpoint_callback_struct_t ep_callback;
    508                  epInitStruct.zlt = 0;
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xF88D 0x0004      STRB     R0,[SP, #+4]
    509                  epInitStruct.endpointAddress = interface->endpointList.endpoint[count].endpointAddress;
   \   000000C8   0x68B0             LDR      R0,[R6, #+8]
   \   000000CA   0xF810 0x0028      LDRB     R0,[R0, R8, LSL #+2]
   \   000000CE   0xF88D 0x0002      STRB     R0,[SP, #+2]
    510                  epInitStruct.maxPacketSize = interface->endpointList.endpoint[count].maxPacketSize;
   \   000000D2   0x68B0             LDR      R0,[R6, #+8]
   \   000000D4   0xEB00 0x0088      ADD      R0,R0,R8, LSL #+2
   \   000000D8   0x8840             LDRH     R0,[R0, #+2]
   \   000000DA   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    511                  epInitStruct.transferType = interface->endpointList.endpoint[count].transferType;
   \   000000DE   0x68B0             LDR      R0,[R6, #+8]
   \   000000E0   0xEB00 0x0088      ADD      R0,R0,R8, LSL #+2
   \   000000E4   0x7840             LDRB     R0,[R0, #+1]
   \   000000E6   0xF88D 0x0003      STRB     R0,[SP, #+3]
    512          
    513                  if (USB_IN == ((epInitStruct.endpointAddress & USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_MASK) >>
    514                                 USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT))
   \   000000EA   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   000000EE   0x09C0             LSRS     R0,R0,#+7
   \   000000F0   0x2801             CMP      R0,#+1
   \   000000F2   0xD106             BNE.N    ??USB_DeviceMscEndpointsInit_12
    515                  {
    516                      mscHandle->bulkInEndpoint = epInitStruct.endpointAddress;
   \   000000F4   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   000000F8   0xF884 0x00F9      STRB     R0,[R4, #+249]
    517                      ep_callback.callbackFn = USB_DeviceMscBulkIn;
   \   000000FC   0x....             LDR.N    R0,??DataTable3_3
   \   000000FE   0x9002             STR      R0,[SP, #+8]
   \   00000100   0xE005             B.N      ??USB_DeviceMscEndpointsInit_13
    518                  }
    519                  else
    520                  {
    521                      mscHandle->bulkOutEndpoint = epInitStruct.endpointAddress;
   \                     ??USB_DeviceMscEndpointsInit_12: (+1)
   \   00000102   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000106   0xF884 0x00FA      STRB     R0,[R4, #+250]
    522                      ep_callback.callbackFn = USB_DeviceMscBulkOut;
   \   0000010A   0x....             LDR.N    R0,??DataTable3_4
   \   0000010C   0x9002             STR      R0,[SP, #+8]
    523                  }
    524                  ep_callback.callbackParam = mscHandle;
   \                     ??USB_DeviceMscEndpointsInit_13: (+1)
   \   0000010E   0x9403             STR      R4,[SP, #+12]
    525          
    526                  error = USB_DeviceInitEndpoint(mscHandle->handle, &epInitStruct, &ep_callback);
   \   00000110   0xAA02             ADD      R2,SP,#+8
   \   00000112   0x4669             MOV      R1,SP
   \   00000114   0x6820             LDR      R0,[R4, #+0]
   \   00000116   0x.... 0x....      BL       USB_DeviceInitEndpoint
   \   0000011A   0x0007             MOVS     R7,R0
    527              }
   \   0000011C   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000120   0xE7CC             B.N      ??USB_DeviceMscEndpointsInit_10
    528          
    529              mscHandle->dataOutFlag = 0;
   \                     ??USB_DeviceMscEndpointsInit_11: (+1)
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0xF884 0x00EC      STRB     R0,[R4, #+236]
    530              mscHandle->dataInFlag = 0;
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0xF884 0x00ED      STRB     R0,[R4, #+237]
    531              mscHandle->outEndpointStallFlag = 0;
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0xF884 0x00EF      STRB     R0,[R4, #+239]
    532              mscHandle->inEndpointStallFlag = 0;
   \   00000134   0x2000             MOVS     R0,#+0
   \   00000136   0xF884 0x00EE      STRB     R0,[R4, #+238]
    533              mscHandle->needOutStallFlag = 0;
   \   0000013A   0x2000             MOVS     R0,#+0
   \   0000013C   0xF884 0x00F4      STRB     R0,[R4, #+244]
    534              mscHandle->needInStallFlag = 0;
   \   00000140   0x2000             MOVS     R0,#+0
   \   00000142   0xF884 0x00F3      STRB     R0,[R4, #+243]
    535              mscHandle->cbwValidFlag = 1;
   \   00000146   0x2001             MOVS     R0,#+1
   \   00000148   0xF884 0x00F0      STRB     R0,[R4, #+240]
    536              mscHandle->transferRemaining = 0;
   \   0000014C   0x2000             MOVS     R0,#+0
   \   0000014E   0x60E0             STR      R0,[R4, #+12]
    537              mscHandle->performResetRecover = 0;
   \   00000150   0x2000             MOVS     R0,#+0
   \   00000152   0xF884 0x00F1      STRB     R0,[R4, #+241]
    538              mscHandle->performResetDoneFlag = 0;
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0xF884 0x00F2      STRB     R0,[R4, #+242]
    539              mscHandle->stallStatus = 0;
   \   0000015C   0x2000             MOVS     R0,#+0
   \   0000015E   0xF884 0x00F7      STRB     R0,[R4, #+247]
    540          
    541              if (mscHandle->cbwPrimeFlag == 1)
   \   00000162   0xF894 0x00F5      LDRB     R0,[R4, #+245]
   \   00000166   0x2801             CMP      R0,#+1
   \   00000168   0xD104             BNE.N    ??USB_DeviceMscEndpointsInit_14
    542              {
    543                  USB_DeviceCancel(mscHandle->handle, mscHandle->bulkOutEndpoint);
   \   0000016A   0xF894 0x10FA      LDRB     R1,[R4, #+250]
   \   0000016E   0x6820             LDR      R0,[R4, #+0]
   \   00000170   0x.... 0x....      BL       USB_DeviceCancel
    544              }
    545              USB_DeviceRecvRequest(mscHandle->handle, mscHandle->bulkOutEndpoint, (uint8_t *)&mscHandle->mscCbw,
    546                                    USB_DEVICE_MSC_CBW_LENGTH);
   \                     ??USB_DeviceMscEndpointsInit_14: (+1)
   \   00000174   0x231F             MOVS     R3,#+31
   \   00000176   0xF114 0x0228      ADDS     R2,R4,#+40
   \   0000017A   0xF894 0x10FA      LDRB     R1,[R4, #+250]
   \   0000017E   0x6820             LDR      R0,[R4, #+0]
   \   00000180   0x.... 0x....      BL       USB_DeviceRecvRequest
    547              mscHandle->cbwPrimeFlag = 1;
   \   00000184   0x2001             MOVS     R0,#+1
   \   00000186   0xF884 0x00F5      STRB     R0,[R4, #+245]
    548          
    549              return error;
   \   0000018A   0x0038             MOVS     R0,R7
   \   0000018C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceMscEndpointsInit_1: (+1)
   \   0000018E   0xB004             ADD      SP,SP,#+16
   \   00000190   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    550          }
    551          
    552          /*!
    553           * @brief De-initialize the endpoints of the msc class.
    554           *
    555           * This callback function is used to de-initialize the endpoints of the msc class.
    556           *
    557           * @param mscHandle          The device msc class handle. It equals the value returned from
    558           * usb_device_class_config_struct_t::classHandle.
    559           *
    560           * @return A USB error code or kStatus_USB_Success.
    561           */

   \                                 In section .text, align 2, keep-with-next
    562          usb_status_t USB_DeviceMscEndpointsDeinit(usb_device_msc_struct_t *mscHandle)
    563          {
   \                     USB_DeviceMscEndpointsDeinit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    564              usb_status_t error = kStatus_USB_Error;
   \   00000004   0x2501             MOVS     R5,#+1
    565          
    566              if (!mscHandle->interfaceHandle)
   \   00000006   0x68A0             LDR      R0,[R4, #+8]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD102             BNE.N    ??USB_DeviceMscEndpointsDeinit_0
    567              {
    568                  return error;
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xE010             B.N      ??USB_DeviceMscEndpointsDeinit_1
    569              }
    570              /* De-initialize all endpoints of the interface */
    571              for (int count = 0; count < mscHandle->interfaceHandle->endpointList.count; count++)
   \                     ??USB_DeviceMscEndpointsDeinit_0: (+1)
   \   00000012   0x2600             MOVS     R6,#+0
   \                     ??USB_DeviceMscEndpointsDeinit_2: (+1)
   \   00000014   0x68A0             LDR      R0,[R4, #+8]
   \   00000016   0x7900             LDRB     R0,[R0, #+4]
   \   00000018   0x4286             CMP      R6,R0
   \   0000001A   0xDA09             BGE.N    ??USB_DeviceMscEndpointsDeinit_3
    572              {
    573                  error = USB_DeviceDeinitEndpoint(mscHandle->handle,
    574                                                   mscHandle->interfaceHandle->endpointList.endpoint[count].endpointAddress);
   \   0000001C   0x68A0             LDR      R0,[R4, #+8]
   \   0000001E   0x6880             LDR      R0,[R0, #+8]
   \   00000020   0xF810 0x1026      LDRB     R1,[R0, R6, LSL #+2]
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x.... 0x....      BL       USB_DeviceDeinitEndpoint
   \   0000002A   0x0005             MOVS     R5,R0
    575              }
   \   0000002C   0x1C76             ADDS     R6,R6,#+1
   \   0000002E   0xE7F1             B.N      ??USB_DeviceMscEndpointsDeinit_2
    576              return error;
   \                     ??USB_DeviceMscEndpointsDeinit_3: (+1)
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceMscEndpointsDeinit_1: (+1)
   \   00000034   0xBD70             POP      {R4-R6,PC}       ;; return
    577          }
    578          
    579          /*!
    580           * @brief Initialize the msc class.
    581           *
    582           * This function is used to initialize the msc class.
    583           *
    584           * @param controllerId   The controller id of the USB IP. Please refer to the enumeration usb_controller_index_t.
    585           * @param config          The class configuration information.
    586           * @param handle          It is out parameter, is used to return pointer of the msc class handle to the caller.
    587           *
    588           * @return A USB error code or kStatus_USB_Success.
    589           */

   \                                 In section .text, align 2, keep-with-next
    590          usb_status_t USB_DeviceMscInit(uint8_t controllerId, usb_device_class_config_struct_t *config, class_handle_t *handle)
    591          {
   \                     USB_DeviceMscInit: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    592              usb_device_msc_struct_t *mscHandle;
    593              usb_status_t error = kStatus_USB_Error;
   \   0000000C   0xF05F 0x0901      MOVS     R9,#+1
    594              uint32_t implementingDiskDrive = USB_DEVICE_CONFIG_MSC_IMPLEMENTING_DISK_DRIVE;
   \   00000010   0x2700             MOVS     R7,#+0
    595              usb_device_lba_information_struct_t diskInformation;
    596              usb_device_msc_ufi_struct_t *ufi = NULL;
   \   00000012   0xF05F 0x0800      MOVS     R8,#+0
    597          
    598              /* Allocate a msc class handle. */
    599              error = USB_DeviceMscAllocateHandle(&mscHandle);
   \   00000016   0x4668             MOV      R0,SP
   \   00000018   0x.... 0x....      BL       USB_DeviceMscAllocateHandle
   \   0000001C   0x4681             MOV      R9,R0
    600          
    601              if (kStatus_USB_Success != error)
   \   0000001E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000022   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000026   0xD002             BEQ.N    ??USB_DeviceMscInit_0
    602              {
    603                  return error;
   \   00000028   0x4648             MOV      R0,R9
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0xE0D2             B.N      ??USB_DeviceMscInit_1
    604              }
    605          
    606              /* Get the device handle according to the controller id. */
    607              error = USB_DeviceClassGetDeviceHandle(controllerId, &mscHandle->handle);
   \                     ??USB_DeviceMscInit_0: (+1)
   \   0000002E   0x9900             LDR      R1,[SP, #+0]
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x.... 0x....      BL       USB_DeviceClassGetDeviceHandle
   \   00000038   0x4681             MOV      R9,R0
    608          
    609              if (kStatus_USB_Success != error)
   \   0000003A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000003E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000042   0xD005             BEQ.N    ??USB_DeviceMscInit_2
    610              {
    611                  USB_DeviceMscFreeHandle(mscHandle);
   \   00000044   0x9800             LDR      R0,[SP, #+0]
   \   00000046   0x.... 0x....      BL       USB_DeviceMscFreeHandle
    612                  return error;
   \   0000004A   0x4648             MOV      R0,R9
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0xE0C1             B.N      ??USB_DeviceMscInit_1
    613              }
    614              if (!mscHandle->handle)
   \                     ??USB_DeviceMscInit_2: (+1)
   \   00000050   0x9800             LDR      R0,[SP, #+0]
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD104             BNE.N    ??USB_DeviceMscInit_3
    615              {
    616                  USB_DeviceMscFreeHandle(mscHandle);
   \   00000058   0x9800             LDR      R0,[SP, #+0]
   \   0000005A   0x.... 0x....      BL       USB_DeviceMscFreeHandle
    617                  return kStatus_USB_InvalidHandle;
   \   0000005E   0x2003             MOVS     R0,#+3
   \   00000060   0xE0B8             B.N      ??USB_DeviceMscInit_1
    618              }
    619              /* Save the configuration of the class. */
    620              mscHandle->configurationStruct = config;
   \                     ??USB_DeviceMscInit_3: (+1)
   \   00000062   0x9800             LDR      R0,[SP, #+0]
   \   00000064   0x6045             STR      R5,[R0, #+4]
    621              /* Clear the configuration value. */
    622              mscHandle->configuration = 0;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x9900             LDR      R1,[SP, #+0]
   \   0000006A   0xF881 0x00FC      STRB     R0,[R1, #+252]
    623              mscHandle->alternate = 0xff;
   \   0000006E   0x20FF             MOVS     R0,#+255
   \   00000070   0x9900             LDR      R1,[SP, #+0]
   \   00000072   0xF881 0x00FB      STRB     R0,[R1, #+251]
    624          
    625              /* Get device information. */
    626              error = mscHandle->configurationStruct->classCallback(
    627                  (class_handle_t)mscHandle, kUSB_DeviceMscEventGetLbaInformation, (void *)&diskInformation);
   \   00000076   0xAA01             ADD      R2,SP,#+4
   \   00000078   0x2105             MOVS     R1,#+5
   \   0000007A   0x9800             LDR      R0,[SP, #+0]
   \   0000007C   0x9B00             LDR      R3,[SP, #+0]
   \   0000007E   0x685B             LDR      R3,[R3, #+4]
   \   00000080   0x681B             LDR      R3,[R3, #+0]
   \   00000082   0x4798             BLX      R3
   \   00000084   0x4681             MOV      R9,R0
    628          
    629              if (((diskInformation.lengthOfEachLba) && (diskInformation.totalLbaNumberSupports)) == 0)
   \   00000086   0x9802             LDR      R0,[SP, #+8]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD004             BEQ.N    ??USB_DeviceMscInit_4
   \   0000008C   0x9801             LDR      R0,[SP, #+4]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD001             BEQ.N    ??USB_DeviceMscInit_4
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0xE000             B.N      ??USB_DeviceMscInit_5
   \                     ??USB_DeviceMscInit_4: (+1)
   \   00000096   0x2000             MOVS     R0,#+0
   \                     ??USB_DeviceMscInit_5: (+1)
   \   00000098   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD107             BNE.N    ??USB_DeviceMscInit_6
    630              {
    631                  error = kStatus_USB_Error;
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0x4681             MOV      R9,R0
    632                  USB_DeviceMscFreeHandle(mscHandle);
   \   000000A2   0x9800             LDR      R0,[SP, #+0]
   \   000000A4   0x.... 0x....      BL       USB_DeviceMscFreeHandle
    633                  return error;
   \   000000A8   0x4648             MOV      R0,R9
   \   000000AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AC   0xE092             B.N      ??USB_DeviceMscInit_1
    634              }
    635              mscHandle->logicalUnitNumber = diskInformation.logicalUnitNumberSupported;
   \                     ??USB_DeviceMscInit_6: (+1)
   \   000000AE   0xF89D 0x0014      LDRB     R0,[SP, #+20]
   \   000000B2   0x9900             LDR      R1,[SP, #+0]
   \   000000B4   0xF881 0x00F8      STRB     R0,[R1, #+248]
    636              /*initialize the basic device information*/
    637              ufi = &mscHandle->mscUfi;
   \   000000B8   0x9800             LDR      R0,[SP, #+0]
   \   000000BA   0x3058             ADDS     R0,R0,#+88
   \   000000BC   0x4680             MOV      R8,R0
    638              mscHandle->totalLogicalBlockNumber = diskInformation.totalLbaNumberSupports;
   \   000000BE   0x9801             LDR      R0,[SP, #+4]
   \   000000C0   0x9900             LDR      R1,[SP, #+0]
   \   000000C2   0x6148             STR      R0,[R1, #+20]
    639              mscHandle->lengthOfEachLba = diskInformation.lengthOfEachLba;
   \   000000C4   0x9802             LDR      R0,[SP, #+8]
   \   000000C6   0x9900             LDR      R1,[SP, #+0]
   \   000000C8   0x6188             STR      R0,[R1, #+24]
    640              mscHandle->logicalUnitNumber = diskInformation.logicalUnitNumberSupported - 1;
   \   000000CA   0xF89D 0x0014      LDRB     R0,[SP, #+20]
   \   000000CE   0x1E40             SUBS     R0,R0,#+1
   \   000000D0   0x9900             LDR      R1,[SP, #+0]
   \   000000D2   0xF881 0x00F8      STRB     R0,[R1, #+248]
    641              mscHandle->bulkInBufferSize = diskInformation.bulkInBufferSize;
   \   000000D6   0x9803             LDR      R0,[SP, #+12]
   \   000000D8   0x9900             LDR      R1,[SP, #+0]
   \   000000DA   0x6208             STR      R0,[R1, #+32]
    642              mscHandle->bulkOutBufferSize = diskInformation.bulkOutBufferSize;
   \   000000DC   0x9804             LDR      R0,[SP, #+16]
   \   000000DE   0x9900             LDR      R1,[SP, #+0]
   \   000000E0   0x6248             STR      R0,[R1, #+36]
    643              mscHandle->implementingDiskDrive = implementingDiskDrive;
   \   000000E2   0x9800             LDR      R0,[SP, #+0]
   \   000000E4   0x61C7             STR      R7,[R0, #+28]
    644          
    645              ufi->requestSense.validErrorCode = USB_DEVICE_MSC_UFI_REQ_SENSE_VALID_ERROR_CODE;
   \   000000E6   0x2070             MOVS     R0,#+112
   \   000000E8   0xF888 0x0000      STRB     R0,[R8, #+0]
    646              ufi->requestSense.additionalSenseLength = USB_DEVICE_MSC_UFI_REQ_SENSE_ADDITIONAL_SENSE_LEN;
   \   000000EC   0x200A             MOVS     R0,#+10
   \   000000EE   0xF888 0x0007      STRB     R0,[R8, #+7]
    647              ufi->requestSense.senseKey = USB_DEVICE_MSC_UFI_NO_SENSE;
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0xF888 0x0002      STRB     R0,[R8, #+2]
    648              ufi->requestSense.additionalSenseCode = USB_DEVICE_MSC_UFI_NO_SENSE;
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xF888 0x000C      STRB     R0,[R8, #+12]
    649              ufi->requestSense.additionalSenseQualifer = USB_DEVICE_MSC_UFI_NO_SENSE;
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0xF888 0x000D      STRB     R0,[R8, #+13]
    650          
    651              ufi->readCapacity.lastLogicalBlockAddress = USB_LONG_TO_BIG_ENDIAN(mscHandle->totalLogicalBlockNumber - 1);
   \   00000104   0x9800             LDR      R0,[SP, #+0]
   \   00000106   0x6940             LDR      R0,[R0, #+20]
   \   00000108   0x1E40             SUBS     R0,R0,#+1
   \   0000010A   0x9900             LDR      R1,[SP, #+0]
   \   0000010C   0x6949             LDR      R1,[R1, #+20]
   \   0000010E   0x1E49             SUBS     R1,R1,#+1
   \   00000110   0x0209             LSLS     R1,R1,#+8
   \   00000112   0xF411 0x017F      ANDS     R1,R1,#0xFF0000
   \   00000116   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   0000011A   0x9900             LDR      R1,[SP, #+0]
   \   0000011C   0x6949             LDR      R1,[R1, #+20]
   \   0000011E   0x1E49             SUBS     R1,R1,#+1
   \   00000120   0x0A09             LSRS     R1,R1,#+8
   \   00000122   0xF411 0x417F      ANDS     R1,R1,#0xFF00
   \   00000126   0x4308             ORRS     R0,R1,R0
   \   00000128   0x9900             LDR      R1,[SP, #+0]
   \   0000012A   0x6949             LDR      R1,[R1, #+20]
   \   0000012C   0x1E49             SUBS     R1,R1,#+1
   \   0000012E   0xEA50 0x6011      ORRS     R0,R0,R1, LSR #+24
   \   00000132   0xF8C8 0x002C      STR      R0,[R8, #+44]
    652              ufi->readCapacity.blockSize = USB_LONG_TO_BIG_ENDIAN((uint32_t)mscHandle->lengthOfEachLba);
   \   00000136   0x9800             LDR      R0,[SP, #+0]
   \   00000138   0x6980             LDR      R0,[R0, #+24]
   \   0000013A   0x9900             LDR      R1,[SP, #+0]
   \   0000013C   0x6989             LDR      R1,[R1, #+24]
   \   0000013E   0x0209             LSLS     R1,R1,#+8
   \   00000140   0xF411 0x017F      ANDS     R1,R1,#0xFF0000
   \   00000144   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   00000148   0x9900             LDR      R1,[SP, #+0]
   \   0000014A   0x6989             LDR      R1,[R1, #+24]
   \   0000014C   0x0A09             LSRS     R1,R1,#+8
   \   0000014E   0xF411 0x417F      ANDS     R1,R1,#0xFF00
   \   00000152   0x4308             ORRS     R0,R1,R0
   \   00000154   0x9900             LDR      R1,[SP, #+0]
   \   00000156   0x6989             LDR      R1,[R1, #+24]
   \   00000158   0xEA50 0x6011      ORRS     R0,R0,R1, LSR #+24
   \   0000015C   0xF8C8 0x0030      STR      R0,[R8, #+48]
    653              ufi->readCapacity16.lastLogicalBlockAddress1 = USB_LONG_TO_BIG_ENDIAN(mscHandle->totalLogicalBlockNumber - 1);
   \   00000160   0x9800             LDR      R0,[SP, #+0]
   \   00000162   0x6940             LDR      R0,[R0, #+20]
   \   00000164   0x1E40             SUBS     R0,R0,#+1
   \   00000166   0x9900             LDR      R1,[SP, #+0]
   \   00000168   0x6949             LDR      R1,[R1, #+20]
   \   0000016A   0x1E49             SUBS     R1,R1,#+1
   \   0000016C   0x0209             LSLS     R1,R1,#+8
   \   0000016E   0xF411 0x017F      ANDS     R1,R1,#0xFF0000
   \   00000172   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   00000176   0x9900             LDR      R1,[SP, #+0]
   \   00000178   0x6949             LDR      R1,[R1, #+20]
   \   0000017A   0x1E49             SUBS     R1,R1,#+1
   \   0000017C   0x0A09             LSRS     R1,R1,#+8
   \   0000017E   0xF411 0x417F      ANDS     R1,R1,#0xFF00
   \   00000182   0x4308             ORRS     R0,R1,R0
   \   00000184   0x9900             LDR      R1,[SP, #+0]
   \   00000186   0x6949             LDR      R1,[R1, #+20]
   \   00000188   0x1E49             SUBS     R1,R1,#+1
   \   0000018A   0xEA50 0x6011      ORRS     R0,R0,R1, LSR #+24
   \   0000018E   0xF8C8 0x0038      STR      R0,[R8, #+56]
    654              ufi->readCapacity16.blockSize = USB_LONG_TO_BIG_ENDIAN((uint32_t)mscHandle->lengthOfEachLba);
   \   00000192   0x9800             LDR      R0,[SP, #+0]
   \   00000194   0x6980             LDR      R0,[R0, #+24]
   \   00000196   0x9900             LDR      R1,[SP, #+0]
   \   00000198   0x6989             LDR      R1,[R1, #+24]
   \   0000019A   0x0209             LSLS     R1,R1,#+8
   \   0000019C   0xF411 0x017F      ANDS     R1,R1,#0xFF0000
   \   000001A0   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   000001A4   0x9900             LDR      R1,[SP, #+0]
   \   000001A6   0x6989             LDR      R1,[R1, #+24]
   \   000001A8   0x0A09             LSRS     R1,R1,#+8
   \   000001AA   0xF411 0x417F      ANDS     R1,R1,#0xFF00
   \   000001AE   0x4308             ORRS     R0,R1,R0
   \   000001B0   0x9900             LDR      R1,[SP, #+0]
   \   000001B2   0x6989             LDR      R1,[R1, #+24]
   \   000001B4   0xEA50 0x6011      ORRS     R0,R0,R1, LSR #+24
   \   000001B8   0xF8C8 0x003C      STR      R0,[R8, #+60]
    655          
    656              mscHandle->cbwPrimeFlag = 0;
   \   000001BC   0x2000             MOVS     R0,#+0
   \   000001BE   0x9900             LDR      R1,[SP, #+0]
   \   000001C0   0xF881 0x00F5      STRB     R0,[R1, #+245]
    657              mscHandle->cswPrimeFlag = 0;
   \   000001C4   0x2000             MOVS     R0,#+0
   \   000001C6   0x9900             LDR      R1,[SP, #+0]
   \   000001C8   0xF881 0x00F6      STRB     R0,[R1, #+246]
    658          
    659              *handle = (class_handle_t)mscHandle;
   \   000001CC   0x9800             LDR      R0,[SP, #+0]
   \   000001CE   0x6030             STR      R0,[R6, #+0]
    660              return error;
   \   000001D0   0x4648             MOV      R0,R9
   \   000001D2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceMscInit_1: (+1)
   \   000001D4   0xB007             ADD      SP,SP,#+28
   \   000001D6   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    661          }
    662          
    663          /*!
    664           * @brief De-initialize the device msc class.
    665           *
    666           * The function de-initializes the device msc class.
    667           *
    668           * @param handle The msc class handle got from usb_device_class_config_struct_t::classHandle.
    669           *
    670           * @return A USB error code or kStatus_USB_Success.
    671           */

   \                                 In section .text, align 2, keep-with-next
    672          usb_status_t USB_DeviceMscDeinit(class_handle_t handle)
    673          {
   \                     USB_DeviceMscDeinit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    674              usb_device_msc_struct_t *mscHandle;
    675              usb_status_t error = kStatus_USB_Error;
   \   00000004   0x2601             MOVS     R6,#+1
    676          
    677              mscHandle = (usb_device_msc_struct_t *)handle;
   \   00000006   0x0025             MOVS     R5,R4
    678          
    679              if (!mscHandle)
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD101             BNE.N    ??USB_DeviceMscDeinit_0
    680              {
    681                  return kStatus_USB_InvalidHandle;
   \   0000000C   0x2003             MOVS     R0,#+3
   \   0000000E   0xE008             B.N      ??USB_DeviceMscDeinit_1
    682              }
    683              error = USB_DeviceMscEndpointsDeinit(mscHandle);
   \                     ??USB_DeviceMscDeinit_0: (+1)
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0x.... 0x....      BL       USB_DeviceMscEndpointsDeinit
   \   00000016   0x0006             MOVS     R6,R0
    684              USB_DeviceMscFreeHandle(mscHandle);
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       USB_DeviceMscFreeHandle
    685              return error;
   \   0000001E   0x0030             MOVS     R0,R6
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceMscDeinit_1: (+1)
   \   00000022   0xBD70             POP      {R4-R6,PC}       ;; return
    686          }
    687          
    688          /*!
    689           * @brief Handle the event passed to the msc class.
    690           *
    691           * This function handles the event passed to the msc class.
    692           *
    693           * @param handle          The msc class handle, got from the usb_device_class_config_struct_t::classHandle.
    694           * @param event           The event codes. Please refer to the enumeration usb_device_class_event_t.
    695           * @param param           The param type is determined by the event code.
    696           *
    697           * @return A USB error code or kStatus_USB_Success.
    698           * @retval kStatus_USB_Success              Free device handle successfully.
    699           * @retval kStatus_USB_InvalidParameter     The device handle not be found.
    700           * @retval kStatus_USB_InvalidRequest       The request is invalid, and the control pipe will be stalled by the caller.
    701           */

   \                                 In section .text, align 2, keep-with-next
    702          usb_status_t USB_DeviceMscEvent(void *handle, uint32_t event, void *param)
    703          {
   \                     USB_DeviceMscEvent: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    704              usb_status_t error = kStatus_USB_Error;
   \   0000000A   0x2701             MOVS     R7,#+1
    705              usb_device_msc_struct_t *mscHandle;
    706          
    707              uint16_t interfaceAlternate;
    708              uint8_t *temp8;
    709              uint8_t alternate;
    710          
    711              if ((!param) || (!handle))
   \   0000000C   0x2E00             CMP      R6,#+0
   \   0000000E   0xD001             BEQ.N    ??USB_DeviceMscEvent_0
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD101             BNE.N    ??USB_DeviceMscEvent_1
    712              {
    713                  return kStatus_USB_InvalidHandle;
   \                     ??USB_DeviceMscEvent_0: (+1)
   \   00000014   0x2003             MOVS     R0,#+3
   \   00000016   0xE18B             B.N      ??USB_DeviceMscEvent_2
    714              }
    715          
    716              /* Get the msc class handle. */
    717              mscHandle = (usb_device_msc_struct_t *)handle;
   \                     ??USB_DeviceMscEvent_1: (+1)
   \   00000018   0x46A0             MOV      R8,R4
    718              switch (event)
   \   0000001A   0x2D01             CMP      R5,#+1
   \   0000001C   0xF000 0x811D      BEQ.W    ??USB_DeviceMscEvent_3
   \   00000020   0xF0C0 0x8184      BCC.W    ??USB_DeviceMscEvent_4
   \   00000024   0x2D03             CMP      R5,#+3
   \   00000026   0xD00B             BEQ.N    ??USB_DeviceMscEvent_5
   \   00000028   0xD306             BCC.N    ??USB_DeviceMscEvent_6
   \   0000002A   0x2D05             CMP      R5,#+5
   \   0000002C   0xD050             BEQ.N    ??USB_DeviceMscEvent_7
   \   0000002E   0xD328             BCC.N    ??USB_DeviceMscEvent_8
   \   00000030   0x2D06             CMP      R5,#+6
   \   00000032   0xF000 0x8087      BEQ.W    ??USB_DeviceMscEvent_9
   \   00000036   0xE179             B.N      ??USB_DeviceMscEvent_4
    719              {
    720                  case kUSB_DeviceClassEventDeviceReset:
    721                      /* Bus reset, clear the configuration. */
    722                      mscHandle->configuration = 0;
   \                     ??USB_DeviceMscEvent_6: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xF888 0x00FC      STRB     R0,[R8, #+252]
    723                      break;
   \   0000003E   0xE175             B.N      ??USB_DeviceMscEvent_10
    724                  case kUSB_DeviceClassEventSetConfiguration:
    725                      /* Get the new configuration. */
    726                      temp8 = ((uint8_t *)param);
   \                     ??USB_DeviceMscEvent_5: (+1)
   \   00000040   0x46B2             MOV      R10,R6
    727                      if (!mscHandle->configurationStruct)
   \   00000042   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xF000 0x8170      BEQ.W    ??USB_DeviceMscEvent_10
    728                      {
    729                          break;
    730                      }
    731                      if (*temp8 == mscHandle->configuration)
   \                     ??USB_DeviceMscEvent_11: (+1)
   \   0000004C   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   00000050   0xF898 0x10FC      LDRB     R1,[R8, #+252]
   \   00000054   0x4288             CMP      R0,R1
   \   00000056   0xF000 0x8169      BEQ.W    ??USB_DeviceMscEvent_10
    732                      {
    733                          break;
    734                      }
    735          
    736                      if (mscHandle->configuration)
   \                     ??USB_DeviceMscEvent_12: (+1)
   \   0000005A   0xF898 0x00FC      LDRB     R0,[R8, #+252]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD003             BEQ.N    ??USB_DeviceMscEvent_13
    737                      {
    738                          /* De-initialize the endpoints when current configuration is none zero. */
    739                          error = USB_DeviceMscEndpointsDeinit(mscHandle);
   \   00000062   0x4640             MOV      R0,R8
   \   00000064   0x.... 0x....      BL       USB_DeviceMscEndpointsDeinit
   \   00000068   0x0007             MOVS     R7,R0
    740                      }
    741                      /* Save new configuration. */
    742                      mscHandle->configuration = *temp8;
   \                     ??USB_DeviceMscEvent_13: (+1)
   \   0000006A   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   0000006E   0xF888 0x00FC      STRB     R0,[R8, #+252]
    743                      /* Clear the alternate setting value. */
    744                      mscHandle->alternate = 0;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xF888 0x00FB      STRB     R0,[R8, #+251]
    745                      /* Initialize the endpoints of the new current configuration by using the alternate setting 0. */
    746                      error = USB_DeviceMscEndpointsInit(mscHandle);
   \   00000078   0x4640             MOV      R0,R8
   \   0000007A   0x.... 0x....      BL       USB_DeviceMscEndpointsInit
   \   0000007E   0x0007             MOVS     R7,R0
    747                      break;
   \   00000080   0xE154             B.N      ??USB_DeviceMscEvent_10
    748                  case kUSB_DeviceClassEventSetInterface:
    749          
    750                      if (!mscHandle->configurationStruct)
   \                     ??USB_DeviceMscEvent_8: (+1)
   \   00000082   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xF000 0x8150      BEQ.W    ??USB_DeviceMscEvent_10
    751                      {
    752                          break;
    753                      }
    754                      /* Get the new alternate setting of the interface */
    755                      interfaceAlternate = *((uint16_t *)param);
   \                     ??USB_DeviceMscEvent_14: (+1)
   \   0000008C   0x8830             LDRH     R0,[R6, #+0]
   \   0000008E   0x4681             MOV      R9,R0
    756                      /* Get the alternate setting value */
    757                      alternate = (uint8_t)(interfaceAlternate & 0xFF);
   \   00000090   0x4648             MOV      R0,R9
   \   00000092   0xF88D 0x0000      STRB     R0,[SP, #+0]
    758          
    759                      /* Whether the interface belongs to the class. */
    760                      if (mscHandle->interfaceNumber != ((uint8_t)(interfaceAlternate >> 8)))
   \   00000096   0xF898 0x10FD      LDRB     R1,[R8, #+253]
   \   0000009A   0x4648             MOV      R0,R9
   \   0000009C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009E   0x0A00             LSRS     R0,R0,#+8
   \   000000A0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A2   0x4281             CMP      R1,R0
   \   000000A4   0xF040 0x8142      BNE.W    ??USB_DeviceMscEvent_10
    761                      {
    762                          break;
    763                      }
    764                      /* Only handle new alternate setting. */
    765                      if (alternate == mscHandle->alternate)
   \                     ??USB_DeviceMscEvent_15: (+1)
   \   000000A8   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000AC   0xF898 0x10FB      LDRB     R1,[R8, #+251]
   \   000000B0   0x4288             CMP      R0,R1
   \   000000B2   0xF000 0x813B      BEQ.W    ??USB_DeviceMscEvent_10
    766                      {
    767                          break;
    768                      }
    769                      /* De-initialize old endpoints */
    770                      error = USB_DeviceMscEndpointsDeinit(mscHandle);
   \                     ??USB_DeviceMscEvent_16: (+1)
   \   000000B6   0x4640             MOV      R0,R8
   \   000000B8   0x.... 0x....      BL       USB_DeviceMscEndpointsDeinit
   \   000000BC   0x0007             MOVS     R7,R0
    771                      mscHandle->alternate = alternate;
   \   000000BE   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000C2   0xF888 0x00FB      STRB     R0,[R8, #+251]
    772                      /* Initialize new endpoints */
    773                      error = USB_DeviceMscEndpointsInit(mscHandle);
   \   000000C6   0x4640             MOV      R0,R8
   \   000000C8   0x.... 0x....      BL       USB_DeviceMscEndpointsInit
   \   000000CC   0x0007             MOVS     R7,R0
    774                      break;
   \   000000CE   0xE12D             B.N      ??USB_DeviceMscEvent_10
    775                  case kUSB_DeviceClassEventSetEndpointHalt:
    776                      if ((!mscHandle->configurationStruct) || (!mscHandle->interfaceHandle))
   \                     ??USB_DeviceMscEvent_7: (+1)
   \   000000D0   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD003             BEQ.N    ??USB_DeviceMscEvent_17
   \   000000D8   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD100             BNE.N    ??USB_DeviceMscEvent_18
    777                      {
    778                          break;
   \                     ??USB_DeviceMscEvent_17: (+1)
   \   000000E0   0xE124             B.N      ??USB_DeviceMscEvent_10
    779                      }
    780                      /* Get the endpoint address */
    781                      temp8 = ((uint8_t *)param);
   \                     ??USB_DeviceMscEvent_18: (+1)
   \   000000E2   0x46B2             MOV      R10,R6
    782                      for (int count = 0; count < mscHandle->interfaceHandle->endpointList.count; count++)
   \   000000E4   0xF05F 0x0B00      MOVS     R11,#+0
   \                     ??USB_DeviceMscEvent_19: (+1)
   \   000000E8   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   000000EC   0x7900             LDRB     R0,[R0, #+4]
   \   000000EE   0x4583             CMP      R11,R0
   \   000000F0   0xDA27             BGE.N    ??USB_DeviceMscEvent_20
    783                      {
    784                          if (*temp8 == mscHandle->interfaceHandle->endpointList.endpoint[count].endpointAddress)
   \   000000F2   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   000000F6   0xF8D8 0x1008      LDR      R1,[R8, #+8]
   \   000000FA   0x6889             LDR      R1,[R1, #+8]
   \   000000FC   0xF811 0x102B      LDRB     R1,[R1, R11, LSL #+2]
   \   00000100   0x4288             CMP      R0,R1
   \   00000102   0xD11B             BNE.N    ??USB_DeviceMscEvent_21
    785                          {
    786                              if (mscHandle->inEndpointStallFlag == 0)
   \   00000104   0xF898 0x00EE      LDRB     R0,[R8, #+238]
   \   00000108   0x2800             CMP      R0,#+0
   \   0000010A   0xD109             BNE.N    ??USB_DeviceMscEvent_22
    787                              {
    788                                  /* Only stall the endpoint belongs to the class */
    789                                  error = USB_DeviceStallEndpoint(mscHandle->handle, *temp8);
   \   0000010C   0xF89A 0x1000      LDRB     R1,[R10, #+0]
   \   00000110   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000114   0x.... 0x....      BL       USB_DeviceStallEndpoint
   \   00000118   0x0007             MOVS     R7,R0
    790                                  mscHandle->inEndpointStallFlag = 1;
   \   0000011A   0x2001             MOVS     R0,#+1
   \   0000011C   0xF888 0x00EE      STRB     R0,[R8, #+238]
    791                              }
    792                              if (mscHandle->outEndpointStallFlag == 0)
   \                     ??USB_DeviceMscEvent_22: (+1)
   \   00000120   0xF898 0x00EF      LDRB     R0,[R8, #+239]
   \   00000124   0x2800             CMP      R0,#+0
   \   00000126   0xD109             BNE.N    ??USB_DeviceMscEvent_21
    793                              {
    794                                  error = USB_DeviceStallEndpoint(mscHandle->handle, *temp8);
   \   00000128   0xF89A 0x1000      LDRB     R1,[R10, #+0]
   \   0000012C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000130   0x.... 0x....      BL       USB_DeviceStallEndpoint
   \   00000134   0x0007             MOVS     R7,R0
    795                                  mscHandle->inEndpointStallFlag = 0;
   \   00000136   0x2000             MOVS     R0,#+0
   \   00000138   0xF888 0x00EE      STRB     R0,[R8, #+238]
    796                              }
    797                          }
    798                      }
   \                     ??USB_DeviceMscEvent_21: (+1)
   \   0000013C   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   00000140   0xE7D2             B.N      ??USB_DeviceMscEvent_19
    799          
    800                      break;
   \                     ??USB_DeviceMscEvent_20: (+1)
   \   00000142   0xE0F3             B.N      ??USB_DeviceMscEvent_10
    801                  case kUSB_DeviceClassEventClearEndpointHalt:
    802                      if ((!mscHandle->configurationStruct) || (!mscHandle->interfaceHandle) ||
    803                          (mscHandle->performResetRecover == 1))
   \                     ??USB_DeviceMscEvent_9: (+1)
   \   00000144   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000148   0x2800             CMP      R0,#+0
   \   0000014A   0xD007             BEQ.N    ??USB_DeviceMscEvent_23
   \   0000014C   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   00000150   0x2800             CMP      R0,#+0
   \   00000152   0xD003             BEQ.N    ??USB_DeviceMscEvent_23
   \   00000154   0xF898 0x00F1      LDRB     R0,[R8, #+241]
   \   00000158   0x2801             CMP      R0,#+1
   \   0000015A   0xD100             BNE.N    ??USB_DeviceMscEvent_24
    804                      {
    805                          break;
   \                     ??USB_DeviceMscEvent_23: (+1)
   \   0000015C   0xE0E6             B.N      ??USB_DeviceMscEvent_10
    806                      }
    807                      /* Get the endpoint address */
    808                      temp8 = ((uint8_t *)param);
   \                     ??USB_DeviceMscEvent_24: (+1)
   \   0000015E   0x46B2             MOV      R10,R6
    809                      for (int count = 0; count < mscHandle->interfaceHandle->endpointList.count; count++)
   \   00000160   0xF05F 0x0B00      MOVS     R11,#+0
   \                     ??USB_DeviceMscEvent_25: (+1)
   \   00000164   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   00000168   0x7900             LDRB     R0,[R0, #+4]
   \   0000016A   0x4583             CMP      R11,R0
   \   0000016C   0xDA27             BGE.N    ??USB_DeviceMscEvent_26
    810                      {
    811                          if (*temp8 == mscHandle->interfaceHandle->endpointList.endpoint[count].endpointAddress)
   \   0000016E   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   00000172   0xF8D8 0x1008      LDR      R1,[R8, #+8]
   \   00000176   0x6889             LDR      R1,[R1, #+8]
   \   00000178   0xF811 0x102B      LDRB     R1,[R1, R11, LSL #+2]
   \   0000017C   0x4288             CMP      R0,R1
   \   0000017E   0xD11B             BNE.N    ??USB_DeviceMscEvent_27
    812                          {
    813                              /* Only un-stall the endpoint belongs to the class , If the dedpoint is in stall status ,then
    814                               * un-stall it*/
    815                              if (mscHandle->inEndpointStallFlag == 1)
   \   00000180   0xF898 0x00EE      LDRB     R0,[R8, #+238]
   \   00000184   0x2801             CMP      R0,#+1
   \   00000186   0xD109             BNE.N    ??USB_DeviceMscEvent_28
    816                              {
    817                                  error = USB_DeviceUnstallEndpoint(mscHandle->handle, *temp8);
   \   00000188   0xF89A 0x1000      LDRB     R1,[R10, #+0]
   \   0000018C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000190   0x.... 0x....      BL       USB_DeviceUnstallEndpoint
   \   00000194   0x0007             MOVS     R7,R0
    818                                  mscHandle->inEndpointStallFlag = 0;
   \   00000196   0x2000             MOVS     R0,#+0
   \   00000198   0xF888 0x00EE      STRB     R0,[R8, #+238]
    819                              }
    820                              if (mscHandle->outEndpointStallFlag == 1)
   \                     ??USB_DeviceMscEvent_28: (+1)
   \   0000019C   0xF898 0x00EF      LDRB     R0,[R8, #+239]
   \   000001A0   0x2801             CMP      R0,#+1
   \   000001A2   0xD109             BNE.N    ??USB_DeviceMscEvent_27
    821                              {
    822                                  error = USB_DeviceUnstallEndpoint(mscHandle->handle, *temp8);
   \   000001A4   0xF89A 0x1000      LDRB     R1,[R10, #+0]
   \   000001A8   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000001AC   0x.... 0x....      BL       USB_DeviceUnstallEndpoint
   \   000001B0   0x0007             MOVS     R7,R0
    823                                  mscHandle->inEndpointStallFlag = 0;
   \   000001B2   0x2000             MOVS     R0,#+0
   \   000001B4   0xF888 0x00EE      STRB     R0,[R8, #+238]
    824                              }
    825                          }
    826                      }
   \                     ??USB_DeviceMscEvent_27: (+1)
   \   000001B8   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   000001BC   0xE7D2             B.N      ??USB_DeviceMscEvent_25
    827                      if (((mscHandle->stallStatus == USB_DEVICE_MSC_STALL_IN_CSW) ||
    828                           (mscHandle->stallStatus == USB_DEVICE_MSC_STALL_IN_DATA)) &&
    829                          (mscHandle->performResetDoneFlag != 1))
   \                     ??USB_DeviceMscEvent_26: (+1)
   \   000001BE   0xF898 0x00F7      LDRB     R0,[R8, #+247]
   \   000001C2   0x2803             CMP      R0,#+3
   \   000001C4   0xD003             BEQ.N    ??USB_DeviceMscEvent_29
   \   000001C6   0xF898 0x00F7      LDRB     R0,[R8, #+247]
   \   000001CA   0x2802             CMP      R0,#+2
   \   000001CC   0xD11C             BNE.N    ??USB_DeviceMscEvent_30
   \                     ??USB_DeviceMscEvent_29: (+1)
   \   000001CE   0xF898 0x00F2      LDRB     R0,[R8, #+242]
   \   000001D2   0x2801             CMP      R0,#+1
   \   000001D4   0xD018             BEQ.N    ??USB_DeviceMscEvent_30
    830                      {
    831                          if (mscHandle->cswPrimeFlag == 1)
   \   000001D6   0xF898 0x00F6      LDRB     R0,[R8, #+246]
   \   000001DA   0x2801             CMP      R0,#+1
   \   000001DC   0xD105             BNE.N    ??USB_DeviceMscEvent_31
    832                          {
    833                              USB_DeviceCancel(mscHandle->handle, mscHandle->bulkInEndpoint);
   \   000001DE   0xF898 0x10F9      LDRB     R1,[R8, #+249]
   \   000001E2   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000001E6   0x.... 0x....      BL       USB_DeviceCancel
    834                          }
    835                          /*send csw*/
    836                          USB_DeviceSendRequest(mscHandle->handle, mscHandle->bulkInEndpoint, (uint8_t *)&mscHandle->mscCsw,
    837                                                USB_DEVICE_MSC_CSW_LENGTH);
   \                     ??USB_DeviceMscEvent_31: (+1)
   \   000001EA   0x230D             MOVS     R3,#+13
   \   000001EC   0xF118 0x0248      ADDS     R2,R8,#+72
   \   000001F0   0xF898 0x10F9      LDRB     R1,[R8, #+249]
   \   000001F4   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000001F8   0x.... 0x....      BL       USB_DeviceSendRequest
    838                          mscHandle->cswPrimeFlag = 0;
   \   000001FC   0x2000             MOVS     R0,#+0
   \   000001FE   0xF888 0x00F6      STRB     R0,[R8, #+246]
    839                          mscHandle->stallStatus = 0;
   \   00000202   0x2000             MOVS     R0,#+0
   \   00000204   0xF888 0x00F7      STRB     R0,[R8, #+247]
    840                      }
    841                      if ((mscHandle->performResetDoneFlag == 1) && (mscHandle->inEndpointStallFlag == 0) &&
    842                          (mscHandle->outEndpointStallFlag == 0))
   \                     ??USB_DeviceMscEvent_30: (+1)
   \   00000208   0xF898 0x00F2      LDRB     R0,[R8, #+242]
   \   0000020C   0x2801             CMP      R0,#+1
   \   0000020E   0xD123             BNE.N    ??USB_DeviceMscEvent_32
   \   00000210   0xF898 0x00EE      LDRB     R0,[R8, #+238]
   \   00000214   0x2800             CMP      R0,#+0
   \   00000216   0xD11F             BNE.N    ??USB_DeviceMscEvent_32
   \   00000218   0xF898 0x00EF      LDRB     R0,[R8, #+239]
   \   0000021C   0x2800             CMP      R0,#+0
   \   0000021E   0xD11B             BNE.N    ??USB_DeviceMscEvent_32
    843                      {
    844                          mscHandle->performResetDoneFlag = 0;
   \   00000220   0x2000             MOVS     R0,#+0
   \   00000222   0xF888 0x00F2      STRB     R0,[R8, #+242]
    845                          if (mscHandle->cswPrimeFlag == 1)
   \   00000226   0xF898 0x00F6      LDRB     R0,[R8, #+246]
   \   0000022A   0x2801             CMP      R0,#+1
   \   0000022C   0xD105             BNE.N    ??USB_DeviceMscEvent_33
    846                          {
    847                              USB_DeviceCancel(mscHandle->handle, mscHandle->bulkInEndpoint);
   \   0000022E   0xF898 0x10F9      LDRB     R1,[R8, #+249]
   \   00000232   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000236   0x.... 0x....      BL       USB_DeviceCancel
    848                          }
    849                          /*prime cbw for new transfer*/
    850                          USB_DeviceRecvRequest(mscHandle->handle, mscHandle->bulkOutEndpoint, (uint8_t *)&mscHandle->mscCbw,
    851                                                USB_DEVICE_MSC_CBW_LENGTH);
   \                     ??USB_DeviceMscEvent_33: (+1)
   \   0000023A   0x231F             MOVS     R3,#+31
   \   0000023C   0xF118 0x0228      ADDS     R2,R8,#+40
   \   00000240   0xF898 0x10FA      LDRB     R1,[R8, #+250]
   \   00000244   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000248   0x.... 0x....      BL       USB_DeviceRecvRequest
    852                          mscHandle->cswPrimeFlag = 0;
   \   0000024C   0x2000             MOVS     R0,#+0
   \   0000024E   0xF888 0x00F6      STRB     R0,[R8, #+246]
    853                          mscHandle->stallStatus = 0;
   \   00000252   0x2000             MOVS     R0,#+0
   \   00000254   0xF888 0x00F7      STRB     R0,[R8, #+247]
    854                      }
    855                      break;
   \                     ??USB_DeviceMscEvent_32: (+1)
   \   00000258   0xE068             B.N      ??USB_DeviceMscEvent_10
    856                  case kUSB_DeviceClassEventClassRequest:
    857                      if (param)
   \                     ??USB_DeviceMscEvent_3: (+1)
   \   0000025A   0x2E00             CMP      R6,#+0
   \   0000025C   0xD065             BEQ.N    ??USB_DeviceMscEvent_34
    858                      {
    859                          /* Handle the msc class specific request. */
    860                          usb_device_control_request_struct_t *control_request = (usb_device_control_request_struct_t *)param;
   \   0000025E   0x46B3             MOV      R11,R6
    861          
    862                          if ((control_request->setup->bmRequestType & USB_REQUEST_TYPE_RECIPIENT_MASK) !=
    863                              USB_REQUEST_TYPE_RECIPIENT_INTERFACE)
   \   00000260   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   00000264   0x7800             LDRB     R0,[R0, #+0]
   \   00000266   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   0000026A   0x2801             CMP      R0,#+1
   \   0000026C   0xD15E             BNE.N    ??USB_DeviceMscEvent_10
    864                          {
    865                              break;
    866                          }
    867          
    868                          if ((control_request->setup->wIndex & 0xFF) != mscHandle->interfaceNumber)
   \                     ??USB_DeviceMscEvent_35: (+1)
   \   0000026E   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   00000272   0x7900             LDRB     R0,[R0, #+4]
   \   00000274   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   00000278   0xF898 0x10FD      LDRB     R1,[R8, #+253]
   \   0000027C   0x4288             CMP      R0,R1
   \   0000027E   0xD155             BNE.N    ??USB_DeviceMscEvent_10
    869                          {
    870                              break;
    871                          }
    872          
    873                          switch (control_request->setup->bRequest)
   \                     ??USB_DeviceMscEvent_36: (+1)
   \   00000280   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   00000284   0x7840             LDRB     R0,[R0, #+1]
   \   00000286   0x28FE             CMP      R0,#+254
   \   00000288   0xD002             BEQ.N    ??USB_DeviceMscEvent_37
   \   0000028A   0x28FF             CMP      R0,#+255
   \   0000028C   0xD024             BEQ.N    ??USB_DeviceMscEvent_38
   \   0000028E   0xE04C             B.N      ??USB_DeviceMscEvent_39
    874                          {
    875                              case USB_DEVICE_MSC_GET_MAX_LUN:
    876                                  /*Get Max LUN */
    877                                  if ((control_request->setup->wIndex == mscHandle->interfaceNumber) &&
    878                                      (!control_request->setup->wValue) && (control_request->setup->wLength <= 0x0001) &&
    879                                      ((control_request->setup->bmRequestType & USB_REQUSET_TYPE_DIR_MASK) ==
    880                                       USB_REQUEST_TYPE_DIR_IN))
   \                     ??USB_DeviceMscEvent_37: (+1)
   \   00000290   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   00000294   0x8880             LDRH     R0,[R0, #+4]
   \   00000296   0xF898 0x10FD      LDRB     R1,[R8, #+253]
   \   0000029A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000029C   0x4288             CMP      R0,R1
   \   0000029E   0xD118             BNE.N    ??USB_DeviceMscEvent_40
   \   000002A0   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000002A4   0x8840             LDRH     R0,[R0, #+2]
   \   000002A6   0x2800             CMP      R0,#+0
   \   000002A8   0xD113             BNE.N    ??USB_DeviceMscEvent_40
   \   000002AA   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000002AE   0x88C0             LDRH     R0,[R0, #+6]
   \   000002B0   0x2802             CMP      R0,#+2
   \   000002B2   0xDA0E             BGE.N    ??USB_DeviceMscEvent_40
   \   000002B4   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000002B8   0x7800             LDRB     R0,[R0, #+0]
   \   000002BA   0x0600             LSLS     R0,R0,#+24
   \   000002BC   0xD509             BPL.N    ??USB_DeviceMscEvent_40
    881                                  {
    882                                      control_request->buffer = &mscHandle->logicalUnitNumber;
   \   000002BE   0xF118 0x00F8      ADDS     R0,R8,#+248
   \   000002C2   0xF8CB 0x0004      STR      R0,[R11, #+4]
    883                                      control_request->length = (uint32_t)control_request->setup->wLength;
   \   000002C6   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000002CA   0x88C0             LDRH     R0,[R0, #+6]
   \   000002CC   0xF8CB 0x0008      STR      R0,[R11, #+8]
   \   000002D0   0xE001             B.N      ??USB_DeviceMscEvent_41
    884                                  }
    885                                  else
    886                                  {
    887                                      error = kStatus_USB_InvalidRequest;
   \                     ??USB_DeviceMscEvent_40: (+1)
   \   000002D2   0x2005             MOVS     R0,#+5
   \   000002D4   0x0007             MOVS     R7,R0
    888                                  }
    889          
    890                                  break;
   \                     ??USB_DeviceMscEvent_41: (+1)
   \   000002D6   0xE028             B.N      ??USB_DeviceMscEvent_34
    891                              case USB_DEVICE_MSC_BULK_ONLY_MASS_STORAGE_RESET:
    892                                  /*Bulk-Only Mass Storage Reset (class-specific request)*/
    893                                  if ((control_request->setup->wIndex == mscHandle->interfaceNumber) &&
    894                                      (!control_request->setup->wValue) && (!control_request->setup->wLength) &&
    895                                      ((control_request->setup->bmRequestType & USB_REQUSET_TYPE_DIR_MASK) ==
    896                                       USB_REQUEST_TYPE_DIR_OUT))
   \                     ??USB_DeviceMscEvent_38: (+1)
   \   000002D8   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000002DC   0x8880             LDRH     R0,[R0, #+4]
   \   000002DE   0xF898 0x10FD      LDRB     R1,[R8, #+253]
   \   000002E2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000002E4   0x4288             CMP      R0,R1
   \   000002E6   0xD11D             BNE.N    ??USB_DeviceMscEvent_42
   \   000002E8   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000002EC   0x8840             LDRH     R0,[R0, #+2]
   \   000002EE   0x2800             CMP      R0,#+0
   \   000002F0   0xD118             BNE.N    ??USB_DeviceMscEvent_42
   \   000002F2   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000002F6   0x88C0             LDRH     R0,[R0, #+6]
   \   000002F8   0x2800             CMP      R0,#+0
   \   000002FA   0xD113             BNE.N    ??USB_DeviceMscEvent_42
   \   000002FC   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   00000300   0x7800             LDRB     R0,[R0, #+0]
   \   00000302   0x0600             LSLS     R0,R0,#+24
   \   00000304   0xD40E             BMI.N    ??USB_DeviceMscEvent_42
    897                                  {
    898                                      error = USB_DeviceMscEndpointsDeinit(mscHandle);
   \   00000306   0x4640             MOV      R0,R8
   \   00000308   0x.... 0x....      BL       USB_DeviceMscEndpointsDeinit
   \   0000030C   0x0007             MOVS     R7,R0
    899                                      error = USB_DeviceMscEndpointsInit(mscHandle);
   \   0000030E   0x4640             MOV      R0,R8
   \   00000310   0x.... 0x....      BL       USB_DeviceMscEndpointsInit
   \   00000314   0x0007             MOVS     R7,R0
    900                                      mscHandle->performResetRecover = 0;
   \   00000316   0x2000             MOVS     R0,#+0
   \   00000318   0xF888 0x00F1      STRB     R0,[R8, #+241]
    901                                      mscHandle->performResetDoneFlag = 1;
   \   0000031C   0x2001             MOVS     R0,#+1
   \   0000031E   0xF888 0x00F2      STRB     R0,[R8, #+242]
   \   00000322   0xE001             B.N      ??USB_DeviceMscEvent_43
    902                                  }
    903                                  else
    904                                  {
    905                                      error = kStatus_USB_InvalidRequest;
   \                     ??USB_DeviceMscEvent_42: (+1)
   \   00000324   0x2005             MOVS     R0,#+5
   \   00000326   0x0007             MOVS     R7,R0
    906                                  }
    907          
    908                                  break;
   \                     ??USB_DeviceMscEvent_43: (+1)
   \   00000328   0xE7FF             B.N      ??USB_DeviceMscEvent_34
    909                              default:
    910                                  break;
    911                          }
    912                      }
    913                      break;
   \                     ??USB_DeviceMscEvent_39: (+1)
   \                     ??USB_DeviceMscEvent_34: (+1)
   \   0000032A   0xE7FF             B.N      ??USB_DeviceMscEvent_10
    914                  default:
    915                      break;
    916              }
    917          
    918              return error;
   \                     ??USB_DeviceMscEvent_4: (+1)
   \                     ??USB_DeviceMscEvent_10: (+1)
   \   0000032C   0x0038             MOVS     R0,R7
   \   0000032E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceMscEvent_2: (+1)
   \   00000330   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    919          }
    920          
    921          /*!
    922           * @brief Send data through a specified endpoint.
    923           *
    924           * The function is used to send data through a specified endpoint.
    925           * The function calls USB_DeviceSendRequest internally.
    926           *
    927           * @param handle The msc class handle got from usb_device_class_config_struct_t::classHandle.
    928           *
    929           * @return A USB error code or kStatus_USB_Success.
    930           *
    931           * @note The return value just means if the sending request is successful or not; the transfer done is notified by
    932           * USB_DeviceMscBulkIn.
    933           * Currently, only one transfer request can be supported for one specific endpoint.
    934           * If there is a specific requirement to support multiple transfer requests for one specific endpoint, the application
    935           * should implement a queue in the application level.
    936           * The subsequent transfer could begin only when the previous transfer is done (get notification through the endpoint
    937           * callback).
    938           */

   \                                 In section .text, align 2, keep-with-next
    939          usb_status_t USB_DeviceMscSend(usb_device_msc_struct_t *mscHandle)
    940          {
   \                     USB_DeviceMscSend: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    941              usb_status_t error = kStatus_USB_Success;
   \   00000004   0x2500             MOVS     R5,#+0
    942              usb_device_lba_app_struct_t lba;
    943          
    944              lba.offset = mscHandle->currentOffset;
   \   00000006   0x6920             LDR      R0,[R4, #+16]
   \   00000008   0x9000             STR      R0,[SP, #+0]
    945              /*bulkInBufferSize is the application buffer size, USB_DEVICE_MSC_MAX_SEND_TRANSFER_LENGTH is the max transfer
    946                 length by the hardware,
    947                  lba.size is the data pending  for transfer ,select the minimum size to transfer ,the remaining will be transfer
    948                 next time*/
    949              lba.size = (mscHandle->bulkInBufferSize > USB_DEVICE_MSC_MAX_SEND_TRANSFER_LENGTH) ?
    950                             USB_DEVICE_MSC_MAX_SEND_TRANSFER_LENGTH :
    951                             mscHandle->bulkInBufferSize;
   \   0000000A   0x6A20             LDR      R0,[R4, #+32]
   \   0000000C   0xF1B0 0x1F01      CMP      R0,#+65537
   \   00000010   0xD302             BCC.N    ??USB_DeviceMscSend_0
   \   00000012   0xF45F 0x3080      MOVS     R0,#+65536
   \   00000016   0xE000             B.N      ??USB_DeviceMscSend_1
   \                     ??USB_DeviceMscSend_0: (+1)
   \   00000018   0x6A20             LDR      R0,[R4, #+32]
   \                     ??USB_DeviceMscSend_1: (+1)
   \   0000001A   0x9001             STR      R0,[SP, #+4]
    952              lba.size =
    953                  (mscHandle->transferRemaining > lba.size) ? lba.size : mscHandle->transferRemaining; /* which one is smaller */
   \   0000001C   0x9801             LDR      R0,[SP, #+4]
   \   0000001E   0x68E1             LDR      R1,[R4, #+12]
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD201             BCS.N    ??USB_DeviceMscSend_2
   \   00000024   0x9801             LDR      R0,[SP, #+4]
   \   00000026   0xE000             B.N      ??USB_DeviceMscSend_3
   \                     ??USB_DeviceMscSend_2: (+1)
   \   00000028   0x68E0             LDR      R0,[R4, #+12]
   \                     ??USB_DeviceMscSend_3: (+1)
   \   0000002A   0x9001             STR      R0,[SP, #+4]
    954          
    955              lba.buffer = NULL;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x9002             STR      R0,[SP, #+8]
    956              mscHandle->configurationStruct->classCallback((class_handle_t)mscHandle, kUSB_DeviceMscEventReadRequest, &lba);
   \   00000030   0x466A             MOV      R2,SP
   \   00000032   0x2104             MOVS     R1,#+4
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x6863             LDR      R3,[R4, #+4]
   \   00000038   0x681B             LDR      R3,[R3, #+0]
   \   0000003A   0x4798             BLX      R3
    957          
    958              if (mscHandle->currentOffset < (mscHandle->totalLogicalBlockNumber * mscHandle->lengthOfEachLba))
   \   0000003C   0x6920             LDR      R0,[R4, #+16]
   \   0000003E   0x6961             LDR      R1,[R4, #+20]
   \   00000040   0x69A2             LDR      R2,[R4, #+24]
   \   00000042   0x4351             MULS     R1,R2,R1
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD208             BCS.N    ??USB_DeviceMscSend_4
    959              {
    960                  error = USB_DeviceSendRequest(mscHandle->handle, mscHandle->bulkInEndpoint, lba.buffer, lba.size);
   \   00000048   0x9B01             LDR      R3,[SP, #+4]
   \   0000004A   0x9A02             LDR      R2,[SP, #+8]
   \   0000004C   0xF894 0x10F9      LDRB     R1,[R4, #+249]
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x.... 0x....      BL       USB_DeviceSendRequest
   \   00000056   0x0005             MOVS     R5,R0
   \   00000058   0xE010             B.N      ??USB_DeviceMscSend_5
    961              }
    962              else
    963              {
    964                  mscHandle->needInStallFlag = 0;
   \                     ??USB_DeviceMscSend_4: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF884 0x00F3      STRB     R0,[R4, #+243]
    965                  mscHandle->inEndpointStallFlag = 1;
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0xF884 0x00EE      STRB     R0,[R4, #+238]
    966                  mscHandle->dataInFlag = 0;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xF884 0x00ED      STRB     R0,[R4, #+237]
    967                  mscHandle->stallStatus = (uint8_t)USB_DEVICE_MSC_STALL_IN_DATA;
   \   0000006C   0x2002             MOVS     R0,#+2
   \   0000006E   0xF884 0x00F7      STRB     R0,[R4, #+247]
    968                  USB_DeviceStallEndpoint(mscHandle->handle, mscHandle->bulkInEndpoint);
   \   00000072   0xF894 0x10F9      LDRB     R1,[R4, #+249]
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x.... 0x....      BL       USB_DeviceStallEndpoint
    969              }
    970              return error;
   \                     ??USB_DeviceMscSend_5: (+1)
   \   0000007C   0x0028             MOVS     R0,R5
   \   0000007E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000080   0xBD3E             POP      {R1-R5,PC}       ;; return
    971          }
    972          
    973          /*!
    974           * @brief Receive data through a specified endpoint.
    975           *
    976           * The function is used to receive data through a specified endpoint.
    977           * The function calls USB_DeviceRecvRequest internally.
    978           *
    979           * @param handle The msc class handle got from usb_device_class_config_struct_t::classHandle.
    980           *
    981           * @return A USB error code or kStatus_USB_Success.
    982           *
    983           * @note The return value just means if the receiving request is successful or not; the transfer done is notified by
    984           * USB_DeviceMscBulkOut.
    985           * Currently, only one transfer request can be supported for one specific endpoint.
    986           * If there is a specific requirement to support multiple transfer requests for one specific endpoint, the application
    987           * should implement a queue in the application level.
    988           * The subsequent transfer could begin only when the previous transfer is done (get notification through the endpoint
    989           * callback).
    990           */

   \                                 In section .text, align 2, keep-with-next
    991          usb_status_t USB_DeviceMscRecv(usb_device_msc_struct_t *mscHandle)
    992          {
   \                     USB_DeviceMscRecv: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    993              usb_status_t error = kStatus_USB_Success;
   \   00000004   0x2500             MOVS     R5,#+0
    994              usb_device_lba_app_struct_t lba;
    995          
    996              lba.offset = mscHandle->currentOffset;
   \   00000006   0x6920             LDR      R0,[R4, #+16]
   \   00000008   0x9000             STR      R0,[SP, #+0]
    997              /*bulkOutBufferSize is the application buffer size, USB_DEVICE_MSC_MAX_RECV_TRANSFER_LENGTH is the max transfer
    998                 length by the hardware,
    999                 lba.size is the data pending  for transfer ,select the minimum size to transfer ,the remaining will be transfer
   1000                 next time*/
   1001              lba.size = (mscHandle->bulkOutBufferSize > USB_DEVICE_MSC_MAX_RECV_TRANSFER_LENGTH) ?
   1002                             USB_DEVICE_MSC_MAX_RECV_TRANSFER_LENGTH :
   1003                             mscHandle->bulkOutBufferSize;
   \   0000000A   0x6A60             LDR      R0,[R4, #+36]
   \   0000000C   0xF1B0 0x1F01      CMP      R0,#+65537
   \   00000010   0xD302             BCC.N    ??USB_DeviceMscRecv_0
   \   00000012   0xF45F 0x3080      MOVS     R0,#+65536
   \   00000016   0xE000             B.N      ??USB_DeviceMscRecv_1
   \                     ??USB_DeviceMscRecv_0: (+1)
   \   00000018   0x6A60             LDR      R0,[R4, #+36]
   \                     ??USB_DeviceMscRecv_1: (+1)
   \   0000001A   0x9001             STR      R0,[SP, #+4]
   1004              lba.size =
   1005                  (mscHandle->transferRemaining > lba.size) ? lba.size : mscHandle->transferRemaining; /* whichever is smaller */
   \   0000001C   0x9801             LDR      R0,[SP, #+4]
   \   0000001E   0x68E1             LDR      R1,[R4, #+12]
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD201             BCS.N    ??USB_DeviceMscRecv_2
   \   00000024   0x9801             LDR      R0,[SP, #+4]
   \   00000026   0xE000             B.N      ??USB_DeviceMscRecv_3
   \                     ??USB_DeviceMscRecv_2: (+1)
   \   00000028   0x68E0             LDR      R0,[R4, #+12]
   \                     ??USB_DeviceMscRecv_3: (+1)
   \   0000002A   0x9001             STR      R0,[SP, #+4]
   1006          
   1007              lba.buffer = NULL;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x9002             STR      R0,[SP, #+8]
   1008              mscHandle->configurationStruct->classCallback((class_handle_t)mscHandle, kUSB_DeviceMscEventWriteRequest, &lba);
   \   00000030   0x466A             MOV      R2,SP
   \   00000032   0x2103             MOVS     R1,#+3
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x6863             LDR      R3,[R4, #+4]
   \   00000038   0x681B             LDR      R3,[R3, #+0]
   \   0000003A   0x4798             BLX      R3
   1009          
   1010              if (mscHandle->currentOffset < (mscHandle->totalLogicalBlockNumber * mscHandle->lengthOfEachLba))
   \   0000003C   0x6920             LDR      R0,[R4, #+16]
   \   0000003E   0x6961             LDR      R1,[R4, #+20]
   \   00000040   0x69A2             LDR      R2,[R4, #+24]
   \   00000042   0x4351             MULS     R1,R2,R1
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD208             BCS.N    ??USB_DeviceMscRecv_4
   1011              {
   1012                  error = USB_DeviceRecvRequest(mscHandle->handle, mscHandle->bulkOutEndpoint, lba.buffer, lba.size);
   \   00000048   0x9B01             LDR      R3,[SP, #+4]
   \   0000004A   0x9A02             LDR      R2,[SP, #+8]
   \   0000004C   0xF894 0x10FA      LDRB     R1,[R4, #+250]
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x.... 0x....      BL       USB_DeviceRecvRequest
   \   00000056   0x0005             MOVS     R5,R0
   \   00000058   0xE010             B.N      ??USB_DeviceMscRecv_5
   1013              }
   1014              else
   1015              {
   1016                  mscHandle->needOutStallFlag = 0;
   \                     ??USB_DeviceMscRecv_4: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF884 0x00F4      STRB     R0,[R4, #+244]
   1017                  mscHandle->outEndpointStallFlag = 1;
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0xF884 0x00EF      STRB     R0,[R4, #+239]
   1018                  mscHandle->dataOutFlag = 0;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xF884 0x00EC      STRB     R0,[R4, #+236]
   1019                  mscHandle->stallStatus = (uint8_t)USB_DEVICE_MSC_STALL_IN_DATA;
   \   0000006C   0x2002             MOVS     R0,#+2
   \   0000006E   0xF884 0x00F7      STRB     R0,[R4, #+247]
   1020                  USB_DeviceStallEndpoint(mscHandle->handle, mscHandle->bulkOutEndpoint);
   \   00000072   0xF894 0x10FA      LDRB     R1,[R4, #+250]
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x.... 0x....      BL       USB_DeviceStallEndpoint
   1021              }
   1022              return error;
   \                     ??USB_DeviceMscRecv_5: (+1)
   \   0000007C   0x0028             MOVS     R0,R5
   \   0000007E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000080   0xBD3E             POP      {R1-R5,PC}       ;; return
   1023          }
   1024          
   1025          /*!
   1026           * @brief Recv Send data through a specified endpoint.
   1027           *
   1028           * The function is used when ufi process read/write command .
   1029           * The function calls USB_DeviceMscRecv or  usb_device_send_recv as the direction internally.
   1030           *
   1031           * @param handle The msc class handle got from usb_device_class_config_struct_t::classHandle.
   1032           * @param direction     Data direction: 0 = Data-Out from host to the device, 1 = Data-In from the device to the host.
   1033           * @param buffer The memory address to hold the data need to be sent.
   1034           * @return A USB error code or kStatus_USB_Success.
   1035           *
   1036           * @note The return value just means if the sending or reciving request is successful or not.
   1037           */

   \                                 In section .text, align 2, keep-with-next
   1038          usb_status_t USB_DeviceMscLbaTransfer(usb_device_msc_struct_t *mscHandle,
   1039                                                uint8_t direction,
   1040                                                usb_lba_transfer_information_struct_t *lba_info_ptr)
   1041          {
   \                     USB_DeviceMscLbaTransfer: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1042              usb_status_t error = kStatus_USB_Success;
   \   00000008   0x2700             MOVS     R7,#+0
   1043          
   1044              mscHandle->transferRemaining = lba_info_ptr->transferNumber * mscHandle->lengthOfEachLba;
   \   0000000A   0x6870             LDR      R0,[R6, #+4]
   \   0000000C   0x69A1             LDR      R1,[R4, #+24]
   \   0000000E   0x4348             MULS     R0,R1,R0
   \   00000010   0x60E0             STR      R0,[R4, #+12]
   1045              mscHandle->currentOffset = lba_info_ptr->startingLogicalBlockAddress * mscHandle->lengthOfEachLba;
   \   00000012   0x6830             LDR      R0,[R6, #+0]
   \   00000014   0x69A1             LDR      R1,[R4, #+24]
   \   00000016   0x4348             MULS     R0,R1,R0
   \   00000018   0x6120             STR      R0,[R4, #+16]
   1046          
   1047              if (direction == USB_IN)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D01             CMP      R5,#+1
   \   0000001E   0xD104             BNE.N    ??USB_DeviceMscLbaTransfer_0
   1048              {
   1049                  error = USB_DeviceMscSend(mscHandle);
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       USB_DeviceMscSend
   \   00000026   0x0007             MOVS     R7,R0
   \   00000028   0xE003             B.N      ??USB_DeviceMscLbaTransfer_1
   1050              }
   1051              else
   1052              {
   1053                  error = USB_DeviceMscRecv(mscHandle);
   \                     ??USB_DeviceMscLbaTransfer_0: (+1)
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       USB_DeviceMscRecv
   \   00000030   0x0007             MOVS     R7,R0
   1054              }
   1055              return error;
   \                     ??USB_DeviceMscLbaTransfer_1: (+1)
   \   00000032   0x0038             MOVS     R0,R7
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1056          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     g_msc_handle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x53425355         DC32     0x53425355

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x43425355         DC32     0x43425355

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     USB_DeviceMscBulkIn

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     USB_DeviceMscBulkOut
   1057          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   USB_DeviceMscAllocateHandle
      56   USB_DeviceMscBulkIn
        56   -- Indirect call
        56   -> USB_DeviceMscSend
        56   -> USB_DeviceRecvRequest
        56   -> USB_DeviceSendRequest
        56   -> USB_DeviceStallEndpoint
      48   USB_DeviceMscBulkOut
        48   -- Indirect call
        48   -> USB_DeviceMscProcessUfiCommand
        48   -> USB_DeviceMscRecv
        48   -> USB_DeviceSendRequest
        48   -> USB_DeviceStallEndpoint
      16   USB_DeviceMscDeinit
        16   -> USB_DeviceMscEndpointsDeinit
        16   -> USB_DeviceMscFreeHandle
      16   USB_DeviceMscEndpointsDeinit
        16   -> USB_DeviceDeinitEndpoint
      40   USB_DeviceMscEndpointsInit
        40   -> USB_DeviceCancel
        40   -> USB_DeviceInitEndpoint
        40   -> USB_DeviceRecvRequest
      40   USB_DeviceMscEvent
        40   -> USB_DeviceCancel
        40   -> USB_DeviceMscEndpointsDeinit
        40   -> USB_DeviceMscEndpointsInit
        40   -> USB_DeviceRecvRequest
        40   -> USB_DeviceSendRequest
        40   -> USB_DeviceStallEndpoint
        40   -> USB_DeviceUnstallEndpoint
       0   USB_DeviceMscFreeHandle
      56   USB_DeviceMscInit
        56   -- Indirect call
        56   -> USB_DeviceClassGetDeviceHandle
        56   -> USB_DeviceMscAllocateHandle
        56   -> USB_DeviceMscFreeHandle
      24   USB_DeviceMscLbaTransfer
        24   -> USB_DeviceMscRecv
        24   -> USB_DeviceMscSend
      16   USB_DeviceMscProcessUfiCommand
        16   -> USB_DeviceMscUfiFormatUnitCommand
        16   -> USB_DeviceMscUfiInquiryCommand
        16   -> USB_DeviceMscUfiModeSelectCommand
        16   -> USB_DeviceMscUfiModeSenseCommand
        16   -> USB_DeviceMscUfiPreventAllowMediumCommand
        16   -> USB_DeviceMscUfiReadCapacityCommand
        16   -> USB_DeviceMscUfiReadCommand
        16   -> USB_DeviceMscUfiReadFormatCapacityCommand
        16   -> USB_DeviceMscUfiRequestSenseCommand
        16   -> USB_DeviceMscUfiSendDiagnosticCommand
        16   -> USB_DeviceMscUfiStartStopUnitCommand
        16   -> USB_DeviceMscUfiTestUnitReadyCommand
        16   -> USB_DeviceMscUfiUnsupportCommand
        16   -> USB_DeviceMscUfiVerifyCommand
        16   -> USB_DeviceMscUfiWriteCommand
      24   USB_DeviceMscRecv
        24   -- Indirect call
        24   -> USB_DeviceRecvRequest
        24   -> USB_DeviceStallEndpoint
      24   USB_DeviceMscSend
        24   -- Indirect call
        24   -> USB_DeviceSendRequest
        24   -> USB_DeviceStallEndpoint


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
      56  USB_DeviceMscAllocateHandle
     328  USB_DeviceMscBulkIn
     646  USB_DeviceMscBulkOut
      36  USB_DeviceMscDeinit
      54  USB_DeviceMscEndpointsDeinit
     404  USB_DeviceMscEndpointsInit
     820  USB_DeviceMscEvent
      26  USB_DeviceMscFreeHandle
     474  USB_DeviceMscInit
      56  USB_DeviceMscLbaTransfer
     314  USB_DeviceMscProcessUfiCommand
     130  USB_DeviceMscRecv
     130  USB_DeviceMscSend
     256  g_msc_handle

 
 3 494 bytes in section .text
   256 bytes in section m_usb_global
 
 3 494 bytes of CODE memory
   256 bytes of DATA memory

Errors: none
Warnings: none
