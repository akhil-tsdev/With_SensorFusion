###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:14
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_hid.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_hid.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\usb_device_hid.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\usb_device_hid.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_hid.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "usb_device_config.h"
     32          #include "usb.h"
     33          #include "usb_device.h"
     34          
     35          #include "usb_device_class.h"
     36          
     37          #if ((defined(USB_DEVICE_CONFIG_HID)) && (USB_DEVICE_CONFIG_HID > 0U))
     38          #include "usb_device_hid.h"
     39          
     40          /*******************************************************************************
     41           * Definitions
     42           ******************************************************************************/
     43          
     44          /*******************************************************************************
     45           * Prototypes
     46           ******************************************************************************/
     47          
     48          static usb_status_t USB_DeviceHidAllocateHandle(usb_device_hid_struct_t **handle);
     49          static usb_status_t USB_DeviceHidFreeHandle(usb_device_hid_struct_t *handle);
     50          static usb_status_t USB_DeviceHidInterruptIn(usb_device_handle handle,
     51                                                       usb_device_endpoint_callback_message_struct_t *message,
     52                                                       void *callbackParam);
     53          static usb_status_t USB_DeviceHidInterruptOut(usb_device_handle handle,
     54                                                        usb_device_endpoint_callback_message_struct_t *message,
     55                                                        void *callbackParam);
     56          static usb_status_t USB_DeviceHidEndpointsInit(usb_device_hid_struct_t *hidHandle);
     57          static usb_status_t USB_DeviceHidEndpointsDeinit(usb_device_hid_struct_t *hidHandle);
     58          
     59          /*******************************************************************************
     60           * Variables
     61           ******************************************************************************/
     62          

   \                                 In section m_usb_global, align 4
     63          USB_GLOBAL static usb_device_hid_struct_t s_UsbDeviceHidHandle[USB_DEVICE_CONFIG_HID];
   \                     s_UsbDeviceHidHandle:
   \   00000000                      DS8 20
     64          
     65          /*******************************************************************************
     66           * Code
     67           ******************************************************************************/
     68          
     69          /*!
     70           * @brief Allocate a device hid class handle.
     71           *
     72           * This function allocates a device hid class handle.
     73           *
     74           * @param handle          It is out parameter, is used to return pointer of the device hid class handle to the caller.
     75           *
     76           * @retval kStatus_USB_Success              Get a device hid class handle successfully.
     77           * @retval kStatus_USB_Busy                 Cannot allocate a device hid class handle.
     78           */

   \                                 In section .text, align 2, keep-with-next
     79          static usb_status_t USB_DeviceHidAllocateHandle(usb_device_hid_struct_t **handle)
     80          {
   \                     USB_DeviceHidAllocateHandle: (+1)
   \   00000000   0x0001             MOVS     R1,R0
     81              int32_t count;
     82              for (count = 0U; count < USB_DEVICE_CONFIG_HID; count++)
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x0002             MOVS     R2,R0
   \                     ??USB_DeviceHidAllocateHandle_0: (+1)
   \   00000006   0x2A01             CMP      R2,#+1
   \   00000008   0xDA10             BGE.N    ??USB_DeviceHidAllocateHandle_1
     83              {
     84                  if (NULL == s_UsbDeviceHidHandle[count].handle)
   \   0000000A   0x....             LDR.N    R0,??DataTable1
   \   0000000C   0x2314             MOVS     R3,#+20
   \   0000000E   0xFB03 0xF302      MUL      R3,R3,R2
   \   00000012   0x58C0             LDR      R0,[R0, R3]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD107             BNE.N    ??USB_DeviceHidAllocateHandle_2
     85                  {
     86                      *handle = &s_UsbDeviceHidHandle[count];
   \   00000018   0x....             LDR.N    R0,??DataTable1
   \   0000001A   0x2314             MOVS     R3,#+20
   \   0000001C   0xFB03 0xF302      MUL      R3,R3,R2
   \   00000020   0x4418             ADD      R0,R0,R3
   \   00000022   0x6008             STR      R0,[R1, #+0]
     87                      return kStatus_USB_Success;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE002             B.N      ??USB_DeviceHidAllocateHandle_3
     88                  }
     89              }
   \                     ??USB_DeviceHidAllocateHandle_2: (+1)
   \   00000028   0x1C52             ADDS     R2,R2,#+1
   \   0000002A   0xE7EC             B.N      ??USB_DeviceHidAllocateHandle_0
     90          
     91              return kStatus_USB_Busy;
   \                     ??USB_DeviceHidAllocateHandle_1: (+1)
   \   0000002C   0x2002             MOVS     R0,#+2
   \                     ??USB_DeviceHidAllocateHandle_3: (+1)
   \   0000002E   0x4770             BX       LR               ;; return
     92          }
     93          
     94          /*!
     95           * @brief Free a device hid class hanlde.
     96           *
     97           * This function frees a device hid class hanlde.
     98           *
     99           * @param handle          The device hid class hanlde.
    100           *
    101           * @retval kStatus_USB_Success              Free device hid class hanlde successfully.
    102           */

   \                                 In section .text, align 2, keep-with-next
    103          static usb_status_t USB_DeviceHidFreeHandle(usb_device_hid_struct_t *handle)
    104          {
   \                     USB_DeviceHidFreeHandle: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    105              handle->handle = NULL;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x6008             STR      R0,[R1, #+0]
    106              handle->configStruct = (usb_device_class_config_struct_t *)NULL;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x6048             STR      R0,[R1, #+4]
    107              handle->configuration = 0U;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x7308             STRB     R0,[R1, #+12]
    108              handle->alternate = 0U;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x7388             STRB     R0,[R1, #+14]
    109              return kStatus_USB_Success;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4770             BX       LR               ;; return
    110          }
    111          
    112          /*!
    113           * @brief Interrupt IN endpoint callback function.
    114           *
    115           * This callback function is used to notify uplayer the tranfser result of a transfer.
    116           * This callback pointer is passed when the interrupt IN pipe initialized.
    117           *
    118           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    119           * @param message         The result of the interrupt IN pipe transfer.
    120           * @param callbackParam  The paramter for this callback. It is same with
    121           * usb_device_endpoint_callback_struct_t::callbackParam. In the class, the value is the HID class handle.
    122           *
    123           * @return A USB error code or kStatus_USB_Success.
    124           */

   \                                 In section .text, align 2, keep-with-next
    125          static usb_status_t USB_DeviceHidInterruptIn(usb_device_handle handle,
    126                                                       usb_device_endpoint_callback_message_struct_t *message,
    127                                                       void *callbackParam)
    128          {
   \                     USB_DeviceHidInterruptIn: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    129              usb_device_hid_struct_t *hidHandle;
    130              usb_status_t error = kStatus_USB_Error;
   \   0000000A   0xF05F 0x0801      MOVS     R8,#+1
    131          
    132              /* Get the HID class handle */
    133              hidHandle = (usb_device_hid_struct_t *)callbackParam;
   \   0000000E   0x0037             MOVS     R7,R6
    134          
    135              if (!hidHandle)
   \   00000010   0x2F00             CMP      R7,#+0
   \   00000012   0xD101             BNE.N    ??USB_DeviceHidInterruptIn_0
    136              {
    137                  return kStatus_USB_InvalidHandle;
   \   00000014   0x2003             MOVS     R0,#+3
   \   00000016   0xE011             B.N      ??USB_DeviceHidInterruptIn_1
    138              }
    139              hidHandle->interruptInPipeBusy = 0U;
   \                     ??USB_DeviceHidInterruptIn_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x7478             STRB     R0,[R7, #+17]
    140              if ((NULL != hidHandle->configStruct) && (hidHandle->configStruct->classCallback))
   \   0000001C   0x6878             LDR      R0,[R7, #+4]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD00A             BEQ.N    ??USB_DeviceHidInterruptIn_2
   \   00000022   0x6878             LDR      R0,[R7, #+4]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD006             BEQ.N    ??USB_DeviceHidInterruptIn_2
    141              {
    142                  /* Notify the application data sent by calling the hid class callback. */
    143                  error =
    144                      hidHandle->configStruct->classCallback((class_handle_t)hidHandle, kUSB_DeviceHidEventSendResponse, message);
   \   0000002A   0x002A             MOVS     R2,R5
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x0038             MOVS     R0,R7
   \   00000030   0x687B             LDR      R3,[R7, #+4]
   \   00000032   0x681B             LDR      R3,[R3, #+0]
   \   00000034   0x4798             BLX      R3
   \   00000036   0x4680             MOV      R8,R0
    145              }
    146          
    147              return error;
   \                     ??USB_DeviceHidInterruptIn_2: (+1)
   \   00000038   0x4640             MOV      R0,R8
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceHidInterruptIn_1: (+1)
   \   0000003C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    148          }
    149          
    150          /*!
    151           * @brief Interrupt OUT endpoint callback function.
    152           *
    153           * This callback function is used to notify uplayer the tranfser result of a transfer.
    154           * This callback pointer is passed when the interrupt OUT pipe initialized.
    155           *
    156           * @param handle          The device handle. It equals the value returned from USB_DeviceInit.
    157           * @param message         The result of the interrupt OUT pipe transfer.
    158           * @param callbackParam  The paramter for this callback. It is same with
    159           * usb_device_endpoint_callback_struct_t::callbackParam. In the class, the value is the HID class handle.
    160           *
    161           * @return A USB error code or kStatus_USB_Success.
    162           */

   \                                 In section .text, align 2, keep-with-next
    163          static usb_status_t USB_DeviceHidInterruptOut(usb_device_handle handle,
    164                                                        usb_device_endpoint_callback_message_struct_t *message,
    165                                                        void *callbackParam)
    166          {
   \                     USB_DeviceHidInterruptOut: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    167              usb_device_hid_struct_t *hidHandle;
    168              usb_status_t error = kStatus_USB_Error;
   \   0000000A   0xF05F 0x0801      MOVS     R8,#+1
    169          
    170              /* Get the HID class handle */
    171              hidHandle = (usb_device_hid_struct_t *)callbackParam;
   \   0000000E   0x0037             MOVS     R7,R6
    172          
    173              if (!hidHandle)
   \   00000010   0x2F00             CMP      R7,#+0
   \   00000012   0xD101             BNE.N    ??USB_DeviceHidInterruptOut_0
    174              {
    175                  return kStatus_USB_InvalidHandle;
   \   00000014   0x2003             MOVS     R0,#+3
   \   00000016   0xE011             B.N      ??USB_DeviceHidInterruptOut_1
    176              }
    177              hidHandle->interruptOutPipeBusy = 0U;
   \                     ??USB_DeviceHidInterruptOut_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x74B8             STRB     R0,[R7, #+18]
    178              if ((NULL != hidHandle->configStruct) && (hidHandle->configStruct->classCallback))
   \   0000001C   0x6878             LDR      R0,[R7, #+4]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD00A             BEQ.N    ??USB_DeviceHidInterruptOut_2
   \   00000022   0x6878             LDR      R0,[R7, #+4]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD006             BEQ.N    ??USB_DeviceHidInterruptOut_2
    179              {
    180                  /* Notify the application data received by calling the hid class callback. */
    181                  error =
    182                      hidHandle->configStruct->classCallback((class_handle_t)hidHandle, kUSB_DeviceHidEventRecvResponse, message);
   \   0000002A   0x002A             MOVS     R2,R5
   \   0000002C   0x2102             MOVS     R1,#+2
   \   0000002E   0x0038             MOVS     R0,R7
   \   00000030   0x687B             LDR      R3,[R7, #+4]
   \   00000032   0x681B             LDR      R3,[R3, #+0]
   \   00000034   0x4798             BLX      R3
   \   00000036   0x4680             MOV      R8,R0
    183              }
    184          
    185              return error;
   \                     ??USB_DeviceHidInterruptOut_2: (+1)
   \   00000038   0x4640             MOV      R0,R8
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceHidInterruptOut_1: (+1)
   \   0000003C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    186          }
    187          
    188          /*!
    189           * @brief Initialize the endpoints of the hid class.
    190           *
    191           * This callback function is used to initialize the endpoints of the hid class.
    192           *
    193           * @param hidHandle          The device hid class handle. It equals the value returned from
    194           * usb_device_class_config_struct_t::classHandle.
    195           *
    196           * @return A USB error code or kStatus_USB_Success.
    197           */

   \                                 In section .text, align 2, keep-with-next
    198          static usb_status_t USB_DeviceHidEndpointsInit(usb_device_hid_struct_t *hidHandle)
    199          {
   \                     USB_DeviceHidEndpointsInit: (+1)
   \   00000000   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    200              usb_device_interface_list_t *interfaceList;
    201              usb_device_interface_struct_t *interface = (usb_device_interface_struct_t *)NULL;
   \   00000006   0x2600             MOVS     R6,#+0
    202              usb_status_t error = kStatus_USB_Error;
   \   00000008   0x2701             MOVS     R7,#+1
    203          
    204              /* Check the configuration is valid or not. */
    205              if (hidHandle->configuration > hidHandle->configStruct->classInfomation->configurations)
   \   0000000A   0x6860             LDR      R0,[R4, #+4]
   \   0000000C   0x6880             LDR      R0,[R0, #+8]
   \   0000000E   0x7940             LDRB     R0,[R0, #+5]
   \   00000010   0x7B21             LDRB     R1,[R4, #+12]
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD202             BCS.N    ??USB_DeviceHidEndpointsInit_0
    206              {
    207                  return error;
   \   00000016   0x0038             MOVS     R0,R7
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xE078             B.N      ??USB_DeviceHidEndpointsInit_1
    208              }
    209          
    210              /* Get the interface list of the new configuration. */
    211              if (NULL == hidHandle->configStruct->classInfomation->interfaceList)
   \                     ??USB_DeviceHidEndpointsInit_0: (+1)
   \   0000001C   0x6860             LDR      R0,[R4, #+4]
   \   0000001E   0x6880             LDR      R0,[R0, #+8]
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD102             BNE.N    ??USB_DeviceHidEndpointsInit_2
    212              {
    213                  return error;
   \   00000026   0x0038             MOVS     R0,R7
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0xE070             B.N      ??USB_DeviceHidEndpointsInit_1
    214              }
    215              interfaceList = &hidHandle->configStruct->classInfomation->interfaceList[hidHandle->configuration - 1U];
   \                     ??USB_DeviceHidEndpointsInit_2: (+1)
   \   0000002C   0x6860             LDR      R0,[R4, #+4]
   \   0000002E   0x6880             LDR      R0,[R0, #+8]
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x7B21             LDRB     R1,[R4, #+12]
   \   00000034   0xEB00 0x00C1      ADD      R0,R0,R1, LSL #+3
   \   00000038   0x3808             SUBS     R0,R0,#+8
   \   0000003A   0x0005             MOVS     R5,R0
    216          
    217              /* Find interface by using the alternate setting of the interface. */
    218              for (int count = 0U; count < interfaceList->count; count++)
   \   0000003C   0x2000             MOVS     R0,#+0
   \                     ??USB_DeviceHidEndpointsInit_3: (+1)
   \   0000003E   0x7829             LDRB     R1,[R5, #+0]
   \   00000040   0x4288             CMP      R0,R1
   \   00000042   0xDA2F             BGE.N    ??USB_DeviceHidEndpointsInit_4
    219              {
    220                  if (USB_DEVICE_CONFIG_HID_CLASS_CODE == interfaceList->interfaces[count].classCode)
   \   00000044   0x6869             LDR      R1,[R5, #+4]
   \   00000046   0x220C             MOVS     R2,#+12
   \   00000048   0xFB02 0xF200      MUL      R2,R2,R0
   \   0000004C   0x5C89             LDRB     R1,[R1, R2]
   \   0000004E   0x2903             CMP      R1,#+3
   \   00000050   0xD126             BNE.N    ??USB_DeviceHidEndpointsInit_5
    221                  {
    222                      for (int index = 0U; index < interfaceList->interfaces[count].count; index++)
   \   00000052   0x2100             MOVS     R1,#+0
   \                     ??USB_DeviceHidEndpointsInit_6: (+1)
   \   00000054   0x686A             LDR      R2,[R5, #+4]
   \   00000056   0x230C             MOVS     R3,#+12
   \   00000058   0xFB03 0xF300      MUL      R3,R3,R0
   \   0000005C   0x441A             ADD      R2,R2,R3
   \   0000005E   0x7A12             LDRB     R2,[R2, #+8]
   \   00000060   0x4291             CMP      R1,R2
   \   00000062   0xDA16             BGE.N    ??USB_DeviceHidEndpointsInit_7
    223                      {
    224                          if (interfaceList->interfaces[count].interface[index].alternateSetting == hidHandle->alternate)
   \   00000064   0x686A             LDR      R2,[R5, #+4]
   \   00000066   0x230C             MOVS     R3,#+12
   \   00000068   0xFB03 0xF300      MUL      R3,R3,R0
   \   0000006C   0x441A             ADD      R2,R2,R3
   \   0000006E   0x6852             LDR      R2,[R2, #+4]
   \   00000070   0x010B             LSLS     R3,R1,#+4
   \   00000072   0x5CD2             LDRB     R2,[R2, R3]
   \   00000074   0x7BA3             LDRB     R3,[R4, #+14]
   \   00000076   0x429A             CMP      R2,R3
   \   00000078   0xD109             BNE.N    ??USB_DeviceHidEndpointsInit_8
    225                          {
    226                              interface = &interfaceList->interfaces[count].interface[index];
   \   0000007A   0x686A             LDR      R2,[R5, #+4]
   \   0000007C   0x230C             MOVS     R3,#+12
   \   0000007E   0xFB03 0xF300      MUL      R3,R3,R0
   \   00000082   0x441A             ADD      R2,R2,R3
   \   00000084   0x6852             LDR      R2,[R2, #+4]
   \   00000086   0x0109             LSLS     R1,R1,#+4
   \   00000088   0x4411             ADD      R1,R2,R1
   \   0000008A   0x000E             MOVS     R6,R1
    227                              break;
   \   0000008C   0xE001             B.N      ??USB_DeviceHidEndpointsInit_7
    228                          }
    229                      }
   \                     ??USB_DeviceHidEndpointsInit_8: (+1)
   \   0000008E   0x1C49             ADDS     R1,R1,#+1
   \   00000090   0xE7E0             B.N      ??USB_DeviceHidEndpointsInit_6
    230                      hidHandle->interfaceNumber = interfaceList->interfaces[count].interfaceNumber;
   \                     ??USB_DeviceHidEndpointsInit_7: (+1)
   \   00000092   0x6869             LDR      R1,[R5, #+4]
   \   00000094   0x220C             MOVS     R2,#+12
   \   00000096   0x4350             MULS     R0,R2,R0
   \   00000098   0x4408             ADD      R0,R1,R0
   \   0000009A   0x78C0             LDRB     R0,[R0, #+3]
   \   0000009C   0x7360             STRB     R0,[R4, #+13]
    231                      break;
   \   0000009E   0xE001             B.N      ??USB_DeviceHidEndpointsInit_4
    232                  }
    233              }
   \                     ??USB_DeviceHidEndpointsInit_5: (+1)
   \   000000A0   0x1C40             ADDS     R0,R0,#+1
   \   000000A2   0xE7CC             B.N      ??USB_DeviceHidEndpointsInit_3
    234              if (!interface)
   \                     ??USB_DeviceHidEndpointsInit_4: (+1)
   \   000000A4   0x2E00             CMP      R6,#+0
   \   000000A6   0xD102             BNE.N    ??USB_DeviceHidEndpointsInit_9
    235              {
    236                  /* Return error if the interface is not found. */
    237                  return error;
   \   000000A8   0x0038             MOVS     R0,R7
   \   000000AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AC   0xE02F             B.N      ??USB_DeviceHidEndpointsInit_1
    238              }
    239          
    240              /* Keep new interface handle. */
    241              hidHandle->interfaceHandle = interface;
   \                     ??USB_DeviceHidEndpointsInit_9: (+1)
   \   000000AE   0x60A6             STR      R6,[R4, #+8]
    242          
    243              /* Initialize the endpoints of the new interface. */
    244              for (int count = 0U; count < interface->endpointList.count; count++)
   \   000000B0   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??USB_DeviceHidEndpointsInit_10: (+1)
   \   000000B4   0x7930             LDRB     R0,[R6, #+4]
   \   000000B6   0x4580             CMP      R8,R0
   \   000000B8   0xDA27             BGE.N    ??USB_DeviceHidEndpointsInit_11
    245              {
    246                  usb_device_endpoint_init_struct_t epInitStruct;
    247                  usb_device_endpoint_callback_struct_t ep_callback;
    248                  epInitStruct.zlt = 0U;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xF88D 0x0004      STRB     R0,[SP, #+4]
    249                  epInitStruct.endpointAddress = interface->endpointList.endpoint[count].endpointAddress;
   \   000000C0   0x68B0             LDR      R0,[R6, #+8]
   \   000000C2   0xF810 0x0028      LDRB     R0,[R0, R8, LSL #+2]
   \   000000C6   0xF88D 0x0002      STRB     R0,[SP, #+2]
    250                  epInitStruct.maxPacketSize = interface->endpointList.endpoint[count].maxPacketSize;
   \   000000CA   0x68B0             LDR      R0,[R6, #+8]
   \   000000CC   0xEB00 0x0088      ADD      R0,R0,R8, LSL #+2
   \   000000D0   0x8840             LDRH     R0,[R0, #+2]
   \   000000D2   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    251                  epInitStruct.transferType = interface->endpointList.endpoint[count].transferType;
   \   000000D6   0x68B0             LDR      R0,[R6, #+8]
   \   000000D8   0xEB00 0x0088      ADD      R0,R0,R8, LSL #+2
   \   000000DC   0x7840             LDRB     R0,[R0, #+1]
   \   000000DE   0xF88D 0x0003      STRB     R0,[SP, #+3]
    252          
    253                  if (USB_IN == ((epInitStruct.endpointAddress & USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_MASK) >>
    254                                 USB_DESCRIPTOR_ENDPOINT_ADDRESS_DIRECTION_SHIFT))
   \   000000E2   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   000000E6   0x09C0             LSRS     R0,R0,#+7
   \   000000E8   0x2801             CMP      R0,#+1
   \   000000EA   0xD102             BNE.N    ??USB_DeviceHidEndpointsInit_12
    255                  {
    256                      ep_callback.callbackFn = USB_DeviceHidInterruptIn;
   \   000000EC   0x....             LDR.N    R0,??DataTable1_1
   \   000000EE   0x9002             STR      R0,[SP, #+8]
   \   000000F0   0xE001             B.N      ??USB_DeviceHidEndpointsInit_13
    257                  }
    258                  else
    259                  {
    260                      ep_callback.callbackFn = USB_DeviceHidInterruptOut;
   \                     ??USB_DeviceHidEndpointsInit_12: (+1)
   \   000000F2   0x....             LDR.N    R0,??DataTable1_2
   \   000000F4   0x9002             STR      R0,[SP, #+8]
    261                  }
    262                  ep_callback.callbackParam = hidHandle;
   \                     ??USB_DeviceHidEndpointsInit_13: (+1)
   \   000000F6   0x9403             STR      R4,[SP, #+12]
    263          
    264                  error = USB_DeviceInitEndpoint(hidHandle->handle, &epInitStruct, &ep_callback);
   \   000000F8   0xAA02             ADD      R2,SP,#+8
   \   000000FA   0x4669             MOV      R1,SP
   \   000000FC   0x6820             LDR      R0,[R4, #+0]
   \   000000FE   0x.... 0x....      BL       USB_DeviceInitEndpoint
   \   00000102   0x0007             MOVS     R7,R0
    265              }
   \   00000104   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000108   0xE7D4             B.N      ??USB_DeviceHidEndpointsInit_10
    266              return error;
   \                     ??USB_DeviceHidEndpointsInit_11: (+1)
   \   0000010A   0x0038             MOVS     R0,R7
   \   0000010C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceHidEndpointsInit_1: (+1)
   \   0000010E   0xB004             ADD      SP,SP,#+16
   \   00000110   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    267          }
    268          
    269          /*!
    270           * @brief De-initialize the endpoints of the hid class.
    271           *
    272           * This callback function is used to de-initialize the endpoints of the hid class.
    273           *
    274           * @param hidHandle          The device hid class handle. It equals the value returned from
    275           * usb_device_class_config_struct_t::classHandle.
    276           *
    277           * @return A USB error code or kStatus_USB_Success.
    278           */

   \                                 In section .text, align 2, keep-with-next
    279          static usb_status_t USB_DeviceHidEndpointsDeinit(usb_device_hid_struct_t *hidHandle)
    280          {
   \                     USB_DeviceHidEndpointsDeinit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    281              usb_status_t error = kStatus_USB_Error;
   \   00000004   0x2501             MOVS     R5,#+1
    282          
    283              if (!hidHandle->interfaceHandle)
   \   00000006   0x68A0             LDR      R0,[R4, #+8]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD102             BNE.N    ??USB_DeviceHidEndpointsDeinit_0
    284              {
    285                  return error;
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xE010             B.N      ??USB_DeviceHidEndpointsDeinit_1
    286              }
    287              /* De-initialize all endpoints of the interface */
    288              for (int count = 0U; count < hidHandle->interfaceHandle->endpointList.count; count++)
   \                     ??USB_DeviceHidEndpointsDeinit_0: (+1)
   \   00000012   0x2600             MOVS     R6,#+0
   \                     ??USB_DeviceHidEndpointsDeinit_2: (+1)
   \   00000014   0x68A0             LDR      R0,[R4, #+8]
   \   00000016   0x7900             LDRB     R0,[R0, #+4]
   \   00000018   0x4286             CMP      R6,R0
   \   0000001A   0xDA09             BGE.N    ??USB_DeviceHidEndpointsDeinit_3
    289              {
    290                  error = USB_DeviceDeinitEndpoint(hidHandle->handle,
    291                                                   hidHandle->interfaceHandle->endpointList.endpoint[count].endpointAddress);
   \   0000001C   0x68A0             LDR      R0,[R4, #+8]
   \   0000001E   0x6880             LDR      R0,[R0, #+8]
   \   00000020   0xF810 0x1026      LDRB     R1,[R0, R6, LSL #+2]
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x.... 0x....      BL       USB_DeviceDeinitEndpoint
   \   0000002A   0x0005             MOVS     R5,R0
    292              }
   \   0000002C   0x1C76             ADDS     R6,R6,#+1
   \   0000002E   0xE7F1             B.N      ??USB_DeviceHidEndpointsDeinit_2
    293              return error;
   \                     ??USB_DeviceHidEndpointsDeinit_3: (+1)
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceHidEndpointsDeinit_1: (+1)
   \   00000034   0xBD70             POP      {R4-R6,PC}       ;; return
    294          }
    295          
    296          /*!
    297           * @brief Handle the event passed to the hid class.
    298           *
    299           * This function handles the event passed to the hid class.
    300           *
    301           * @param handle          The hid class handle, got from the usb_device_class_config_struct_t::classHandle.
    302           * @param event           The event codes. Please refer to the enumeration usb_device_class_event_t.
    303           * @param param           The param type is determined by the event code.
    304           *
    305           * @return A USB error code or kStatus_USB_Success.
    306           * @retval kStatus_USB_Success              Free device handle successfully.
    307           * @retval kStatus_USB_InvalidParameter     The device handle not be found.
    308           * @retval kStatus_USB_InvalidRequest       The request is invalid, and the control pipe will be stalled by the caller.
    309           */

   \                                 In section .text, align 2, keep-with-next
    310          usb_status_t USB_DeviceHidEvent(void *handle, uint32_t event, void *param)
    311          {
   \                     USB_DeviceHidEvent: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    312              usb_device_hid_struct_t *hidHandle;
    313              usb_device_hid_report_struct_t report;
    314              usb_status_t error = kStatus_USB_Error;
   \   0000000C   0xF05F 0x0801      MOVS     R8,#+1
    315              uint16_t interfaceAlternate;
    316              uint8_t *temp8;
    317              uint8_t alternate;
    318          
    319              if ((!param) || (!handle))
   \   00000010   0x2E00             CMP      R6,#+0
   \   00000012   0xD001             BEQ.N    ??USB_DeviceHidEvent_0
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD101             BNE.N    ??USB_DeviceHidEvent_1
    320              {
    321                  return kStatus_USB_InvalidHandle;
   \                     ??USB_DeviceHidEvent_0: (+1)
   \   00000018   0x2003             MOVS     R0,#+3
   \   0000001A   0xE13B             B.N      ??USB_DeviceHidEvent_2
    322              }
    323          
    324              /* Get the hid class handle. */
    325              hidHandle = (usb_device_hid_struct_t *)handle;
   \                     ??USB_DeviceHidEvent_1: (+1)
   \   0000001C   0x0027             MOVS     R7,R4
    326          
    327              switch (event)
   \   0000001E   0x2D01             CMP      R5,#+1
   \   00000020   0xF000 0x8091      BEQ.W    ??USB_DeviceHidEvent_3
   \   00000024   0xF0C0 0x8134      BCC.W    ??USB_DeviceHidEvent_4
   \   00000028   0x2D03             CMP      R5,#+3
   \   0000002A   0xD00D             BEQ.N    ??USB_DeviceHidEvent_5
   \   0000002C   0xD305             BCC.N    ??USB_DeviceHidEvent_6
   \   0000002E   0x2D05             CMP      R5,#+5
   \   00000030   0xD049             BEQ.N    ??USB_DeviceHidEvent_7
   \   00000032   0xD325             BCC.N    ??USB_DeviceHidEvent_8
   \   00000034   0x2D06             CMP      R5,#+6
   \   00000036   0xD066             BEQ.N    ??USB_DeviceHidEvent_9
   \   00000038   0xE12A             B.N      ??USB_DeviceHidEvent_4
    328              {
    329                  case kUSB_DeviceClassEventDeviceReset:
    330                      /* Bus reset, clear the configuration. */
    331                      hidHandle->configuration = 0U;
   \                     ??USB_DeviceHidEvent_6: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x7338             STRB     R0,[R7, #+12]
    332                      hidHandle->interruptInPipeBusy = 0U;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7478             STRB     R0,[R7, #+17]
    333                      hidHandle->interruptOutPipeBusy = 0U;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x74B8             STRB     R0,[R7, #+18]
    334                      break;
   \   00000046   0xE123             B.N      ??USB_DeviceHidEvent_10
    335                  case kUSB_DeviceClassEventSetConfiguration:
    336                      /* Get the new configuration. */
    337                      temp8 = ((uint8_t *)param);
   \                     ??USB_DeviceHidEvent_5: (+1)
   \   00000048   0x46B2             MOV      R10,R6
    338                      if (!hidHandle->configStruct)
   \   0000004A   0x6878             LDR      R0,[R7, #+4]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xF000 0x811F      BEQ.W    ??USB_DeviceHidEvent_10
    339                      {
    340                          break;
    341                      }
    342                      if (*temp8 == hidHandle->configuration)
   \                     ??USB_DeviceHidEvent_11: (+1)
   \   00000052   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   00000056   0x7B39             LDRB     R1,[R7, #+12]
   \   00000058   0x4288             CMP      R0,R1
   \   0000005A   0xF000 0x8119      BEQ.W    ??USB_DeviceHidEvent_10
    343                      {
    344                          break;
    345                      }
    346          
    347                      /* De-initialize the endpoints when current configuration is none zero. */
    348                      if (hidHandle->configuration)
   \                     ??USB_DeviceHidEvent_12: (+1)
   \   0000005E   0x7B38             LDRB     R0,[R7, #+12]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD003             BEQ.N    ??USB_DeviceHidEvent_13
    349                      {
    350                          error = USB_DeviceHidEndpointsDeinit(hidHandle);
   \   00000064   0x0038             MOVS     R0,R7
   \   00000066   0x.... 0x....      BL       USB_DeviceHidEndpointsDeinit
   \   0000006A   0x4680             MOV      R8,R0
    351                      }
    352                      /* Save new configuration. */
    353                      hidHandle->configuration = *temp8;
   \                     ??USB_DeviceHidEvent_13: (+1)
   \   0000006C   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   00000070   0x7338             STRB     R0,[R7, #+12]
    354                      /* Clear the alternate setting value. */
    355                      hidHandle->alternate = 0U;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x73B8             STRB     R0,[R7, #+14]
    356          
    357                      /* Initialize the endpoints of the new current configuration by using the alternate setting 0. */
    358                      error = USB_DeviceHidEndpointsInit(hidHandle);
   \   00000076   0x0038             MOVS     R0,R7
   \   00000078   0x.... 0x....      BL       USB_DeviceHidEndpointsInit
   \   0000007C   0x4680             MOV      R8,R0
    359                      break;
   \   0000007E   0xE107             B.N      ??USB_DeviceHidEvent_10
    360                  case kUSB_DeviceClassEventSetInterface:
    361                      if (!hidHandle->configStruct)
   \                     ??USB_DeviceHidEvent_8: (+1)
   \   00000080   0x6878             LDR      R0,[R7, #+4]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xF000 0x8104      BEQ.W    ??USB_DeviceHidEvent_10
    362                      {
    363                          break;
    364                      }
    365                      /* Get the new alternate setting of the interface */
    366                      interfaceAlternate = *((uint16_t *)param);
   \                     ??USB_DeviceHidEvent_14: (+1)
   \   00000088   0x8830             LDRH     R0,[R6, #+0]
   \   0000008A   0x4681             MOV      R9,R0
    367                      /* Get the alternate setting value */
    368                      alternate = (uint8_t)(interfaceAlternate & 0xFFU);
   \   0000008C   0x4648             MOV      R0,R9
   \   0000008E   0xF88D 0x000C      STRB     R0,[SP, #+12]
    369          
    370                      /* Whether the interface belongs to the class. */
    371                      if (hidHandle->interfaceNumber != ((uint8_t)(interfaceAlternate >> 8U)))
   \   00000092   0x7B79             LDRB     R1,[R7, #+13]
   \   00000094   0x4648             MOV      R0,R9
   \   00000096   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000098   0x0A00             LSRS     R0,R0,#+8
   \   0000009A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009C   0x4281             CMP      R1,R0
   \   0000009E   0xF040 0x80F7      BNE.W    ??USB_DeviceHidEvent_10
    372                      {
    373                          break;
    374                      }
    375                      /* Only handle new alternate setting. */
    376                      if (alternate == hidHandle->alternate)
   \                     ??USB_DeviceHidEvent_15: (+1)
   \   000000A2   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   000000A6   0x7BB9             LDRB     R1,[R7, #+14]
   \   000000A8   0x4288             CMP      R0,R1
   \   000000AA   0xF000 0x80F1      BEQ.W    ??USB_DeviceHidEvent_10
    377                      {
    378                          break;
    379                      }
    380                      /* De-initialize old endpoints */
    381                      error = USB_DeviceHidEndpointsDeinit(hidHandle);
   \                     ??USB_DeviceHidEvent_16: (+1)
   \   000000AE   0x0038             MOVS     R0,R7
   \   000000B0   0x.... 0x....      BL       USB_DeviceHidEndpointsDeinit
   \   000000B4   0x4680             MOV      R8,R0
    382                      hidHandle->alternate = alternate;
   \   000000B6   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   000000BA   0x73B8             STRB     R0,[R7, #+14]
    383                      /* Initialize new endpoints */
    384                      error = USB_DeviceHidEndpointsInit(hidHandle);
   \   000000BC   0x0038             MOVS     R0,R7
   \   000000BE   0x.... 0x....      BL       USB_DeviceHidEndpointsInit
   \   000000C2   0x4680             MOV      R8,R0
    385                      break;
   \   000000C4   0xE0E4             B.N      ??USB_DeviceHidEvent_10
    386                  case kUSB_DeviceClassEventSetEndpointHalt:
    387                      if ((!hidHandle->configStruct) || (!hidHandle->interfaceHandle))
   \                     ??USB_DeviceHidEvent_7: (+1)
   \   000000C6   0x6878             LDR      R0,[R7, #+4]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD002             BEQ.N    ??USB_DeviceHidEvent_17
   \   000000CC   0x68B8             LDR      R0,[R7, #+8]
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD100             BNE.N    ??USB_DeviceHidEvent_18
    388                      {
    389                          break;
   \                     ??USB_DeviceHidEvent_17: (+1)
   \   000000D2   0xE0DD             B.N      ??USB_DeviceHidEvent_10
    390                      }
    391                      /* Get the endpoint address */
    392                      temp8 = ((uint8_t *)param);
   \                     ??USB_DeviceHidEvent_18: (+1)
   \   000000D4   0x46B2             MOV      R10,R6
    393                      for (int count = 0U; count < hidHandle->interfaceHandle->endpointList.count; count++)
   \   000000D6   0xF05F 0x0B00      MOVS     R11,#+0
   \                     ??USB_DeviceHidEvent_19: (+1)
   \   000000DA   0x68B8             LDR      R0,[R7, #+8]
   \   000000DC   0x7900             LDRB     R0,[R0, #+4]
   \   000000DE   0x4583             CMP      R11,R0
   \   000000E0   0xDA10             BGE.N    ??USB_DeviceHidEvent_20
    394                      {
    395                          if (*temp8 == hidHandle->interfaceHandle->endpointList.endpoint[count].endpointAddress)
   \   000000E2   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   000000E6   0x68B9             LDR      R1,[R7, #+8]
   \   000000E8   0x6889             LDR      R1,[R1, #+8]
   \   000000EA   0xF811 0x102B      LDRB     R1,[R1, R11, LSL #+2]
   \   000000EE   0x4288             CMP      R0,R1
   \   000000F0   0xD105             BNE.N    ??USB_DeviceHidEvent_21
    396                          {
    397                              /* Only stall the endpoint belongs to the class */
    398                              error = USB_DeviceStallEndpoint(hidHandle->handle, *temp8);
   \   000000F2   0xF89A 0x1000      LDRB     R1,[R10, #+0]
   \   000000F6   0x6838             LDR      R0,[R7, #+0]
   \   000000F8   0x.... 0x....      BL       USB_DeviceStallEndpoint
   \   000000FC   0x4680             MOV      R8,R0
    399                          }
    400                      }
   \                     ??USB_DeviceHidEvent_21: (+1)
   \   000000FE   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   00000102   0xE7EA             B.N      ??USB_DeviceHidEvent_19
    401                      break;
   \                     ??USB_DeviceHidEvent_20: (+1)
   \   00000104   0xE0C4             B.N      ??USB_DeviceHidEvent_10
    402                  case kUSB_DeviceClassEventClearEndpointHalt:
    403                      if ((!hidHandle->configStruct) || (!hidHandle->interfaceHandle))
   \                     ??USB_DeviceHidEvent_9: (+1)
   \   00000106   0x6878             LDR      R0,[R7, #+4]
   \   00000108   0x2800             CMP      R0,#+0
   \   0000010A   0xD002             BEQ.N    ??USB_DeviceHidEvent_22
   \   0000010C   0x68B8             LDR      R0,[R7, #+8]
   \   0000010E   0x2800             CMP      R0,#+0
   \   00000110   0xD100             BNE.N    ??USB_DeviceHidEvent_23
    404                      {
    405                          break;
   \                     ??USB_DeviceHidEvent_22: (+1)
   \   00000112   0xE0BD             B.N      ??USB_DeviceHidEvent_10
    406                      }
    407                      /* Get the endpoint address */
    408                      temp8 = ((uint8_t *)param);
   \                     ??USB_DeviceHidEvent_23: (+1)
   \   00000114   0x46B2             MOV      R10,R6
    409                      for (int count = 0U; count < hidHandle->interfaceHandle->endpointList.count; count++)
   \   00000116   0xF05F 0x0B00      MOVS     R11,#+0
   \                     ??USB_DeviceHidEvent_24: (+1)
   \   0000011A   0x68B8             LDR      R0,[R7, #+8]
   \   0000011C   0x7900             LDRB     R0,[R0, #+4]
   \   0000011E   0x4583             CMP      R11,R0
   \   00000120   0xDA10             BGE.N    ??USB_DeviceHidEvent_25
    410                      {
    411                          if (*temp8 == hidHandle->interfaceHandle->endpointList.endpoint[count].endpointAddress)
   \   00000122   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   00000126   0x68B9             LDR      R1,[R7, #+8]
   \   00000128   0x6889             LDR      R1,[R1, #+8]
   \   0000012A   0xF811 0x102B      LDRB     R1,[R1, R11, LSL #+2]
   \   0000012E   0x4288             CMP      R0,R1
   \   00000130   0xD105             BNE.N    ??USB_DeviceHidEvent_26
    412                          {
    413                              /* Only un-stall the endpoint belongs to the class */
    414                              error = USB_DeviceUnstallEndpoint(hidHandle->handle, *temp8);
   \   00000132   0xF89A 0x1000      LDRB     R1,[R10, #+0]
   \   00000136   0x6838             LDR      R0,[R7, #+0]
   \   00000138   0x.... 0x....      BL       USB_DeviceUnstallEndpoint
   \   0000013C   0x4680             MOV      R8,R0
    415                          }
    416                      }
   \                     ??USB_DeviceHidEvent_26: (+1)
   \   0000013E   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   00000142   0xE7EA             B.N      ??USB_DeviceHidEvent_24
    417                      break;
   \                     ??USB_DeviceHidEvent_25: (+1)
   \   00000144   0xE0A4             B.N      ??USB_DeviceHidEvent_10
    418                  case kUSB_DeviceClassEventClassRequest:
    419                      if (param)
   \                     ??USB_DeviceHidEvent_3: (+1)
   \   00000146   0x2E00             CMP      R6,#+0
   \   00000148   0xF000 0x80A1      BEQ.W    ??USB_DeviceHidEvent_27
    420                      {
    421                          /* Handle the hid class specific request. */
    422                          usb_device_control_request_struct_t *controlRequest = (usb_device_control_request_struct_t *)param;
   \   0000014C   0x46B3             MOV      R11,R6
    423          
    424                          if ((controlRequest->setup->bmRequestType & USB_REQUEST_TYPE_RECIPIENT_MASK) !=
    425                              USB_REQUEST_TYPE_RECIPIENT_INTERFACE)
   \   0000014E   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   00000152   0x7800             LDRB     R0,[R0, #+0]
   \   00000154   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000158   0x2801             CMP      R0,#+1
   \   0000015A   0xF040 0x8099      BNE.W    ??USB_DeviceHidEvent_10
    426                          {
    427                              break;
    428                          }
    429          
    430                          if ((controlRequest->setup->wIndex & 0xFFU) != hidHandle->interfaceNumber)
   \                     ??USB_DeviceHidEvent_28: (+1)
   \   0000015E   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   00000162   0x7900             LDRB     R0,[R0, #+4]
   \   00000164   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   00000168   0x7B79             LDRB     R1,[R7, #+13]
   \   0000016A   0x4288             CMP      R0,R1
   \   0000016C   0xF040 0x8090      BNE.W    ??USB_DeviceHidEvent_10
    431                          {
    432                              break;
    433                          }
    434          
    435                          switch (controlRequest->setup->bRequest)
   \                     ??USB_DeviceHidEvent_29: (+1)
   \   00000170   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   00000174   0x7840             LDRB     R0,[R0, #+1]
   \   00000176   0x2801             CMP      R0,#+1
   \   00000178   0xD00A             BEQ.N    ??USB_DeviceHidEvent_30
   \   0000017A   0x2802             CMP      R0,#+2
   \   0000017C   0xD021             BEQ.N    ??USB_DeviceHidEvent_31
   \   0000017E   0x2803             CMP      R0,#+3
   \   00000180   0xD02C             BEQ.N    ??USB_DeviceHidEvent_32
   \   00000182   0x2809             CMP      R0,#+9
   \   00000184   0xD037             BEQ.N    ??USB_DeviceHidEvent_33
   \   00000186   0x280A             CMP      R0,#+10
   \   00000188   0xD063             BEQ.N    ??USB_DeviceHidEvent_34
   \   0000018A   0x280B             CMP      R0,#+11
   \   0000018C   0xD070             BEQ.N    ??USB_DeviceHidEvent_35
   \   0000018E   0xE07C             B.N      ??USB_DeviceHidEvent_36
    436                          {
    437                              case USB_DEVICE_HID_REQUEST_GET_REPORT:
    438                                  /* Get report request */
    439                                  report.reportType = (controlRequest->setup->wValue & 0xFF00U) >> 0x08U;
   \                     ??USB_DeviceHidEvent_30: (+1)
   \   00000190   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   00000194   0x8840             LDRH     R0,[R0, #+2]
   \   00000196   0x0A00             LSRS     R0,R0,#+8
   \   00000198   0xF88D 0x0008      STRB     R0,[SP, #+8]
    440                                  report.reportId = (controlRequest->setup->wValue & 0x00FFU);
   \   0000019C   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000001A0   0x8840             LDRH     R0,[R0, #+2]
   \   000001A2   0xF88D 0x0009      STRB     R0,[SP, #+9]
    441                                  error = hidHandle->configStruct->classCallback((class_handle_t)hidHandle,
    442                                                                                 kUSB_DeviceHidEventGetReport, &report);
   \   000001A6   0x466A             MOV      R2,SP
   \   000001A8   0x2103             MOVS     R1,#+3
   \   000001AA   0x0038             MOVS     R0,R7
   \   000001AC   0x687B             LDR      R3,[R7, #+4]
   \   000001AE   0x681B             LDR      R3,[R3, #+0]
   \   000001B0   0x4798             BLX      R3
   \   000001B2   0x4680             MOV      R8,R0
    443                                  controlRequest->buffer = report.reportBuffer;
   \   000001B4   0x9800             LDR      R0,[SP, #+0]
   \   000001B6   0xF8CB 0x0004      STR      R0,[R11, #+4]
    444                                  controlRequest->length = report.reportLength;
   \   000001BA   0x9801             LDR      R0,[SP, #+4]
   \   000001BC   0xF8CB 0x0008      STR      R0,[R11, #+8]
    445                                  break;
   \   000001C0   0xE065             B.N      ??USB_DeviceHidEvent_27
    446                              case USB_DEVICE_HID_REQUEST_GET_IDLE:
    447                                  /* Get idle request */
    448                                  error = hidHandle->configStruct->classCallback(
    449                                      (class_handle_t)hidHandle, kUSB_DeviceHidEventGetIdle, &hidHandle->idleRate);
   \                     ??USB_DeviceHidEvent_31: (+1)
   \   000001C2   0xF117 0x020F      ADDS     R2,R7,#+15
   \   000001C6   0x2104             MOVS     R1,#+4
   \   000001C8   0x0038             MOVS     R0,R7
   \   000001CA   0x687B             LDR      R3,[R7, #+4]
   \   000001CC   0x681B             LDR      R3,[R3, #+0]
   \   000001CE   0x4798             BLX      R3
   \   000001D0   0x4680             MOV      R8,R0
    450                                  controlRequest->buffer = &hidHandle->idleRate;
   \   000001D2   0xF117 0x000F      ADDS     R0,R7,#+15
   \   000001D6   0xF8CB 0x0004      STR      R0,[R11, #+4]
    451                                  break;
   \   000001DA   0xE058             B.N      ??USB_DeviceHidEvent_27
    452                              case USB_DEVICE_HID_REQUEST_GET_PROTOCOL:
    453                                  /* Get protocol request */
    454                                  error = hidHandle->configStruct->classCallback(
    455                                      (class_handle_t)hidHandle, kUSB_DeviceHidEventGetIdle, &hidHandle->protocol);
   \                     ??USB_DeviceHidEvent_32: (+1)
   \   000001DC   0xF117 0x0210      ADDS     R2,R7,#+16
   \   000001E0   0x2104             MOVS     R1,#+4
   \   000001E2   0x0038             MOVS     R0,R7
   \   000001E4   0x687B             LDR      R3,[R7, #+4]
   \   000001E6   0x681B             LDR      R3,[R3, #+0]
   \   000001E8   0x4798             BLX      R3
   \   000001EA   0x4680             MOV      R8,R0
    456                                  controlRequest->buffer = &hidHandle->protocol;
   \   000001EC   0xF117 0x0010      ADDS     R0,R7,#+16
   \   000001F0   0xF8CB 0x0004      STR      R0,[R11, #+4]
    457                                  break;
   \   000001F4   0xE04B             B.N      ??USB_DeviceHidEvent_27
    458                              case USB_DEVICE_HID_REQUEST_SET_REPORT:
    459                                  /* Set report request */
    460                                  report.reportType = (controlRequest->setup->wValue & 0xFF00U) >> 0x08U;
   \                     ??USB_DeviceHidEvent_33: (+1)
   \   000001F6   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000001FA   0x8840             LDRH     R0,[R0, #+2]
   \   000001FC   0x0A00             LSRS     R0,R0,#+8
   \   000001FE   0xF88D 0x0008      STRB     R0,[SP, #+8]
    461                                  report.reportId = (controlRequest->setup->wValue & 0x00FFU);
   \   00000202   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   00000206   0x8840             LDRH     R0,[R0, #+2]
   \   00000208   0xF88D 0x0009      STRB     R0,[SP, #+9]
    462                                  if (controlRequest->isSetup)
   \   0000020C   0xF89B 0x000C      LDRB     R0,[R11, #+12]
   \   00000210   0x2800             CMP      R0,#+0
   \   00000212   0xD010             BEQ.N    ??USB_DeviceHidEvent_37
    463                                  {
    464                                      report.reportLength = controlRequest->length;
   \   00000214   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   00000218   0x9001             STR      R0,[SP, #+4]
    465                                      error = hidHandle->configStruct->classCallback(
    466                                          (class_handle_t)hidHandle, kUSB_DeviceHidEventRequestReportBuffer, &report);
   \   0000021A   0x466A             MOV      R2,SP
   \   0000021C   0x2109             MOVS     R1,#+9
   \   0000021E   0x0038             MOVS     R0,R7
   \   00000220   0x687B             LDR      R3,[R7, #+4]
   \   00000222   0x681B             LDR      R3,[R3, #+0]
   \   00000224   0x4798             BLX      R3
   \   00000226   0x4680             MOV      R8,R0
    467                                      controlRequest->buffer = report.reportBuffer;
   \   00000228   0x9800             LDR      R0,[SP, #+0]
   \   0000022A   0xF8CB 0x0004      STR      R0,[R11, #+4]
    468                                      controlRequest->length = report.reportLength;
   \   0000022E   0x9801             LDR      R0,[SP, #+4]
   \   00000230   0xF8CB 0x0008      STR      R0,[R11, #+8]
   \   00000234   0xE00C             B.N      ??USB_DeviceHidEvent_38
    469                                  }
    470                                  else
    471                                  {
    472                                      report.reportBuffer = controlRequest->buffer;
   \                     ??USB_DeviceHidEvent_37: (+1)
   \   00000236   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   0000023A   0x9000             STR      R0,[SP, #+0]
    473                                      report.reportLength = controlRequest->length;
   \   0000023C   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   00000240   0x9001             STR      R0,[SP, #+4]
    474                                      error = hidHandle->configStruct->classCallback((class_handle_t)hidHandle,
    475                                                                                     kUSB_DeviceHidEventSetReport, &report);
   \   00000242   0x466A             MOV      R2,SP
   \   00000244   0x2106             MOVS     R1,#+6
   \   00000246   0x0038             MOVS     R0,R7
   \   00000248   0x687B             LDR      R3,[R7, #+4]
   \   0000024A   0x681B             LDR      R3,[R3, #+0]
   \   0000024C   0x4798             BLX      R3
   \   0000024E   0x4680             MOV      R8,R0
    476                                  }
    477                                  break;
   \                     ??USB_DeviceHidEvent_38: (+1)
   \   00000250   0xE01D             B.N      ??USB_DeviceHidEvent_27
    478                              case USB_DEVICE_HID_REQUEST_SET_IDLE:
    479                                  /* Set idle request */
    480                                  {
    481                                      hidHandle->idleRate = (controlRequest->setup->wValue & 0xFF00U) >> 0x08U;
   \                     ??USB_DeviceHidEvent_34: (+1)
   \   00000252   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   00000256   0x8840             LDRH     R0,[R0, #+2]
   \   00000258   0x0A00             LSRS     R0,R0,#+8
   \   0000025A   0x73F8             STRB     R0,[R7, #+15]
    482                                      error = hidHandle->configStruct->classCallback(
    483                                          (class_handle_t)hidHandle, kUSB_DeviceHidEventSetIdle, &controlRequest->setup->wValue);
   \   0000025C   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   00000260   0x1C82             ADDS     R2,R0,#+2
   \   00000262   0x2107             MOVS     R1,#+7
   \   00000264   0x0038             MOVS     R0,R7
   \   00000266   0x687B             LDR      R3,[R7, #+4]
   \   00000268   0x681B             LDR      R3,[R3, #+0]
   \   0000026A   0x4798             BLX      R3
   \   0000026C   0x4680             MOV      R8,R0
    484                                  }
    485                                  break;
   \   0000026E   0xE00E             B.N      ??USB_DeviceHidEvent_27
    486                              case USB_DEVICE_HID_REQUEST_SET_PROTOCOL:
    487                                  /* Set protocol request */
    488                                  {
    489                                      hidHandle->protocol = (controlRequest->setup->wValue & 0x00FFU);
   \                     ??USB_DeviceHidEvent_35: (+1)
   \   00000270   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   00000274   0x8840             LDRH     R0,[R0, #+2]
   \   00000276   0x7438             STRB     R0,[R7, #+16]
    490                                      error = hidHandle->configStruct->classCallback(
    491                                          (class_handle_t)hidHandle, kUSB_DeviceHidEventSetProtocol, &hidHandle->protocol);
   \   00000278   0xF117 0x0210      ADDS     R2,R7,#+16
   \   0000027C   0x2108             MOVS     R1,#+8
   \   0000027E   0x0038             MOVS     R0,R7
   \   00000280   0x687B             LDR      R3,[R7, #+4]
   \   00000282   0x681B             LDR      R3,[R3, #+0]
   \   00000284   0x4798             BLX      R3
   \   00000286   0x4680             MOV      R8,R0
    492                                  }
    493                                  break;
   \   00000288   0xE001             B.N      ??USB_DeviceHidEvent_27
    494                              default:
    495                                  error = kStatus_USB_InvalidRequest;
   \                     ??USB_DeviceHidEvent_36: (+1)
   \   0000028A   0x2005             MOVS     R0,#+5
   \   0000028C   0x4680             MOV      R8,R0
    496                                  break;
    497                          }
    498                      }
    499                      break;
   \                     ??USB_DeviceHidEvent_27: (+1)
   \   0000028E   0xE7FF             B.N      ??USB_DeviceHidEvent_10
    500                  default:
    501                      break;
    502              }
    503              return error;
   \                     ??USB_DeviceHidEvent_4: (+1)
   \                     ??USB_DeviceHidEvent_10: (+1)
   \   00000290   0x4640             MOV      R0,R8
   \   00000292   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceHidEvent_2: (+1)
   \   00000294   0xB005             ADD      SP,SP,#+20
   \   00000296   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    504          }
    505          
    506          /*!
    507           * @brief Initialize the hid class.
    508           *
    509           * This function is used to initialize the hid class.
    510           *
    511           * @param controllerId   The controller id of the USB IP. Please refer to the enumeration usb_controller_index_t.
    512           * @param config          The class configuration information.
    513           * @param handle          It is out parameter, is used to return pointer of the hid class handle to the caller.
    514           *
    515           * @return A USB error code or kStatus_USB_Success.
    516           */

   \                                 In section .text, align 2, keep-with-next
    517          usb_status_t USB_DeviceHidInit(uint8_t controllerId, usb_device_class_config_struct_t *config, class_handle_t *handle)
    518          {
   \                     USB_DeviceHidInit: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    519              usb_device_hid_struct_t *hidHandle;
    520              usb_status_t error = kStatus_USB_Error;
   \   00000008   0x2701             MOVS     R7,#+1
    521          
    522              /* Allocate a hid class handle. */
    523              error = USB_DeviceHidAllocateHandle(&hidHandle);
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       USB_DeviceHidAllocateHandle
   \   00000010   0x0007             MOVS     R7,R0
    524          
    525              if (kStatus_USB_Success != error)
   \   00000012   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000014   0x2F00             CMP      R7,#+0
   \   00000016   0xD002             BEQ.N    ??USB_DeviceHidInit_0
    526              {
    527                  return error;
   \   00000018   0x0038             MOVS     R0,R7
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xE01D             B.N      ??USB_DeviceHidInit_1
    528              }
    529          
    530              /* Get the device handle according to the controller id. */
    531              error = USB_DeviceClassGetDeviceHandle(controllerId, &hidHandle->handle);
   \                     ??USB_DeviceHidInit_0: (+1)
   \   0000001E   0x9900             LDR      R1,[SP, #+0]
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0x.... 0x....      BL       USB_DeviceClassGetDeviceHandle
   \   00000028   0x0007             MOVS     R7,R0
    532          
    533              if (kStatus_USB_Success != error)
   \   0000002A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD002             BEQ.N    ??USB_DeviceHidInit_2
    534              {
    535                  return error;
   \   00000030   0x0038             MOVS     R0,R7
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0xE011             B.N      ??USB_DeviceHidInit_1
    536              }
    537          
    538              if (!hidHandle->handle)
   \                     ??USB_DeviceHidInit_2: (+1)
   \   00000036   0x9800             LDR      R0,[SP, #+0]
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD101             BNE.N    ??USB_DeviceHidInit_3
    539              {
    540                  return kStatus_USB_InvalidHandle;
   \   0000003E   0x2003             MOVS     R0,#+3
   \   00000040   0xE00B             B.N      ??USB_DeviceHidInit_1
    541              }
    542              /* Save the configuration of the class. */
    543              hidHandle->configStruct = config;
   \                     ??USB_DeviceHidInit_3: (+1)
   \   00000042   0x9800             LDR      R0,[SP, #+0]
   \   00000044   0x6045             STR      R5,[R0, #+4]
    544              /* Clear the configuration value. */
    545              hidHandle->configuration = 0U;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x9900             LDR      R1,[SP, #+0]
   \   0000004A   0x7308             STRB     R0,[R1, #+12]
    546              hidHandle->alternate = 0xffU;
   \   0000004C   0x20FF             MOVS     R0,#+255
   \   0000004E   0x9900             LDR      R1,[SP, #+0]
   \   00000050   0x7388             STRB     R0,[R1, #+14]
    547          
    548              *handle = (class_handle_t)hidHandle;
   \   00000052   0x9800             LDR      R0,[SP, #+0]
   \   00000054   0x6030             STR      R0,[R6, #+0]
    549              return error;
   \   00000056   0x0038             MOVS     R0,R7
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceHidInit_1: (+1)
   \   0000005A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    550          }
    551          
    552          /*!
    553           * @brief De-initialize the device hid class.
    554           *
    555           * The function de-initializes the device hid class.
    556           *
    557           * @param handle The hid class handle got from usb_device_class_config_struct_t::classHandle.
    558           *
    559           * @return A USB error code or kStatus_USB_Success.
    560           */

   \                                 In section .text, align 2, keep-with-next
    561          usb_status_t USB_DeviceHidDeinit(class_handle_t handle)
    562          {
   \                     USB_DeviceHidDeinit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    563              usb_device_hid_struct_t *hidHandle;
    564              usb_status_t error = kStatus_USB_Error;
   \   00000004   0x2601             MOVS     R6,#+1
    565          
    566              hidHandle = (usb_device_hid_struct_t *)handle;
   \   00000006   0x0025             MOVS     R5,R4
    567          
    568              if (!hidHandle)
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD101             BNE.N    ??USB_DeviceHidDeinit_0
    569              {
    570                  return kStatus_USB_InvalidHandle;
   \   0000000C   0x2003             MOVS     R0,#+3
   \   0000000E   0xE008             B.N      ??USB_DeviceHidDeinit_1
    571              }
    572              /* De-initialzie the endpoints. */
    573              error = USB_DeviceHidEndpointsDeinit(hidHandle);
   \                     ??USB_DeviceHidDeinit_0: (+1)
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0x.... 0x....      BL       USB_DeviceHidEndpointsDeinit
   \   00000016   0x0006             MOVS     R6,R0
    574              /* Free the hid class handle. */
    575              USB_DeviceHidFreeHandle(hidHandle);
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       USB_DeviceHidFreeHandle
    576              return error;
   \   0000001E   0x0030             MOVS     R0,R6
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceHidDeinit_1: (+1)
   \   00000022   0xBD70             POP      {R4-R6,PC}       ;; return
    577          }
    578          
    579          /*!
    580           * @brief Send data through a specified endpoint.
    581           *
    582           * The function is used to send data through a specified endpoint.
    583           * The function calls USB_DeviceSendRequest internally.
    584           *
    585           * @param handle The hid class handle got from usb_device_class_config_struct_t::classHandle.
    586           * @param ep     Endpoint index.
    587           * @param buffer The memory address to hold the data need to be sent.
    588           * @param length The data length need to be sent.
    589           *
    590           * @return A USB error code or kStatus_USB_Success.
    591           *
    592           * @note The return value just means if the sending request is successful or not; the transfer done is notified by
    593           * USB_DeviceHidInterruptIn.
    594           * Currently, only one transfer request can be supported for one specific endpoint.
    595           * If there is a specific requirement to support multiple transfer requests for one specific endpoint, the application
    596           * should implement a queue in the application level.
    597           * The subsequent transfer could begin only when the previous transfer is done (get notification through the endpoint
    598           * callback).
    599           */

   \                                 In section .text, align 2, keep-with-next
    600          usb_status_t USB_DeviceHidSend(class_handle_t handle, uint8_t ep, uint8_t *buffer, uint32_t length)
    601          {
   \                     USB_DeviceHidSend: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    602              usb_device_hid_struct_t *hidHandle;
    603              usb_status_t error = kStatus_USB_Error;
   \   0000000C   0xF05F 0x0901      MOVS     R9,#+1
    604          
    605              if (!handle)
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD101             BNE.N    ??USB_DeviceHidSend_0
    606              {
    607                  return kStatus_USB_InvalidHandle;
   \   00000014   0x2003             MOVS     R0,#+3
   \   00000016   0xE019             B.N      ??USB_DeviceHidSend_1
    608              }
    609              hidHandle = (usb_device_hid_struct_t *)handle;
   \                     ??USB_DeviceHidSend_0: (+1)
   \   00000018   0x46A0             MOV      R8,R4
    610          
    611              if (hidHandle->interruptInPipeBusy)
   \   0000001A   0xF898 0x0011      LDRB     R0,[R8, #+17]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD001             BEQ.N    ??USB_DeviceHidSend_2
    612              {
    613                  return kStatus_USB_Busy;
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE012             B.N      ??USB_DeviceHidSend_1
    614              }
    615              error = USB_DeviceSendRequest(hidHandle->handle, ep, buffer, length);
   \                     ??USB_DeviceHidSend_2: (+1)
   \   00000026   0x003B             MOVS     R3,R7
   \   00000028   0x0032             MOVS     R2,R6
   \   0000002A   0x0029             MOVS     R1,R5
   \   0000002C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000032   0x.... 0x....      BL       USB_DeviceSendRequest
   \   00000036   0x4681             MOV      R9,R0
    616              if (kStatus_USB_Success == error)
   \   00000038   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000003C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000040   0xD102             BNE.N    ??USB_DeviceHidSend_3
    617              {
    618                  hidHandle->interruptInPipeBusy = 1U;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xF888 0x0011      STRB     R0,[R8, #+17]
    619              }
    620              return error;
   \                     ??USB_DeviceHidSend_3: (+1)
   \   00000048   0x4648             MOV      R0,R9
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceHidSend_1: (+1)
   \   0000004C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    621          }
    622          
    623          /*!
    624           * @brief Receive data through a specified endpoint.
    625           *
    626           * The function is used to receive data through a specified endpoint.
    627           * The function calls USB_DeviceRecvRequest internally.
    628           *
    629           * @param handle The hid class handle got from usb_device_class_config_struct_t::classHandle.
    630           * @param ep     Endpoint index.
    631           * @param buffer The memory address to save the received data.
    632           * @param length The data length want to be received.
    633           *
    634           * @return A USB error code or kStatus_USB_Success.
    635           *
    636           * @note The return value just means if the receiving request is successful or not; the transfer done is notified by
    637           * USB_DeviceHidInterruptOut.
    638           * Currently, only one transfer request can be supported for one specific endpoint.
    639           * If there is a specific requirement to support multiple transfer requests for one specific endpoint, the application
    640           * should implement a queue in the application level.
    641           * The subsequent transfer could begin only when the previous transfer is done (get notification through the endpoint
    642           * callback).
    643           */

   \                                 In section .text, align 2, keep-with-next
    644          usb_status_t USB_DeviceHidRecv(class_handle_t handle, uint8_t ep, uint8_t *buffer, uint32_t length)
    645          {
   \                     USB_DeviceHidRecv: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    646              usb_device_hid_struct_t *hidHandle;
    647              usb_status_t error = kStatus_USB_Error;
   \   0000000C   0xF05F 0x0901      MOVS     R9,#+1
    648          
    649              if (!handle)
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD101             BNE.N    ??USB_DeviceHidRecv_0
    650              {
    651                  return kStatus_USB_InvalidHandle;
   \   00000014   0x2003             MOVS     R0,#+3
   \   00000016   0xE019             B.N      ??USB_DeviceHidRecv_1
    652              }
    653              hidHandle = (usb_device_hid_struct_t *)handle;
   \                     ??USB_DeviceHidRecv_0: (+1)
   \   00000018   0x46A0             MOV      R8,R4
    654          
    655              if (hidHandle->interruptOutPipeBusy)
   \   0000001A   0xF898 0x0012      LDRB     R0,[R8, #+18]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD001             BEQ.N    ??USB_DeviceHidRecv_2
    656              {
    657                  return kStatus_USB_Busy;
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE012             B.N      ??USB_DeviceHidRecv_1
    658              }
    659              error = USB_DeviceRecvRequest(hidHandle->handle, ep, buffer, length);
   \                     ??USB_DeviceHidRecv_2: (+1)
   \   00000026   0x003B             MOVS     R3,R7
   \   00000028   0x0032             MOVS     R2,R6
   \   0000002A   0x0029             MOVS     R1,R5
   \   0000002C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000032   0x.... 0x....      BL       USB_DeviceRecvRequest
   \   00000036   0x4681             MOV      R9,R0
    660              if (kStatus_USB_Success == error)
   \   00000038   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000003C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000040   0xD102             BNE.N    ??USB_DeviceHidRecv_3
    661              {
    662                  hidHandle->interruptOutPipeBusy = 1U;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xF888 0x0012      STRB     R0,[R8, #+18]
    663              }
    664              return error;
   \                     ??USB_DeviceHidRecv_3: (+1)
   \   00000048   0x4648             MOV      R0,R9
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceHidRecv_1: (+1)
   \   0000004C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    665          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     s_UsbDeviceHidHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     USB_DeviceHidInterruptIn

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     USB_DeviceHidInterruptOut
    666          
    667          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   USB_DeviceHidAllocateHandle
      16   USB_DeviceHidDeinit
        16   -> USB_DeviceHidEndpointsDeinit
        16   -> USB_DeviceHidFreeHandle
      16   USB_DeviceHidEndpointsDeinit
        16   -> USB_DeviceDeinitEndpoint
      40   USB_DeviceHidEndpointsInit
        40   -> USB_DeviceInitEndpoint
      56   USB_DeviceHidEvent
        56   -- Indirect call
        56   -> USB_DeviceHidEndpointsDeinit
        56   -> USB_DeviceHidEndpointsInit
        56   -> USB_DeviceStallEndpoint
        56   -> USB_DeviceUnstallEndpoint
       0   USB_DeviceHidFreeHandle
      24   USB_DeviceHidInit
        24   -> USB_DeviceClassGetDeviceHandle
        24   -> USB_DeviceHidAllocateHandle
      24   USB_DeviceHidInterruptIn
        24   -- Indirect call
      24   USB_DeviceHidInterruptOut
        24   -- Indirect call
      32   USB_DeviceHidRecv
        32   -> USB_DeviceRecvRequest
      32   USB_DeviceHidSend
        32   -> USB_DeviceSendRequest


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
      48  USB_DeviceHidAllocateHandle
      36  USB_DeviceHidDeinit
      54  USB_DeviceHidEndpointsDeinit
     276  USB_DeviceHidEndpointsInit
     666  USB_DeviceHidEvent
      22  USB_DeviceHidFreeHandle
      92  USB_DeviceHidInit
      64  USB_DeviceHidInterruptIn
      64  USB_DeviceHidInterruptOut
      80  USB_DeviceHidRecv
      80  USB_DeviceHidSend
      20  s_UsbDeviceHidHandle

 
 1 494 bytes in section .text
    20 bytes in section m_usb_global
 
 1 494 bytes of CODE memory
    20 bytes of DATA memory

Errors: none
Warnings: none
