###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:00
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\dspi_peripheral_interface.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\dspi_peripheral_interface.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\dspi_peripheral_interface.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\dspi_peripheral_interface.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\dspi_peripheral_interface.c
      1          /*
      2           * Copyright (c) 2013, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "utilities/fsl_assert.h"
     32          #include "bootloader/bl_context.h"
     33          #include "bootloader_common.h"
     34          #include "bootloader/bl_irq_common.h"
     35          #include "packet/command_packet.h"
     36          #include "dspi/fsl_dspi.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t DSPI_GetStatusFlags(SPI_Type *)
   \                     DSPI_GetStatusFlags: (+1)
   \   00000000   0x6AC0             LDR      R0,[R0, #+44]
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void DSPI_ClearStatusFlags(SPI_Type *, uint32_t)
   \                     DSPI_ClearStatusFlags: (+1)
   \   00000000   0x62C1             STR      R1,[R0, #+44]
   \   00000002   0x4770             BX       LR               ;; return
     37          #include "fsl_device_registers.h"
     38          #include "packet/serial_packet.h"
     39          
     40          #if BL_CONFIG_DSPI
     41          
     42          //! @addtogroup dspi_peripheral
     43          //! @{
     44          
     45          ////////////////////////////////////////////////////////////////////////////////
     46          // Definitions
     47          ////////////////////////////////////////////////////////////////////////////////
     48          
     49          //! @brief Synchronization state between DSPI ISR and read/write functions.
     50          typedef struct _dspi_transfer_info
     51          {
     52              const uint8_t *writeData;                                //!< The applications data to write
     53              volatile uint32_t bytesToTransfer;                       //!< The total number of bytes to be transmitted
     54              void (*data_source)(uint8_t *source_byte);               // !< Callback used to get byte to transmit.
     55              void (*data_sink)(uint8_t sink_byte, uint32_t instance); // !< Callback used to put received byte.
     56          } dspi_transfer_info_t;
     57          
     58          ////////////////////////////////////////////////////////////////////////////////
     59          // Prototypes
     60          ////////////////////////////////////////////////////////////////////////////////
     61          
     62          //! @brief DSPI slave poll for activity function
     63          static bool dspi_poll_for_activity(const peripheral_descriptor_t *self);
     64          //! @brief DSPI slave init function
     65          static status_t dspi_full_init(const peripheral_descriptor_t *self, serial_byte_receive_func_t function);
     66          //! @brief DSPI slave shutdown function
     67          static void dspi_full_shutdown(const peripheral_descriptor_t *self);
     68          //! @brief DSPI slave sending data function
     69          static void dspi_data_source(uint8_t *source_byte);
     70          //! @brief DSPI slave receiving data function
     71          static void dspi_data_sink(uint8_t sink_byte, uint32_t instance);
     72          //! @brief DSPI slave receiving first byte data function
     73          static void dspi_initial_data_sink(uint8_t sink_byte, uint32_t instance);
     74          //! @brief DSPI slave writing data function
     75          status_t dspi_write(const peripheral_descriptor_t *self, const uint8_t *buffer, uint32_t byteCount);
     76          
     77          ////////////////////////////////////////////////////////////////////////////////
     78          // Variables
     79          ////////////////////////////////////////////////////////////////////////////////
     80          
     81          /*!
     82           * @brief DSPI slave control interface information
     83           */

   \                                 In section .rodata, align 4
     84          const peripheral_control_interface_t g_dspiControlInterface = {
   \                     g_dspiControlInterface:
   \   00000000   0x........         DC32 dspi_poll_for_activity, dspi_full_init, dspi_full_shutdown, 0H
   \              0x........   
   \              0x........   
   \              0x00000000   
     85              .pollForActivity = dspi_poll_for_activity, .init = dspi_full_init, .shutdown = dspi_full_shutdown, .pump = 0
     86          };
     87          
     88          /*!
     89           * @brief DSPI slave byte interface information
     90           */

   \                                 In section .rodata, align 4
     91          const peripheral_byte_inteface_t g_dspiByteInterface = {.init = NULL, .write = dspi_write };
   \                     g_dspiByteInterface:
   \   00000000   0x00000000         DC32 0H, dspi_write
   \              0x........   
     92          
     93          //! @brief Global state for the DSPI slave peripheral interface.

   \                                 In section .data, align 4
     94          static dspi_transfer_info_t s_dspiInfo = {
   \                     s_dspiInfo:
   \   00000000   0x00000000         DC32 0H, 0, dspi_data_source, dspi_initial_data_sink
   \              0x00000000   
   \              0x........   
   \              0x........   
     95              .writeData = 0, .bytesToTransfer = 0, .data_source = dspi_data_source, .data_sink = dspi_initial_data_sink
     96          };
     97          
     98          //! @brief Flag for DSPI detecting device activity

   \                                 In section .bss, align 4
     99          static bool s_dspiActivity[FSL_FEATURE_SOC_DSPI_COUNT] = { false };
   \                     s_dspiActivity:
   \   00000000                      DS8 4
    100          
    101          //! @brief Flag for DSPI intialization state

   \                                 In section .bss, align 4
    102          static bool s_dspiIntialized[FSL_FEATURE_SOC_DSPI_COUNT] = { false };
   \                     s_dspiIntialized:
   \   00000000                      DS8 4
    103          
    104          /*!
    105           * @brief DSPI slave receiving data call back function
    106           */

   \                                 In section .bss, align 4
    107          static serial_byte_receive_func_t s_dspi_app_data_sink_callback;
   \                     s_dspi_app_data_sink_callback:
   \   00000000                      DS8 4
    108          

   \                                 In section .rodata, align 4
    109          const static uint32_t g_dspiBaseAddr[] = SPI_BASE_ADDRS;
   \                     g_dspiBaseAddr:
   \   00000000   0x4002C000         DC32 1073922048, 1073926144, 1074446336
   \              0x4002D000   
   \              0x400AC000   
    110          
    111          ////////////////////////////////////////////////////////////////////////////////
    112          // Code
    113          ////////////////////////////////////////////////////////////////////////////////
    114          
    115          /*FUNCTION**********************************************************************
    116           *
    117           * Function Name : dspi_poll_for_activity
    118           * Description   : Polling for DSPI slave activities
    119           *
    120           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    121          bool dspi_poll_for_activity(const peripheral_descriptor_t *self)
    122          {
    123              return s_dspiActivity[self->instance];
   \                     dspi_poll_for_activity: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable7
   \   00000002   0x6840             LDR      R0,[R0, #+4]
   \   00000004   0x5C08             LDRB     R0,[R1, R0]
   \   00000006   0x4770             BX       LR               ;; return
    124          }
    125          
    126          /*FUNCTION**********************************************************************
    127           *
    128           * Function Name : dspi_data_source
    129           * Description   : DSPI slave sending data function
    130           *
    131           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    132          void dspi_data_source(uint8_t *source_byte)
    133          {
    134              assert(source_byte);
    135          
    136              if (s_dspiInfo.bytesToTransfer)
   \                     dspi_data_source: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable7_1
   \   00000002   0x6849             LDR      R1,[R1, #+4]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD00E             BEQ.N    ??dspi_data_source_0
    137              {
    138                  *source_byte = *s_dspiInfo.writeData++;
   \   00000008   0x....             LDR.N    R1,??DataTable7_1
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x7809             LDRB     R1,[R1, #+0]
   \   0000000E   0x7001             STRB     R1,[R0, #+0]
   \   00000010   0x....             LDR.N    R1,??DataTable7_1
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x1C49             ADDS     R1,R1,#+1
   \   00000016   0x....             LDR.N    R2,??DataTable7_1
   \   00000018   0x6011             STR      R1,[R2, #+0]
    139                  s_dspiInfo.bytesToTransfer--;
   \   0000001A   0x....             LDR.N    R1,??DataTable7_1
   \   0000001C   0x6849             LDR      R1,[R1, #+4]
   \   0000001E   0x1E49             SUBS     R1,R1,#+1
   \   00000020   0x....             LDR.N    R2,??DataTable7_1
   \   00000022   0x6051             STR      R1,[R2, #+4]
   \   00000024   0xE001             B.N      ??dspi_data_source_1
    140              }
    141              else
    142              {
    143                  *source_byte = 0;
   \                     ??dspi_data_source_0: (+1)
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x7001             STRB     R1,[R0, #+0]
    144              }
    145          }
   \                     ??dspi_data_source_1: (+1)
   \   0000002A   0x4770             BX       LR               ;; return
    146          
    147          /*FUNCTION**********************************************************************
    148           *
    149           * Function Name : dspi_initial_data_sink
    150           * Description   : DSPI slave receiving first byte data function
    151           *
    152           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    153          void dspi_initial_data_sink(uint8_t sink_byte, uint32_t instance)
    154          {
   \                     dspi_initial_data_sink: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    155              if (sink_byte == kFramingPacketStartByte)
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C5A             CMP      R4,#+90
   \   0000000A   0xD10B             BNE.N    ??dspi_initial_data_sink_0
    156              {
    157                  s_dspiActivity[instance] = true;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x....             LDR.N    R1,??DataTable7
   \   00000010   0x5548             STRB     R0,[R1, R5]
    158                  s_dspiInfo.data_sink = dspi_data_sink;
   \   00000012   0x.... 0x....      ADR.W    R0,dspi_data_sink
   \   00000016   0x....             LDR.N    R1,??DataTable7_1
   \   00000018   0x60C8             STR      R0,[R1, #+12]
    159                  s_dspi_app_data_sink_callback(sink_byte);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x....             LDR.N    R1,??DataTable7_2
   \   00000020   0x6809             LDR      R1,[R1, #+0]
   \   00000022   0x4788             BLX      R1
    160              }
    161          }
   \                     ??dspi_initial_data_sink_0: (+1)
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    162          
    163          /*FUNCTION**********************************************************************
    164           *
    165           * Function Name : dspi_data_sink
    166           * Description   : DSPI slave receiving data function
    167           *
    168           *END**************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    169          void dspi_data_sink(uint8_t sink_byte, uint32_t instance)
    170          {
   \                     dspi_data_sink: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    171              s_dspi_app_data_sink_callback(sink_byte);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x....             LDR.N    R1,??DataTable7_2
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0x4788             BLX      R1
    172          }
   \   00000010   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    173          
    174          /*FUNCTION**********************************************************************
    175           *
    176           * Function Name : dspi_full_init
    177           * Description   : DSPI slave full init function
    178           *
    179           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    180          status_t dspi_full_init(const peripheral_descriptor_t *self, serial_byte_receive_func_t function)
    181          {
   \                     dspi_full_init: (+1)
   \   00000000   0xB57F             PUSH     {R0-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    182              s_dspi_app_data_sink_callback = function;
   \   00000006   0x....             LDR.N    R0,??DataTable7_2
   \   00000008   0x6005             STR      R5,[R0, #+0]
    183              dspi_slave_config_t config;
    184              uint32_t baseAddr = g_dspiBaseAddr[self->instance];
   \   0000000A   0x....             LDR.N    R0,??DataTable7_3
   \   0000000C   0x6861             LDR      R1,[R4, #+4]
   \   0000000E   0xF850 0x6021      LDR      R6,[R0, R1, LSL #+2]
    185          
    186              DSPI_SlaveGetDefaultConfig(&config);
   \   00000012   0x4668             MOV      R0,SP
   \   00000014   0x.... 0x....      BL       DSPI_SlaveGetDefaultConfig
    187          
    188              config.ctarConfig.cpol = kDSPI_ClockPolarityActiveLow;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xF88D 0x0008      STRB     R0,[SP, #+8]
    189              config.ctarConfig.cpha = kDSPI_ClockPhaseSecondEdge;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF88D 0x0009      STRB     R0,[SP, #+9]
    190          
    191              s_dspiInfo.data_source = dspi_data_source, s_dspiInfo.data_sink = dspi_initial_data_sink,
    192          
    193              // Configure selected pin as spi peripheral interface
    194                  self->pinmuxConfig(self->instance, kPinmuxType_Peripheral);
   \   00000024   0x....             LDR.N    R0,??DataTable7_4
   \   00000026   0x....             LDR.N    R1,??DataTable7_1
   \   00000028   0x6088             STR      R0,[R1, #+8]
   \   0000002A   0x....             LDR.N    R0,??DataTable7_5
   \   0000002C   0x....             LDR.N    R1,??DataTable7_1
   \   0000002E   0x60C8             STR      R0,[R1, #+12]
   \   00000030   0x2102             MOVS     R1,#+2
   \   00000032   0x6860             LDR      R0,[R4, #+4]
   \   00000034   0x68A2             LDR      R2,[R4, #+8]
   \   00000036   0x4790             BLX      R2
    195              DSPI_SlaveInit((SPI_Type *)baseAddr, &config);
   \   00000038   0x4669             MOV      R1,SP
   \   0000003A   0x0030             MOVS     R0,R6
   \   0000003C   0x.... 0x....      BL       DSPI_SlaveInit
    196              DSPI_EnableInterrupts((SPI_Type *)baseAddr, SPI_SR_TFFF_MASK | SPI_SR_RFDF_MASK | SPI_SR_TFUF_MASK);
   \   00000040   0x....             LDR.N    R1,??DataTable7_6  ;; 0xa020000
   \   00000042   0x0030             MOVS     R0,R6
   \   00000044   0x.... 0x....      BL       DSPI_EnableInterrupts
    197              DSPI_SetSystemIRQ(self->instance, kPeripheralEnableIRQ);
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0x6860             LDR      R0,[R4, #+4]
   \   0000004C   0x.... 0x....      BL       DSPI_SetSystemIRQ
    198          
    199              s_dspiIntialized[self->instance] = true;
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x....             LDR.N    R1,??DataTable7_7
   \   00000054   0x6862             LDR      R2,[R4, #+4]
   \   00000056   0x5488             STRB     R0,[R1, R2]
    200          
    201              return kStatus_Success;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xB004             ADD      SP,SP,#+16
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
    202          }
    203          
    204          /*FUNCTION**********************************************************************
    205           *
    206           * Function Name : dspi_full_shutdown
    207           * Description   : DSPI slave full shutdown function
    208           *
    209           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    210          void dspi_full_shutdown(const peripheral_descriptor_t *self)
    211          {
   \                     dspi_full_shutdown: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    212              if (s_dspiIntialized[self->instance])
   \   00000004   0x....             LDR.N    R0,??DataTable7_7
   \   00000006   0x6861             LDR      R1,[R4, #+4]
   \   00000008   0x5C40             LDRB     R0,[R0, R1]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD012             BEQ.N    ??dspi_full_shutdown_0
    213              {
    214                  uint32_t baseAddr = g_dspiBaseAddr[self->instance];
   \   0000000E   0x....             LDR.N    R0,??DataTable7_3
   \   00000010   0x6861             LDR      R1,[R4, #+4]
   \   00000012   0xF850 0x5021      LDR      R5,[R0, R1, LSL #+2]
    215                  DSPI_SetSystemIRQ(self->instance, kPeripheralDisableIRQ);
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x6860             LDR      R0,[R4, #+4]
   \   0000001A   0x.... 0x....      BL       DSPI_SetSystemIRQ
    216                  DSPI_Deinit((SPI_Type *)baseAddr);
   \   0000001E   0x0028             MOVS     R0,R5
   \   00000020   0x.... 0x....      BL       DSPI_Deinit
    217                  // Restore selected pin to default state to reduce IDD.
    218                  self->pinmuxConfig(self->instance, kPinmuxType_Default);
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x6860             LDR      R0,[R4, #+4]
   \   00000028   0x68A2             LDR      R2,[R4, #+8]
   \   0000002A   0x4790             BLX      R2
    219          
    220                  s_dspiIntialized[self->instance] = false;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x....             LDR.N    R1,??DataTable7_7
   \   00000030   0x6862             LDR      R2,[R4, #+4]
   \   00000032   0x5488             STRB     R0,[R1, R2]
    221              }
    222          }
   \                     ??dspi_full_shutdown_0: (+1)
   \   00000034   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    223          
    224          /*FUNCTION**********************************************************************
    225           *
    226           * Function Name : dspi_write
    227           * Description   : DSPI slave writing data function
    228           *
    229           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    230          status_t dspi_write(const peripheral_descriptor_t *self, const uint8_t *buffer, uint32_t byteCount)
    231          {
   \                     dspi_write: (+1)
   \   00000000   0x0003             MOVS     R3,R0
    232              s_dspiInfo.writeData = buffer;
   \   00000002   0x....             LDR.N    R0,??DataTable7_1
   \   00000004   0x6001             STR      R1,[R0, #+0]
    233              s_dspiInfo.bytesToTransfer = byteCount;
   \   00000006   0x....             LDR.N    R0,??DataTable7_1
   \   00000008   0x6042             STR      R2,[R0, #+4]
    234          
    235              while (s_dspiInfo.bytesToTransfer)
   \                     ??dspi_write_0: (+1)
   \   0000000A   0x....             LDR.N    R0,??DataTable7_1
   \   0000000C   0x6840             LDR      R0,[R0, #+4]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD1FB             BNE.N    ??dspi_write_0
    236                  ;
    237          
    238              return kStatus_Success;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4770             BX       LR               ;; return
    239          }
    240          

   \                                 In section .text, align 2, keep-with-next
    241          void dspi_slave_irq_handler(uint32_t instance)
    242          {
   \                     dspi_slave_irq_handler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    243              uint32_t baseAddr = g_dspiBaseAddr[instance];
   \   00000006   0x....             LDR.N    R0,??DataTable7_3
   \   00000008   0xF850 0x5024      LDR      R5,[R0, R4, LSL #+2]
    244          
    245              /* catch tx fifo underflow conditions */
    246              if (DSPI_GetStatusFlags((SPI_Type *)baseAddr) & kDSPI_TxFifoUnderflowFlag)
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   00000012   0x0100             LSLS     R0,R0,#+4
   \   00000014   0xD504             BPL.N    ??dspi_slave_irq_handler_0
    247              {
    248                  DSPI_ClearStatusFlags((SPI_Type *)baseAddr, kDSPI_TxFifoUnderflowFlag);
   \   00000016   0xF05F 0x6100      MOVS     R1,#+134217728
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0x.... 0x....      BL       DSPI_ClearStatusFlags
    249              }
    250          
    251              /* Fill the tx fifo, where the fifo can be 1 entry or more */
    252              while (DSPI_GetStatusFlags((SPI_Type *)baseAddr) & kDSPI_TxFifoFillRequestFlag)
   \                     ??dspi_slave_irq_handler_0: (+1)
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   00000026   0x0180             LSLS     R0,R0,#+6
   \   00000028   0xD50E             BPL.N    ??dspi_slave_irq_handler_1
    253              {
    254                  /* SPI transmit interrupt */
    255                  uint32_t sourceWord = 0;
   \   0000002A   0x2600             MOVS     R6,#+0
    256                  uint8_t sourceWordTemp;
    257          
    258                  /* get the first 8-bits of data */
    259                  s_dspiInfo.data_source(&sourceWordTemp);
   \   0000002C   0x4668             MOV      R0,SP
   \   0000002E   0x....             LDR.N    R1,??DataTable7_1
   \   00000030   0x6889             LDR      R1,[R1, #+8]
   \   00000032   0x4788             BLX      R1
    260                  sourceWord = sourceWordTemp;
   \   00000034   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000038   0x0006             MOVS     R6,R0
    261          
    262                  /* Finally, write the data to the DSPI data register */
    263                  ((SPI_Type *)baseAddr)->PUSHR_SLAVE = sourceWord;
   \   0000003A   0x636E             STR      R6,[R5, #+52]
    264          
    265                  /* try to clear TFFF by writing a one to it; it will not clear if TX FIFO not full */
    266                  DSPI_ClearStatusFlags((SPI_Type *)baseAddr, kDSPI_TxFifoFillRequestFlag);
   \   0000003C   0xF05F 0x7100      MOVS     R1,#+33554432
   \   00000040   0x0028             MOVS     R0,R5
   \   00000042   0x.... 0x....      BL       DSPI_ClearStatusFlags
   \   00000046   0xE7EB             B.N      ??dspi_slave_irq_handler_0
    267              }
    268          
    269              /* Fill the rx fifo, where the fifo can be 1 entry or more */
    270              while (DSPI_GetStatusFlags((SPI_Type *)baseAddr) & kDSPI_RxFifoDrainRequestFlag)
   \                     ??dspi_slave_irq_handler_1: (+1)
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0x.... 0x....      BL       DSPI_GetStatusFlags
   \   0000004E   0x0380             LSLS     R0,R0,#+14
   \   00000050   0xD50C             BPL.N    ??dspi_slave_irq_handler_2
    271              {
    272                  /* SPI receive interrupt, read the data from the DSPI data register */
    273                  uint32_t readData = ((SPI_Type *)baseAddr)->POPR;
   \   00000052   0x6BAE             LDR      R6,[R5, #+56]
    274          
    275                  /* clear the rx fifo drain request, needed for non-DMA applications as this flag
    276                   * will remain set even if the rx fifo is empty. By manually clearing this flag, it
    277                   * either remain clear if no more data is in the fifo, or it will set if there is
    278                   * more data in the fifo.
    279                   */
    280                  DSPI_ClearStatusFlags((SPI_Type *)baseAddr, kDSPI_RxFifoDrainRequestFlag);
   \   00000054   0xF45F 0x3100      MOVS     R1,#+131072
   \   00000058   0x0028             MOVS     R0,R5
   \   0000005A   0x.... 0x....      BL       DSPI_ClearStatusFlags
    281          
    282                  /* Sink the first 8-bits */
    283                  s_dspiInfo.data_sink((uint8_t)readData, instance);
   \   0000005E   0x0021             MOVS     R1,R4
   \   00000060   0x0030             MOVS     R0,R6
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0x....             LDR.N    R2,??DataTable7_1
   \   00000066   0x68D2             LDR      R2,[R2, #+12]
   \   00000068   0x4790             BLX      R2
   \   0000006A   0xE7ED             B.N      ??dspi_slave_irq_handler_1
    284              }
    285          }
   \                     ??dspi_slave_irq_handler_2: (+1)
   \   0000006C   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    286          
    287          #if defined(SPI0)

   \                                 In section .text, align 2, keep-with-next
    288          void SPI0_IRQHandler(void)
    289          {
   \                     SPI0_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    290              dspi_slave_irq_handler(0);
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       dspi_slave_irq_handler
    291          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    292          #endif
    293          
    294          #if defined(SPI1)

   \                                 In section .text, align 2, keep-with-next
    295          void SPI1_IRQHandler(void)
    296          {
   \                     SPI1_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    297              dspi_slave_irq_handler(1);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       dspi_slave_irq_handler
    298          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    299          #endif
    300          
    301          #if defined(SPI2)

   \                                 In section .text, align 2, keep-with-next
    302          void SPI2_IRQHandler(void)
    303          {
   \                     SPI2_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    304              dspi_slave_irq_handler(2);
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x.... 0x....      BL       dspi_slave_irq_handler
    305          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     s_dspiActivity

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     s_dspiInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     s_dspi_app_data_sink_callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     g_dspiBaseAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x........         DC32     dspi_data_source

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x........         DC32     dspi_initial_data_sink

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x0A020000         DC32     0xa020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x........         DC32     s_dspiIntialized
    306          #endif
    307          
    308          //! @}
    309          
    310          #endif // BL_CONFIG_DSPI
    311          
    312          ////////////////////////////////////////////////////////////////////////////////
    313          // EOF
    314          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DSPI_ClearStatusFlags
       0   DSPI_GetStatusFlags
       8   SPI0_IRQHandler
         8   -> dspi_slave_irq_handler
       8   SPI1_IRQHandler
         8   -> dspi_slave_irq_handler
       8   SPI2_IRQHandler
         8   -> dspi_slave_irq_handler
      16   dspi_data_sink
        16   -- Indirect call
       0   dspi_data_source
      32   dspi_full_init
        32   -- Indirect call
        32   -> DSPI_EnableInterrupts
        32   -> DSPI_SetSystemIRQ
        32   -> DSPI_SlaveGetDefaultConfig
        32   -> DSPI_SlaveInit
      16   dspi_full_shutdown
        16   -- Indirect call
        16   -> DSPI_Deinit
        16   -> DSPI_SetSystemIRQ
      16   dspi_initial_data_sink
        16   -- Indirect call
       0   dspi_poll_for_activity
      24   dspi_slave_irq_handler
        24   -- Indirect call
        24   -> DSPI_ClearStatusFlags
        24   -> DSPI_GetStatusFlags
       0   dspi_write


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  DSPI_ClearStatusFlags
       4  DSPI_GetStatusFlags
      10  SPI0_IRQHandler
      10  SPI1_IRQHandler
      10  SPI2_IRQHandler
      18  dspi_data_sink
      44  dspi_data_source
      94  dspi_full_init
      54  dspi_full_shutdown
      38  dspi_initial_data_sink
       8  dspi_poll_for_activity
     110  dspi_slave_irq_handler
      22  dspi_write
      12  g_dspiBaseAddr
       8  g_dspiByteInterface
      16  g_dspiControlInterface
       4  s_dspiActivity
      16  s_dspiInfo
       4  s_dspiIntialized
       4  s_dspi_app_data_sink_callback

 
  12 bytes in section .bss
  16 bytes in section .data
  36 bytes in section .rodata
 458 bytes in section .text
 
 458 bytes of CODE  memory
  36 bytes of CONST memory
  28 bytes of DATA  memory

Errors: none
Warnings: none
