###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:13
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_class.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_class.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\usb_device_class.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\usb_device_class.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\usb\device\class\usb_device_class.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "usb_device_config.h"
     32          #include "usb.h"
     33          
     34          #include "usb_device.h"
     35          #include "usb_device_ch9.h"
     36          #include "usb_device_class.h"
     37          
     38          #if ((defined(USB_DEVICE_CONFIG_NUM)) && (USB_DEVICE_CONFIG_NUM > 0U))
     39          /* Include the class drivers according to the usb_device_config.h. */
     40          #if ((defined(USB_DEVICE_CONFIG_HID)) && (USB_DEVICE_CONFIG_HID > 0U))
     41          #include "usb_device_hid.h"
     42          #endif
     43          
     44          #if ((defined(USB_DEVICE_CONFIG_CDC_ACM)) && (USB_DEVICE_CONFIG_CDC_ACM > 0U))
     45          #include "usb_device_cdc_acm.h"
     46          #endif
     47          
     48          #if ((defined(USB_DEVICE_CONFIG_MSC)) && (USB_DEVICE_CONFIG_MSC > 0U))
     49          #include "usb_device_msc.h"
     50          #endif
     51          
     52          #if ((defined(USB_DEVICE_CONFIG_AUDIO)) && (USB_DEVICE_CONFIG_AUDIO > 0U))
     53          #include "usb_device_audio.h"
     54          #endif
     55          
     56          #if ((defined(USB_DEVICE_CONFIG_PHDC)) && (USB_DEVICE_CONFIG_PHDC > 0U))
     57          #include "usb_device_phdc.h"
     58          #endif
     59          
     60          #if ((defined(USB_DEVICE_CONFIG_VIDEO)) && (USB_DEVICE_CONFIG_VIDEO > 0U))
     61          #include "usb_device_video.h"
     62          #endif
     63          
     64          #if ((defined(USB_DEVICE_CONFIG_PRINTER)) && (USB_DEVICE_CONFIG_PRINTER > 0U))
     65          #include "usb_device_printer_config.h"
     66          #include "usb_device_printer.h"
     67          #endif
     68          
     69          #if ((defined(USB_DEVICE_CONFIG_DFU)) && (USB_DEVICE_CONFIG_DFU > 0U))
     70          #include "usb_device_dfu_config.h"
     71          #include "usb_device_dfu.h"
     72          #endif
     73          
     74          #if ((defined(USB_DEVICE_CONFIG_CCID)) && (USB_DEVICE_CONFIG_CCID > 0U))
     75          #include "usb_device_ccid.h"
     76          #endif
     77          
     78          /*******************************************************************************
     79           * Definitions
     80           ******************************************************************************/
     81          
     82          /*******************************************************************************
     83           * Prototypes
     84           ******************************************************************************/
     85          static usb_status_t USB_DeviceClassAllocateHandle(uint8_t controllerId, usb_device_common_class_struct_t **handle);
     86          static usb_status_t USB_DeviceClassFreeHandle(uint8_t controllerId);
     87          static usb_status_t USB_DeviceClassGetHandleByControllerId(uint8_t controllerId,
     88                                                                     usb_device_common_class_struct_t **handle);
     89          static usb_status_t USB_DeviceClassGetHandleByDeviceHandle(usb_device_handle deviceHandle,
     90                                                                     usb_device_common_class_struct_t **handle);
     91          
     92          /*******************************************************************************
     93           * Variables
     94           ******************************************************************************/
     95          
     96          /* The device class driver list. */

   \                                 In section .rodata, align 4
     97          static const usb_device_class_map_t s_UsbDeviceClassInterfaceMap[] = {
   \                     s_UsbDeviceClassInterfaceMap:
   \   00000000   0x........         DC32 USB_DeviceHidInit, USB_DeviceHidDeinit, USB_DeviceHidEvent
   \              0x........   
   \              0x........   
   \   0000000C   0x01 0x00          DC8 1, 0, 0, 0
   \              0x00 0x00    
   \   00000010   0x........         DC32 USB_DeviceMscInit, USB_DeviceMscDeinit, USB_DeviceMscEvent
   \              0x........   
   \              0x........   
   \   0000001C   0x03 0x00          DC8 3, 0, 0, 0
   \              0x00 0x00    
   \   00000020   0x00000000         DC32 0H, 0H, 0H
   \              0x00000000   
   \              0x00000000   
   \   0000002C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
     98          #if ((defined(USB_DEVICE_CONFIG_HID)) && (USB_DEVICE_CONFIG_HID > 0U))
     99              {USB_DeviceHidInit, USB_DeviceHidDeinit, USB_DeviceHidEvent, kUSB_DeviceClassTypeHid},
    100          #endif
    101          
    102          #if ((defined(USB_DEVICE_CONFIG_CDC_ACM)) && (USB_DEVICE_CONFIG_CDC_ACM > 0U))
    103              {USB_DeviceCdcAcmInit, USB_DeviceCdcAcmDeinit, USB_DeviceCdcAcmEvent, kUSB_DeviceClassTypeCdc},
    104          #endif
    105          
    106          #if ((defined(USB_DEVICE_CONFIG_MSC)) && (USB_DEVICE_CONFIG_MSC > 0U))
    107              {USB_DeviceMscInit, USB_DeviceMscDeinit, USB_DeviceMscEvent, kUSB_DeviceClassTypeMsc},
    108          #endif
    109          
    110          #if ((defined USB_DEVICE_CONFIG_AUDIO) && (USB_DEVICE_CONFIG_AUDIO > 0U))
    111              {USB_DeviceAudioInit, USB_DeviceAudioDeinit, USB_DeviceAudioEvent, kUSB_DeviceClassTypeAudio},
    112          #endif
    113          
    114          #if ((defined USB_DEVICE_CONFIG_PHDC) && (USB_DEVICE_CONFIG_PHDC > 0U))
    115              {USB_DevicePhdcInit, USB_DevicePhdcDeinit, USB_DevicePhdcEvent, kUSB_DeviceClassTypePhdc},
    116          #endif
    117          
    118          #if ((defined USB_DEVICE_CONFIG_VIDEO) && (USB_DEVICE_CONFIG_VIDEO > 0U))
    119              {USB_DeviceVideoInit, USB_DeviceVideoDeinit, USB_DeviceVideoEvent, kUSB_DeviceClassTypeVideo},
    120          #endif
    121          
    122          #if ((defined USB_DEVICE_CONFIG_PRINTER) && (USB_DEVICE_CONFIG_PRINTER > 0U))
    123              {usb_device_printer_init, usb_device_printer_deinit, usb_device_printer_event, kUSB_DeviceClassTypePrinter},
    124          #endif
    125          
    126          #if ((defined USB_DEVICE_CONFIG_DFU) && (USB_DEVICE_CONFIG_DFU > 0U))
    127              {usb_device_dfu_init, usb_device_dfu_deinit, usb_device_dfu_event, kUSB_DeviceClassTypeDfu},
    128          #endif
    129          
    130          #if ((defined USB_DEVICE_CONFIG_CCID) && (USB_DEVICE_CONFIG_CCID > 0U))
    131              {USB_DeviceCcidInit, USB_DeviceCcidDeinit, USB_DeviceCcidEvent, kUSB_DeviceClassTypeCcid},
    132          #endif
    133          
    134              {(usb_device_class_init_call_t)NULL, (usb_device_class_deinit_call_t)NULL, (usb_device_class_event_callback_t)NULL,
    135               (usb_device_class_type_t)0},
    136          };
    137          

   \                                 In section m_usb_global, align 4
    138          USB_GLOBAL static usb_device_common_class_struct_t s_UsbDeviceCommonClassStruct[USB_DEVICE_CONFIG_NUM];
   \                     s_UsbDeviceCommonClassStruct:
   \   00000000                      DS8 20
    139          
    140          /*******************************************************************************
    141           * Code
    142           ******************************************************************************/
    143          
    144          /*!
    145           * @brief Allocate a device common class handle.
    146           *
    147           * This function allocates a a device common class handle.
    148           *
    149           * @param controllerId   The controller id of the USB IP. Please refer to the enumeration usb_controller_index_t.
    150           * @param handle          It is out parameter, is used to return pointer of the device common class handle to the
    151           * caller.
    152           *
    153           * @retval kStatus_USB_Success              Get a device handle successfully.
    154           * @retval kStatus_USB_Busy                 Cannot allocate a common class handle.
    155           * @retval kStatus_USB_Error                The common class has been initialized.
    156           */

   \                                 In section .text, align 2, keep-with-next
    157          static usb_status_t USB_DeviceClassAllocateHandle(uint8_t controllerId, usb_device_common_class_struct_t **handle)
    158          {
   \                     USB_DeviceClassAllocateHandle: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000C             MOVS     R4,R1
    159              int32_t count;
    160              USB_OSA_SR_ALLOC();
    161          
    162              USB_OSA_ENTER_CRITICAL();
   \   00000006   0x.... 0x....      BL       USB_BmEnterCritical
    163              /* Check the controller is initialized or not. */
    164              for (count = 0U; count < USB_DEVICE_CONFIG_NUM; count++)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0005             MOVS     R5,R0
   \                     ??USB_DeviceClassAllocateHandle_0: (+1)
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD118             BNE.N    ??USB_DeviceClassAllocateHandle_1
    165              {
    166                  if ((NULL != s_UsbDeviceCommonClassStruct[count].handle) &&
    167                      (controllerId == s_UsbDeviceCommonClassStruct[count].controllerId))
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable7
   \   00000016   0x2114             MOVS     R1,#+20
   \   00000018   0xFB01 0xF105      MUL      R1,R1,R5
   \   0000001C   0x5840             LDR      R0,[R0, R1]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD00E             BEQ.N    ??USB_DeviceClassAllocateHandle_2
   \   00000022   0x0030             MOVS     R0,R6
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable7
   \   00000028   0x2214             MOVS     R2,#+20
   \   0000002A   0xFB02 0xF205      MUL      R2,R2,R5
   \   0000002E   0x4411             ADD      R1,R1,R2
   \   00000030   0x7C89             LDRB     R1,[R1, #+18]
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD103             BNE.N    ??USB_DeviceClassAllocateHandle_2
    168                  {
    169                      USB_OSA_EXIT_CRITICAL();
   \   00000038   0x.... 0x....      BL       USB_BmExitCritical
    170                      return kStatus_USB_Error;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xE024             B.N      ??USB_DeviceClassAllocateHandle_3
    171                  }
    172              }
   \                     ??USB_DeviceClassAllocateHandle_2: (+1)
   \   00000040   0x1C6D             ADDS     R5,R5,#+1
   \   00000042   0xE7E4             B.N      ??USB_DeviceClassAllocateHandle_0
    173              /* Get a free common class handle. */
    174              for (count = 0U; count < USB_DEVICE_CONFIG_NUM; count++)
   \                     ??USB_DeviceClassAllocateHandle_1: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x0005             MOVS     R5,R0
   \                     ??USB_DeviceClassAllocateHandle_4: (+1)
   \   00000048   0x2D00             CMP      R5,#+0
   \   0000004A   0xD11B             BNE.N    ??USB_DeviceClassAllocateHandle_5
    175              {
    176                  if (NULL == s_UsbDeviceCommonClassStruct[count].handle)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable7
   \   00000050   0x2114             MOVS     R1,#+20
   \   00000052   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000056   0x5840             LDR      R0,[R0, R1]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD111             BNE.N    ??USB_DeviceClassAllocateHandle_6
    177                  {
    178                      s_UsbDeviceCommonClassStruct[count].controllerId = controllerId;
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable7
   \   00000060   0x2114             MOVS     R1,#+20
   \   00000062   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000066   0x4408             ADD      R0,R0,R1
   \   00000068   0x7486             STRB     R6,[R0, #+18]
    179                      *handle = &s_UsbDeviceCommonClassStruct[count];
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable7
   \   0000006E   0x2114             MOVS     R1,#+20
   \   00000070   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000074   0x4408             ADD      R0,R0,R1
   \   00000076   0x6020             STR      R0,[R4, #+0]
    180                      USB_OSA_EXIT_CRITICAL();
   \   00000078   0x.... 0x....      BL       USB_BmExitCritical
    181                      return kStatus_USB_Success;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xE004             B.N      ??USB_DeviceClassAllocateHandle_3
    182                  }
    183              }
   \                     ??USB_DeviceClassAllocateHandle_6: (+1)
   \   00000080   0x1C6D             ADDS     R5,R5,#+1
   \   00000082   0xE7E1             B.N      ??USB_DeviceClassAllocateHandle_4
    184          
    185              USB_OSA_EXIT_CRITICAL();
   \                     ??USB_DeviceClassAllocateHandle_5: (+1)
   \   00000084   0x.... 0x....      BL       USB_BmExitCritical
    186              return kStatus_USB_Busy;
   \   00000088   0x2002             MOVS     R0,#+2
   \                     ??USB_DeviceClassAllocateHandle_3: (+1)
   \   0000008A   0xBD70             POP      {R4-R6,PC}       ;; return
    187          }
    188          
    189          /*!
    190           * @brief Free a device common class handle.
    191           *
    192           * This function frees a device common class handle.
    193           *
    194           * @param controllerId   The controller id of the USB IP. Please refer to the enumeration usb_controller_index_t.
    195           *
    196           * @retval kStatus_USB_Success              Free device hanlde successfully.
    197           * @retval kStatus_USB_InvalidParameter     The common class can not be found.
    198           */

   \                                 In section .text, align 2, keep-with-next
    199          static usb_status_t USB_DeviceClassFreeHandle(uint8_t controllerId)
    200          {
   \                     USB_DeviceClassFreeHandle: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    201              int32_t count = 0U;
   \   00000004   0x2500             MOVS     R5,#+0
    202              USB_OSA_SR_ALLOC();
    203          
    204              USB_OSA_ENTER_CRITICAL();
   \   00000006   0x.... 0x....      BL       USB_BmEnterCritical
    205              for (; count < USB_DEVICE_CONFIG_NUM; count++)
   \                     ??USB_DeviceClassFreeHandle_0: (+1)
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD12F             BNE.N    ??USB_DeviceClassFreeHandle_1
    206              {
    207                  if ((NULL != s_UsbDeviceCommonClassStruct[count].handle) &&
    208                      (controllerId == s_UsbDeviceCommonClassStruct[count].controllerId))
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable7
   \   00000012   0x2114             MOVS     R1,#+20
   \   00000014   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000018   0x5840             LDR      R0,[R0, R1]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD025             BEQ.N    ??USB_DeviceClassFreeHandle_2
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable7
   \   00000024   0x2214             MOVS     R2,#+20
   \   00000026   0xFB02 0xF205      MUL      R2,R2,R5
   \   0000002A   0x4411             ADD      R1,R1,R2
   \   0000002C   0x7C89             LDRB     R1,[R1, #+18]
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD11A             BNE.N    ??USB_DeviceClassFreeHandle_2
    209                  {
    210                      s_UsbDeviceCommonClassStruct[count].handle = NULL;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable7
   \   0000003A   0x2214             MOVS     R2,#+20
   \   0000003C   0xFB02 0xF205      MUL      R2,R2,R5
   \   00000040   0x5088             STR      R0,[R1, R2]
    211                      s_UsbDeviceCommonClassStruct[count].configList = (usb_device_class_config_list_struct_t *)NULL;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable7
   \   00000048   0x2214             MOVS     R2,#+20
   \   0000004A   0xFB02 0xF205      MUL      R2,R2,R5
   \   0000004E   0x4411             ADD      R1,R1,R2
   \   00000050   0x6048             STR      R0,[R1, #+4]
    212                      s_UsbDeviceCommonClassStruct[count].controllerId = 0U;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable7
   \   00000058   0x2214             MOVS     R2,#+20
   \   0000005A   0xFB02 0xF205      MUL      R2,R2,R5
   \   0000005E   0x4411             ADD      R1,R1,R2
   \   00000060   0x7488             STRB     R0,[R1, #+18]
    213                      USB_OSA_EXIT_CRITICAL();
   \   00000062   0x.... 0x....      BL       USB_BmExitCritical
    214                      return kStatus_USB_Success;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xE004             B.N      ??USB_DeviceClassFreeHandle_3
    215                  }
    216              }
   \                     ??USB_DeviceClassFreeHandle_2: (+1)
   \   0000006A   0x1C6D             ADDS     R5,R5,#+1
   \   0000006C   0xE7CD             B.N      ??USB_DeviceClassFreeHandle_0
    217              USB_OSA_EXIT_CRITICAL();
   \                     ??USB_DeviceClassFreeHandle_1: (+1)
   \   0000006E   0x.... 0x....      BL       USB_BmExitCritical
    218          
    219              return kStatus_USB_InvalidParameter;
   \   00000072   0x2004             MOVS     R0,#+4
   \                     ??USB_DeviceClassFreeHandle_3: (+1)
   \   00000074   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    220          }
    221          
    222          /*!
    223           * @brief Get the device common class handle according to the controller id.
    224           *
    225           * This function gets the device common class handle according to the controller id.
    226           *
    227           * @param controllerId   The controller id of the USB IP. Please refer to the enumeration usb_controller_index_t.
    228           * @param handle          It is out parameter, is used to return pointer of the device common class handle to the
    229           * caller.
    230           *
    231           * @retval kStatus_USB_Success              Free device hanlde successfully.
    232           * @retval kStatus_USB_InvalidParameter     The common class can not be found.
    233           */

   \                                 In section .text, align 2, keep-with-next
    234          static usb_status_t USB_DeviceClassGetHandleByControllerId(uint8_t controllerId,
    235                                                                     usb_device_common_class_struct_t **handle)
    236          {
   \                     USB_DeviceClassGetHandleByControllerId: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    237              int32_t count = 0U;
   \   00000006   0x2600             MOVS     R6,#+0
    238              USB_OSA_SR_ALLOC();
    239          
    240              USB_OSA_ENTER_CRITICAL();
   \   00000008   0x.... 0x....      BL       USB_BmEnterCritical
    241              for (; count < USB_DEVICE_CONFIG_NUM; count++)
   \                     ??USB_DeviceClassGetHandleByControllerId_0: (+1)
   \   0000000C   0x2E00             CMP      R6,#+0
   \   0000000E   0xD11E             BNE.N    ??USB_DeviceClassGetHandleByControllerId_1
    242              {
    243                  if ((NULL != s_UsbDeviceCommonClassStruct[count].handle) &&
    244                      (controllerId == s_UsbDeviceCommonClassStruct[count].controllerId))
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable7
   \   00000014   0x2114             MOVS     R1,#+20
   \   00000016   0xFB01 0xF106      MUL      R1,R1,R6
   \   0000001A   0x5840             LDR      R0,[R0, R1]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD014             BEQ.N    ??USB_DeviceClassGetHandleByControllerId_2
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable7
   \   00000026   0x2214             MOVS     R2,#+20
   \   00000028   0xFB02 0xF206      MUL      R2,R2,R6
   \   0000002C   0x4411             ADD      R1,R1,R2
   \   0000002E   0x7C89             LDRB     R1,[R1, #+18]
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD109             BNE.N    ??USB_DeviceClassGetHandleByControllerId_2
    245                  {
    246                      *handle = &s_UsbDeviceCommonClassStruct[count];
   \   00000036   0x....             LDR.N    R0,??DataTable7
   \   00000038   0x2114             MOVS     R1,#+20
   \   0000003A   0xFB01 0xF106      MUL      R1,R1,R6
   \   0000003E   0x4408             ADD      R0,R0,R1
   \   00000040   0x6028             STR      R0,[R5, #+0]
    247                      USB_OSA_EXIT_CRITICAL();
   \   00000042   0x.... 0x....      BL       USB_BmExitCritical
    248                      return kStatus_USB_Success;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xE004             B.N      ??USB_DeviceClassGetHandleByControllerId_3
    249                  }
    250              }
   \                     ??USB_DeviceClassGetHandleByControllerId_2: (+1)
   \   0000004A   0x1C76             ADDS     R6,R6,#+1
   \   0000004C   0xE7DE             B.N      ??USB_DeviceClassGetHandleByControllerId_0
    251              USB_OSA_EXIT_CRITICAL();
   \                     ??USB_DeviceClassGetHandleByControllerId_1: (+1)
   \   0000004E   0x.... 0x....      BL       USB_BmExitCritical
    252              return kStatus_USB_InvalidParameter;
   \   00000052   0x2004             MOVS     R0,#+4
   \                     ??USB_DeviceClassGetHandleByControllerId_3: (+1)
   \   00000054   0xBD70             POP      {R4-R6,PC}       ;; return
    253          }
    254          
    255          /*!
    256           * @brief Get the device common class handle according to the device handle.
    257           *
    258           * This function gets the device common class handle according to the device handle.
    259           *
    260           * @param deviceHandle          The device handle, got from the USB_DeviceInit.
    261           * @param handle                 It is out parameter, is used to return pointer of the device common class handle to the
    262           * caller.
    263           *
    264           * @retval kStatus_USB_Success              Free device hanlde successfully.
    265           * @retval kStatus_USB_InvalidParameter     The common class can not be found.
    266           */

   \                                 In section .text, align 2, keep-with-next
    267          static usb_status_t USB_DeviceClassGetHandleByDeviceHandle(usb_device_handle deviceHandle,
    268                                                                     usb_device_common_class_struct_t **handle)
    269          {
   \                     USB_DeviceClassGetHandleByDeviceHandle: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    270              int32_t count = 0U;
   \   00000006   0x2600             MOVS     R6,#+0
    271              USB_OSA_SR_ALLOC();
    272          
    273              USB_OSA_ENTER_CRITICAL();
   \   00000008   0x.... 0x....      BL       USB_BmEnterCritical
    274              for (; count < USB_DEVICE_CONFIG_NUM; count++)
   \                     ??USB_DeviceClassGetHandleByDeviceHandle_0: (+1)
   \   0000000C   0x2E00             CMP      R6,#+0
   \   0000000E   0xD112             BNE.N    ??USB_DeviceClassGetHandleByDeviceHandle_1
    275              {
    276                  if (deviceHandle == s_UsbDeviceCommonClassStruct[count].handle)
   \   00000010   0x....             LDR.N    R0,??DataTable7
   \   00000012   0x2114             MOVS     R1,#+20
   \   00000014   0xFB01 0xF106      MUL      R1,R1,R6
   \   00000018   0x5840             LDR      R0,[R0, R1]
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD109             BNE.N    ??USB_DeviceClassGetHandleByDeviceHandle_2
    277                  {
    278                      *handle = &s_UsbDeviceCommonClassStruct[count];
   \   0000001E   0x....             LDR.N    R0,??DataTable7
   \   00000020   0x2114             MOVS     R1,#+20
   \   00000022   0xFB01 0xF106      MUL      R1,R1,R6
   \   00000026   0x4408             ADD      R0,R0,R1
   \   00000028   0x6028             STR      R0,[R5, #+0]
    279                      USB_OSA_EXIT_CRITICAL();
   \   0000002A   0x.... 0x....      BL       USB_BmExitCritical
    280                      return kStatus_USB_Success;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xE004             B.N      ??USB_DeviceClassGetHandleByDeviceHandle_3
    281                  }
    282              }
   \                     ??USB_DeviceClassGetHandleByDeviceHandle_2: (+1)
   \   00000032   0x1C76             ADDS     R6,R6,#+1
   \   00000034   0xE7EA             B.N      ??USB_DeviceClassGetHandleByDeviceHandle_0
    283              USB_OSA_EXIT_CRITICAL();
   \                     ??USB_DeviceClassGetHandleByDeviceHandle_1: (+1)
   \   00000036   0x.... 0x....      BL       USB_BmExitCritical
    284              return kStatus_USB_InvalidParameter;
   \   0000003A   0x2004             MOVS     R0,#+4
   \                     ??USB_DeviceClassGetHandleByDeviceHandle_3: (+1)
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
    285          }
    286          
    287          /*!
    288           * @brief Get the device handle according to the controller id.
    289           *
    290           * This function gets the device handle according to the controller id.
    291           *
    292           * @param controllerId   The controller id of the USB IP. Please refer to the enumeration usb_controller_index_t.
    293           * @param handle          It is out parameter, is used to return pointer of the device handle to the caller.
    294           *
    295           * @retval kStatus_USB_Success              Free device hanlde successfully.
    296           * @retval kStatus_USB_InvalidParameter     The device handle not be found.
    297           */

   \                                 In section .text, align 2, keep-with-next
    298          usb_status_t USB_DeviceClassGetDeviceHandle(uint8_t controllerId, usb_device_handle *handle)
    299          {
   \                     USB_DeviceClassGetDeviceHandle: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    300              int32_t count = 0U;
   \   00000006   0x2600             MOVS     R6,#+0
    301              USB_OSA_SR_ALLOC();
    302          
    303              USB_OSA_ENTER_CRITICAL();
   \   00000008   0x.... 0x....      BL       USB_BmEnterCritical
    304              for (; count < USB_DEVICE_CONFIG_NUM; count++)
   \                     ??USB_DeviceClassGetDeviceHandle_0: (+1)
   \   0000000C   0x2E00             CMP      R6,#+0
   \   0000000E   0xD11C             BNE.N    ??USB_DeviceClassGetDeviceHandle_1
    305              {
    306                  if ((NULL != s_UsbDeviceCommonClassStruct[count].handle) &&
    307                      (controllerId == s_UsbDeviceCommonClassStruct[count].controllerId))
   \   00000010   0x....             LDR.N    R0,??DataTable7
   \   00000012   0x2114             MOVS     R1,#+20
   \   00000014   0xFB01 0xF106      MUL      R1,R1,R6
   \   00000018   0x5840             LDR      R0,[R0, R1]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD013             BEQ.N    ??USB_DeviceClassGetDeviceHandle_2
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x....             LDR.N    R1,??DataTable7
   \   00000022   0x2214             MOVS     R2,#+20
   \   00000024   0xFB02 0xF206      MUL      R2,R2,R6
   \   00000028   0x4411             ADD      R1,R1,R2
   \   0000002A   0x7C89             LDRB     R1,[R1, #+18]
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD109             BNE.N    ??USB_DeviceClassGetDeviceHandle_2
    308                  {
    309                      *handle = s_UsbDeviceCommonClassStruct[count].handle;
   \   00000032   0x....             LDR.N    R0,??DataTable7
   \   00000034   0x2114             MOVS     R1,#+20
   \   00000036   0xFB01 0xF106      MUL      R1,R1,R6
   \   0000003A   0x5840             LDR      R0,[R0, R1]
   \   0000003C   0x6028             STR      R0,[R5, #+0]
    310                      USB_OSA_EXIT_CRITICAL();
   \   0000003E   0x.... 0x....      BL       USB_BmExitCritical
    311                      return kStatus_USB_Success;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE004             B.N      ??USB_DeviceClassGetDeviceHandle_3
    312                  }
    313              }
   \                     ??USB_DeviceClassGetDeviceHandle_2: (+1)
   \   00000046   0x1C76             ADDS     R6,R6,#+1
   \   00000048   0xE7E0             B.N      ??USB_DeviceClassGetDeviceHandle_0
    314              USB_OSA_EXIT_CRITICAL();
   \                     ??USB_DeviceClassGetDeviceHandle_1: (+1)
   \   0000004A   0x.... 0x....      BL       USB_BmExitCritical
    315              return kStatus_USB_InvalidParameter;
   \   0000004E   0x2004             MOVS     R0,#+4
   \                     ??USB_DeviceClassGetDeviceHandle_3: (+1)
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
    316          }
    317          
    318          /*!
    319           * @brief Handle the event passed to the class drivers.
    320           *
    321           * This function handles the event passed to the class drivers.
    322           *
    323           * @param handle          The device handle, got from the USB_DeviceInit.
    324           * @param event           The event codes. Please refer to the enumeration usb_device_class_event_t.
    325           * @param param           The param type is determined by the event code.
    326           *
    327           * @return A USB error code or kStatus_USB_Success.
    328           * @retval kStatus_USB_Success              A valid request has been handled.
    329           * @retval kStatus_USB_InvalidParameter     The device handle not be found.
    330           * @retval kStatus_USB_InvalidRequest       The request is invalid, and the control pipe will be stalled by the caller.
    331           */

   \                                 In section .text, align 2, keep-with-next
    332          usb_status_t USB_DeviceClassEvent(usb_device_handle handle, usb_device_class_event_t event, void *param)
    333          {
   \                     USB_DeviceClassEvent: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x468A             MOV      R10,R1
   \   0000000A   0x0015             MOVS     R5,R2
    334              usb_device_common_class_struct_t *classHandle;
    335              uint8_t mapIndex;
    336              uint8_t classIndex;
    337              usb_status_t errorReturn = kStatus_USB_Error;
   \   0000000C   0xF05F 0x0801      MOVS     R8,#+1
    338              usb_status_t error = kStatus_USB_Error;
   \   00000010   0xF05F 0x0901      MOVS     R9,#+1
    339          
    340              if (NULL == param)
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD101             BNE.N    ??USB_DeviceClassEvent_0
    341              {
    342                  return kStatus_USB_InvalidParameter;
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0xE054             B.N      ??USB_DeviceClassEvent_1
    343              }
    344          
    345              /* Get the common class handle according to the device handle. */
    346              errorReturn = USB_DeviceClassGetHandleByDeviceHandle(handle, &classHandle);
   \                     ??USB_DeviceClassEvent_0: (+1)
   \   0000001C   0x4669             MOV      R1,SP
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       USB_DeviceClassGetHandleByDeviceHandle
   \   00000024   0x4680             MOV      R8,R0
    347              if (kStatus_USB_Success != errorReturn)
   \   00000026   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000002A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000002E   0xD001             BEQ.N    ??USB_DeviceClassEvent_2
    348              {
    349                  return kStatus_USB_InvalidParameter;
   \   00000030   0x2004             MOVS     R0,#+4
   \   00000032   0xE048             B.N      ??USB_DeviceClassEvent_1
    350              }
    351          
    352              for (classIndex = 0U; classIndex < classHandle->configList->count; classIndex++)
   \                     ??USB_DeviceClassEvent_2: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x0007             MOVS     R7,R0
   \                     ??USB_DeviceClassEvent_3: (+1)
   \   00000038   0x0038             MOVS     R0,R7
   \   0000003A   0x9900             LDR      R1,[SP, #+0]
   \   0000003C   0x6849             LDR      R1,[R1, #+4]
   \   0000003E   0x7A09             LDRB     R1,[R1, #+8]
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xD23D             BCS.N    ??USB_DeviceClassEvent_4
    353              {
    354                  for (mapIndex = 0U; mapIndex < (sizeof(s_UsbDeviceClassInterfaceMap) / sizeof(usb_device_class_map_t));
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x0006             MOVS     R6,R0
   \                     ??USB_DeviceClassEvent_5: (+1)
   \   0000004A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004C   0x2E03             CMP      R6,#+3
   \   0000004E   0xD236             BCS.N    ??USB_DeviceClassEvent_6
    355                       mapIndex++)
    356                  {
    357                      if (s_UsbDeviceClassInterfaceMap[mapIndex].type ==
    358                          classHandle->configList->config[classIndex].classInfomation->type)
   \   00000050   0x....             LDR.N    R0,??DataTable7_1
   \   00000052   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000054   0x0131             LSLS     R1,R6,#+4
   \   00000056   0x4408             ADD      R0,R0,R1
   \   00000058   0x7B00             LDRB     R0,[R0, #+12]
   \   0000005A   0x9900             LDR      R1,[SP, #+0]
   \   0000005C   0x6849             LDR      R1,[R1, #+4]
   \   0000005E   0x6809             LDR      R1,[R1, #+0]
   \   00000060   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000062   0x220C             MOVS     R2,#+12
   \   00000064   0xFB02 0xF207      MUL      R2,R2,R7
   \   00000068   0x4411             ADD      R1,R1,R2
   \   0000006A   0x6889             LDR      R1,[R1, #+8]
   \   0000006C   0x7909             LDRB     R1,[R1, #+4]
   \   0000006E   0x4288             CMP      R0,R1
   \   00000070   0xD123             BNE.N    ??USB_DeviceClassEvent_7
    359                      {
    360                          /* Call class event callback of supported class */
    361                          errorReturn = s_UsbDeviceClassInterfaceMap[mapIndex].classEventCallback(
    362                              (void *)classHandle->configList->config[classIndex].classHandle, event, param);
   \   00000072   0x002A             MOVS     R2,R5
   \   00000074   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000078   0x4651             MOV      R1,R10
   \   0000007A   0x9800             LDR      R0,[SP, #+0]
   \   0000007C   0x6840             LDR      R0,[R0, #+4]
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000082   0x230C             MOVS     R3,#+12
   \   00000084   0xFB03 0xF307      MUL      R3,R3,R7
   \   00000088   0x4418             ADD      R0,R0,R3
   \   0000008A   0x6840             LDR      R0,[R0, #+4]
   \   0000008C   0x....             LDR.N    R3,??DataTable7_1
   \   0000008E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000090   0xEA5F 0x1C06      LSLS     R12,R6,#+4
   \   00000094   0x4463             ADD      R3,R3,R12
   \   00000096   0x689B             LDR      R3,[R3, #+8]
   \   00000098   0x4798             BLX      R3
   \   0000009A   0x4680             MOV      R8,R0
    363                          /* Return the error code kStatus_USB_InvalidRequest immediately, when a class returns
    364                           * kStatus_USB_InvalidRequest. */
    365                          if (kStatus_USB_InvalidRequest == errorReturn)
   \   0000009C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000A0   0xF1B8 0x0F05      CMP      R8,#+5
   \   000000A4   0xD101             BNE.N    ??USB_DeviceClassEvent_8
    366                          {
    367                              return kStatus_USB_InvalidRequest;
   \   000000A6   0x2005             MOVS     R0,#+5
   \   000000A8   0xE00D             B.N      ??USB_DeviceClassEvent_1
    368                          }
    369                          /* For composite device, it should return kStatus_USB_Success once a valid request has been handled */
    370                          if (kStatus_USB_Success == errorReturn)
   \                     ??USB_DeviceClassEvent_8: (+1)
   \   000000AA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000AE   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000B2   0xD101             BNE.N    ??USB_DeviceClassEvent_9
    371                          {
    372                              error = kStatus_USB_Success;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x4681             MOV      R9,R0
    373                          }
    374                          break;
   \                     ??USB_DeviceClassEvent_9: (+1)
   \   000000B8   0xE001             B.N      ??USB_DeviceClassEvent_6
    375                      }
    376                  }
   \                     ??USB_DeviceClassEvent_7: (+1)
   \   000000BA   0x1C76             ADDS     R6,R6,#+1
   \   000000BC   0xE7C5             B.N      ??USB_DeviceClassEvent_5
    377              }
   \                     ??USB_DeviceClassEvent_6: (+1)
   \   000000BE   0x1C7F             ADDS     R7,R7,#+1
   \   000000C0   0xE7BA             B.N      ??USB_DeviceClassEvent_3
    378          
    379              return error;
   \                     ??USB_DeviceClassEvent_4: (+1)
   \   000000C2   0x4648             MOV      R0,R9
   \   000000C4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceClassEvent_1: (+1)
   \   000000C6   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    380          }
    381          
    382          /*!
    383           * @brief Handle the common class callback.
    384           *
    385           * This function handles the common class callback.
    386           *
    387           * @param handle          The device handle, got from the USB_DeviceInit.
    388           * @param event           The event codes. Please refer to the enumeration usb_device_event_t.
    389           * @param param           The param type is determined by the event code.
    390           *
    391           * @return A USB error code or kStatus_USB_Success.
    392           */

   \                                 In section .text, align 2, keep-with-next
    393          usb_status_t USB_DeviceClassCallback(usb_device_handle handle, uint32_t event, void *param)
    394          {
   \                     USB_DeviceClassCallback: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    395              usb_device_common_class_struct_t *classHandle;
    396              usb_status_t error = kStatus_USB_Error;
   \   00000008   0x2701             MOVS     R7,#+1
    397          
    398              /* Get the common class handle according to the device handle. */
    399              error = USB_DeviceClassGetHandleByDeviceHandle(handle, &classHandle);
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       USB_DeviceClassGetHandleByDeviceHandle
   \   00000012   0x0007             MOVS     R7,R0
    400              if (kStatus_USB_Success != error)
   \   00000014   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000016   0x2F00             CMP      R7,#+0
   \   00000018   0xD002             BEQ.N    ??USB_DeviceClassCallback_0
    401              {
    402                  return error;
   \   0000001A   0x0038             MOVS     R0,R7
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0xE014             B.N      ??USB_DeviceClassCallback_1
    403              }
    404          
    405              if (kUSB_DeviceEventBusReset == event)
   \                     ??USB_DeviceClassCallback_0: (+1)
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD108             BNE.N    ??USB_DeviceClassCallback_2
    406              {
    407                  /* Initialize the control pipes */
    408                  USB_DeviceControlPipeInit(handle, classHandle);
   \   00000024   0x9900             LDR      R1,[SP, #+0]
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       USB_DeviceControlPipeInit
    409          
    410                  /* Notify the classes the USB bus reset signal detected. */
    411                  USB_DeviceClassEvent(handle, kUSB_DeviceClassEventDeviceReset, classHandle);
   \   0000002C   0x9A00             LDR      R2,[SP, #+0]
   \   0000002E   0x2102             MOVS     R1,#+2
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       USB_DeviceClassEvent
    412              }
    413          
    414              /* Call the application device callback function. */
    415              error = classHandle->configList->deviceCallback(handle, event, param);
   \                     ??USB_DeviceClassCallback_2: (+1)
   \   00000036   0x0032             MOVS     R2,R6
   \   00000038   0x0029             MOVS     R1,R5
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x9B00             LDR      R3,[SP, #+0]
   \   0000003E   0x685B             LDR      R3,[R3, #+4]
   \   00000040   0x685B             LDR      R3,[R3, #+4]
   \   00000042   0x4798             BLX      R3
   \   00000044   0x0007             MOVS     R7,R0
    416              return error;
   \   00000046   0x0038             MOVS     R0,R7
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceClassCallback_1: (+1)
   \   0000004A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    417          }
    418          
    419          /*!
    420           * @brief Initialize the common class and the supported classes.
    421           *
    422           * This function is used to initialize the common class and the supported classes.
    423           *
    424           * @param[in] controllerId   The controller id of the USB IP. Please refer to the enumeration #usb_controller_index_t.
    425           * @param[in] configList     The class configurations. The pointer must point to the goblal variable.
    426           *                           Please refer to the structure #usb_device_class_config_list_struct_t.
    427           * @param[out] handle        It is out parameter, is used to return pointer of the device handle to the caller.
    428           *                           The value of parameter is a pointer points the device handle, and this design is uesd to
    429           *                           make simple device align with composite device. For composite device, there are many
    430           *                           kinds of class handle, but there is only one device handle. So the handle points to
    431           *                           a device instead of a class. And the class handle can be got from the
    432           *                           #usb_device_class_config_struct_t::classHandle after the the function successfully.
    433           *
    434           * @return A USB error code or kStatus_USB_Success.
    435           */

   \                                 In section .text, align 2, keep-with-next
    436          usb_status_t USB_DeviceClassInit(
    437              uint8_t controllerId,                              /*!< [IN] Controller ID */
    438              usb_device_class_config_list_struct_t *configList, /*!< [IN] Pointer to class configuration list */
    439              usb_device_handle *handle                          /*!< [OUT] Pointer to the device handle */
    440              )
    441          {
   \                     USB_DeviceClassInit: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    442              usb_device_common_class_struct_t *classHandle;
    443              usb_status_t error = kStatus_USB_Error;
   \   0000000A   0xF05F 0x0901      MOVS     R9,#+1
    444              uint8_t mapIndex;
    445              uint8_t classIndex;
    446          
    447              if ((NULL == handle) || (NULL == configList) || ((usb_device_callback_t)NULL == configList->deviceCallback))
   \   0000000E   0x2E00             CMP      R6,#+0
   \   00000010   0xD004             BEQ.N    ??USB_DeviceClassInit_0
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD002             BEQ.N    ??USB_DeviceClassInit_0
   \   00000016   0x6868             LDR      R0,[R5, #+4]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD101             BNE.N    ??USB_DeviceClassInit_1
    448              {
    449                  return kStatus_USB_InvalidParameter;
   \                     ??USB_DeviceClassInit_0: (+1)
   \   0000001C   0x2004             MOVS     R0,#+4
   \   0000001E   0xE06C             B.N      ??USB_DeviceClassInit_2
    450              }
    451          
    452              /* Allocate a common class driver handle. */
    453              error = USB_DeviceClassAllocateHandle(controllerId, &classHandle);
   \                     ??USB_DeviceClassInit_1: (+1)
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x.... 0x....      BL       USB_DeviceClassAllocateHandle
   \   0000002A   0x4681             MOV      R9,R0
    454              if (kStatus_USB_Success != error)
   \   0000002C   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000030   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000034   0xD002             BEQ.N    ??USB_DeviceClassInit_3
    455              {
    456                  return error;
   \   00000036   0x4648             MOV      R0,R9
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0xE05E             B.N      ??USB_DeviceClassInit_2
    457              }
    458              /* Save the configuration list */
    459              classHandle->configList = configList;
   \                     ??USB_DeviceClassInit_3: (+1)
   \   0000003C   0x9800             LDR      R0,[SP, #+0]
   \   0000003E   0x6045             STR      R5,[R0, #+4]
    460          
    461              /* Initialize the device stack. */
    462              error = USB_DeviceInit(controllerId, USB_DeviceClassCallback, &classHandle->handle);
   \   00000040   0x9A00             LDR      R2,[SP, #+0]
   \   00000042   0x....             LDR.N    R1,??DataTable7_2
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0x.... 0x....      BL       USB_DeviceInit
   \   0000004C   0x4681             MOV      R9,R0
    463          
    464              if (kStatus_USB_Success != error)
   \   0000004E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000052   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000056   0xD00A             BEQ.N    ??USB_DeviceClassInit_4
    465              {
    466                  USB_DeviceDeinit(classHandle->handle);
   \   00000058   0x9800             LDR      R0,[SP, #+0]
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x.... 0x....      BL       USB_DeviceDeinit
    467                  USB_DeviceClassFreeHandle(controllerId);
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0x.... 0x....      BL       USB_DeviceClassFreeHandle
    468                  return error;
   \   00000068   0x4648             MOV      R0,R9
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006C   0xE045             B.N      ??USB_DeviceClassInit_2
    469              }
    470          
    471              /* Initialize the all supported classes according to the configuration list. */
    472              for (classIndex = 0U; classIndex < classHandle->configList->count; classIndex++)
   \                     ??USB_DeviceClassInit_4: (+1)
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x4680             MOV      R8,R0
   \                     ??USB_DeviceClassInit_5: (+1)
   \   00000072   0x4640             MOV      R0,R8
   \   00000074   0x9900             LDR      R1,[SP, #+0]
   \   00000076   0x6849             LDR      R1,[R1, #+4]
   \   00000078   0x7A09             LDRB     R1,[R1, #+8]
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0x4288             CMP      R0,R1
   \   0000007E   0xD237             BCS.N    ??USB_DeviceClassInit_6
    473              {
    474                  for (mapIndex = 0U; mapIndex < (sizeof(s_UsbDeviceClassInterfaceMap) / sizeof(usb_device_class_map_t));
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x0007             MOVS     R7,R0
   \                     ??USB_DeviceClassInit_7: (+1)
   \   00000084   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000086   0x2F03             CMP      R7,#+3
   \   00000088   0xD22F             BCS.N    ??USB_DeviceClassInit_8
    475                       mapIndex++)
    476                  {
    477                      if (classHandle->configList->config[classIndex].classInfomation->type ==
    478                          s_UsbDeviceClassInterfaceMap[mapIndex].type)
   \   0000008A   0x9800             LDR      R0,[SP, #+0]
   \   0000008C   0x6840             LDR      R0,[R0, #+4]
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000094   0x210C             MOVS     R1,#+12
   \   00000096   0xFB01 0xF108      MUL      R1,R1,R8
   \   0000009A   0x4408             ADD      R0,R0,R1
   \   0000009C   0x6880             LDR      R0,[R0, #+8]
   \   0000009E   0x7900             LDRB     R0,[R0, #+4]
   \   000000A0   0x....             LDR.N    R1,??DataTable7_1
   \   000000A2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000A4   0x013A             LSLS     R2,R7,#+4
   \   000000A6   0x4411             ADD      R1,R1,R2
   \   000000A8   0x7B09             LDRB     R1,[R1, #+12]
   \   000000AA   0x4288             CMP      R0,R1
   \   000000AC   0xD11B             BNE.N    ??USB_DeviceClassInit_9
    479                      {
    480                          (void)s_UsbDeviceClassInterfaceMap[mapIndex].classInit(
    481                              controllerId, &classHandle->configList->config[classIndex],
    482                              &classHandle->configList->config[classIndex].classHandle);
   \   000000AE   0x9800             LDR      R0,[SP, #+0]
   \   000000B0   0x6840             LDR      R0,[R0, #+4]
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000B8   0x210C             MOVS     R1,#+12
   \   000000BA   0xFB01 0xF108      MUL      R1,R1,R8
   \   000000BE   0x4408             ADD      R0,R0,R1
   \   000000C0   0x1D02             ADDS     R2,R0,#+4
   \   000000C2   0x9800             LDR      R0,[SP, #+0]
   \   000000C4   0x6840             LDR      R0,[R0, #+4]
   \   000000C6   0x6800             LDR      R0,[R0, #+0]
   \   000000C8   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000CC   0x210C             MOVS     R1,#+12
   \   000000CE   0xFB01 0xF108      MUL      R1,R1,R8
   \   000000D2   0x4401             ADD      R1,R0,R1
   \   000000D4   0x0020             MOVS     R0,R4
   \   000000D6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D8   0x....             LDR.N    R3,??DataTable7_1
   \   000000DA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000DC   0xEA5F 0x1C07      LSLS     R12,R7,#+4
   \   000000E0   0xF853 0x300C      LDR      R3,[R3, R12]
   \   000000E4   0x4798             BLX      R3
    483                      }
    484                  }
   \                     ??USB_DeviceClassInit_9: (+1)
   \   000000E6   0x1C7F             ADDS     R7,R7,#+1
   \   000000E8   0xE7CC             B.N      ??USB_DeviceClassInit_7
    485              }
   \                     ??USB_DeviceClassInit_8: (+1)
   \   000000EA   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000EE   0xE7C0             B.N      ??USB_DeviceClassInit_5
    486          
    487              *handle = classHandle->handle;
   \                     ??USB_DeviceClassInit_6: (+1)
   \   000000F0   0x9800             LDR      R0,[SP, #+0]
   \   000000F2   0x6800             LDR      R0,[R0, #+0]
   \   000000F4   0x6030             STR      R0,[R6, #+0]
    488              return error;
   \   000000F6   0x4648             MOV      R0,R9
   \   000000F8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceClassInit_2: (+1)
   \   000000FA   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    489          }
    490          
    491          /*!
    492           * @brief De-initialize the common class and the supported classes.
    493           *
    494           * This function is used to de-initialize the common class and the supported classes.
    495           *
    496           * @param controllerId   The controller id of the USB IP. Please refer to the enumeration usb_controller_index_t.
    497           *
    498           * @return A USB error code or kStatus_USB_Success.
    499           */

   \                                 In section .text, align 2, keep-with-next
    500          usb_status_t USB_DeviceClassDeinit(uint8_t controllerId /*!< [IN] Controller ID */
    501                                             )
    502          {
   \                     USB_DeviceClassDeinit: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    503              usb_device_common_class_struct_t *classHandle;
    504              usb_status_t error = kStatus_USB_Error;
   \   00000004   0x2701             MOVS     R7,#+1
    505              uint8_t mapIndex;
    506              uint8_t classIndex;
    507          
    508              /* Get the common class handle according to the controller id. */
    509              error = USB_DeviceClassGetHandleByControllerId(controllerId, &classHandle);
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       USB_DeviceClassGetHandleByControllerId
   \   00000010   0x0007             MOVS     R7,R0
    510          
    511              if (kStatus_USB_Success != error)
   \   00000012   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000014   0x2F00             CMP      R7,#+0
   \   00000016   0xD002             BEQ.N    ??USB_DeviceClassDeinit_0
    512              {
    513                  return error;
   \   00000018   0x0038             MOVS     R0,R7
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xE03F             B.N      ??USB_DeviceClassDeinit_1
    514              }
    515          
    516              /* De-initialize the all supported classes according to the configuration list. */
    517              for (classIndex = 0U; classIndex < classHandle->configList->count; classIndex++)
   \                     ??USB_DeviceClassDeinit_0: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x0006             MOVS     R6,R0
   \                     ??USB_DeviceClassDeinit_2: (+1)
   \   00000022   0x0030             MOVS     R0,R6
   \   00000024   0x9900             LDR      R1,[SP, #+0]
   \   00000026   0x6849             LDR      R1,[R1, #+4]
   \   00000028   0x7A09             LDRB     R1,[R1, #+8]
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD228             BCS.N    ??USB_DeviceClassDeinit_3
    518              {
    519                  for (mapIndex = 0U; mapIndex < (sizeof(s_UsbDeviceClassInterfaceMap) / sizeof(usb_device_class_map_t));
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x0005             MOVS     R5,R0
   \                     ??USB_DeviceClassDeinit_4: (+1)
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D03             CMP      R5,#+3
   \   00000038   0xD221             BCS.N    ??USB_DeviceClassDeinit_5
    520                       mapIndex++)
    521                  {
    522                      if (classHandle->configList->config[classIndex].classInfomation->type ==
    523                          s_UsbDeviceClassInterfaceMap[mapIndex].type)
   \   0000003A   0x9800             LDR      R0,[SP, #+0]
   \   0000003C   0x6840             LDR      R0,[R0, #+4]
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000042   0x210C             MOVS     R1,#+12
   \   00000044   0xFB01 0xF106      MUL      R1,R1,R6
   \   00000048   0x4408             ADD      R0,R0,R1
   \   0000004A   0x6880             LDR      R0,[R0, #+8]
   \   0000004C   0x7900             LDRB     R0,[R0, #+4]
   \   0000004E   0x....             LDR.N    R1,??DataTable7_1
   \   00000050   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000052   0x012A             LSLS     R2,R5,#+4
   \   00000054   0x4411             ADD      R1,R1,R2
   \   00000056   0x7B09             LDRB     R1,[R1, #+12]
   \   00000058   0x4288             CMP      R0,R1
   \   0000005A   0xD10E             BNE.N    ??USB_DeviceClassDeinit_6
    524                      {
    525                          (void)s_UsbDeviceClassInterfaceMap[mapIndex].classDeinit(
    526                              classHandle->configList->config[classIndex].classHandle);
   \   0000005C   0x9800             LDR      R0,[SP, #+0]
   \   0000005E   0x6840             LDR      R0,[R0, #+4]
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000064   0x210C             MOVS     R1,#+12
   \   00000066   0xFB01 0xF106      MUL      R1,R1,R6
   \   0000006A   0x4408             ADD      R0,R0,R1
   \   0000006C   0x6840             LDR      R0,[R0, #+4]
   \   0000006E   0x....             LDR.N    R1,??DataTable7_1
   \   00000070   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000072   0x012A             LSLS     R2,R5,#+4
   \   00000074   0x4411             ADD      R1,R1,R2
   \   00000076   0x6849             LDR      R1,[R1, #+4]
   \   00000078   0x4788             BLX      R1
    527                      }
    528                  }
   \                     ??USB_DeviceClassDeinit_6: (+1)
   \   0000007A   0x1C6D             ADDS     R5,R5,#+1
   \   0000007C   0xE7DA             B.N      ??USB_DeviceClassDeinit_4
    529              }
   \                     ??USB_DeviceClassDeinit_5: (+1)
   \   0000007E   0x1C76             ADDS     R6,R6,#+1
   \   00000080   0xE7CF             B.N      ??USB_DeviceClassDeinit_2
    530          
    531              /* De-initialize the USB device stack. */
    532              error = USB_DeviceDeinit(classHandle->handle);
   \                     ??USB_DeviceClassDeinit_3: (+1)
   \   00000082   0x9800             LDR      R0,[SP, #+0]
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x.... 0x....      BL       USB_DeviceDeinit
   \   0000008A   0x0007             MOVS     R7,R0
    533              if (kStatus_USB_Success == error)
   \   0000008C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000008E   0x2F00             CMP      R7,#+0
   \   00000090   0xD103             BNE.N    ??USB_DeviceClassDeinit_7
    534              {
    535                  /* Free the common class handle. */
    536                  (void)USB_DeviceClassFreeHandle(controllerId);
   \   00000092   0x0020             MOVS     R0,R4
   \   00000094   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000096   0x.... 0x....      BL       USB_DeviceClassFreeHandle
    537              }
    538              return error;
   \                     ??USB_DeviceClassDeinit_7: (+1)
   \   0000009A   0x0038             MOVS     R0,R7
   \   0000009C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceClassDeinit_1: (+1)
   \   0000009E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    539          }
    540          
    541          /*!
    542           * @brief Get the USB bus speed.
    543           *
    544           * This function is used to get the USB bus speed.
    545           *
    546           * @param controllerId   The controller id of the USB IP. Please refer to the enumeration usb_controller_index_t.
    547           * @param speed           It is an OUT parameter, return current speed of the controller.
    548           *
    549           * @return A USB error code or kStatus_USB_Success.
    550           */

   \                                 In section .text, align 2, keep-with-next
    551          usb_status_t USB_DeviceClassGetSpeed(uint8_t controllerId, /*!< [IN] Controller ID */
    552                                               uint8_t *speed        /*!< [OUT] Current speed */
    553                                               )
    554          {
   \                     USB_DeviceClassGetSpeed: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    555              usb_device_common_class_struct_t *classHandle;
    556              usb_status_t error = kStatus_USB_Error;
   \   00000008   0x2601             MOVS     R6,#+1
    557          
    558              /* Get the common class handle according to the controller id. */
    559              error = USB_DeviceClassGetHandleByControllerId(controllerId, &classHandle);
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       USB_DeviceClassGetHandleByControllerId
   \   00000014   0x0006             MOVS     R6,R0
    560          
    561              if (kStatus_USB_Success != error)
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD002             BEQ.N    ??USB_DeviceClassGetSpeed_0
    562              {
    563                  return error;
   \   0000001C   0x0030             MOVS     R0,R6
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0xE008             B.N      ??USB_DeviceClassGetSpeed_1
    564              }
    565          
    566              /* Get the current speed. */
    567              error = USB_DeviceGetStatus(classHandle->handle, kUSB_DeviceStatusSpeed, speed);
   \                     ??USB_DeviceClassGetSpeed_0: (+1)
   \   00000022   0x002A             MOVS     R2,R5
   \   00000024   0x2102             MOVS     R1,#+2
   \   00000026   0x9800             LDR      R0,[SP, #+0]
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x.... 0x....      BL       USB_DeviceGetStatus
   \   0000002E   0x0006             MOVS     R6,R0
    568          
    569              return error;
   \   00000030   0x0030             MOVS     R0,R6
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_DeviceClassGetSpeed_1: (+1)
   \   00000034   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    570          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     s_UsbDeviceCommonClassStruct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     s_UsbDeviceClassInterfaceMap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     USB_DeviceClassCallback
    571          #endif /* USB_DEVICE_CONFIG_NUM */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   USB_DeviceClassAllocateHandle
        16   -> USB_BmEnterCritical
        16   -> USB_BmExitCritical
      24   USB_DeviceClassCallback
        24   -- Indirect call
        24   -> USB_DeviceClassEvent
        24   -> USB_DeviceClassGetHandleByDeviceHandle
        24   -> USB_DeviceControlPipeInit
      24   USB_DeviceClassDeinit
        24   -- Indirect call
        24   -> USB_DeviceClassFreeHandle
        24   -> USB_DeviceClassGetHandleByControllerId
        24   -> USB_DeviceDeinit
      40   USB_DeviceClassEvent
        40   -- Indirect call
        40   -> USB_DeviceClassGetHandleByDeviceHandle
      16   USB_DeviceClassFreeHandle
        16   -> USB_BmEnterCritical
        16   -> USB_BmExitCritical
      16   USB_DeviceClassGetDeviceHandle
        16   -> USB_BmEnterCritical
        16   -> USB_BmExitCritical
      16   USB_DeviceClassGetHandleByControllerId
        16   -> USB_BmEnterCritical
        16   -> USB_BmExitCritical
      16   USB_DeviceClassGetHandleByDeviceHandle
        16   -> USB_BmEnterCritical
        16   -> USB_BmExitCritical
      24   USB_DeviceClassGetSpeed
        24   -> USB_DeviceClassGetHandleByControllerId
        24   -> USB_DeviceGetStatus
      32   USB_DeviceClassInit
        32   -- Indirect call
        32   -> USB_DeviceClassAllocateHandle
        32   -> USB_DeviceClassFreeHandle
        32   -> USB_DeviceDeinit
        32   -> USB_DeviceInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
     140  USB_DeviceClassAllocateHandle
      76  USB_DeviceClassCallback
     160  USB_DeviceClassDeinit
     202  USB_DeviceClassEvent
     118  USB_DeviceClassFreeHandle
      82  USB_DeviceClassGetDeviceHandle
      86  USB_DeviceClassGetHandleByControllerId
      62  USB_DeviceClassGetHandleByDeviceHandle
      54  USB_DeviceClassGetSpeed
     254  USB_DeviceClassInit
      48  s_UsbDeviceClassInterfaceMap
      20  s_UsbDeviceCommonClassStruct

 
    48 bytes in section .rodata
 1 246 bytes in section .text
    20 bytes in section m_usb_global
 
 1 246 bytes of CODE  memory
    48 bytes of CONST memory
    20 bytes of DATA  memory

Errors: none
Warnings: none
