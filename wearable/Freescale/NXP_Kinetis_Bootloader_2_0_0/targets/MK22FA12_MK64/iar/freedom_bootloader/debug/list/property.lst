###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:08
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\property\src\property.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\property\src\property.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\property.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\property.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\property\src\property.c
      1          /*
      2           * Copyright (c) 2013-2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "bootloader_common.h"
     32          #include "property/property.h"
     33          #include "memory/memory.h"
     34          #include "packet/command_packet.h"
     35          #include "packet/serial_packet.h"
     36          #include "bootloader/bl_peripheral.h"
     37          #include "bootloader/bl_context.h"
     38          #include "bootloader/bl_version.h"
     39          #include "utilities/fsl_assert.h"
     40          #include <string.h>
     41          #if !defined(BOOTLOADER_HOST)
     42          #include "flash/fsl_flash.h"
     43          #include "fsl_device_registers.h"
     44          #if BL_FEATURE_QSPI_MODULE
     45          #include "qspi/qspi.h"
     46          #endif // BL_FEATURE_QSPI_MODULE
     47          #if BL_FEATURE_CRC_CHECK
     48          #include "bootloader/bl_app_crc_check.h"
     49          #endif // BL_FEATURE_CRC_CHECK
     50          #endif //! BOOTLOADER_HOST
     51          
     52          ////////////////////////////////////////////////////////////////////////////////
     53          // Declarations
     54          ////////////////////////////////////////////////////////////////////////////////
     55          
     56          #if (defined(__ICCARM__)) // IAR
     57          #pragma section = ".intvec"
     58          #pragma section = "ApplicationFlash"
     59          #pragma section = "ApplicationRam"
     60          #if defined(BL_TARGET_RAM)
     61          #define __RAM_START ((uint32_t)__section_begin(".intvec"))
     62          #else
     63          #define __RAM_START ((uint32_t)__section_begin("ApplicationRam"))
     64          #endif // #if defined(BL_TARGET_RAM)
     65          #define __RAM_END ((uint32_t)__section_end("ApplicationRam") - 1)
     66          #define __ROM_START ((uint32_t)__section_begin(".intvec"))
     67          #define __ROM_END ((uint32_t)__section_end("ApplicationFlash"))
     68          #elif(defined(__CC_ARM)) // MDK
     69          extern uint32_t Image$$VECTOR_ROM$$Base[];
     70          extern uint32_t Image$$ER_m_text$$Limit[];
     71          extern char Image$$VECTOR_RAM$$Base[];
     72          extern uint32_t Image$$ARM_LIB_STACK$$ZI$$Limit[];
     73          #define __RAM_START ((uint32_t)Image$$VECTOR_RAM$$Base)
     74          #define __RAM_END ((uint32_t)Image$$ARM_LIB_STACK$$ZI$$Limit - 1)
     75          #define __ROM_START ((uint32_t)Image$$VECTOR_ROM$$Base)
     76          #define __ROM_END ((uint32_t)Image$$ER_m_text$$Limit)
     77          #elif(defined(__GNUC__)) // GCC
     78          extern uint32_t __VECTOR_RAM[];
     79          extern uint32_t __VECTOR_TABLE[];
     80          extern char __DATA_END[];
     81          extern uint32_t __STACK_TOP[];
     82          #define __RAM_START ((uint32_t)__VECTOR_RAM)
     83          #define __RAM_END ((uint32_t)__STACK_TOP - 1)
     84          #define __ROM_START ((uint32_t)__VECTOR_TABLE)
     85          #define __ROM_END ((uint32_t)__DATA_END)
     86          #else
     87          #error Unknown toolchain!
     88          #endif // __ICCARM__
     89          
     90          ////////////////////////////////////////////////////////////////////////////////
     91          // Variables
     92          ////////////////////////////////////////////////////////////////////////////////
     93          
     94          //! @brief Storage for property values.

   \                                 In section .bss, align 4
     95          property_store_t g_propertyStore;
   \                     g_propertyStore:
   \   00000000                      DS8 188
     96          //! @brief Map for external memory property interface.
     97          extern const external_memory_property_interface_t g_externalMemPropertyInterfaceMap[];
     98          
     99          // See property.h for documentation on this data structure.

   \                                 In section .rodata, align 4
    100          const property_interface_t g_propertyInterface = { bootloader_property_load_user_config, bootloader_property_init,
   \                     g_propertyInterface:
   \   00000000   0x........         DC32 bootloader_property_load_user_config, bootloader_property_init
   \              0x........   
   \   00000008   0x........         DC32 bootloader_property_get, bootloader_property_set_uint32
   \              0x........   
   \   00000010   0x........         DC32 g_propertyStore
    101                                                             bootloader_property_get, bootloader_property_set_uint32,
    102                                                             &g_propertyStore };
    103          
    104          //! @brief Storage for property values computed every time they are read.

   \                                 In section .bss, align 4
    105          static uint32_t s_propertyReturnValue;
   \                     s_propertyReturnValue:
   \   00000000                      DS8 4
    106          
    107          ////////////////////////////////////////////////////////////////////////////////
    108          // Prototypes
    109          ////////////////////////////////////////////////////////////////////////////////
    110          // !@brief Get external memoery proporties
    111          status_t bootloader_get_external_memory_properties(uint8_t memoryId, external_memory_property_store_t *store);
    112          
    113          ////////////////////////////////////////////////////////////////////////////////
    114          // Code
    115          ////////////////////////////////////////////////////////////////////////////////
    116          
    117          // See property.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    118          status_t bootloader_property_load_user_config(void)
    119          {
   \                     bootloader_property_load_user_config: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    120          #if !defined(BOOTLOADER_HOST)
    121          
    122              bootloader_configuration_data_t *config = &g_bootloaderContext.propertyInterface->store->configurationData;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable3
   \   00000006   0x6880             LDR      R0,[R0, #+8]
   \   00000008   0x6900             LDR      R0,[R0, #+16]
   \   0000000A   0xF110 0x046C      ADDS     R4,R0,#+108
    123          
    124          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    125              if (is_in_execute_only_region(kBootloaderConfigAreaAddress, sizeof(bootloader_configuration_data_t)))
    126              {
    127                  memset(config, 0xff, sizeof(bootloader_configuration_data_t));
    128              }
    129              else
    130          #endif // FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    131              {
    132                  // Copy bootloader configuration data from the flash into the property store.
    133                  memcpy(config, (const void *)kBootloaderConfigAreaAddress, sizeof(bootloader_configuration_data_t));
   \   0000000E   0x2534             MOVS     R5,#+52
   \   00000010   0xF24F 0x36C0      MOVW     R6,#+62400
   \   00000014   0x002A             MOVS     R2,R5
   \   00000016   0x0031             MOVS     R1,R6
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       __aeabi_memcpy
    134          
    135                  // Verify tag. If it is invalid, wipe the config data to all 0xff.
    136                  if (kPropertyStoreTag != config->tag)
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable3_1  ;; 0x6766636b
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD006             BEQ.N    ??bootloader_property_load_user_config_0
    137                  {
    138                      memset(config, 0xff, sizeof(bootloader_configuration_data_t));
   \   00000028   0x2534             MOVS     R5,#+52
   \   0000002A   0x26FF             MOVS     R6,#+255
   \   0000002C   0x0032             MOVS     R2,R6
   \   0000002E   0x0029             MOVS     R1,R5
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       __aeabi_memset
    139                  }
    140              }
    141          
    142              // Update available peripherals based on specific chips
    143              update_available_peripherals();
   \                     ??bootloader_property_load_user_config_0: (+1)
   \   00000036   0x.... 0x....      BL       update_available_peripherals
    144          
    145          #endif // BOOTLOADER_HOST
    146          
    147              return kStatus_Success;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
    148          }
    149          
    150          // See property.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    151          status_t bootloader_property_init(void)
    152          {
   \                     bootloader_property_init: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
    153              property_store_t *propertyStore = g_bootloaderContext.propertyInterface->store;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable3
   \   00000008   0x6880             LDR      R0,[R0, #+8]
   \   0000000A   0x6904             LDR      R4,[R0, #+16]
    154          
    155              // Fill in default values.
    156              propertyStore->bootloaderVersion.name = kBootloader_Version_Name;
   \   0000000C   0x204B             MOVS     R0,#+75
   \   0000000E   0x70E0             STRB     R0,[R4, #+3]
    157              propertyStore->bootloaderVersion.major = kBootloader_Version_Major;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0x70A0             STRB     R0,[R4, #+2]
    158              propertyStore->bootloaderVersion.minor = kBootloader_Version_Minor;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x7060             STRB     R0,[R4, #+1]
    159              propertyStore->bootloaderVersion.bugfix = kBootloader_Version_Bugfix;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x7020             STRB     R0,[R4, #+0]
    160          
    161              propertyStore->serialProtocolVersion.name = kSerialProtocol_Version_Name;
   \   0000001C   0x2050             MOVS     R0,#+80
   \   0000001E   0x71E0             STRB     R0,[R4, #+7]
    162              propertyStore->serialProtocolVersion.major = kSerialProtocol_Version_Major;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x71A0             STRB     R0,[R4, #+6]
    163              propertyStore->serialProtocolVersion.minor = kSerialProtocol_Version_Minor;
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0x7160             STRB     R0,[R4, #+5]
    164              propertyStore->serialProtocolVersion.bugfix = kSerialProtocol_Version_Bugfix;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x7120             STRB     R0,[R4, #+4]
    165          
    166          #if defined(BOOTLOADER_HOST)
    167              propertyStore->targetVersion.name = 'H';
    168              propertyStore->targetVersion.major = 1;
    169              propertyStore->targetVersion.minor = 0;
    170              propertyStore->targetVersion.bugfix = 0;
    171          #else
    172              propertyStore->targetVersion.name = kTarget_Version_Name;
   \   0000002C   0x2054             MOVS     R0,#+84
   \   0000002E   0x72E0             STRB     R0,[R4, #+11]
    173              propertyStore->targetVersion.major = kTarget_Version_Major;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x72A0             STRB     R0,[R4, #+10]
    174              propertyStore->targetVersion.minor = kTarget_Version_Minor;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x7260             STRB     R0,[R4, #+9]
    175              propertyStore->targetVersion.bugfix = kTarget_Version_Bugfix;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7220             STRB     R0,[R4, #+8]
    176          #endif
    177              propertyStore->verifyWrites = true;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x6320             STR      R0,[R4, #+48]
    178          
    179              propertyStore->availableCommands = kAvailableCommands;
   \   00000040   0xF64E 0x70FF      MOVW     R0,#+61439
   \   00000044   0x6360             STR      R0,[R4, #+52]
    180          
    181          #if !defined(BOOTLOADER_HOST)
    182          
    183              /// Initialize flash properties.
    184              g_bootloaderContext.flashDriverInterface->flash_get_property(
    185                  &g_bootloaderContext.flashState, kFLASH_PropertyPflashBlockBaseAddr, &propertyStore->flashStartAddress);
   \   00000046   0xF114 0x0210      ADDS     R2,R4,#+16
   \   0000004A   0x2104             MOVS     R1,#+4
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \   00000050   0x....             LDR.N    R3,??DataTable3
   \   00000052   0x691B             LDR      R3,[R3, #+16]
   \   00000054   0x6ADB             LDR      R3,[R3, #+44]
   \   00000056   0x4798             BLX      R3
    186              g_bootloaderContext.flashDriverInterface->flash_get_property(
    187                  &g_bootloaderContext.flashState, kFLASH_PropertyPflashTotalSize, &propertyStore->flashSizeInBytes);
   \   00000058   0xF114 0x0214      ADDS     R2,R4,#+20
   \   0000005C   0x2101             MOVS     R1,#+1
   \   0000005E   0x....             LDR.N    R0,??DataTable3_2
   \   00000060   0x....             LDR.N    R3,??DataTable3
   \   00000062   0x691B             LDR      R3,[R3, #+16]
   \   00000064   0x6ADB             LDR      R3,[R3, #+44]
   \   00000066   0x4798             BLX      R3
    188              g_bootloaderContext.flashDriverInterface->flash_get_property(
    189                  &g_bootloaderContext.flashState, kFLASH_PropertyPflashSectorSize, &propertyStore->flashSectorSize);
   \   00000068   0xF114 0x0218      ADDS     R2,R4,#+24
   \   0000006C   0x2100             MOVS     R1,#+0
   \   0000006E   0x....             LDR.N    R0,??DataTable3_2
   \   00000070   0x....             LDR.N    R3,??DataTable3
   \   00000072   0x691B             LDR      R3,[R3, #+16]
   \   00000074   0x6ADB             LDR      R3,[R3, #+44]
   \   00000076   0x4798             BLX      R3
    190              g_bootloaderContext.flashDriverInterface->flash_get_property(
    191                  &g_bootloaderContext.flashState, kFLASH_PropertyPflashBlockSize, &propertyStore->flashBlockSize);
   \   00000078   0xF114 0x021C      ADDS     R2,R4,#+28
   \   0000007C   0x2102             MOVS     R1,#+2
   \   0000007E   0x....             LDR.N    R0,??DataTable3_2
   \   00000080   0x....             LDR.N    R3,??DataTable3
   \   00000082   0x691B             LDR      R3,[R3, #+16]
   \   00000084   0x6ADB             LDR      R3,[R3, #+44]
   \   00000086   0x4798             BLX      R3
    192              g_bootloaderContext.flashDriverInterface->flash_get_property(
    193                  &g_bootloaderContext.flashState, kFLASH_PropertyPflashBlockCount, &propertyStore->flashBlockCount);
   \   00000088   0xF114 0x0220      ADDS     R2,R4,#+32
   \   0000008C   0x2103             MOVS     R1,#+3
   \   0000008E   0x....             LDR.N    R0,??DataTable3_2
   \   00000090   0x....             LDR.N    R3,??DataTable3
   \   00000092   0x691B             LDR      R3,[R3, #+16]
   \   00000094   0x6ADB             LDR      R3,[R3, #+44]
   \   00000096   0x4798             BLX      R3
    194              g_bootloaderContext.flashDriverInterface->flash_get_property(
    195                  &g_bootloaderContext.flashState, kFLASH_PropertyPflashFacSupport, &propertyStore->flashFacSupport);
   \   00000098   0xF114 0x0248      ADDS     R2,R4,#+72
   \   0000009C   0x2105             MOVS     R1,#+5
   \   0000009E   0x....             LDR.N    R0,??DataTable3_2
   \   000000A0   0x....             LDR.N    R3,??DataTable3
   \   000000A2   0x691B             LDR      R3,[R3, #+16]
   \   000000A4   0x6ADB             LDR      R3,[R3, #+44]
   \   000000A6   0x4798             BLX      R3
    196              g_bootloaderContext.flashDriverInterface->flash_get_property(&g_bootloaderContext.flashState,
    197                                                                           kFLASH_PropertyPflashAccessSegmentSize,
    198                                                                           &propertyStore->flashAccessSegmentSize);
   \   000000A8   0xF114 0x024C      ADDS     R2,R4,#+76
   \   000000AC   0x2106             MOVS     R1,#+6
   \   000000AE   0x....             LDR.N    R0,??DataTable3_2
   \   000000B0   0x....             LDR.N    R3,??DataTable3
   \   000000B2   0x691B             LDR      R3,[R3, #+16]
   \   000000B4   0x6ADB             LDR      R3,[R3, #+44]
   \   000000B6   0x4798             BLX      R3
    199              g_bootloaderContext.flashDriverInterface->flash_get_property(&g_bootloaderContext.flashState,
    200                                                                           kFLASH_PropertyPflashAccessSegmentCount,
    201                                                                           &propertyStore->flashAccessSegmentCount);
   \   000000B8   0xF114 0x0250      ADDS     R2,R4,#+80
   \   000000BC   0x2107             MOVS     R1,#+7
   \   000000BE   0x....             LDR.N    R0,??DataTable3_2
   \   000000C0   0x....             LDR.N    R3,??DataTable3
   \   000000C2   0x691B             LDR      R3,[R3, #+16]
   \   000000C4   0x6ADB             LDR      R3,[R3, #+44]
   \   000000C6   0x4798             BLX      R3
    202          
    203              // Fill in reserved regions.
    204              //! @todo Support other tool chain
    205          
    206              uint32_t flashStart = 0;
   \   000000C8   0x2700             MOVS     R7,#+0
    207              uint32_t flashEnd = 0;
   \   000000CA   0xF05F 0x0800      MOVS     R8,#+0
    208              uint32_t ramStart = 0;
   \   000000CE   0x2500             MOVS     R5,#+0
    209              uint32_t ramEnd = 0;
   \   000000D0   0x2600             MOVS     R6,#+0
    210          
    211          #if !BL_TARGET_FLASH
    212              flashStart = (&g_bootloaderContext.memoryMap[kIndexFlashArray])->startAddress;
    213              flashEnd = (&g_bootloaderContext.memoryMap[kIndexFlashArray])->startAddress;
    214          #else
    215              flashStart = __ROM_START;
   \   000000D2   0x....             LDR.N    R0,??DataTable3_3
   \   000000D4   0x0007             MOVS     R7,R0
    216              flashEnd = __ROM_END;
   \   000000D6   0x....             LDR.N    R0,??DataTable3_4
   \   000000D8   0x4680             MOV      R8,R0
    217              assert(flashEnd);
    218          
    219              // Force flash erase size alignment.
    220              flashStart = ALIGN_DOWN(flashStart, propertyStore->flashSectorSize);
   \   000000DA   0x69A0             LDR      R0,[R4, #+24]
   \   000000DC   0x4240             RSBS     R0,R0,#+0
   \   000000DE   0x4007             ANDS     R7,R0,R7
    221              flashEnd = ALIGN_UP(flashEnd, propertyStore->flashSectorSize) - 1;
   \   000000E0   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000E4   0xF1D8 0x0100      RSBS     R1,R8,#+0
   \   000000E8   0x69A2             LDR      R2,[R4, #+24]
   \   000000EA   0x4252             RSBS     R2,R2,#+0
   \   000000EC   0x4011             ANDS     R1,R2,R1
   \   000000EE   0xEBB0 0x0801      SUBS     R8,R0,R1
    222          #endif
    223              ramStart = __RAM_START;
   \   000000F2   0x....             LDR.N    R0,??DataTable3_5
   \   000000F4   0x0005             MOVS     R5,R0
    224              ramEnd = __RAM_END;
   \   000000F6   0x....             LDR.N    R0,??DataTable3_6
   \   000000F8   0x0006             MOVS     R6,R0
    225              assert(ramEnd);
    226          
    227              propertyStore->reservedRegions[kProperty_FlashReservedRegionIndex].startAddress = flashStart;
   \   000000FA   0x65E7             STR      R7,[R4, #+92]
    228              propertyStore->reservedRegions[kProperty_FlashReservedRegionIndex].endAddress = flashEnd;
   \   000000FC   0xF8C4 0x8060      STR      R8,[R4, #+96]
    229              propertyStore->reservedRegions[kProperty_RamReservedRegionIndex].startAddress = ramStart;
   \   00000100   0x6665             STR      R5,[R4, #+100]
    230              propertyStore->reservedRegions[kProperty_RamReservedRegionIndex].endAddress = ramEnd;
   \   00000102   0x66A6             STR      R6,[R4, #+104]
    231          
    232              // Fill in available peripherals array.
    233              const peripheral_descriptor_t *peripherals = g_bootloaderContext.allPeripherals;
   \   00000104   0x....             LDR.N    R0,??DataTable3
   \   00000106   0xF8D0 0x9014      LDR      R9,[R0, #+20]
    234              propertyStore->availablePeripherals = 0;
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0x60E0             STR      R0,[R4, #+12]
    235              for (uint32_t i = 0; peripherals[i].typeMask != 0; ++i)
   \   0000010E   0x2000             MOVS     R0,#+0
   \                     ??bootloader_property_init_0: (+1)
   \   00000110   0x2118             MOVS     R1,#+24
   \   00000112   0xFB01 0xF100      MUL      R1,R1,R0
   \   00000116   0xF859 0x1001      LDR      R1,[R9, R1]
   \   0000011A   0x2900             CMP      R1,#+0
   \   0000011C   0xD012             BEQ.N    ??bootloader_property_init_1
    236              {
    237                  // Check that the peripheral is enabled in the user configuration data.
    238                  if (propertyStore->configurationData.enabledPeripherals & peripherals[i].typeMask)
   \   0000011E   0xF894 0x107C      LDRB     R1,[R4, #+124]
   \   00000122   0x2218             MOVS     R2,#+24
   \   00000124   0xFB02 0xF200      MUL      R2,R2,R0
   \   00000128   0xF859 0x2002      LDR      R2,[R9, R2]
   \   0000012C   0x4211             TST      R1,R2
   \   0000012E   0xD007             BEQ.N    ??bootloader_property_init_2
    239                  {
    240                      propertyStore->availablePeripherals |= peripherals[i].typeMask;
   \   00000130   0x68E1             LDR      R1,[R4, #+12]
   \   00000132   0x2218             MOVS     R2,#+24
   \   00000134   0xFB02 0xF200      MUL      R2,R2,R0
   \   00000138   0xF859 0x2002      LDR      R2,[R9, R2]
   \   0000013C   0x4311             ORRS     R1,R2,R1
   \   0000013E   0x60E1             STR      R1,[R4, #+12]
    241                  }
    242              }
   \                     ??bootloader_property_init_2: (+1)
   \   00000140   0x1C40             ADDS     R0,R0,#+1
   \   00000142   0xE7E5             B.N      ??bootloader_property_init_0
    243          
    244          // Fill in unique device id value.
    245          // Different series have different length of UID (K series=128 bits, KL series=80 bits)
    246          #if defined(SIM_UIDH)
    247              propertyStore->UniqueDeviceId.uidh = SIM_RD_UIDH(SIM);
   \                     ??bootloader_property_init_1: (+1)
   \   00000144   0x....             LDR.N    R0,??DataTable3_7  ;; 0x40048054
   \   00000146   0x6800             LDR      R0,[R0, #+0]
   \   00000148   0x6460             STR      R0,[R4, #+68]
    248          #endif
    249              propertyStore->UniqueDeviceId.uidmh = SIM->UIDMH;
   \   0000014A   0x....             LDR.N    R0,??DataTable3_8  ;; 0x40048058
   \   0000014C   0x6800             LDR      R0,[R0, #+0]
   \   0000014E   0x6420             STR      R0,[R4, #+64]
    250              propertyStore->UniqueDeviceId.uidml = SIM->UIDML;
   \   00000150   0x....             LDR.N    R0,??DataTable3_9  ;; 0x4004805c
   \   00000152   0x6800             LDR      R0,[R0, #+0]
   \   00000154   0x63E0             STR      R0,[R4, #+60]
    251              propertyStore->UniqueDeviceId.uidl = SIM->UIDL;
   \   00000156   0x....             LDR.N    R0,??DataTable3_10  ;; 0x40048060
   \   00000158   0x6800             LDR      R0,[R0, #+0]
   \   0000015A   0x63A0             STR      R0,[R4, #+56]
    252          
    253              // Set address range of RAM in property interface
    254              const memory_map_entry_t *map = (memory_map_entry_t *)&g_bootloaderContext.memoryMap[kIndexSRAM];
   \   0000015C   0x....             LDR.N    R0,??DataTable3
   \   0000015E   0x6840             LDR      R0,[R0, #+4]
   \   00000160   0xF110 0x0A10      ADDS     R10,R0,#+16
    255              propertyStore->ramStartAddress[kIndexSRAM - 1] = map->startAddress;
   \   00000164   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000168   0x6260             STR      R0,[R4, #+36]
    256              propertyStore->ramSizeInBytes[kIndexSRAM - 1] = map->endAddress - map->startAddress + 1;
   \   0000016A   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \   0000016E   0xF8DA 0x1000      LDR      R1,[R10, #+0]
   \   00000172   0x1A40             SUBS     R0,R0,R1
   \   00000174   0x1C40             ADDS     R0,R0,#+1
   \   00000176   0x62A0             STR      R0,[R4, #+40]
    257          #if CPU_IS_ARM_CORTEX_M7
    258              map = (memory_map_entry_t *)&g_bootloaderContext.memoryMap[kIndexDTCM];
    259              propertyStore->ramStartAddress[kIndexDTCM - 1] = map->startAddress;
    260              propertyStore->ramSizeInBytes[kIndexDTCM - 1] = map->endAddress - map->startAddress + 1;
    261              map = (memory_map_entry_t *)&g_bootloaderContext.memoryMap[kIndexOCRAM];
    262              propertyStore->ramStartAddress[kIndexOCRAM - 1] = map->startAddress;
    263              propertyStore->ramSizeInBytes[kIndexOCRAM - 1] = map->endAddress - map->startAddress + 1;
    264          
    265          #endif
    266          
    267          #if BL_FEATURE_CRC_CHECK
    268              // Initialize crc check status property based on BCA related fields.
    269              init_crc_check_status(propertyStore);
   \   00000178   0x0020             MOVS     R0,R4
   \   0000017A   0x.... 0x....      BL       init_crc_check_status
    270          #endif
    271          
    272              // Fill in default margin level.
    273              propertyStore->flashReadMargin = (uint32_t)kFLASH_MarginValueUser;
   \   0000017E   0x2001             MOVS     R0,#+1
   \   00000180   0x6560             STR      R0,[R4, #+84]
    274          
    275          #if BL_FEATURE_QSPI_MODULE
    276              propertyStore->qspiInitStatus = get_qspi_otfad_init_status();
    277          #endif // BL_FEATURE_QSPI_MODULE
    278          
    279          #else
    280          
    281              const memory_map_entry_t *entry;
    282          
    283              // Initialize simulated flash properties.
    284              entry = &g_bootloaderContext.memoryMap[kIndexFlashArray];
    285          
    286              propertyStore->flashStartAddress = entry->startAddress;
    287              propertyStore->flashSizeInBytes = entry->endAddress - entry->startAddress + 1;
    288              propertyStore->flashSectorSize = 1024;
    289              propertyStore->flashBlockSize = propertyStore->flashSizeInBytes;
    290              propertyStore->flashBlockCount = 1;
    291          
    292              // Initialize simulated RAM properties.
    293              entry = &g_bootloaderContext.memoryMap[kIndexSRAM];
    294          
    295              propertyStore->ramStartAddress = entry->startAddress;
    296              propertyStore->ramSizeInBytes = entry->endAddress - entry->startAddress + 1;
    297          
    298          #endif // !BOOTLOADER_HOST
    299          
    300              return kStatus_Success;
   \   00000182   0x2000             MOVS     R0,#+0
   \   00000184   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    301          }
    302          
    303          // See property.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    304          status_t bootloader_property_get(uint8_t tag, uint8_t id, const void **value, uint32_t *valueSize)
    305          {
   \                     bootloader_property_get: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    306              property_store_t *propertyStore = g_bootloaderContext.propertyInterface->store;
   \   0000000E   0x....             LDR.N    R0,??DataTable3
   \   00000010   0x6880             LDR      R0,[R0, #+8]
   \   00000012   0xF8D0 0x8010      LDR      R8,[R0, #+16]
    307          
    308              // Set default value size, may be modified below.
    309              uint32_t returnSize = sizeof(uint32_t);
   \   00000016   0xF05F 0x0904      MOVS     R9,#+4
    310              const void *returnValue;
    311              switch (tag)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD028             BEQ.N    ??bootloader_property_get_0
   \   00000022   0x2802             CMP      R0,#+2
   \   00000024   0xD028             BEQ.N    ??bootloader_property_get_1
   \   00000026   0x2803             CMP      R0,#+3
   \   00000028   0xD02A             BEQ.N    ??bootloader_property_get_2
   \   0000002A   0x2804             CMP      R0,#+4
   \   0000002C   0xD02C             BEQ.N    ??bootloader_property_get_3
   \   0000002E   0x2805             CMP      R0,#+5
   \   00000030   0xD02E             BEQ.N    ??bootloader_property_get_4
   \   00000032   0x2806             CMP      R0,#+6
   \   00000034   0xD030             BEQ.N    ??bootloader_property_get_5
   \   00000036   0x2807             CMP      R0,#+7
   \   00000038   0xD03A             BEQ.N    ??bootloader_property_get_6
   \   0000003A   0x2808             CMP      R0,#+8
   \   0000003C   0xD03C             BEQ.N    ??bootloader_property_get_7
   \   0000003E   0x280A             CMP      R0,#+10
   \   00000040   0xD03E             BEQ.N    ??bootloader_property_get_8
   \   00000042   0x280B             CMP      R0,#+11
   \   00000044   0xD040             BEQ.N    ??bootloader_property_get_9
   \   00000046   0x280C             CMP      R0,#+12
   \   00000048   0xD04A             BEQ.N    ??bootloader_property_get_10
   \   0000004A   0x280E             CMP      R0,#+14
   \   0000004C   0xD028             BEQ.N    ??bootloader_property_get_11
   \   0000004E   0x280F             CMP      R0,#+15
   \   00000050   0xD02A             BEQ.N    ??bootloader_property_get_12
   \   00000052   0x2810             CMP      R0,#+16
   \   00000054   0xD04A             BEQ.N    ??bootloader_property_get_13
   \   00000056   0x2811             CMP      R0,#+17
   \   00000058   0xD04F             BEQ.N    ??bootloader_property_get_14
   \   0000005A   0x2812             CMP      R0,#+18
   \   0000005C   0xD060             BEQ.N    ??bootloader_property_get_15
   \   0000005E   0x2813             CMP      R0,#+19
   \   00000060   0xD064             BEQ.N    ??bootloader_property_get_16
   \   00000062   0x2814             CMP      R0,#+20
   \   00000064   0xD068             BEQ.N    ??bootloader_property_get_17
   \   00000066   0x2815             CMP      R0,#+21
   \   00000068   0xD06C             BEQ.N    ??bootloader_property_get_18
   \   0000006A   0x2816             CMP      R0,#+22
   \   0000006C   0xD070             BEQ.N    ??bootloader_property_get_19
   \   0000006E   0x2818             CMP      R0,#+24
   \   00000070   0xD074             BEQ.N    ??bootloader_property_get_20
   \   00000072   0xE077             B.N      ??bootloader_property_get_21
    312              {
    313                  case kPropertyTag_BootloaderVersion:
    314                      returnValue = &propertyStore->bootloaderVersion.version;
   \                     ??bootloader_property_get_0: (+1)
   \   00000074   0x46C2             MOV      R10,R8
    315                      break;
   \   00000076   0xE078             B.N      ??bootloader_property_get_22
    316          
    317                  case kPropertyTag_AvailablePeripherals:
    318                      returnValue = &propertyStore->availablePeripherals;
   \                     ??bootloader_property_get_1: (+1)
   \   00000078   0xF118 0x000C      ADDS     R0,R8,#+12
   \   0000007C   0x4682             MOV      R10,R0
    319                      break;
   \   0000007E   0xE074             B.N      ??bootloader_property_get_22
    320          
    321                  case kPropertyTag_FlashStartAddress:
    322                      returnValue = &propertyStore->flashStartAddress;
   \                     ??bootloader_property_get_2: (+1)
   \   00000080   0xF118 0x0010      ADDS     R0,R8,#+16
   \   00000084   0x4682             MOV      R10,R0
    323                      break;
   \   00000086   0xE070             B.N      ??bootloader_property_get_22
    324          
    325                  case kPropertyTag_FlashSizeInBytes:
    326                      returnValue = &propertyStore->flashSizeInBytes;
   \                     ??bootloader_property_get_3: (+1)
   \   00000088   0xF118 0x0014      ADDS     R0,R8,#+20
   \   0000008C   0x4682             MOV      R10,R0
    327                      break;
   \   0000008E   0xE06C             B.N      ??bootloader_property_get_22
    328          
    329                  case kPropertyTag_FlashSectorSize:
    330                      returnValue = &propertyStore->flashSectorSize;
   \                     ??bootloader_property_get_4: (+1)
   \   00000090   0xF118 0x0018      ADDS     R0,R8,#+24
   \   00000094   0x4682             MOV      R10,R0
    331                      break;
   \   00000096   0xE068             B.N      ??bootloader_property_get_22
    332          
    333                  case kPropertyTag_FlashBlockCount:
    334                      returnValue = &propertyStore->flashBlockCount;
   \                     ??bootloader_property_get_5: (+1)
   \   00000098   0xF118 0x0020      ADDS     R0,R8,#+32
   \   0000009C   0x4682             MOV      R10,R0
    335                      break;
   \   0000009E   0xE064             B.N      ??bootloader_property_get_22
    336          
    337                  case kPropertyTag_RAMStartAddress:
    338                      returnValue = &propertyStore->ramStartAddress[0];
   \                     ??bootloader_property_get_11: (+1)
   \   000000A0   0xF118 0x0024      ADDS     R0,R8,#+36
   \   000000A4   0x4682             MOV      R10,R0
    339          
    340          #if CPU_IS_ARM_CORTEX_M7
    341                      returnValue = &propertyStore->ramStartAddress[id];
    342          #endif // CPU_IS_ARM_CORTEX_M7
    343          
    344                      break;
   \   000000A6   0xE060             B.N      ??bootloader_property_get_22
    345          
    346                  case kPropertyTag_RAMSizeInBytes:
    347                      returnValue = &propertyStore->ramSizeInBytes[0];
   \                     ??bootloader_property_get_12: (+1)
   \   000000A8   0xF118 0x0028      ADDS     R0,R8,#+40
   \   000000AC   0x4682             MOV      R10,R0
    348          
    349          #if CPU_IS_ARM_CORTEX_M7
    350                      returnValue = &propertyStore->ramSizeInBytes[id];
    351          #endif // CPU_IS_ARM_CORTEX_M7
    352          
    353                      break;
   \   000000AE   0xE05C             B.N      ??bootloader_property_get_22
    354          
    355                  case kPropertyTag_AvailableCommands:
    356                      returnValue = &propertyStore->availableCommands;
   \                     ??bootloader_property_get_6: (+1)
   \   000000B0   0xF118 0x0034      ADDS     R0,R8,#+52
   \   000000B4   0x4682             MOV      R10,R0
    357                      break;
   \   000000B6   0xE058             B.N      ??bootloader_property_get_22
    358          
    359          #if BL_FEATURE_CRC_CHECK
    360                  case kPropertyTag_CrcCheckStatus:
    361                      returnValue = &propertyStore->crcCheckStatus;
   \                     ??bootloader_property_get_7: (+1)
   \   000000B8   0xF118 0x002C      ADDS     R0,R8,#+44
   \   000000BC   0x4682             MOV      R10,R0
    362                      break;
   \   000000BE   0xE054             B.N      ??bootloader_property_get_22
    363          #endif // else falls through to unknown
    364          
    365                  case kPropertyTag_VerifyWrites:
    366                      returnValue = &propertyStore->verifyWrites;
   \                     ??bootloader_property_get_8: (+1)
   \   000000C0   0xF118 0x0030      ADDS     R0,R8,#+48
   \   000000C4   0x4682             MOV      R10,R0
    367                      break;
   \   000000C6   0xE050             B.N      ??bootloader_property_get_22
    368          
    369                  case kPropertyTag_MaxPacketSize:
    370                      // Read the max packet size from the active peripheral.
    371                      s_propertyReturnValue = g_bootloaderContext.activePeripheral->packetInterface->getMaxPacketSize(
    372                          g_bootloaderContext.activePeripheral);
   \                     ??bootloader_property_get_9: (+1)
   \   000000C8   0x....             LDR.N    R0,??DataTable3
   \   000000CA   0x69C0             LDR      R0,[R0, #+28]
   \   000000CC   0x....             LDR.N    R1,??DataTable3
   \   000000CE   0x69C9             LDR      R1,[R1, #+28]
   \   000000D0   0x6949             LDR      R1,[R1, #+20]
   \   000000D2   0x6949             LDR      R1,[R1, #+20]
   \   000000D4   0x4788             BLX      R1
   \   000000D6   0x....             LDR.N    R1,??DataTable3_11
   \   000000D8   0x6008             STR      R0,[R1, #+0]
    373                      returnValue = &s_propertyReturnValue;
   \   000000DA   0x....             LDR.N    R0,??DataTable3_11
   \   000000DC   0x4682             MOV      R10,R0
    374                      break;
   \   000000DE   0xE044             B.N      ??bootloader_property_get_22
    375          
    376                  case kPropertyTag_ReservedRegions:
    377                      returnSize = sizeof(propertyStore->reservedRegions);
   \                     ??bootloader_property_get_10: (+1)
   \   000000E0   0x2010             MOVS     R0,#+16
   \   000000E2   0x4681             MOV      R9,R0
    378                      returnValue = propertyStore->reservedRegions;
   \   000000E4   0xF118 0x005C      ADDS     R0,R8,#+92
   \   000000E8   0x4682             MOV      R10,R0
    379                      break;
   \   000000EA   0xE03E             B.N      ??bootloader_property_get_22
    380          
    381                  case kPropertyTag_SystemDeviceId:
    382          // Get system device identification
    383          #if BOOTLOADER_HOST
    384                      s_propertyReturnValue = 0;
    385          #else
    386                      s_propertyReturnValue = SIM->SDID;
   \                     ??bootloader_property_get_13: (+1)
   \   000000EC   0x....             LDR.N    R0,??DataTable3_12  ;; 0x40048024
   \   000000EE   0x6800             LDR      R0,[R0, #+0]
   \   000000F0   0x....             LDR.N    R1,??DataTable3_11
   \   000000F2   0x6008             STR      R0,[R1, #+0]
    387          #endif // BOOTLOADER_HOST
    388                      returnValue = &s_propertyReturnValue;
   \   000000F4   0x....             LDR.N    R0,??DataTable3_11
   \   000000F6   0x4682             MOV      R10,R0
    389                      break;
   \   000000F8   0xE037             B.N      ??bootloader_property_get_22
    390          
    391                  case kPropertyTag_FlashSecurityState:
    392                  {
    393          #if BOOTLOADER_HOST
    394                      s_propertyReturnValue = 0;
    395          #else
    396                      flash_security_state_t securityState;
    397                      g_bootloaderContext.flashDriverInterface->flash_get_security_state(&g_bootloaderContext.flashState,
    398                                                                                         &securityState);
   \                     ??bootloader_property_get_14: (+1)
   \   000000FA   0x4669             MOV      R1,SP
   \   000000FC   0x....             LDR.N    R0,??DataTable3_2
   \   000000FE   0x....             LDR.N    R2,??DataTable3
   \   00000100   0x6912             LDR      R2,[R2, #+16]
   \   00000102   0x6992             LDR      R2,[R2, #+24]
   \   00000104   0x4790             BLX      R2
    399                      s_propertyReturnValue = (securityState != kFLASH_SecurityStateNotSecure);
   \   00000106   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000010A   0x2800             CMP      R0,#+0
   \   0000010C   0xD001             BEQ.N    ??bootloader_property_get_23
   \   0000010E   0x2001             MOVS     R0,#+1
   \   00000110   0xE000             B.N      ??bootloader_property_get_24
   \                     ??bootloader_property_get_23: (+1)
   \   00000112   0x2000             MOVS     R0,#+0
   \                     ??bootloader_property_get_24: (+1)
   \   00000114   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000116   0x....             LDR.N    R1,??DataTable3_11
   \   00000118   0x6008             STR      R0,[R1, #+0]
    400          #endif // BOOTLOADER_HOST
    401                      returnValue = &s_propertyReturnValue;
   \   0000011A   0x....             LDR.N    R0,??DataTable3_11
   \   0000011C   0x4682             MOV      R10,R0
    402                      break;
   \   0000011E   0xE024             B.N      ??bootloader_property_get_22
    403                  }
    404          
    405                  case kPropertyTag_UniqueDeviceId:
    406                      returnSize = sizeof(propertyStore->UniqueDeviceId);
   \                     ??bootloader_property_get_15: (+1)
   \   00000120   0x2010             MOVS     R0,#+16
   \   00000122   0x4681             MOV      R9,R0
    407                      returnValue = &propertyStore->UniqueDeviceId;
   \   00000124   0xF118 0x0038      ADDS     R0,R8,#+56
   \   00000128   0x4682             MOV      R10,R0
    408                      break;
   \   0000012A   0xE01E             B.N      ??bootloader_property_get_22
    409          
    410                  case kPropertyTag_FacSupport:
    411                      returnSize = sizeof(propertyStore->flashFacSupport);
   \                     ??bootloader_property_get_16: (+1)
   \   0000012C   0x2004             MOVS     R0,#+4
   \   0000012E   0x4681             MOV      R9,R0
    412                      returnValue = &propertyStore->flashFacSupport;
   \   00000130   0xF118 0x0048      ADDS     R0,R8,#+72
   \   00000134   0x4682             MOV      R10,R0
    413                      break;
   \   00000136   0xE018             B.N      ??bootloader_property_get_22
    414          
    415                  case kPropertyTag_FlashAccessSegmentSize:
    416                      returnSize = sizeof(propertyStore->flashAccessSegmentSize);
   \                     ??bootloader_property_get_17: (+1)
   \   00000138   0x2004             MOVS     R0,#+4
   \   0000013A   0x4681             MOV      R9,R0
    417                      returnValue = &propertyStore->flashAccessSegmentSize;
   \   0000013C   0xF118 0x004C      ADDS     R0,R8,#+76
   \   00000140   0x4682             MOV      R10,R0
    418                      break;
   \   00000142   0xE012             B.N      ??bootloader_property_get_22
    419          
    420                  case kPropertyTag_FlashAccessSegmentCount:
    421                      returnSize = sizeof(propertyStore->flashAccessSegmentCount);
   \                     ??bootloader_property_get_18: (+1)
   \   00000144   0x2004             MOVS     R0,#+4
   \   00000146   0x4681             MOV      R9,R0
    422                      returnValue = &propertyStore->flashAccessSegmentCount;
   \   00000148   0xF118 0x0050      ADDS     R0,R8,#+80
   \   0000014C   0x4682             MOV      R10,R0
    423                      break;
   \   0000014E   0xE00C             B.N      ??bootloader_property_get_22
    424          
    425                  case kPropertyTag_FlashReadMargin:
    426                      returnSize = sizeof(propertyStore->flashReadMargin);
   \                     ??bootloader_property_get_19: (+1)
   \   00000150   0x2004             MOVS     R0,#+4
   \   00000152   0x4681             MOV      R9,R0
    427                      returnValue = &propertyStore->flashReadMargin;
   \   00000154   0xF118 0x0054      ADDS     R0,R8,#+84
   \   00000158   0x4682             MOV      R10,R0
    428                      break;
   \   0000015A   0xE006             B.N      ??bootloader_property_get_22
    429          
    430          #if BL_FEATURE_QSPI_MODULE
    431                  case kPropertyTag_QspiInitStatus:
    432                      returnValue = &propertyStore->qspiInitStatus;
    433                      break;
    434          #endif // else falls through to unknown
    435          
    436                  case kPropertyTag_TargetVersion:
    437                      returnValue = &propertyStore->targetVersion.version;
   \                     ??bootloader_property_get_20: (+1)
   \   0000015C   0xF118 0x0008      ADDS     R0,R8,#+8
   \   00000160   0x4682             MOV      R10,R0
    438                      break;
   \   00000162   0xE002             B.N      ??bootloader_property_get_22
    439          #if BL_FEATURE_EXTERNAL_MEMORY_PROPERTY
    440                  case kPropertyTag_ExternalMemoryAttributes:
    441                  {
    442                      status_t status =
    443                          bootloader_get_external_memory_properties(id, &propertyStore->externalMemoryPropertyStore);
    444                      if (status != kStatus_Success)
    445                      {
    446                          return status;
    447                      }
    448                  }
    449                      returnSize = sizeof(propertyStore->externalMemoryPropertyStore);
    450                      returnValue = &propertyStore->externalMemoryPropertyStore;
    451                      break;
    452          #endif // BL_FEATURE_EXTERNAL_MEMORY_PROPERTY
    453          
    454          #if BL_FEATURE_RELIABLE_UPDATE
    455                  case kPropertyTag_ReliableUpdateStatus:
    456                      returnValue = &propertyStore->reliableUpdateStatus;
    457                      break;
    458          #endif // BL_FEATURE_RELIABLE_UPDATE
    459          
    460                  default:
    461                      return kStatus_UnknownProperty;
   \                     ??bootloader_property_get_21: (+1)
   \   00000164   0xF642 0x003C      MOVW     R0,#+10300
   \   00000168   0xE008             B.N      ??bootloader_property_get_25
    462              }
    463          
    464              // Set the return size.
    465              if (valueSize)
   \                     ??bootloader_property_get_22: (+1)
   \   0000016A   0x2F00             CMP      R7,#+0
   \   0000016C   0xD001             BEQ.N    ??bootloader_property_get_26
    466              {
    467                  *valueSize = returnSize;
   \   0000016E   0xF8C7 0x9000      STR      R9,[R7, #+0]
    468              }
    469          
    470              // Set the return value
    471              if (value)
   \                     ??bootloader_property_get_26: (+1)
   \   00000172   0x2E00             CMP      R6,#+0
   \   00000174   0xD001             BEQ.N    ??bootloader_property_get_27
    472              {
    473                  *value = returnValue;
   \   00000176   0xF8C6 0xA000      STR      R10,[R6, #+0]
    474              }
    475          
    476              return kStatus_Success;
   \                     ??bootloader_property_get_27: (+1)
   \   0000017A   0x2000             MOVS     R0,#+0
   \                     ??bootloader_property_get_25: (+1)
   \   0000017C   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    477          }
    478          
    479          // See property.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    480          status_t bootloader_property_set_uint32(uint8_t tag, uint32_t value)
    481          {
   \                     bootloader_property_set_uint32: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    482              property_store_t *propertyStore = g_bootloaderContext.propertyInterface->store;
   \   00000004   0x....             LDR.N    R0,??DataTable3
   \   00000006   0x6880             LDR      R0,[R0, #+8]
   \   00000008   0x6903             LDR      R3,[R0, #+16]
    483          
    484              switch (tag)
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0x0010             MOVS     R0,R2
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x2807             CMP      R0,#+7
   \   00000012   0xD91E             BLS.N    ??bootloader_property_set_uint32_0
   \   00000014   0x3809             SUBS     R0,R0,#+9
   \   00000016   0xD00A             BEQ.N    ??bootloader_property_set_uint32_1
   \   00000018   0x1E40             SUBS     R0,R0,#+1
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD919             BLS.N    ??bootloader_property_set_uint32_0
   \   0000001E   0x1EC0             SUBS     R0,R0,#+3
   \   00000020   0x2803             CMP      R0,#+3
   \   00000022   0xD916             BLS.N    ??bootloader_property_set_uint32_0
   \   00000024   0x3808             SUBS     R0,R0,#+8
   \   00000026   0xD00C             BEQ.N    ??bootloader_property_set_uint32_2
   \   00000028   0x1E80             SUBS     R0,R0,#+2
   \   0000002A   0xD012             BEQ.N    ??bootloader_property_set_uint32_0
   \   0000002C   0xE014             B.N      ??bootloader_property_set_uint32_3
    485              {
    486                  case kPropertyTag_VerifyWrites:
    487                      if (value != 0 && value != 1)
   \                     ??bootloader_property_set_uint32_1: (+1)
   \   0000002E   0x2900             CMP      R1,#+0
   \   00000030   0xD004             BEQ.N    ??bootloader_property_set_uint32_4
   \   00000032   0x2901             CMP      R1,#+1
   \   00000034   0xD002             BEQ.N    ??bootloader_property_set_uint32_4
    488                      {
    489                          return kStatus_InvalidPropertyValue;
   \   00000036   0xF642 0x003E      MOVW     R0,#+10302
   \   0000003A   0xE00F             B.N      ??bootloader_property_set_uint32_5
    490                      }
    491                      propertyStore->verifyWrites = value;
   \                     ??bootloader_property_set_uint32_4: (+1)
   \   0000003C   0x6319             STR      R1,[R3, #+48]
    492                      return kStatus_Success;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE00C             B.N      ??bootloader_property_set_uint32_5
    493          
    494                  case kPropertyTag_FlashReadMargin:
    495          #if !defined(BOOTLOADER_HOST)
    496                      if (value >= kFLASH_MarginValueInvalid)
   \                     ??bootloader_property_set_uint32_2: (+1)
   \   00000042   0x2903             CMP      R1,#+3
   \   00000044   0xD302             BCC.N    ??bootloader_property_set_uint32_6
    497                      {
    498                          return kStatus_InvalidPropertyValue;
   \   00000046   0xF642 0x003E      MOVW     R0,#+10302
   \   0000004A   0xE007             B.N      ??bootloader_property_set_uint32_5
    499                      }
    500                      propertyStore->flashReadMargin = value;
   \                     ??bootloader_property_set_uint32_6: (+1)
   \   0000004C   0x6559             STR      R1,[R3, #+84]
    501          #endif // !BOOTLOADER_HOST
    502                      return kStatus_Success;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE004             B.N      ??bootloader_property_set_uint32_5
    503          
    504                  case kPropertyTag_BootloaderVersion:
    505                  case kPropertyTag_AvailablePeripherals:
    506                  case kPropertyTag_FlashStartAddress:
    507                  case kPropertyTag_FlashSizeInBytes:
    508                  case kPropertyTag_FlashSectorSize:
    509                  case kPropertyTag_FlashBlockCount:
    510                  case kPropertyTag_RAMStartAddress:
    511                  case kPropertyTag_RAMSizeInBytes:
    512                  case kPropertyTag_AvailableCommands:
    513          #if BL_FEATURE_CRC_CHECK
    514                  case kPropertyTag_CrcCheckStatus:
    515          #endif
    516          #if BL_FEATURE_QSPI_MODULE
    517                  case kPropertyTag_QspiInitStatus:
    518          #endif
    519          #if BL_FEATURE_EXTERNAL_MEMORY_PROPERTY
    520                  case kPropertyTag_ExternalMemoryAttributes:
    521          #endif // BL_FEATURE_EXTERNAL_MEMORY_PROPERTY
    522          #if BL_FEATURE_RELIABLE_UPDATE
    523                  case kPropertyTag_ReliableUpdateStatus:
    524          #endif // BL_FEATURE_RELIABLE_UPDATE
    525                  case kPropertyTag_MaxPacketSize:
    526                  case kPropertyTag_ReservedRegions:
    527                  case kPropertyTag_SystemDeviceId:
    528                  case kPropertyTag_FlashSecurityState:
    529                  case kPropertyTag_TargetVersion:
    530                      return kStatus_ReadOnlyProperty;
   \                     ??bootloader_property_set_uint32_0: (+1)
   \   00000052   0xF642 0x003D      MOVW     R0,#+10301
   \   00000056   0xE001             B.N      ??bootloader_property_set_uint32_5
    531                  default:
    532                      return kStatus_UnknownProperty;
   \                     ??bootloader_property_set_uint32_3: (+1)
   \   00000058   0xF642 0x003C      MOVW     R0,#+10300
   \                     ??bootloader_property_set_uint32_5: (+1)
   \   0000005C   0xBC10             POP      {R4}
   \   0000005E   0x4770             BX       LR               ;; return
    533              }
    534          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     g_bootloaderContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x6766636B         DC32     0x6766636b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     g_bootloaderContext+0x20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     SFB(`.intvec`)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     SFE(ApplicationFlash)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     SFB(ApplicationRam)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x........         DC32     SFE(ApplicationRam)+0xFFFFFFFF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x40048054         DC32     0x40048054

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x40048058         DC32     0x40048058

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   0x4004805C         DC32     0x4004805c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \   00000000   0x40048060         DC32     0x40048060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \   00000000   0x........         DC32     s_propertyReturnValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_12:
   \   00000000   0x40048024         DC32     0x40048024
    535          
    536          #if BL_FEATURE_EXTERNAL_MEMORY_PROPERTY
    537          status_t bootloader_get_external_memory_properties(uint8_t memoryId, external_memory_property_store_t *store)
    538          {
    539              extern const external_memory_property_interface_t g_externalMemPropertyInterfaceMap[];
    540          
    541              // Find external memory property interface map.
    542              const external_memory_property_interface_t *map = &g_externalMemPropertyInterfaceMap[0];
    543              while (map && map->get)
    544              {
    545                  if (map->memoryId == memoryId)
    546                  {
    547                      break;
    548                  }
    549                  map++;
    550              }
    551          
    552              if (map->get == NULL)
    553              {
    554                  return kStatus_InvalidArgument;
    555              }
    556          
    557              external_memory_property_store_t propertyStore;
    558              uint32_t memoryInitStatus;
    559              map->get(kExternalMemoryPropertyTag_InitStatus, &memoryInitStatus);
    560              if (memoryInitStatus != kStatus_Success)
    561              {
    562                  return memoryInitStatus;
    563              }
    564          
    565              uint32_t *property = (uint32_t *)&propertyStore.startAddress;
    566              propertyStore.availableAttributesFlag = 0;
    567              for (uint32_t tag = kExternalMemoryPropertyTag_Start; tag <= kExternalMemoryPropertyTag_End; tag++)
    568              {
    569                  uint32_t tmp = 0;
    570                  status_t status = map->get(tag, &tmp);
    571                  if (status == kStatus_Success)
    572                  {
    573                      *property = tmp;
    574                      propertyStore.availableAttributesFlag |= 1 << (tag - 1);
    575                  }
    576                  else
    577                  {
    578                      *property = 0;
    579                  }
    580          
    581                  property++;
    582              }
    583          
    584              memcpy(store, &propertyStore, sizeof(propertyStore));
    585          
    586              return kStatus_Success;
    587          }
    588          #endif // BL_FEATURE_EXTERNAL_MEMORY_PROPERTY
    589          
    590          ////////////////////////////////////////////////////////////////////////////////
    591          // EOF
    592          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   bootloader_property_get
        40   -- Indirect call
      32   bootloader_property_init
        32   -- Indirect call
        32   -> init_crc_check_status
      16   bootloader_property_load_user_config
        16   -> __aeabi_memcpy
        16   -> __aeabi_memset
        16   -> update_available_peripherals
       4   bootloader_property_set_uint32


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
     384  bootloader_property_get
     392  bootloader_property_init
      62  bootloader_property_load_user_config
      96  bootloader_property_set_uint32
      20  g_propertyInterface
     188  g_propertyStore
       4  s_propertyReturnValue

 
 192 bytes in section .bss
  20 bytes in section .rodata
 986 bytes in section .text
 
 986 bytes of CODE  memory
  20 bytes of CONST memory
 192 bytes of DATA  memory

Errors: none
Warnings: none
