###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:04
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\i2c_peripheral_interface.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\i2c_peripheral_interface.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\i2c_peripheral_interface.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\i2c_peripheral_interface.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\i2c_peripheral_interface.c
      1          /*
      2           * Copyright (c) 2013, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "utilities/fsl_assert.h"
     32          #include "bootloader/bl_context.h"
     33          #include "bootloader/bl_irq_common.h"
     34          #include "bootloader_common.h"
     35          #include "packet/command_packet.h"
     36          #include "i2c/fsl_i2c.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void I2C_Enable(I2C_Type *, bool)
   \                     I2C_Enable: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??I2C_Enable_0
   \   00000006   0x7882             LDRB     R2,[R0, #+2]
   \   00000008   0xF052 0x0280      ORRS     R2,R2,#0x80
   \   0000000C   0x7082             STRB     R2,[R0, #+2]
   \   0000000E   0xE003             B.N      ??I2C_Enable_1
   \                     ??I2C_Enable_0: (+1)
   \   00000010   0x7882             LDRB     R2,[R0, #+2]
   \   00000012   0xF012 0x027F      ANDS     R2,R2,#0x7F
   \   00000016   0x7082             STRB     R2,[R0, #+2]
   \                     ??I2C_Enable_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t I2C_SlaveGetStatusFlags(I2C_Type *)
   \                     I2C_SlaveGetStatusFlags: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       I2C_MasterGetStatusFlags
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
     37          #include "fsl_device_registers.h"
     38          #include "packet/serial_packet.h"
     39          
     40          #if BL_CONFIG_I2C
     41          //! @addtogroup i2c_peripheral
     42          //! @{
     43          
     44          ////////////////////////////////////////////////////////////////////////////////
     45          // Definitions
     46          ////////////////////////////////////////////////////////////////////////////////
     47          
     48          // Allow the default to be overridden via the bootloader_config.h file.
     49          #if !defined(BL_DEFAULT_I2C_SLAVE_ADDRESS)
     50          //! @brief Default I2C slave address in 7-bit format.
     51          #define BL_DEFAULT_I2C_SLAVE_ADDRESS (0x10)
     52          //! @brief Secondary I2C slave address in 7-bit format.
     53          #define BL_SECONDARY_I2C_SLAVE_ADDRESS (0x12)
     54          #endif // BL_DEFAULT_I2C_SLAVE_ADDRESS
     55          
     56          //! @brief Default width of glitches to filter in nanoseconds.
     57          enum
     58          {
     59              //! Width of glitches to filter in nanoseconds.
     60              kI2CGlitchFilterWidth_ns = 50
     61          };
     62          
     63          //! @brief Synchronization state between I2C ISR and read/write functions.
     64          typedef struct _i2c_transfer_info
     65          {
     66              const uint8_t *writeData;                                //!< The applications data to write
     67              volatile uint32_t bytesToTransfer;                       //!< The total number of bytes to be transmitted
     68              void (*data_source)(uint8_t *source_byte);               // !< Callback used to get byte to transmit.
     69              void (*data_sink)(uint8_t sink_byte, uint32_t instance); // !< Callback used to put received byte.
     70          } i2c_transfer_info_t;
     71          
     72          #define I2C_EMPTY_CHAR (0x00) //!< Empty character.
     73          
     74          enum
     75          {
     76              //! Max cycles supported to set glitch filter
     77              kI2CGlitchFilterMaxCycles = 31,
     78          };
     79          
     80          ////////////////////////////////////////////////////////////////////////////////
     81          // Prototypes
     82          ////////////////////////////////////////////////////////////////////////////////
     83          
     84          //! @brief I2C slave poll for activity function
     85          static bool i2c_poll_for_activity(const peripheral_descriptor_t *self);
     86          //! @brief I2C slave init function
     87          static status_t i2c_full_init(const peripheral_descriptor_t *self, serial_byte_receive_func_t function);
     88          //! @brief I2C slave shutdown function
     89          static void i2c_full_shutdown(const peripheral_descriptor_t *self);
     90          //! @brief I2C slave internal init function
     91          static void i2c_peripheral_init(uint32_t instance);
     92          //! @brief I2C slave writing data function
     93          status_t i2c_write(const peripheral_descriptor_t *self, const uint8_t *buffer, uint32_t byteCount);
     94          
     95          static void i2c_initial_data_sink(uint8_t sink_byte, uint32_t instance);
     96          static void i2c_data_sink(uint8_t sink_byte, uint32_t instance);
     97          static void i2c_data_source(uint8_t *source_byte);
     98          static void i2c_set_glitch_filter_width(I2C_Type *base, uint32_t busClock_Hz, uint32_t glitchWidth_ns);
     99          static void i2c_SlaveIRQHandler(uint32_t instance);
    100          
    101          ////////////////////////////////////////////////////////////////////////////////
    102          // Variables
    103          ////////////////////////////////////////////////////////////////////////////////
    104          
    105          /*!
    106           * @brief I2C slave control interface information
    107           */

   \                                 In section .rodata, align 4
    108          const peripheral_control_interface_t g_i2cControlInterface = {
   \                     g_i2cControlInterface:
   \   00000000   0x........         DC32 i2c_poll_for_activity, i2c_full_init, i2c_full_shutdown, 0H
   \              0x........   
   \              0x........   
   \              0x00000000   
    109              .pollForActivity = i2c_poll_for_activity, .init = i2c_full_init, .shutdown = i2c_full_shutdown, .pump = 0
    110          };
    111          
    112          /*!
    113           * @brief I2C slave byte interface information
    114           */

   \                                 In section .rodata, align 4
    115          const peripheral_byte_inteface_t g_i2cByteInterface = {.init = NULL, .write = i2c_write };
   \                     g_i2cByteInterface:
   \   00000000   0x00000000         DC32 0H, i2c_write
   \              0x........   
    116          
    117          //! @brief Global state for the I2C slave peripheral interface.

   \                                 In section .data, align 4
    118          static i2c_transfer_info_t s_i2cInfo = {
   \                     s_i2cInfo:
   \   00000000   0x00000000         DC32 0H, 0, i2c_data_source, i2c_initial_data_sink
   \              0x00000000   
   \              0x........   
   \              0x........   
    119              .writeData = 0, .bytesToTransfer = 0, .data_source = i2c_data_source, .data_sink = i2c_initial_data_sink
    120          };
    121          
    122          //! @brief Global state for the I2C slave peripheral interface.

   \                                 In section .bss, align 4
    123          static bool s_i2cActivity[FSL_FEATURE_SOC_I2C_COUNT] = { false };
   \                     s_i2cActivity:
   \   00000000                      DS8 4

   \                                 In section .rodata, align 4
    124          const static uint32_t g_i2cBaseAddr[] = I2C_BASE_ADDRS;
   \                     g_i2cBaseAddr:
   \   00000000   0x40066000         DC32 1074159616, 1074163712, 1074683904
   \              0x40067000   
   \              0x400E6000   

   \                                 In section .bss, align 4
    125          static bool s_i2cIntialized[FSL_FEATURE_SOC_I2C_COUNT] = { false };
   \                     s_i2cIntialized:
   \   00000000                      DS8 4
    126          
    127          /*!
    128           * @brief I2C slave receiving data call back function
    129           */

   \                                 In section .bss, align 4
    130          static serial_byte_receive_func_t s_i2c_app_data_sink_callback;
   \                     s_i2c_app_data_sink_callback:
   \   00000000                      DS8 4
    131          
    132          ////////////////////////////////////////////////////////////////////////////////
    133          // Code
    134          ////////////////////////////////////////////////////////////////////////////////
    135          
    136          #if !defined(BL_FEATURE_I2C_OPTIMIZE) || USE_ONLY_I2C(0)
    137          //! @brief Implementation of I2C0 handler named in startup code.
    138          //!
    139          //! Passes instance to generic I2C IRQ handler.

   \                                 In section .text, align 2, keep-with-next
    140          void I2C0_IRQHandler(void)
    141          {
   \                     I2C0_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    142              i2c_SlaveIRQHandler(0);
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       i2c_SlaveIRQHandler
    143          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    144          #endif // !defined(BL_FEATURE_I2C_OPTIMIZE) || USE_ONLY_I2C(0)
    145          
    146          #if (!defined(BL_FEATURE_I2C_OPTIMIZE) || USE_ONLY_I2C(1)) && (FSL_FEATURE_SOC_I2C_COUNT > 1)
    147          //! @brief Implementation of I2C1 handler named in startup code.
    148          //!
    149          //! Passes instance to generic I2C IRQ handler.

   \                                 In section .text, align 2, keep-with-next
    150          void I2C1_IRQHandler(void)
    151          {
   \                     I2C1_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    152              i2c_SlaveIRQHandler(1);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       i2c_SlaveIRQHandler
    153          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    154          #endif // (!defined(BL_FEATURE_I2C_OPTIMIZE) || USE_ONLY_I2C(1)) && (FSL_FEATURE_SOC_I2C_COUNT > 1)
    155          
    156          /*FUNCTION**********************************************************************
    157           *
    158           * Function Name : i2c_poll_for_activity
    159           * Description   : Polling for I2C slave activities
    160           *
    161           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    162          bool i2c_poll_for_activity(const peripheral_descriptor_t *self)
    163          {
    164              return s_i2cActivity[self->instance];
   \                     i2c_poll_for_activity: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable9
   \   00000002   0x6840             LDR      R0,[R0, #+4]
   \   00000004   0x5C08             LDRB     R0,[R1, R0]
   \   00000006   0x4770             BX       LR               ;; return
    165          }
    166          
    167          /*FUNCTION**********************************************************************
    168           *
    169           * Function Name : i2c_data_source
    170           * Description   : I2C slave sending data function
    171           *
    172           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    173          static void i2c_data_source(uint8_t *source_byte)
    174          {
    175              assert(source_byte);
    176          
    177              if (s_i2cInfo.bytesToTransfer)
   \                     i2c_data_source: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable9_1
   \   00000002   0x6849             LDR      R1,[R1, #+4]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD00E             BEQ.N    ??i2c_data_source_0
    178              {
    179                  *source_byte = *s_i2cInfo.writeData++;
   \   00000008   0x....             LDR.N    R1,??DataTable9_1
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x7809             LDRB     R1,[R1, #+0]
   \   0000000E   0x7001             STRB     R1,[R0, #+0]
   \   00000010   0x....             LDR.N    R1,??DataTable9_1
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x1C49             ADDS     R1,R1,#+1
   \   00000016   0x....             LDR.N    R2,??DataTable9_1
   \   00000018   0x6011             STR      R1,[R2, #+0]
    180                  s_i2cInfo.bytesToTransfer--;
   \   0000001A   0x....             LDR.N    R1,??DataTable9_1
   \   0000001C   0x6849             LDR      R1,[R1, #+4]
   \   0000001E   0x1E49             SUBS     R1,R1,#+1
   \   00000020   0x....             LDR.N    R2,??DataTable9_1
   \   00000022   0x6051             STR      R1,[R2, #+4]
   \   00000024   0xE001             B.N      ??i2c_data_source_1
    181              }
    182              else
    183              {
    184                  *source_byte = 0;
   \                     ??i2c_data_source_0: (+1)
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x7001             STRB     R1,[R0, #+0]
    185              }
    186          }
   \                     ??i2c_data_source_1: (+1)
   \   0000002A   0x4770             BX       LR               ;; return
    187          
    188          /*FUNCTION**********************************************************************
    189           *
    190           * Function Name : i2c_data_sink
    191           * Description   : I2C slave receiving data function
    192           *
    193           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    194          static void i2c_data_sink(uint8_t sink_byte, uint32_t instance)
    195          {
   \                     i2c_data_sink: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    196              s_i2c_app_data_sink_callback(sink_byte);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x....             LDR.N    R1,??DataTable9_2
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0x4788             BLX      R1
    197          }
   \   00000010   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    198          
    199          /*FUNCTION**********************************************************************
    200           *
    201           * Function Name : i2c_initial_data_sink
    202           * Description   : I2C slave receiving first byte data function
    203           *
    204           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    205          static void i2c_initial_data_sink(uint8_t sink_byte, uint32_t instance)
    206          {
   \                     i2c_initial_data_sink: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    207              if (sink_byte == kFramingPacketStartByte)
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C5A             CMP      R4,#+90
   \   0000000A   0xD10A             BNE.N    ??i2c_initial_data_sink_0
    208              {
    209                  s_i2cActivity[instance] = true;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x....             LDR.N    R1,??DataTable9
   \   00000010   0x5548             STRB     R0,[R1, R5]
    210                  s_i2cInfo.data_sink = i2c_data_sink;
   \   00000012   0x....             LDR.N    R0,??DataTable9_3
   \   00000014   0x....             LDR.N    R1,??DataTable9_1
   \   00000016   0x60C8             STR      R0,[R1, #+12]
    211                  s_i2c_app_data_sink_callback(sink_byte);
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x....             LDR.N    R1,??DataTable9_2
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x4788             BLX      R1
    212              }
    213          }
   \                     ??i2c_initial_data_sink_0: (+1)
   \   00000022   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    214          
    215          /*FUNCTION**********************************************************************
    216           *
    217           * Function Name : i2c_peripheral_init
    218           * Description   : I2C slave Internal init function
    219           *
    220           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    221          void i2c_peripheral_init(uint32_t instance)
    222          {
   \                     i2c_peripheral_init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
    223              uint32_t baseAddr = g_i2cBaseAddr[instance];
   \   00000006   0x....             LDR.N    R0,??DataTable9_4
   \   00000008   0xF850 0x5024      LDR      R5,[R0, R4, LSL #+2]
    224              i2c_slave_config_t i2cSlaveConfig;
    225          
    226              I2C_SlaveGetDefaultConfig(&i2cSlaveConfig);
   \   0000000C   0x4668             MOV      R0,SP
   \   0000000E   0x.... 0x....      BL       I2C_SlaveGetDefaultConfig
    227              i2cSlaveConfig.slaveAddress = BL_DEFAULT_I2C_SLAVE_ADDRESS;
   \   00000012   0x2010             MOVS     R0,#+16
   \   00000014   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    228          
    229              // Read the address from the configuration field. If it is not set, i.e. 0xff,
    230              // use the default address.
    231              uint8_t slaveAddress = g_bootloaderContext.propertyInterface->store->configurationData.i2cSlaveAddress;
   \   00000018   0x....             LDR.N    R0,??DataTable9_5
   \   0000001A   0x6880             LDR      R0,[R0, #+8]
   \   0000001C   0x6900             LDR      R0,[R0, #+16]
   \   0000001E   0xF890 0x607D      LDRB     R6,[R0, #+125]
    232              if (slaveAddress != 0xff)
   \   00000022   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000024   0x2EFF             CMP      R6,#+255
   \   00000026   0xD002             BEQ.N    ??i2c_peripheral_init_0
    233              {
    234                  i2cSlaveConfig.slaveAddress = slaveAddress;
   \   00000028   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002A   0xF8AD 0x6006      STRH     R6,[SP, #+6]
    235              }
    236          #if BL_FEATURE_SECONDARY_I2C_SLAVE_ADDRESS
    237              else if (is_secondary_i2c_slave_address_enabled())
    238              {
    239                  i2cSlaveConfig.slaveAddr = BL_SECONDARY_I2C_SLAVE_ADDRESS;
    240              }
    241          #endif // BL_FEATURE_SECONDARY_I2C_SLAVE_ADDRESS
    242          
    243              I2C_SlaveInit((I2C_Type *)baseAddr, &i2cSlaveConfig);
   \                     ??i2c_peripheral_init_0: (+1)
   \   0000002E   0x4669             MOV      R1,SP
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0x.... 0x....      BL       I2C_SlaveInit
    244              I2C_Enable((I2C_Type *)baseAddr, true);
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0x.... 0x....      BL       I2C_Enable
    245              I2C_EnableInterrupts((I2C_Type *)baseAddr, kI2C_GlobalInterruptEnable);
   \   0000003E   0x2140             MOVS     R1,#+64
   \   00000040   0x0028             MOVS     R0,R5
   \   00000042   0x.... 0x....      BL       I2C_EnableInterrupts
    246              i2c_set_glitch_filter_width((I2C_Type *)baseAddr, get_bus_clock(), kI2CGlitchFilterWidth_ns);
   \   00000046   0x.... 0x....      BL       get_bus_clock
   \   0000004A   0x2232             MOVS     R2,#+50
   \   0000004C   0x0001             MOVS     R1,R0
   \   0000004E   0x0028             MOVS     R0,R5
   \   00000050   0x.... 0x....      BL       i2c_set_glitch_filter_width
    247          
    248              I2C_SetSystemIRQ(instance, kPeripheralEnableIRQ);
   \   00000054   0x2101             MOVS     R1,#+1
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      BL       I2C_SetSystemIRQ
    249          
    250              s_i2cInfo.data_sink = i2c_initial_data_sink;
   \   0000005C   0x....             LDR.N    R0,??DataTable9_6
   \   0000005E   0x....             LDR.N    R1,??DataTable9_1
   \   00000060   0x60C8             STR      R0,[R1, #+12]
    251          }
   \   00000062   0xBD7F             POP      {R0-R6,PC}       ;; return
    252          
    253          /*FUNCTION**********************************************************************
    254           *
    255           * Function Name : i2c_full_init
    256           * Description   : I2C slave full init function
    257           *
    258           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    259          status_t i2c_full_init(const peripheral_descriptor_t *self, serial_byte_receive_func_t function)
    260          {
   \                     i2c_full_init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    261              s_i2c_app_data_sink_callback = function;
   \   00000006   0x....             LDR.N    R0,??DataTable9_2
   \   00000008   0x6005             STR      R5,[R0, #+0]
    262          
    263              // Configure selected pin as i2c peripheral interface
    264              self->pinmuxConfig(self->instance, kPinmuxType_Peripheral);
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0x6860             LDR      R0,[R4, #+4]
   \   0000000E   0x68A2             LDR      R2,[R4, #+8]
   \   00000010   0x4790             BLX      R2
    265          
    266              i2c_peripheral_init(self->instance);
   \   00000012   0x6860             LDR      R0,[R4, #+4]
   \   00000014   0x.... 0x....      BL       i2c_peripheral_init
    267          
    268              s_i2cIntialized[self->instance] = true;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x....             LDR.N    R1,??DataTable9_7
   \   0000001C   0x6862             LDR      R2,[R4, #+4]
   \   0000001E   0x5488             STRB     R0,[R1, R2]
    269          
    270              return kStatus_Success;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    271          }
    272          
    273          /*FUNCTION**********************************************************************
    274           *
    275           * Function Name : i2c_full_shutdown
    276           * Description   : I2C slave full shutdown function
    277           *
    278           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    279          void i2c_full_shutdown(const peripheral_descriptor_t *self)
    280          {
   \                     i2c_full_shutdown: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    281              if (s_i2cIntialized[self->instance])
   \   00000004   0x....             LDR.N    R0,??DataTable9_7
   \   00000006   0x6861             LDR      R1,[R4, #+4]
   \   00000008   0x5C40             LDRB     R0,[R0, R1]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD016             BEQ.N    ??i2c_full_shutdown_0
    282              {
    283                  uint32_t baseAddr = g_i2cBaseAddr[self->instance];
   \   0000000E   0x....             LDR.N    R0,??DataTable9_4
   \   00000010   0x6861             LDR      R1,[R4, #+4]
   \   00000012   0xF850 0x5021      LDR      R5,[R0, R1, LSL #+2]
    284                  I2C_SetSystemIRQ(self->instance, kPeripheralDisableIRQ);
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x6860             LDR      R0,[R4, #+4]
   \   0000001A   0x.... 0x....      BL       I2C_SetSystemIRQ
    285                  I2C_Enable((I2C_Type *)baseAddr, false);
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0x.... 0x....      BL       I2C_Enable
    286                  I2C_SlaveDeinit((I2C_Type *)baseAddr);
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0x.... 0x....      BL       I2C_SlaveDeinit
    287          
    288                  // Restore selected pin to default state to reduce IDD.
    289                  self->pinmuxConfig(self->instance, kPinmuxType_Default);
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x6860             LDR      R0,[R4, #+4]
   \   00000030   0x68A2             LDR      R2,[R4, #+8]
   \   00000032   0x4790             BLX      R2
    290          
    291                  s_i2cIntialized[self->instance] = false;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x....             LDR.N    R1,??DataTable9_7
   \   00000038   0x6862             LDR      R2,[R4, #+4]
   \   0000003A   0x5488             STRB     R0,[R1, R2]
    292              }
    293          }
   \                     ??i2c_full_shutdown_0: (+1)
   \   0000003C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    294          
    295          /*FUNCTION**********************************************************************
    296           *
    297           * Function Name : i2c_write
    298           * Description   : I2C slave writing data function
    299           *
    300           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    301          status_t i2c_write(const peripheral_descriptor_t *self, const uint8_t *buffer, uint32_t byteCount)
    302          {
   \                     i2c_write: (+1)
   \   00000000   0x0003             MOVS     R3,R0
    303              s_i2cInfo.writeData = buffer;
   \   00000002   0x....             LDR.N    R0,??DataTable9_1
   \   00000004   0x6001             STR      R1,[R0, #+0]
    304              s_i2cInfo.bytesToTransfer = byteCount;
   \   00000006   0x....             LDR.N    R0,??DataTable9_1
   \   00000008   0x6042             STR      R2,[R0, #+4]
    305          
    306              while (s_i2cInfo.bytesToTransfer)
   \                     ??i2c_write_0: (+1)
   \   0000000A   0x....             LDR.N    R0,??DataTable9_1
   \   0000000C   0x6840             LDR      R0,[R0, #+4]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD1FB             BNE.N    ??i2c_write_0
    307                  ;
    308          
    309              return kStatus_Success;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4770             BX       LR               ;; return
    310          }
    311          
    312          /*FUNCTION**********************************************************************
    313           *
    314           * Function Name : i2c_DummyRead
    315           * Description   : I2C dummy read
    316           *
    317           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    318          static uint8_t i2c_DummyRead(volatile I2C_Type *base)
    319          {
    320              return base->D;
   \                     i2c_DummyRead: (+1)
   \   00000000   0x7900             LDRB     R0,[R0, #+4]
   \   00000002   0x4770             BX       LR               ;; return
    321          }
    322          
    323          /*FUNCTION**********************************************************************
    324           *
    325           * Function Name : i2c_SlaveIRQHandler
    326           * Description   : I2C slave bootloader interrupt handler
    327           *
    328           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    329          static void i2c_SlaveIRQHandler(uint32_t instance)
    330          {
   \                     i2c_SlaveIRQHandler: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
    331              uint16_t status;
    332              I2C_Type *base = (I2C_Type *)g_i2cBaseAddr[instance];
   \   00000008   0x....             LDR.N    R0,??DataTable9_4
   \   0000000A   0xF850 0x6024      LDR      R6,[R0, R4, LSL #+2]
    333          
    334              status = I2C_SlaveGetStatusFlags(base);
   \   0000000E   0x0030             MOVS     R0,R6
   \   00000010   0x.... 0x....      BL       I2C_SlaveGetStatusFlags
   \   00000014   0x0005             MOVS     R5,R0
    335          
    336              bool doTransmit = false;
   \   00000016   0x2700             MOVS     R7,#+0
    337          
    338              /* Clear the interrupt flag*/
    339              base->S = (kI2C_IntPendingFlag | kI2C_ArbitrationLostFlag) & status;
   \   00000018   0xF015 0x0012      ANDS     R0,R5,#0x12
   \   0000001C   0x70F0             STRB     R0,[R6, #+3]
    340          
    341              if ((status & I2C_S_ARBL_MASK) && (!(status & I2C_S_IAAS_MASK)))
   \   0000001E   0xF015 0x0050      ANDS     R0,R5,#0x50
   \   00000022   0x2810             CMP      R0,#+16
   \   00000024   0xD02A             BEQ.N    ??i2c_SlaveIRQHandler_0
    342              {
    343                  // ArbitrationLost and not AddressedAsSlave
    344              }
    345              else if (status & I2C_S_IAAS_MASK) // AddressedAsSlave
   \   00000026   0x0668             LSLS     R0,R5,#+25
   \   00000028   0xD510             BPL.N    ??i2c_SlaveIRQHandler_1
    346              {
    347                  if (status & I2C_S_SRW_MASK) // Master read from Slave. Slave transmit.
   \   0000002A   0x0768             LSLS     R0,R5,#+29
   \   0000002C   0xD506             BPL.N    ??i2c_SlaveIRQHandler_2
    348                  {
    349                      // Switch to TX mode
    350                      base->C1 |= I2C_C1_TX_MASK;
   \   0000002E   0x78B0             LDRB     R0,[R6, #+2]
   \   00000030   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000034   0x70B0             STRB     R0,[R6, #+2]
    351          
    352                      doTransmit = true;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x0007             MOVS     R7,R0
   \   0000003A   0xE01F             B.N      ??i2c_SlaveIRQHandler_0
    353                  }
    354                  else // Master write to Slave. Slave receive.
    355                  {
    356                      // Switch to RX mode.
    357                      base->C1 &= ~I2C_C1_TX_MASK;
   \                     ??i2c_SlaveIRQHandler_2: (+1)
   \   0000003C   0x78B0             LDRB     R0,[R6, #+2]
   \   0000003E   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   00000042   0x70B0             STRB     R0,[R6, #+2]
    358          
    359                      // Dummy read character.
    360                      i2c_DummyRead(base);
   \   00000044   0x0030             MOVS     R0,R6
   \   00000046   0x.... 0x....      BL       i2c_DummyRead
   \   0000004A   0xE017             B.N      ??i2c_SlaveIRQHandler_0
    361                  }
    362              }
    363              else // not AddressedAsSlave
    364              {
    365                  if (base->C1 & I2C_C1_TX_MASK) // Transmit.
   \                     ??i2c_SlaveIRQHandler_1: (+1)
   \   0000004C   0x78B0             LDRB     R0,[R6, #+2]
   \   0000004E   0x06C0             LSLS     R0,R0,#+27
   \   00000050   0xD50C             BPL.N    ??i2c_SlaveIRQHandler_3
    366                  {
    367                      if (status & I2C_S_RXAK_MASK) // No ACK from receiver.
   \   00000052   0x07E8             LSLS     R0,R5,#+31
   \   00000054   0xD507             BPL.N    ??i2c_SlaveIRQHandler_4
    368                      {
    369                          // Switch to RX mode.
    370                          base->C1 &= ~I2C_C1_TX_MASK;
   \   00000056   0x78B0             LDRB     R0,[R6, #+2]
   \   00000058   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   0000005C   0x70B0             STRB     R0,[R6, #+2]
    371          
    372                          // Dummy read character.
    373                          i2c_DummyRead(base);
   \   0000005E   0x0030             MOVS     R0,R6
   \   00000060   0x.... 0x....      BL       i2c_DummyRead
   \   00000064   0xE00A             B.N      ??i2c_SlaveIRQHandler_0
    374                      }
    375                      else // ACK from receiver.
    376                      {
    377                          // DO TRANSMIT
    378                          doTransmit = true;
   \                     ??i2c_SlaveIRQHandler_4: (+1)
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0x0007             MOVS     R7,R0
   \   0000006A   0xE007             B.N      ??i2c_SlaveIRQHandler_0
    379                      }
    380                  }
    381                  else // Receive.
    382                  {
    383                      // Get byte from data register.
    384                      uint8_t sink_byte = base->D;
   \                     ??i2c_SlaveIRQHandler_3: (+1)
   \   0000006C   0xF896 0x8004      LDRB     R8,[R6, #+4]
    385          
    386                      s_i2cInfo.data_sink(sink_byte, instance);
   \   00000070   0x0021             MOVS     R1,R4
   \   00000072   0x4640             MOV      R0,R8
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0x....             LDR.N    R2,??DataTable9_1
   \   00000078   0x68D2             LDR      R2,[R2, #+12]
   \   0000007A   0x4790             BLX      R2
    387                  }
    388              }
    389          
    390              if (doTransmit)
   \                     ??i2c_SlaveIRQHandler_0: (+1)
   \   0000007C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000007E   0x2F00             CMP      R7,#+0
   \   00000080   0xD009             BEQ.N    ??i2c_SlaveIRQHandler_5
    391              {
    392                  uint8_t source_byte = I2C_EMPTY_CHAR;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF88D 0x0000      STRB     R0,[SP, #+0]
    393          
    394                  s_i2cInfo.data_source(&source_byte);
   \   00000088   0x4668             MOV      R0,SP
   \   0000008A   0x....             LDR.N    R1,??DataTable9_1
   \   0000008C   0x6889             LDR      R1,[R1, #+8]
   \   0000008E   0x4788             BLX      R1
    395          
    396                  // Store char to transmit register.
    397                  base->D = source_byte;
   \   00000090   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000094   0x7130             STRB     R0,[R6, #+4]
    398              }
    399          }
   \                     ??i2c_SlaveIRQHandler_5: (+1)
   \   00000096   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
    400          
    401          /*FUNCTION**********************************************************************
    402           *
    403           * Function Name : i2c_set_glitch_filter_width
    404           * Description   : I2C slave set glitch filter width
    405           *
    406           *END**************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    407          void i2c_set_glitch_filter_width(I2C_Type *base, uint32_t busClock_Hz, uint32_t glitchWidth_ns)
    408          {
   \                     i2c_set_glitch_filter_width: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    409          #if USE_ONLY_I2C(0)
    410              instance = 0;
    411          #elif USE_ONLY_I2C(1)
    412              instance = 1;
    413          #endif // USE_ONLY_I2C(0)
    414          
    415              uint32_t busCycle_ns = 1000000 / (busClock_Hz / 1000);
   \   00000002   0xF44F 0x737A      MOV      R3,#+1000
   \   00000006   0xFBB1 0xF3F3      UDIV     R3,R1,R3
   \   0000000A   0x....             LDR.N    R4,??DataTable9_8  ;; 0xf4240
   \   0000000C   0xFBB4 0xF3F3      UDIV     R3,R4,R3
    416          
    417              // Search for the cycle count just below the desired glitch width.
    418              uint32_t cycles = 0;
   \   00000010   0x2400             MOVS     R4,#+0
    419              while (((cycles + 1) * busCycle_ns) < glitchWidth_ns)
   \                     ??i2c_set_glitch_filter_width_0: (+1)
   \   00000012   0x1C65             ADDS     R5,R4,#+1
   \   00000014   0x435D             MULS     R5,R3,R5
   \   00000016   0x4295             CMP      R5,R2
   \   00000018   0xD201             BCS.N    ??i2c_set_glitch_filter_width_1
    420              {
    421                  ++cycles;
   \   0000001A   0x1C64             ADDS     R4,R4,#+1
   \   0000001C   0xE7F9             B.N      ??i2c_set_glitch_filter_width_0
    422              }
    423          
    424              // If we end up with zero cycles, then set the filter to a single cycle unless the
    425              // bus clock is greater than 10x the desired glitch width.
    426              if ((cycles == 0) && (busCycle_ns <= (glitchWidth_ns * 10)))
   \                     ??i2c_set_glitch_filter_width_1: (+1)
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD107             BNE.N    ??i2c_set_glitch_filter_width_2
   \   00000022   0x250A             MOVS     R5,#+10
   \   00000024   0xFB05 0xF502      MUL      R5,R5,R2
   \   00000028   0x429D             CMP      R5,R3
   \   0000002A   0xD302             BCC.N    ??i2c_set_glitch_filter_width_2
    427              {
    428                  cycles = 1;
   \   0000002C   0x2501             MOVS     R5,#+1
   \   0000002E   0x002C             MOVS     R4,R5
   \   00000030   0xE003             B.N      ??i2c_set_glitch_filter_width_3
    429              }
    430              // If the cycles is greater the max cycles supported to set glitch filter,
    431              // then cycles should be equal to max cycles
    432              else if (cycles > kI2CGlitchFilterMaxCycles)
   \                     ??i2c_set_glitch_filter_width_2: (+1)
   \   00000032   0x2C20             CMP      R4,#+32
   \   00000034   0xD301             BCC.N    ??i2c_set_glitch_filter_width_3
    433              {
    434                  cycles = kI2CGlitchFilterMaxCycles;
   \   00000036   0x251F             MOVS     R5,#+31
   \   00000038   0x002C             MOVS     R4,R5
    435              }
    436          
    437              uint8_t temp = base->FLT;
   \                     ??i2c_set_glitch_filter_width_3: (+1)
   \   0000003A   0x7985             LDRB     R5,[R0, #+6]
    438              base->FLT = (~I2C_FLT_FLT_MASK & temp) | cycles;
   \   0000003C   0xF015 0x06F0      ANDS     R6,R5,#0xF0
   \   00000040   0x4326             ORRS     R6,R4,R6
   \   00000042   0x7186             STRB     R6,[R0, #+6]
    439          }
   \   00000044   0xBC70             POP      {R4-R6}
   \   00000046   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     s_i2cActivity

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     s_i2cInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     s_i2c_app_data_sink_callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     i2c_data_sink

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     g_i2cBaseAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     g_bootloaderContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     i2c_initial_data_sink

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     s_i2cIntialized

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x000F4240         DC32     0xf4240
    440          
    441          //! @}
    442          
    443          #endif // BL_CONFIG_I2C
    444          ////////////////////////////////////////////////////////////////////////////////
    445          // EOF
    446          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   I2C0_IRQHandler
         8   -> i2c_SlaveIRQHandler
       8   I2C1_IRQHandler
         8   -> i2c_SlaveIRQHandler
       0   I2C_Enable
       8   I2C_SlaveGetStatusFlags
         8   -> I2C_MasterGetStatusFlags
       0   i2c_DummyRead
      32   i2c_SlaveIRQHandler
        32   -- Indirect call
        32   -> I2C_SlaveGetStatusFlags
        32   -> i2c_DummyRead
      16   i2c_data_sink
        16   -- Indirect call
       0   i2c_data_source
      16   i2c_full_init
        16   -- Indirect call
        16   -> i2c_peripheral_init
      16   i2c_full_shutdown
        16   -- Indirect call
        16   -> I2C_Enable
        16   -> I2C_SetSystemIRQ
        16   -> I2C_SlaveDeinit
      16   i2c_initial_data_sink
        16   -- Indirect call
      32   i2c_peripheral_init
        32   -> I2C_Enable
        32   -> I2C_EnableInterrupts
        32   -> I2C_SetSystemIRQ
        32   -> I2C_SlaveGetDefaultConfig
        32   -> I2C_SlaveInit
        32   -> get_bus_clock
        32   -> i2c_set_glitch_filter_width
       0   i2c_poll_for_activity
      12   i2c_set_glitch_filter_width
       0   i2c_write


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
      10  I2C0_IRQHandler
      10  I2C1_IRQHandler
      26  I2C_Enable
      12  I2C_SlaveGetStatusFlags
      12  g_i2cBaseAddr
       8  g_i2cByteInterface
      16  g_i2cControlInterface
       4  i2c_DummyRead
     154  i2c_SlaveIRQHandler
      18  i2c_data_sink
      44  i2c_data_source
      36  i2c_full_init
      62  i2c_full_shutdown
      36  i2c_initial_data_sink
     100  i2c_peripheral_init
       8  i2c_poll_for_activity
      72  i2c_set_glitch_filter_width
      22  i2c_write
       4  s_i2cActivity
      16  s_i2cInfo
       4  s_i2cIntialized
       4  s_i2c_app_data_sink_callback

 
  12 bytes in section .bss
  16 bytes in section .data
  36 bytes in section .rodata
 650 bytes in section .text
 
 650 bytes of CODE  memory
  36 bytes of CONST memory
  28 bytes of DATA  memory

Errors: none
Warnings: none
