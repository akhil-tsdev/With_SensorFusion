###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:24:02
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\gpio\fsl_gpio.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\gpio\fsl_gpio.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\fsl_gpio.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\fsl_gpio.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\gpio\fsl_gpio.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "fsl_gpio.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void GPIO_WritePinOutput(GPIO_Type *, uint32_t, uint8_t)
   \                     GPIO_WritePinOutput: (+1)
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD103             BNE.N    ??GPIO_WritePinOutput_0
   \   00000006   0x2301             MOVS     R3,#+1
   \   00000008   0x408B             LSLS     R3,R3,R1
   \   0000000A   0x6083             STR      R3,[R0, #+8]
   \   0000000C   0xE002             B.N      ??GPIO_WritePinOutput_1
   \                     ??GPIO_WritePinOutput_0: (+1)
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0x408B             LSLS     R3,R3,R1
   \   00000012   0x6043             STR      R3,[R0, #+4]
   \                     ??GPIO_WritePinOutput_1: (+1)
   \   00000014   0x4770             BX       LR               ;; return
     32          
     33          /*******************************************************************************
     34           * Variables
     35           ******************************************************************************/

   \                                 In section .rodata, align 4
     36          static PORT_Type *const s_portBases[] = PORT_BASE_PTRS;
   \                     s_portBases:
   \   00000000   0x40049000         DC32 40049000H, 4004A000H, 4004B000H, 4004C000H, 4004D000H
   \              0x4004A000   
   \              0x4004B000   
   \              0x4004C000   
   \              0x4004D000   

   \                                 In section .rodata, align 4
     37          static GPIO_Type *const s_gpioBases[] = GPIO_BASE_PTRS;
   \                     s_gpioBases:
   \   00000000   0x400FF000         DC32 400FF000H, 400FF040H, 400FF080H, 400FF0C0H, 400FF100H
   \              0x400FF040   
   \              0x400FF080   
   \              0x400FF0C0   
   \              0x400FF100   
     38          
     39          /*******************************************************************************
     40          * Prototypes
     41          ******************************************************************************/
     42          
     43          /*!
     44          * @brief Gets the GPIO instance according to the GPIO base
     45          *
     46          * @param base    GPIO peripheral base pointer(PTA, PTB, PTC, etc.)
     47          * @retval GPIO instance
     48          */
     49          static uint32_t GPIO_GetInstance(GPIO_Type *base);
     50          
     51          /*******************************************************************************
     52           * Code
     53           ******************************************************************************/
     54          

   \                                 In section .text, align 2, keep-with-next
     55          static uint32_t GPIO_GetInstance(GPIO_Type *base)
     56          {
   \                     GPIO_GetInstance: (+1)
   \   00000000   0x0001             MOVS     R1,R0
     57              uint32_t instance;
     58          
     59              /* Find the instance index from base address mappings. */
     60              for (instance = 0; instance < FSL_FEATURE_SOC_GPIO_COUNT; instance++)
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x0010             MOVS     R0,R2
   \                     ??GPIO_GetInstance_0: (+1)
   \   00000006   0x2805             CMP      R0,#+5
   \   00000008   0xD206             BCS.N    ??GPIO_GetInstance_1
     61              {
     62                  if (s_gpioBases[instance] == base)
   \   0000000A   0x....             LDR.N    R2,??DataTable2
   \   0000000C   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   00000010   0x428A             CMP      R2,R1
   \   00000012   0xD001             BEQ.N    ??GPIO_GetInstance_1
     63                  {
     64                      break;
     65                  }
     66              }
   \                     ??GPIO_GetInstance_2: (+1)
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0xE7F6             B.N      ??GPIO_GetInstance_0
     67          
     68              assert(instance < FSL_FEATURE_SOC_GPIO_COUNT);
     69          
     70              return instance;
   \                     ??GPIO_GetInstance_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
     71          }
     72          

   \                                 In section .text, align 2, keep-with-next
     73          void GPIO_PinInit(GPIO_Type *base, uint32_t pin, const gpio_pin_config_t *config)
     74          {
   \                     GPIO_PinInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
     75              assert(config);
     76          
     77              if (config->pinDirection == kGPIO_DigitalInput)
   \   00000008   0x7830             LDRB     R0,[R6, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD105             BNE.N    ??GPIO_PinInit_0
     78              {
     79                  base->PDDR &= ~(1U << pin);
   \   0000000E   0x6960             LDR      R0,[R4, #+20]
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x40A9             LSLS     R1,R1,R5
   \   00000014   0x4388             BICS     R0,R0,R1
   \   00000016   0x6160             STR      R0,[R4, #+20]
   \   00000018   0xE009             B.N      ??GPIO_PinInit_1
     80              }
     81              else
     82              {
     83                  GPIO_WritePinOutput(base, pin, config->outputLogic);
   \                     ??GPIO_PinInit_0: (+1)
   \   0000001A   0x7872             LDRB     R2,[R6, #+1]
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       GPIO_WritePinOutput
     84                  base->PDDR |= (1U << pin);
   \   00000024   0x6960             LDR      R0,[R4, #+20]
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0x40A9             LSLS     R1,R1,R5
   \   0000002A   0x4308             ORRS     R0,R1,R0
   \   0000002C   0x6160             STR      R0,[R4, #+20]
     85              }
     86          }
   \                     ??GPIO_PinInit_1: (+1)
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
     87          

   \                                 In section .text, align 2, keep-with-next
     88          uint32_t GPIO_GetPinsInterruptFlags(GPIO_Type *base)
     89          {
   \                     GPIO_GetPinsInterruptFlags: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
     90              uint8_t instance;
     91              PORT_Type *portBase;
     92              instance = GPIO_GetInstance(base);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       GPIO_GetInstance
   \   0000000A   0x0005             MOVS     R5,R0
     93              portBase = s_portBases[instance];
   \   0000000C   0x....             LDR.N    R0,??DataTable2_1
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000014   0x0006             MOVS     R6,R0
     94              return portBase->ISFR;
   \   00000016   0xF8D6 0x00A0      LDR      R0,[R6, #+160]
   \   0000001A   0xBD70             POP      {R4-R6,PC}       ;; return
     95          }
     96          

   \                                 In section .text, align 2, keep-with-next
     97          void GPIO_ClearPinsInterruptFlags(GPIO_Type *base, uint32_t mask)
     98          {
   \                     GPIO_ClearPinsInterruptFlags: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     99              uint8_t instance;
    100              PORT_Type *portBase;
    101              instance = GPIO_GetInstance(base);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       GPIO_GetInstance
   \   0000000C   0x0006             MOVS     R6,R0
    102              portBase = s_portBases[instance];
   \   0000000E   0x....             LDR.N    R0,??DataTable2_1
   \   00000010   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000012   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   00000016   0x0007             MOVS     R7,R0
    103              portBase->ISFR = mask;
   \   00000018   0xF8C7 0x50A0      STR      R5,[R7, #+160]
    104          }
   \   0000001C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     s_gpioBases

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     s_portBases
    105          
    106          #if defined(FSL_FEATURE_SOC_FGPIO_COUNT) && FSL_FEATURE_SOC_FGPIO_COUNT
    107          
    108          /*******************************************************************************
    109           * Variables
    110           ******************************************************************************/
    111          static FGPIO_Type *const s_fgpioBases[] = FGPIO_BASE_PTRS;
    112          
    113          /*******************************************************************************
    114          * Prototypes
    115          ******************************************************************************/
    116          /*!
    117          * @brief Gets the FGPIO instance according to the GPIO base
    118          *
    119          * @param base    FGPIO peripheral base pointer(PTA, PTB, PTC, etc.)
    120          * @retval FGPIO instance
    121          */
    122          static uint32_t FGPIO_GetInstance(FGPIO_Type *base);
    123          
    124          /*******************************************************************************
    125           * Code
    126           ******************************************************************************/
    127          
    128          static uint32_t FGPIO_GetInstance(FGPIO_Type *base)
    129          {
    130              uint32_t instance;
    131          
    132              /* Find the instance index from base address mappings. */
    133              for (instance = 0; instance < FSL_FEATURE_SOC_FGPIO_COUNT; instance++)
    134              {
    135                  if (s_fgpioBases[instance] == base)
    136                  {
    137                      break;
    138                  }
    139              }
    140          
    141              assert(instance < FSL_FEATURE_SOC_FGPIO_COUNT);
    142          
    143              return instance;
    144          }
    145          
    146          void FGPIO_PinInit(FGPIO_Type *base, uint32_t pin, const gpio_pin_config_t *config)
    147          {
    148              assert(config);
    149          
    150              if (config->pinDirection == kGPIO_DigitalInput)
    151              {
    152                  base->PDDR &= ~(1U << pin);
    153              }
    154              else
    155              {
    156                  FGPIO_WritePinOutput(base, pin, config->outputLogic);
    157                  base->PDDR |= (1U << pin);
    158              }
    159          }
    160          
    161          uint32_t FGPIO_GetPinsInterruptFlags(FGPIO_Type *base)
    162          {
    163              uint8_t instance;
    164              instance = FGPIO_GetInstance(base);
    165              PORT_Type *portBase;
    166              portBase = s_portBases[instance];
    167              return portBase->ISFR;
    168          }
    169          
    170          void FGPIO_ClearPinsInterruptFlags(FGPIO_Type *base, uint32_t mask)
    171          {
    172              uint8_t instance;
    173              instance = FGPIO_GetInstance(base);
    174              PORT_Type *portBase;
    175              portBase = s_portBases[instance];
    176              portBase->ISFR = mask;
    177          }
    178          
    179          #endif /* FSL_FEATURE_SOC_FGPIO_COUNT */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   GPIO_ClearPinsInterruptFlags
        24   -> GPIO_GetInstance
       0   GPIO_GetInstance
      16   GPIO_GetPinsInterruptFlags
        16   -> GPIO_GetInstance
      16   GPIO_PinInit
        16   -> GPIO_WritePinOutput
       0   GPIO_WritePinOutput


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
      30  GPIO_ClearPinsInterruptFlags
      26  GPIO_GetInstance
      28  GPIO_GetPinsInterruptFlags
      48  GPIO_PinInit
      22  GPIO_WritePinOutput
      20  s_gpioBases
      20  s_portBases

 
  40 bytes in section .rodata
 162 bytes in section .text
 
 162 bytes of CODE  memory
  40 bytes of CONST memory

Errors: none
Warnings: none
