###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:23:53
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\bl_command.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\bl_command.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\bl_command.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\bl_command.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\bootloader\src\bl_command.c
      1          /*
      2           * Copyright (c) 2013-2016, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "bootloader_common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_SystemReset(void)
   \                     NVIC_SystemReset: (+1)
   \   00000000   0xF3BF 0x8F4F      DSB      
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable27  ;; 0xe000ed0c
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF410 0x60E0      ANDS     R0,R0,#0x700
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable27_1  ;; 0x5fa0004
   \   00000012   0x4308             ORRS     R0,R1,R0
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable27  ;; 0xe000ed0c
   \   00000018   0x6008             STR      R0,[R1, #+0]
   \   0000001A   0xF3BF 0x8F4F      DSB      
   \                     ??NVIC_SystemReset_0: (+1)
   \   0000001E   0xBF00             Nop      
   \   00000020   0xE7FD             B.N      ??NVIC_SystemReset_0
     32          #include "bootloader/bootloader.h"
     33          #include "memory/memory.h"
     34          #include "sbloader/sbloader.h"
     35          #include "property/property.h"
     36          #include "utilities/fsl_assert.h"
     37          #include "utilities/fsl_rtos_abstraction.h"
     38          #include <string.h>
     39          #include <stdint.h>
     40          
     41          #if !defined(BOOTLOADER_HOST)
     42          #include "flash/fsl_flash.h"
     43          #include "fsl_device_registers.h"
     44          #if BL_FEATURE_QSPI_MODULE
     45          #include "qspi/qspi.h"
     46          #endif // #if BL_FEATURE_QSPI_MODULE
     47          #if BL_FEATURE_OTFAD_MODULE
     48          #include "otfad/fsl_otfad_driver.h"
     49          #endif // #if BL_FEATURE_OTFAD_MODULE
     50          #endif
     51          
     52          #if BL_FEATURE_RELIABLE_UPDATE
     53          #include "bootloader/bl_reliable_update.h"
     54          #endif
     55          
     56          //! @addtogroup command
     57          //! @{
     58          
     59          //! @name State machine
     60          //@{
     61          static status_t handle_command(uint8_t *packet, uint32_t packetLength);
     62          static status_t handle_data(bool *hasMoreData);
     63          //@}
     64          
     65          //! @name Command handlers
     66          //@{
     67          void handle_reset(uint8_t *packet, uint32_t packetLength);
     68          void handle_flash_erase_all(uint8_t *packet, uint32_t packetLength);
     69          void handle_flash_erase_all_unsecure(uint8_t *packet, uint32_t packetLength);
     70          void handle_flash_erase_region(uint8_t *packet, uint32_t packetLength);
     71          void handle_receive_sb_file(uint8_t *packet, uint32_t packetLength);
     72          void handle_read_memory(uint8_t *packet, uint32_t packetLength);
     73          void handle_fill_memory(uint8_t *packet, uint32_t packetLength);
     74          void handle_set_property(uint8_t *packet, uint32_t packetLength);
     75          void handle_get_property(uint8_t *packet, uint32_t packetLength);
     76          void handle_write_memory(uint8_t *packet, uint32_t packetLength);
     77          void handle_execute(uint8_t *packet, uint32_t packetLength);
     78          void handle_call(uint8_t *packet, uint32_t packetLength);
     79          void handle_flash_security_disable(uint8_t *packet, uint32_t packetLength);
     80          void handle_flash_program_once(uint8_t *packet, uint32_t length);
     81          void handle_flash_read_once(uint8_t *packet, uint32_t length);
     82          void handle_flash_read_resource(uint8_t *packet, uint32_t length);
     83          void handle_configure_quadspi(uint8_t *packet, uint32_t packetLength);
     84          void handle_reliable_update(uint8_t *packet, uint32_t packetLength);
     85          //@}
     86          
     87          //! @name Command responses
     88          //@{
     89          void send_read_memory_response(uint32_t commandStatus, uint32_t length);
     90          void send_generic_response(uint32_t commandStatus, uint32_t commandTag);
     91          void send_get_property_response(uint32_t commandStatus, uint32_t *value, uint32_t numValues);
     92          void send_flash_read_once_response(uint32_t commandStatus, uint32_t *value, uint32_t byteCount);
     93          void send_flash_read_resource_response(uint32_t commandStatus, uint32_t length);
     94          //@}
     95          
     96          //! @name Data phase
     97          //@{
     98          static void reset_data_phase(void);
     99          void finalize_data_phase(status_t status);
    100          status_t handle_data_producer(bool *hasMoreData);
    101          status_t handle_data_consumer(bool *hasMoreData);
    102          //@}
    103          
    104          ////////////////////////////////////////////////////////////////////////////////
    105          // Definitions
    106          ////////////////////////////////////////////////////////////////////////////////
    107          
    108          //#define TEST_SENDER_ABORT
    109          //#define TEST_RECEIVER_ABORT
    110          
    111          enum _secure_commands
    112          {
    113              //! @brief Bitmask of commands allowed when flash security is enabled.
    114              //!
    115              //! This bitmask uses the same format as the AvailableCommands property. This is,
    116              //! the bit number for a given command is the command's tag value minus one.
    117              kCommandsAllowedWhenSecure = (HAS_CMD(kCommandTag_FlashSecurityDisable) | HAS_CMD(kCommandTag_GetProperty) |
    118                                            HAS_CMD(kCommandTag_Reset) | HAS_CMD(kCommandTag_SetProperty) |
    119                                            HAS_CMD(kCommandTag_FlashEraseAllUnsecure) | HAS_CMD(kCommandTag_ReceiveSbFile))
    120          };
    121          
    122          ////////////////////////////////////////////////////////////////////////////////
    123          // Variables
    124          ////////////////////////////////////////////////////////////////////////////////
    125          
    126          //! @brief Command handler table.

   \                                 In section .rodata, align 4
    127          const command_handler_entry_t g_commandHandlerTable[] = {
   \                     g_commandHandlerTable:
   \   00000000   0x........         DC32 handle_flash_erase_all, 0H, handle_flash_erase_region, 0H
   \              0x00000000   
   \              0x........   
   \              0x00000000   
   \   00000010   0x........         DC32 handle_read_memory, handle_data_producer, handle_write_memory
   \              0x........   
   \              0x........   
   \   0000001C   0x........         DC32 handle_data_consumer, handle_fill_memory, 0H
   \              0x........   
   \              0x00000000   
   \   00000028   0x........         DC32 handle_flash_security_disable, 0H, handle_get_property, 0H
   \              0x00000000   
   \              0x........   
   \              0x00000000   
   \   00000038   0x........         DC32 handle_receive_sb_file, handle_data_consumer, handle_execute, 0H
   \              0x........   
   \              0x........   
   \              0x00000000   
   \   00000048   0x........         DC32 handle_call, 0H, handle_reset, 0H, handle_set_property, 0H, 0H
   \              0x00000000   
   \              0x........   
   \              0x00000000   
   \              0x........   
   \              0x00000000   
   \              0x00000000   
   \   00000064   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000068   0x........         DC32 handle_flash_program_once, 0H, handle_flash_read_once, 0H
   \              0x00000000   
   \              0x........   
   \              0x00000000   
   \   00000078   0x........         DC32 handle_flash_read_resource, handle_data_producer, 0H
   \              0x........   
   \              0x00000000   
   \   00000084   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000088   0x00000000         DC32 0H
   \   0000008C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    128          // cmd handler              // data handler or NULL
    129          #if !BL_FEATURE_MIN_PROFILE
    130              { handle_flash_erase_all, NULL },              // kCommandTag_FlashEraseAll = 0x01
    131              { handle_flash_erase_region, NULL },           // kCommandTag_FlashEraseRegion = 0x02
    132              { handle_read_memory, handle_data_producer },  // kCommandTag_ReadMemory = 0x03
    133              { handle_write_memory, handle_data_consumer }, // kCommandTag_WriteMemory = 0x04
    134              { handle_fill_memory, NULL },                  // kCommandTag_FillMemory = 0x05
    135          #if BL_FEATURE_FLASH_SECURITY
    136              { handle_flash_security_disable, NULL }, // kCommandTag_FlashSecurityDisable = 0x06
    137          #else
    138              { 0 },
    139          #endif                                                // BL_FEATURE_FLASH_SECURITY
    140              { handle_get_property, NULL },                    // kCommandTag_GetProperty = 0x07
    141              { handle_receive_sb_file, handle_data_consumer }, // kCommandTag_ReceiveSbFile = 0x08
    142              { handle_execute, NULL },                         // kCommandTag_Execute = 0x09
    143              { handle_call, NULL },                            // kCommandTag_Call = 0x0a
    144              { handle_reset, NULL },                           // kCommandTag_Reset = 0x0b
    145              { handle_set_property, NULL },                    // kCommandTag_SetProperty = 0x0c
    146          #if BL_FEATURE_ERASEALL_UNSECURE
    147              { handle_flash_erase_all_unsecure, NULL }, // kCommandTag_FlashEraseAllUnsecure = 0x0d
    148          #else  // BL_FEATURE_ERASEALL_UNSECURE
    149              { 0 }, // kCommandTag_FlashEraseAllUnsecure = 0x0d
    150          #endif // BL_FEATURE_ERASEALL_UNSECURE
    151              { handle_flash_program_once, NULL },                  // kCommandTag_ProgramOnce = 0x0e
    152              { handle_flash_read_once, NULL },                     // kCommandTag_ReadOnce = 0x0f
    153              { handle_flash_read_resource, handle_data_producer }, // kCommandTag_ReadResource = 0x10
    154          #if BL_FEATURE_QSPI_MODULE
    155              { handle_configure_quadspi, NULL }, // kCommandTag_ConfigureQuadSpi = 0x11
    156          #else                                   // BL_FEATURE_QSPI_MODULE
    157              { 0 }, // kCommandTag_ConfigureQuadSpi = 0x11
    158          #endif                                  // BL_FEATURE_QSPI_MODULE
    159          #if BL_FEATURE_RELIABLE_UPDATE
    160              { handle_reliable_update, NULL }, // kCommandTag_ReliableUpdate = 0x12
    161          #else
    162              { 0 }, // kCommandTag_ReliableUpdate = 0x12
    163          #endif // BL_FEATURE_RELIABLE_UPDATE
    164          
    165          #else // BL_FEATURE_MIN_PROFILE
    166              { handle_flash_erase_all, NULL },    // kCommandTag_FlashEraseAll = 0x01
    167              { handle_flash_erase_region, NULL }, // kCommandTag_FlashEraseRegion = 0x02
    168          #if BL_FEATURE_READ_MEMORY
    169              { handle_read_memory, handle_data_producer }, // kCommandTag_ReadMemory = 0x03
    170          #else // BL_FEATURE_READ_MEMORY
    171              { 0 }, // kCommandTag_ReadMemory = 0x03
    172          #endif
    173              { handle_write_memory, handle_data_consumer }, // kCommandTag_WriteMemory = 0x04
    174          #if BL_FEATURE_FILL_MEMORY
    175              { handle_fill_memory, NULL }, // kCommandTag_FillMemory = 0x05
    176          #else
    177              { 0 },
    178          #endif // BL_FEATURE_FILL_MEMORY
    179          #if BL_FEATURE_FLASH_SECURITY
    180              { handle_flash_security_disable, NULL }, // kCommandTag_FlashSecurityDisable = 0x06
    181          #else
    182              { 0 },
    183          #endif // BL_FEATURE_FLASH_SECURITY
    184              { handle_get_property, NULL },             // kCommandTag_GetProperty = 0x07
    185              { 0 },                                     // kCommandTag_ReceiveSbFile = 0x08
    186              { handle_execute, NULL },                  // kCommandTag_Execute = 0x09
    187              { 0 },                                     // kCommandTag_Call = 0x0a
    188              { handle_reset, NULL },                    // kCommandTag_Reset = 0x0b
    189              { handle_set_property, NULL },             // kCommandTag_SetProperty = 0x0c
    190          #if BL_FEATURE_ERASEALL_UNSECURE
    191              { handle_flash_erase_all_unsecure, NULL }, // kCommandTag_FlashEraseAllUnsecure = 0x0d
    192          #else  // BL_FEATURE_ERASEALL_UNSECURE
    193              { 0 }, // kCommandTag_FlashEraseAllUnsecure = 0x0d
    194          #endif // BL_FEATURE_ERASEALL_UNSECURE
    195              { 0 },                                     // kCommandTag_ProgramOnce = 0x0e
    196              { 0 },                                     // kCommandTag_ReadOnce = 0x0f
    197              { 0 },                                     // kCommandTag_ReadResource = 0x10
    198              { 0 },                                     // kCommandTag_ConfigureQuadSpi = 0x11
    199              { 0 },                                     // kCommandTag_ReliableUpdate = 0x12
    200          #endif // BL_FEATURE_MIN_PROFILE
    201          };
    202          
    203          //! @brief Command processor state data.

   \                                 In section .bss, align 4
    204          command_processor_data_t g_commandData;
   \                     g_commandData:
   \   00000000                      DS8 36
    205          
    206          // See bl_command.h for documentation on this interface.

   \                                 In section .data, align 4
    207          command_interface_t g_commandInterface = { bootloader_command_init, bootloader_command_pump,
   \                     g_commandInterface:
   \   00000000   0x........         DC32 bootloader_command_init, bootloader_command_pump
   \              0x........   
   \   00000008   0x........         DC32 g_commandHandlerTable, g_commandData
   \              0x........   
    208                                                     (command_handler_entry_t *)&g_commandHandlerTable, &g_commandData };
    209          
    210          ////////////////////////////////////////////////////////////////////////////////
    211          // Code
    212          ////////////////////////////////////////////////////////////////////////////////
    213          
    214          // See bl_command.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    215          status_t bootloader_command_init()
    216          {
    217              command_processor_data_t *data = g_bootloaderContext.commandInterface->stateData;
   \                     bootloader_command_init: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
    218          
    219              data->state = kCommandState_CommandPhase;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    220              return kStatus_Success;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    221          }
    222          
    223          // See bl_command.h for documentation on this function.

   \                                 In section .text, align 2, keep-with-next
    224          status_t bootloader_command_pump()
    225          {
   \                     bootloader_command_pump: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    226              status_t status = kStatus_Success;
   \   00000002   0x2400             MOVS     R4,#+0
    227              bool hasMoreData = false;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    228          
    229              if (g_bootloaderContext.activePeripheral->packetInterface)
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   0000000E   0x69C0             LDR      R0,[R0, #+28]
   \   00000010   0x6940             LDR      R0,[R0, #+20]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD057             BEQ.N    ??bootloader_command_pump_0
    230              {
    231                  switch (g_bootloaderContext.commandInterface->stateData->state)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   0000001A   0x68C0             LDR      R0,[R0, #+12]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD03C             BEQ.N    ??bootloader_command_pump_1
    232                  {
    233                      default:
    234                      case kCommandState_CommandPhase:
    235                          status = g_bootloaderContext.activePeripheral->packetInterface->readPacket(
    236                              g_bootloaderContext.activePeripheral, &g_bootloaderContext.commandInterface->stateData->packet,
    237                              &g_bootloaderContext.commandInterface->stateData->packetLength, kPacketType_Command);
   \   00000024   0x2300             MOVS     R3,#+0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0x68C0             LDR      R0,[R0, #+12]
   \   0000002E   0xF110 0x0208      ADDS     R2,R0,#+8
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000036   0x68C0             LDR      R0,[R0, #+12]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0x1D01             ADDS     R1,R0,#+4
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000040   0x69C0             LDR      R0,[R0, #+28]
   \   00000042   0x.... 0x....      LDR.W    R5,??DataTable27_2
   \   00000046   0x69ED             LDR      R5,[R5, #+28]
   \   00000048   0x696D             LDR      R5,[R5, #+20]
   \   0000004A   0x686D             LDR      R5,[R5, #+4]
   \   0000004C   0x47A8             BLX      R5
   \   0000004E   0x0004             MOVS     R4,R0
    238                          if ((status != kStatus_Success) && (status != kStatus_AbortDataPhase) && (status != kStatus_Ping))
   \   00000050   0x2C00             CMP      R4,#+0
   \   00000052   0xD007             BEQ.N    ??bootloader_command_pump_2
   \   00000054   0xF242 0x7012      MOVW     R0,#+10002
   \   00000058   0x4284             CMP      R4,R0
   \   0000005A   0xD003             BEQ.N    ??bootloader_command_pump_2
   \   0000005C   0xF242 0x7013      MOVW     R0,#+10003
   \   00000060   0x4284             CMP      R4,R0
   \   00000062   0xD130             BNE.N    ??bootloader_command_pump_0
    239                          {
    240                              debug_printf("Error: readPacket returned status 0x%x\r\n", status);
    241                              break;
    242                          }
    243                          if (g_bootloaderContext.commandInterface->stateData->packetLength == 0)
   \                     ??bootloader_command_pump_2: (+1)
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000068   0x68C0             LDR      R0,[R0, #+12]
   \   0000006A   0x68C0             LDR      R0,[R0, #+12]
   \   0000006C   0x6880             LDR      R0,[R0, #+8]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD029             BEQ.N    ??bootloader_command_pump_0
    244                          {
    245                              // No command packet is available. Return success.
    246                              break;
    247                          }
    248                          status = handle_command(g_bootloaderContext.commandInterface->stateData->packet,
    249                                                  g_bootloaderContext.commandInterface->stateData->packetLength);
   \                     ??bootloader_command_pump_3: (+1)
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000076   0x68C0             LDR      R0,[R0, #+12]
   \   00000078   0x68C0             LDR      R0,[R0, #+12]
   \   0000007A   0x6881             LDR      R1,[R0, #+8]
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000080   0x68C0             LDR      R0,[R0, #+12]
   \   00000082   0x68C0             LDR      R0,[R0, #+12]
   \   00000084   0x6840             LDR      R0,[R0, #+4]
   \   00000086   0x.... 0x....      BL       handle_command
   \   0000008A   0x0004             MOVS     R4,R0
    250                          if (status != kStatus_Success)
   \   0000008C   0x2C00             CMP      R4,#+0
   \   0000008E   0xD11A             BNE.N    ??bootloader_command_pump_0
    251                          {
    252                              debug_printf("Error: handle_command returned status 0x%x\r\n", status);
    253                              break;
    254                          }
    255                          g_bootloaderContext.commandInterface->stateData->state = kCommandState_DataPhase;
   \                     ??bootloader_command_pump_4: (+1)
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   00000096   0x68C9             LDR      R1,[R1, #+12]
   \   00000098   0x68C9             LDR      R1,[R1, #+12]
   \   0000009A   0x6008             STR      R0,[R1, #+0]
    256                          break;
   \   0000009C   0xE013             B.N      ??bootloader_command_pump_0
    257          
    258                      case kCommandState_DataPhase:
    259                          status = handle_data(&hasMoreData);
   \                     ??bootloader_command_pump_1: (+1)
   \   0000009E   0x4668             MOV      R0,SP
   \   000000A0   0x.... 0x....      BL       handle_data
   \   000000A4   0x0004             MOVS     R4,R0
    260                          if (status != kStatus_Success)
   \   000000A6   0x2C00             CMP      R4,#+0
   \   000000A8   0xD006             BEQ.N    ??bootloader_command_pump_5
    261                          {
    262                              debug_printf("Error: handle_data returned status 0x%x\r\n", status);
    263                              g_bootloaderContext.commandInterface->stateData->state = kCommandState_CommandPhase;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   000000B0   0x68C9             LDR      R1,[R1, #+12]
   \   000000B2   0x68C9             LDR      R1,[R1, #+12]
   \   000000B4   0x6008             STR      R0,[R1, #+0]
    264                              break;
   \   000000B6   0xE006             B.N      ??bootloader_command_pump_0
    265                          }
    266                          g_bootloaderContext.commandInterface->stateData->state =
    267                              hasMoreData ? kCommandState_DataPhase : kCommandState_CommandPhase;
   \                     ??bootloader_command_pump_5: (+1)
   \   000000B8   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   000000C0   0x68C9             LDR      R1,[R1, #+12]
   \   000000C2   0x68C9             LDR      R1,[R1, #+12]
   \   000000C4   0x6008             STR      R0,[R1, #+0]
    268                          break;
    269                  }
    270              }
    271          
    272              return status;
   \                     ??bootloader_command_pump_0: (+1)
   \   000000C6   0x0020             MOVS     R0,R4
   \   000000C8   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    273          }
    274          
    275          //! @brief Find command handler entry.
    276          //!
    277          //! @retval NULL if no entry found.

   \                                 In section .text, align 2, keep-with-next
    278          static const command_handler_entry_t *find_entry(uint8_t tag)
    279          {
   \                     find_entry: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    280              if (tag < kFirstCommandTag || tag > kLastCommandTag)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD002             BEQ.N    ??find_entry_0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x2913             CMP      R1,#+19
   \   0000000C   0xDB01             BLT.N    ??find_entry_1
    281              {
    282                  return 0; // invalid command
   \                     ??find_entry_0: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE007             B.N      ??find_entry_2
    283              }
    284              const command_handler_entry_t *entry =
    285                  &g_bootloaderContext.commandInterface->handlerTable[(tag - kFirstCommandTag)];
   \                     ??find_entry_1: (+1)
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000016   0x68C0             LDR      R0,[R0, #+12]
   \   00000018   0x6880             LDR      R0,[R0, #+8]
   \   0000001A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   0xEB00 0x00C1      ADD      R0,R0,R1, LSL #+3
   \   00000020   0x3808             SUBS     R0,R0,#+8
    286          
    287              return entry;
   \                     ??find_entry_2: (+1)
   \   00000022   0x4770             BX       LR               ;; return
    288          }
    289          
    290          //! @brief Handle a command transaction.

   \                                 In section .text, align 2, keep-with-next
    291          static status_t handle_command(uint8_t *packet, uint32_t packetLength)
    292          {
   \                     handle_command: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    293              command_packet_t *commandPacket = (command_packet_t *)packet;
   \   0000000A   0x0026             MOVS     R6,R4
    294              uint8_t commandTag = commandPacket->commandTag;
   \   0000000C   0x7837             LDRB     R7,[R6, #+0]
    295              status_t status = kStatus_Success;
   \   0000000E   0xF05F 0x0800      MOVS     R8,#+0
    296          
    297              // Look up the handler entry and save it for the data phaase.
    298              g_bootloaderContext.commandInterface->stateData->handlerEntry = find_entry(commandTag);
   \   00000012   0x0038             MOVS     R0,R7
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x.... 0x....      BL       find_entry
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   0000001E   0x68C9             LDR      R1,[R1, #+12]
   \   00000020   0x68C9             LDR      R1,[R1, #+12]
   \   00000022   0x6208             STR      R0,[R1, #+32]
    299          
    300              if (g_bootloaderContext.commandInterface->stateData->handlerEntry &&
    301                  g_bootloaderContext.commandInterface->stateData->handlerEntry->handleCommand)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000028   0x68C0             LDR      R0,[R0, #+12]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0x6A00             LDR      R0,[R0, #+32]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD02C             BEQ.N    ??handle_command_0
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000036   0x68C0             LDR      R0,[R0, #+12]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0x6A00             LDR      R0,[R0, #+32]
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD024             BEQ.N    ??handle_command_0
    302              {
    303          #if !BOOTLOADER_HOST
    304                  // Get flash security state.
    305                  flash_security_state_t securityState;
    306                  status = g_bootloaderContext.flashDriverInterface->flash_get_security_state(&g_bootloaderContext.flashState,
    307                                                                                              &securityState);
   \   00000042   0x4669             MOV      R1,SP
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   00000048   0x.... 0x....      LDR.W    R2,??DataTable27_2
   \   0000004C   0x6912             LDR      R2,[R2, #+16]
   \   0000004E   0x6992             LDR      R2,[R2, #+24]
   \   00000050   0x4790             BLX      R2
   \   00000052   0x4680             MOV      R8,R0
    308          
    309                  if (status == kStatus_Success)
   \   00000054   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000058   0xD11B             BNE.N    ??handle_command_1
    310                  {
    311                      // If flash security is enabled, make sure the command is one that is allowed. If
    312                      // it's not, then we return an error response.
    313                      if ((securityState != kFLASH_SecurityStateNotSecure) &&
    314                          !IS_CMD_AVAILABLE(kCommandsAllowedWhenSecure, commandTag))
   \   0000005A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD009             BEQ.N    ??handle_command_2
   \   00000062   0xF44F 0x50E7      MOV      R0,#+7392
   \   00000066   0x1E79             SUBS     R1,R7,#+1
   \   00000068   0x4108             ASRS     R0,R0,R1
   \   0000006A   0x07C0             LSLS     R0,R0,#+31
   \   0000006C   0xD403             BMI.N    ??handle_command_2
    315                      {
    316                          // Security is enabled and the command is not one of the few that can be
    317                          // run, so return a security violation error.
    318                          debug_printf("Error: command 0x%x not available due to flash security\r\n", commandPacket->commandTag);
    319                          status = kStatus_SecurityViolation;
   \   0000006E   0xF242 0x7011      MOVW     R0,#+10001
   \   00000072   0x4680             MOV      R8,R0
   \   00000074   0xE00D             B.N      ??handle_command_1
    320                      }
    321                      else
    322                      {
    323          #endif // BOOTLOADER_HOST
    324                          // Process the command normally.
    325                          g_bootloaderContext.commandInterface->stateData->handlerEntry->handleCommand(packet, packetLength);
   \                     ??handle_command_2: (+1)
   \   00000076   0x0029             MOVS     R1,R5
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0x.... 0x....      LDR.W    R2,??DataTable27_2
   \   0000007E   0x68D2             LDR      R2,[R2, #+12]
   \   00000080   0x68D2             LDR      R2,[R2, #+12]
   \   00000082   0x6A12             LDR      R2,[R2, #+32]
   \   00000084   0x6812             LDR      R2,[R2, #+0]
   \   00000086   0x4790             BLX      R2
    326                          return kStatus_Success;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xE008             B.N      ??handle_command_3
    327          #if !BOOTLOADER_HOST
    328                      }
    329                  }
    330          #endif // BOOTLOADER_HOST
    331              }
    332              else
    333              {
    334                  // We don't recognize this command, so return an error response.
    335                  debug_printf("unknown command 0x%x\r\n", commandPacket->commandTag);
    336                  status = kStatus_UnknownCommand;
   \                     ??handle_command_0: (+1)
   \   0000008C   0xF242 0x7010      MOVW     R0,#+10000
   \   00000090   0x4680             MOV      R8,R0
    337              }
    338          
    339              // Should only get to this point if an error occurred before running the command handler.
    340              send_generic_response(status, commandTag);
   \                     ??handle_command_1: (+1)
   \   00000092   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000094   0x0039             MOVS     R1,R7
   \   00000096   0x4640             MOV      R0,R8
   \   00000098   0x.... 0x....      BL       send_generic_response
    341              return status;
   \   0000009C   0x4640             MOV      R0,R8
   \                     ??handle_command_3: (+1)
   \   0000009E   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    342          }
    343          
    344          //! @brief Handle a data transaction.

   \                                 In section .text, align 2, keep-with-next
    345          static status_t handle_data(bool *hasMoreData)
    346          {
   \                     handle_data: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    347              if (g_bootloaderContext.commandInterface->stateData->handlerEntry)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000008   0x68C0             LDR      R0,[R0, #+12]
   \   0000000A   0x68C0             LDR      R0,[R0, #+12]
   \   0000000C   0x6A00             LDR      R0,[R0, #+32]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD014             BEQ.N    ??handle_data_0
    348              {
    349                  // Run data phase if present, otherwise just return success.
    350                  *hasMoreData = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x7020             STRB     R0,[R4, #+0]
    351                  return g_bootloaderContext.commandInterface->stateData->handlerEntry->handleData ?
    352                             g_bootloaderContext.commandInterface->stateData->handlerEntry->handleData(hasMoreData) :
    353                             kStatus_Success;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   0000001A   0x68C0             LDR      R0,[R0, #+12]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0x6A00             LDR      R0,[R0, #+32]
   \   00000020   0x6840             LDR      R0,[R0, #+4]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD008             BEQ.N    ??handle_data_1
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   0000002C   0x68C9             LDR      R1,[R1, #+12]
   \   0000002E   0x68C9             LDR      R1,[R1, #+12]
   \   00000030   0x6A09             LDR      R1,[R1, #+32]
   \   00000032   0x6849             LDR      R1,[R1, #+4]
   \   00000034   0x4788             BLX      R1
   \   00000036   0xE000             B.N      ??handle_data_2
   \                     ??handle_data_1: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??handle_data_2: (+1)
   \   0000003A   0xE000             B.N      ??handle_data_3
    354              }
    355          
    356              debug_printf("Error: no handler entry for data phase\r\n");
    357              return kStatus_Success;
   \                     ??handle_data_0: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \                     ??handle_data_3: (+1)
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    358          }
    359          
    360          ////////////////////////////////////////////////////////////////////////////////
    361          // Command Handlers
    362          ////////////////////////////////////////////////////////////////////////////////
    363          
    364          //! @brief Reset command handler.

   \                                 In section .text, align 2, keep-with-next
    365          void handle_reset(uint8_t *packet, uint32_t packetLength)
    366          {
   \                     handle_reset: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    367              command_packet_t *commandPacket = (command_packet_t *)packet;
    368              send_generic_response(kStatus_Success, commandPacket->commandTag);
   \   00000006   0x7821             LDRB     R1,[R4, #+0]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      BL       send_generic_response
    369          
    370          #if !defined(BOOTLOADER_HOST)
    371              // Wait for the ack from the host to the generic response
    372              g_bootloaderContext.activePeripheral->packetInterface->finalize(g_bootloaderContext.activePeripheral);
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000012   0x69C0             LDR      R0,[R0, #+28]
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   00000018   0x69C9             LDR      R1,[R1, #+28]
   \   0000001A   0x6949             LDR      R1,[R1, #+20]
   \   0000001C   0x6909             LDR      R1,[R1, #+16]
   \   0000001E   0x4788             BLX      R1
    373          
    374              // Prepare for shutdown.
    375              shutdown_cleanup(kShutdownType_Reset);
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x.... 0x....      BL       shutdown_cleanup
    376          
    377              NVIC_SystemReset();
   \   00000026   0x.... 0x....      BL       NVIC_SystemReset
    378              // Does not get here.
    379              assert(0);
    380          #endif // BOOTLOADER_HOST
    381          }
   \   0000002A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    382          
    383          #if BL_FEATURE_RELIABLE_UPDATE
    384          //! @brief Reliable Update command handler.
    385          void handle_reliable_update(uint8_t *packet, uint32_t packetLength)
    386          {
    387              command_packet_t *commandPacket = (command_packet_t *)packet;
    388              status_t status = kStatus_Success;
    389          
    390          #if !defined(BOOTLOADER_HOST)
    391              reliable_update_packet_t *command = (reliable_update_packet_t *)packet;
    392              uint32_t address = command->address;
    393          
    394              // Call reliable update implementation..
    395              bootloader_reliable_update_as_requested(kReliableUpdateOption_Swap, address);
    396          
    397              status = g_bootloaderContext.propertyInterface->store->reliableUpdateStatus;
    398              send_generic_response(status, commandPacket->commandTag);
    399          
    400              if (status == kStatus_ReliableUpdateSuccess)
    401              {
    402                  // Wait for the ack from the host to the generic response
    403                  g_bootloaderContext.activePeripheral->packetInterface->finalize(g_bootloaderContext.activePeripheral);
    404          
    405                  // Prepare for shutdown.
    406                  shutdown_cleanup(kShutdownType_Reset);
    407          
    408                  NVIC_SystemReset();
    409                  // Does not get here.
    410                  assert(0);
    411              }
    412          #else
    413              send_generic_response(status, commandPacket->commandTag);
    414          #endif // BOOTLOADER_HOST
    415          }
    416          #endif // BL_FEATURE_RELIABLE_UPDATE
    417          
    418          //! @brief Reset data phase variables.

   \                                 In section .text, align 2, keep-with-next
    419          static void reset_data_phase()
    420          {
   \                     reset_data_phase: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    421              memset(&g_bootloaderContext.commandInterface->stateData->dataPhase, 0,
    422                     sizeof(g_bootloaderContext.commandInterface->stateData->dataPhase));
   \   00000002   0x2414             MOVS     R4,#+20
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   0000000A   0x68C0             LDR      R0,[R0, #+12]
   \   0000000C   0x68C0             LDR      R0,[R0, #+12]
   \   0000000E   0xF110 0x060C      ADDS     R6,R0,#+12
   \   00000012   0x002A             MOVS     R2,R5
   \   00000014   0x0021             MOVS     R1,R4
   \   00000016   0x0030             MOVS     R0,R6
   \   00000018   0x.... 0x....      BL       __aeabi_memset
    423          }
   \   0000001C   0xBD70             POP      {R4-R6,PC}       ;; return
    424          
    425          //! @brief Flash Erase All command handler.

   \                                 In section .text, align 2, keep-with-next
    426          void handle_flash_erase_all(uint8_t *packet, uint32_t packetLength)
    427          {
   \                     handle_flash_erase_all: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    428              flash_erase_all_packet_t *commandPacket = (flash_erase_all_packet_t *)packet;
    429              status_t status = kStatus_Success;
   \   00000006   0x2600             MOVS     R6,#+0
    430          
    431          // Call flash erase all implementation.
    432          #ifdef BOOTLOADER_HOST
    433              host_flash_erase_all();
    434          #else
    435                                                         // For target without QSPI module, ignore the memory identifier
    436          #if ((!BL_FEATURE_QSPI_MODULE) && (!BL_FEATURE_FAC_ERASE))
    437              status = flash_mem_erase_all();
   \   00000008   0x.... 0x....      BL       flash_mem_erase_all
   \   0000000C   0x0006             MOVS     R6,R0
    438          #else
    439              switch (commandPacket->memoryId)
    440              {
    441          #if BL_FEATURE_FAC_ERASE
    442                  case kFlashMemInternal:
    443                      status = flash_mem_erase_all(kFlashEraseAllOption_Blocks);
    444                      break;
    445                  case kFlashMemExecuteOnly:
    446                      status = flash_mem_erase_all(kFlashEraseAllOption_ExecuteOnlySegments);
    447                      break;
    448          #else
    449                  case kFlashMemInternal:
    450                      status = flash_mem_erase_all();
    451                      break;
    452          #endif
    453          #if BL_FEATURE_QSPI_MODULE
    454                  case kFlashMemQuadSpi0:
    455                      status = qspi_mem_erase_all();
    456                      break;
    457          #endif
    458                  default:
    459                      status = kStatus_InvalidArgument;
    460                      break;
    461              }
    462          #endif // #if (!BL_FEATURE_QSPI_MODULE)
    463          #endif // #ifdef BOOTLOADER_HOST
    464          
    465              send_generic_response(status, commandPacket->commandPacket.commandTag);
   \   0000000E   0x7821             LDRB     R1,[R4, #+0]
   \   00000010   0x0030             MOVS     R0,R6
   \   00000012   0x.... 0x....      BL       send_generic_response
    466          }
   \   00000016   0xBD70             POP      {R4-R6,PC}       ;; return
    467          
    468          //! @brief Flash Erase All Unsecure command handler.

   \                                 In section .text, align 2, keep-with-next
    469          void handle_flash_erase_all_unsecure(uint8_t *packet, uint32_t packetLength)
    470          {
   \                     handle_flash_erase_all_unsecure: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    471              command_packet_t *commandPacket = (command_packet_t *)packet;
    472              status_t status = kStatus_Success;
   \   00000006   0x2600             MOVS     R6,#+0
    473          
    474          // Call flash erase all unsecure implementation.
    475          #ifdef BOOTLOADER_HOST
    476              host_flash_erase_all_unsecure();
    477          #else
    478              status = flash_mem_erase_all_unsecure();
   \   00000008   0x.... 0x....      BL       flash_mem_erase_all_unsecure
   \   0000000C   0x0006             MOVS     R6,R0
    479          #endif
    480          
    481              send_generic_response(status, commandPacket->commandTag);
   \   0000000E   0x7821             LDRB     R1,[R4, #+0]
   \   00000010   0x0030             MOVS     R0,R6
   \   00000012   0x.... 0x....      BL       send_generic_response
    482          }
   \   00000016   0xBD70             POP      {R4-R6,PC}       ;; return
    483          
    484          //! @brief Flash Erase Region command handler.

   \                                 In section .text, align 2, keep-with-next
    485          void handle_flash_erase_region(uint8_t *packet, uint32_t packetLength)
    486          {
   \                     handle_flash_erase_region: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    487              flash_erase_region_packet_t *command = (flash_erase_region_packet_t *)packet;
    488              status_t status = kStatus_Success;
   \   00000006   0x2600             MOVS     R6,#+0
    489          
    490          // Call flash erase region implementation.
    491          #ifdef BOOTLOADER_HOST
    492              host_flash_erase_region(command->startAddress, command->byteCount);
    493          #else
    494              status = g_bootloaderContext.memoryInterface->erase(command->startAddress, command->byteCount);
   \   00000008   0x68A1             LDR      R1,[R4, #+8]
   \   0000000A   0x6860             LDR      R0,[R4, #+4]
   \   0000000C   0x.... 0x....      LDR.W    R2,??DataTable27_2
   \   00000010   0x6812             LDR      R2,[R2, #+0]
   \   00000012   0x6952             LDR      R2,[R2, #+20]
   \   00000014   0x4790             BLX      R2
   \   00000016   0x0006             MOVS     R6,R0
    495          #endif
    496          
    497              send_generic_response(status, command->commandPacket.commandTag);
   \   00000018   0x7821             LDRB     R1,[R4, #+0]
   \   0000001A   0x0030             MOVS     R0,R6
   \   0000001C   0x.... 0x....      BL       send_generic_response
    498          }
   \   00000020   0xBD70             POP      {R4-R6,PC}       ;; return
    499          
    500          //! @brief Receive SB File command handler.

   \                                 In section .text, align 2, keep-with-next
    501          void handle_receive_sb_file(uint8_t *packet, uint32_t packetLength)
    502          {
   \                     handle_receive_sb_file: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    503              receive_sb_file_packet_t *command = (receive_sb_file_packet_t *)packet;
    504          
    505              // Start the data phase.
    506              reset_data_phase();
   \   00000006   0x.... 0x....      BL       reset_data_phase
    507              g_bootloaderContext.commandInterface->stateData->dataPhase.count = command->byteCount;
   \   0000000A   0x6860             LDR      R0,[R4, #+4]
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   00000010   0x68C9             LDR      R1,[R1, #+12]
   \   00000012   0x68C9             LDR      R1,[R1, #+12]
   \   00000014   0x6108             STR      R0,[R1, #+16]
    508              g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag = kCommandTag_ReceiveSbFile;
   \   00000016   0x2008             MOVS     R0,#+8
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   0000001C   0x68C9             LDR      R1,[R1, #+12]
   \   0000001E   0x68C9             LDR      R1,[R1, #+12]
   \   00000020   0x7708             STRB     R0,[R1, #+28]
    509              send_generic_response(kStatus_Success, command->commandPacket.commandTag);
   \   00000022   0x7821             LDRB     R1,[R4, #+0]
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      BL       send_generic_response
    510          
    511              // Initialize the SB file loader state machine
    512              sbloader_init();
   \   0000002A   0x.... 0x....      BL       sbloader_init
    513          }
   \   0000002E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    514          
    515          //! @brief Get Property command handler.

   \                                 In section .text, align 2, keep-with-next
    516          void handle_get_property(uint8_t *packet, uint32_t packetLength)
    517          {
   \                     handle_get_property: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    518              get_property_packet_t *command = (get_property_packet_t *)packet;
    519          
    520              uint32_t *value = NULL;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9001             STR      R0,[SP, #+4]
    521              uint32_t valueSize = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9000             STR      R0,[SP, #+0]
    522              status_t status = g_bootloaderContext.propertyInterface->get(command->propertyTag, command->memoryId,
    523                                                                           (const void **)&value, &valueSize);
   \   0000000E   0x466B             MOV      R3,SP
   \   00000010   0xAA01             ADD      R2,SP,#+4
   \   00000012   0x68A1             LDR      R1,[R4, #+8]
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x6860             LDR      R0,[R4, #+4]
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x.... 0x....      LDR.W    R6,??DataTable27_2
   \   0000001E   0x68B6             LDR      R6,[R6, #+8]
   \   00000020   0x68B6             LDR      R6,[R6, #+8]
   \   00000022   0x47B0             BLX      R6
   \   00000024   0x0006             MOVS     R6,R0
    524          
    525              // Make sure the property's size is no more than the size of the max number of return parameters.
    526              assert(valueSize <= (kMaxPropertyReturnValues * sizeof(uint32_t)));
    527          
    528              // Currently there are no property responses that contain a data phase.
    529              g_bootloaderContext.commandInterface->stateData->dataPhase.count = 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   0000002C   0x68C9             LDR      R1,[R1, #+12]
   \   0000002E   0x68C9             LDR      R1,[R1, #+12]
   \   00000030   0x6108             STR      R0,[R1, #+16]
    530              send_get_property_response(status, value, (valueSize / sizeof(uint32_t)));
   \   00000032   0x9800             LDR      R0,[SP, #+0]
   \   00000034   0x0882             LSRS     R2,R0,#+2
   \   00000036   0x9901             LDR      R1,[SP, #+4]
   \   00000038   0x0030             MOVS     R0,R6
   \   0000003A   0x.... 0x....      BL       send_get_property_response
    531          }
   \   0000003E   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    532          
    533          //! @brief Set Property command handler.

   \                                 In section .text, align 2, keep-with-next
    534          void handle_set_property(uint8_t *packet, uint32_t packetLength)
    535          {
   \                     handle_set_property: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    536              set_property_packet_t *command = (set_property_packet_t *)packet;
    537          
    538              status_t status = g_bootloaderContext.propertyInterface->set_uint32(command->propertyTag, command->propertyValue);
   \   00000006   0x68A1             LDR      R1,[R4, #+8]
   \   00000008   0x6860             LDR      R0,[R4, #+4]
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      LDR.W    R2,??DataTable27_2
   \   00000010   0x6892             LDR      R2,[R2, #+8]
   \   00000012   0x68D2             LDR      R2,[R2, #+12]
   \   00000014   0x4790             BLX      R2
   \   00000016   0x0006             MOVS     R6,R0
    539          
    540              send_generic_response(status, command->commandPacket.commandTag);
   \   00000018   0x7821             LDRB     R1,[R4, #+0]
   \   0000001A   0x0030             MOVS     R0,R6
   \   0000001C   0x.... 0x....      BL       send_generic_response
    541          }
   \   00000020   0xBD70             POP      {R4-R6,PC}       ;; return
    542          
    543          #if BL_FEATURE_QSPI_MODULE
    544          //! @brief Configure QuadSpi command handler.
    545          void handle_configure_quadspi(uint8_t *packet, uint32_t packetLength)
    546          {
    547              configure_quadspi_packet_t *command = (configure_quadspi_packet_t *)packet;
    548              status_t status = kStatus_Success;
    549          
    550              uint32_t startAddr = command->configBlockAddress;
    551              uint32_t endAddr = startAddr + sizeof(qspi_config_t) - 1;
    552          
    553              // Validate parameters.
    554              if ((command->flashMemId != kFlashMemQuadSpi0) || (!is_valid_application_location(startAddr)) ||
    555                  (!is_valid_application_location(endAddr)))
    556              {
    557                  status = kStatus_InvalidArgument;
    558              }
    559          
    560              // Call configure quadspi implementation.
    561              if (status == kStatus_Success)
    562              {
    563          #ifdef BOOTLOADER_HOST
    564          #else
    565                  status = quadspi_init((void *)startAddr);
    566                  if (status == kStatus_Success)
    567                  {
    568                      // Re-init memory interface to intialize qspi memory interface
    569                      g_bootloaderContext.memoryInterface->init();
    570                  }
    571                  g_bootloaderContext.propertyInterface->store->qspiInitStatus = status;
    572          #endif
    573              }
    574          
    575              send_generic_response(status, command->commandPacket.commandTag);
    576          }
    577          #endif // BL_FEATURE_QSPI_MODULE
    578          
    579          //! @brief Write Memory command handler.

   \                                 In section .text, align 2, keep-with-next
    580          void handle_write_memory(uint8_t *packet, uint32_t packetLength)
    581          {
   \                     handle_write_memory: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    582              write_memory_packet_t *command = (write_memory_packet_t *)packet;
    583          
    584              // Start the data phase.
    585              reset_data_phase();
   \   00000006   0x.... 0x....      BL       reset_data_phase
    586              g_bootloaderContext.commandInterface->stateData->dataPhase.count = command->byteCount;
   \   0000000A   0x68A0             LDR      R0,[R4, #+8]
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   00000010   0x68C9             LDR      R1,[R1, #+12]
   \   00000012   0x68C9             LDR      R1,[R1, #+12]
   \   00000014   0x6108             STR      R0,[R1, #+16]
    587              g_bootloaderContext.commandInterface->stateData->dataPhase.address = command->startAddress;
   \   00000016   0x6860             LDR      R0,[R4, #+4]
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   0000001C   0x68C9             LDR      R1,[R1, #+12]
   \   0000001E   0x68C9             LDR      R1,[R1, #+12]
   \   00000020   0x6148             STR      R0,[R1, #+20]
    588              g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag = kCommandTag_WriteMemory;
   \   00000022   0x2004             MOVS     R0,#+4
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   00000028   0x68C9             LDR      R1,[R1, #+12]
   \   0000002A   0x68C9             LDR      R1,[R1, #+12]
   \   0000002C   0x7708             STRB     R0,[R1, #+28]
    589              send_generic_response(kStatus_Success, command->commandPacket.commandTag);
   \   0000002E   0x7821             LDRB     R1,[R4, #+0]
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      BL       send_generic_response
    590          }
   \   00000036   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    591          
    592          //! @brief Read Memory command handler.

   \                                 In section .text, align 2, keep-with-next
    593          void handle_read_memory(uint8_t *packet, uint32_t packetLength)
    594          {
   \                     handle_read_memory: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    595              read_memory_packet_t *command = (read_memory_packet_t *)packet;
    596          
    597              // Start the data phase.
    598              reset_data_phase();
   \   00000006   0x.... 0x....      BL       reset_data_phase
    599              g_bootloaderContext.commandInterface->stateData->dataPhase.count = command->byteCount;
   \   0000000A   0x68A0             LDR      R0,[R4, #+8]
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   00000010   0x68C9             LDR      R1,[R1, #+12]
   \   00000012   0x68C9             LDR      R1,[R1, #+12]
   \   00000014   0x6108             STR      R0,[R1, #+16]
    600              g_bootloaderContext.commandInterface->stateData->dataPhase.address = command->startAddress;
   \   00000016   0x6860             LDR      R0,[R4, #+4]
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   0000001C   0x68C9             LDR      R1,[R1, #+12]
   \   0000001E   0x68C9             LDR      R1,[R1, #+12]
   \   00000020   0x6148             STR      R0,[R1, #+20]
    601              g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag = kCommandTag_ReadMemory;
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   00000028   0x68C9             LDR      R1,[R1, #+12]
   \   0000002A   0x68C9             LDR      R1,[R1, #+12]
   \   0000002C   0x7708             STRB     R0,[R1, #+28]
    602              send_read_memory_response(kStatus_Success, command->byteCount);
   \   0000002E   0x68A1             LDR      R1,[R4, #+8]
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      BL       send_read_memory_response
    603          }
   \   00000036   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    604          
    605          //! @brief Complete the data phase, optionally send a response.

   \                                 In section .text, align 2, keep-with-next
    606          void finalize_data_phase(status_t status)
    607          {
   \                     finalize_data_phase: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    608              g_bootloaderContext.commandInterface->stateData->dataPhase.address = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   0000000A   0x68C9             LDR      R1,[R1, #+12]
   \   0000000C   0x68C9             LDR      R1,[R1, #+12]
   \   0000000E   0x6148             STR      R0,[R1, #+20]
    609              g_bootloaderContext.commandInterface->stateData->dataPhase.count = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   00000016   0x68C9             LDR      R1,[R1, #+12]
   \   00000018   0x68C9             LDR      R1,[R1, #+12]
   \   0000001A   0x6108             STR      R0,[R1, #+16]
    610          
    611              // Force to write cached data to target memory
    612              if (g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag == kCommandTag_WriteMemory)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000020   0x68C0             LDR      R0,[R0, #+12]
   \   00000022   0x68C0             LDR      R0,[R0, #+12]
   \   00000024   0x7F00             LDRB     R0,[R0, #+28]
   \   00000026   0x2804             CMP      R0,#+4
   \   00000028   0xD107             BNE.N    ??finalize_data_phase_0
    613              {
    614                  assert(g_bootloaderContext.memoryInterface->flush);
    615                  status_t flushStatus = g_bootloaderContext.memoryInterface->flush();
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x6900             LDR      R0,[R0, #+16]
   \   00000032   0x4780             BLX      R0
    616          
    617                  // Update status only if the last operation result is successfull in order to reflect
    618                  // real result of the write operation.
    619                  if (status == kStatus_Success)
   \   00000034   0x2C00             CMP      R4,#+0
   \   00000036   0xD100             BNE.N    ??finalize_data_phase_0
    620                  {
    621                      status = flushStatus;
   \   00000038   0x0004             MOVS     R4,R0
    622                  }
    623              }
    624          
    625              // Send final response packet.
    626              send_generic_response(status, g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag);
   \                     ??finalize_data_phase_0: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   0000003E   0x68C0             LDR      R0,[R0, #+12]
   \   00000040   0x68C0             LDR      R0,[R0, #+12]
   \   00000042   0x7F01             LDRB     R1,[R0, #+28]
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       send_generic_response
    627          
    628          #if !BL_FEATURE_MIN_PROFILE
    629              if ((status == kStatus_AbortDataPhase) &&
    630                  g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag == kCommandTag_ReceiveSbFile)
   \   0000004A   0xF242 0x7012      MOVW     R0,#+10002
   \   0000004E   0x4284             CMP      R4,R0
   \   00000050   0xD108             BNE.N    ??finalize_data_phase_1
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000056   0x68C0             LDR      R0,[R0, #+12]
   \   00000058   0x68C0             LDR      R0,[R0, #+12]
   \   0000005A   0x7F00             LDRB     R0,[R0, #+28]
   \   0000005C   0x2808             CMP      R0,#+8
   \   0000005E   0xD101             BNE.N    ??finalize_data_phase_1
    631              {
    632                  // Aborting due to sb loader jump or reset command.
    633                  // If jump or reset successful, this will not return.
    634                  // In the current architecture there is no way to handle an error return from sbloader_finalize()
    635                  // because we already sent the "abort" status above to indicate that a jump command was encountered.
    636                  sbloader_finalize();
   \   00000060   0x.... 0x....      BL       sbloader_finalize
    637              }
    638          #endif // !BL_FEATURE_MIN_PROFILE
    639          }
   \                     ??finalize_data_phase_1: (+1)
   \   00000064   0xBD10             POP      {R4,PC}          ;; return
    640          
    641          //! @brief Handle data phase with data consumer (read from host).

   \                                 In section .text, align 2, keep-with-next
    642          status_t handle_data_consumer(bool *hasMoreData)
    643          {
   \                     handle_data_consumer: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
    644              if (g_bootloaderContext.commandInterface->stateData->dataPhase.count == 0)
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   0000000A   0x68C0             LDR      R0,[R0, #+12]
   \   0000000C   0x68C0             LDR      R0,[R0, #+12]
   \   0000000E   0x6900             LDR      R0,[R0, #+16]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD106             BNE.N    ??handle_data_consumer_0
    645              {
    646                  // No data phase.
    647                  *hasMoreData = false;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x7020             STRB     R0,[R4, #+0]
    648                  finalize_data_phase(kStatus_Success);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      BL       finalize_data_phase
    649                  return kStatus_Success;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE095             B.N      ??handle_data_consumer_1
    650              }
    651          
    652              *hasMoreData = true;
   \                     ??handle_data_consumer_0: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x7020             STRB     R0,[R4, #+0]
    653              uint32_t remaining = g_bootloaderContext.commandInterface->stateData->dataPhase.count;
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0x68C0             LDR      R0,[R0, #+12]
   \   0000002E   0x6905             LDR      R5,[R0, #+16]
    654              uint32_t dataAddress = g_bootloaderContext.commandInterface->stateData->dataPhase.address;
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000034   0x68C0             LDR      R0,[R0, #+12]
   \   00000036   0x68C0             LDR      R0,[R0, #+12]
   \   00000038   0x6946             LDR      R6,[R0, #+20]
    655              uint8_t *packet;
    656              uint32_t packetLength = 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x9000             STR      R0,[SP, #+0]
    657              status_t status;
    658          
    659              // Read the data packet.
    660              status = g_bootloaderContext.activePeripheral->packetInterface->readPacket(
    661                  g_bootloaderContext.activePeripheral, &packet, &packetLength, kPacketType_Data);
   \   0000003E   0x2301             MOVS     R3,#+1
   \   00000040   0x466A             MOV      R2,SP
   \   00000042   0xA901             ADD      R1,SP,#+4
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000048   0x69C0             LDR      R0,[R0, #+28]
   \   0000004A   0x.... 0x....      LDR.W    R12,??DataTable27_2
   \   0000004E   0xF8DC 0xC01C      LDR      R12,[R12, #+28]
   \   00000052   0xF8DC 0xC014      LDR      R12,[R12, #+20]
   \   00000056   0xF8DC 0xC004      LDR      R12,[R12, #+4]
   \   0000005A   0x47E0             BLX      R12
   \   0000005C   0x0007             MOVS     R7,R0
    662              if (status != kStatus_Success)
   \   0000005E   0x2F00             CMP      R7,#+0
   \   00000060   0xD00F             BEQ.N    ??handle_data_consumer_2
    663              {
    664                  // Abort data phase due to error.
    665                  debug_printf("consumer abort data phase due to status 0x%x\r\n", status);
    666                  g_bootloaderContext.activePeripheral->packetInterface->abortDataPhase(g_bootloaderContext.activePeripheral);
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000066   0x69C0             LDR      R0,[R0, #+28]
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   0000006C   0x69C9             LDR      R1,[R1, #+28]
   \   0000006E   0x6949             LDR      R1,[R1, #+20]
   \   00000070   0x68C9             LDR      R1,[R1, #+12]
   \   00000072   0x4788             BLX      R1
    667                  finalize_data_phase(status);
   \   00000074   0x0038             MOVS     R0,R7
   \   00000076   0x.... 0x....      BL       finalize_data_phase
    668                  *hasMoreData = false;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x7020             STRB     R0,[R4, #+0]
    669                  return kStatus_Success;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE065             B.N      ??handle_data_consumer_1
    670              }
    671              if (packetLength == 0)
   \                     ??handle_data_consumer_2: (+1)
   \   00000082   0x9800             LDR      R0,[SP, #+0]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD107             BNE.N    ??handle_data_consumer_3
    672              {
    673                  // Sender requested data phase abort.
    674                  debug_printf("Data phase aborted by sender\r\n");
    675                  finalize_data_phase(kStatus_AbortDataPhase);
   \   00000088   0xF242 0x7012      MOVW     R0,#+10002
   \   0000008C   0x.... 0x....      BL       finalize_data_phase
    676                  *hasMoreData = false;
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x7020             STRB     R0,[R4, #+0]
    677                  return kStatus_Success;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xE05A             B.N      ??handle_data_consumer_1
    678              }
    679          
    680              //
    681              // Write the data to the destination address.
    682              //
    683          
    684              packetLength = MIN(packetLength, remaining);
   \                     ??handle_data_consumer_3: (+1)
   \   00000098   0x9800             LDR      R0,[SP, #+0]
   \   0000009A   0x42A8             CMP      R0,R5
   \   0000009C   0xD202             BCS.N    ??handle_data_consumer_4
   \   0000009E   0x9800             LDR      R0,[SP, #+0]
   \   000000A0   0x9000             STR      R0,[SP, #+0]
   \   000000A2   0xE000             B.N      ??handle_data_consumer_5
   \                     ??handle_data_consumer_4: (+1)
   \   000000A4   0x9500             STR      R5,[SP, #+0]
    685          
    686          #if !BL_FEATURE_MIN_PROFILE
    687              if (g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag == kCommandTag_ReceiveSbFile)
   \                     ??handle_data_consumer_5: (+1)
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   000000AA   0x68C0             LDR      R0,[R0, #+12]
   \   000000AC   0x68C0             LDR      R0,[R0, #+12]
   \   000000AE   0x7F00             LDRB     R0,[R0, #+28]
   \   000000B0   0x2808             CMP      R0,#+8
   \   000000B2   0xD11B             BNE.N    ??handle_data_consumer_6
    688              {
    689                  // Consumer is sb loader state machine
    690                  g_bootloaderContext.commandInterface->stateData->dataPhase.data = packet;
   \   000000B4   0x9801             LDR      R0,[SP, #+4]
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   000000BA   0x68C9             LDR      R1,[R1, #+12]
   \   000000BC   0x68C9             LDR      R1,[R1, #+12]
   \   000000BE   0x60C8             STR      R0,[R1, #+12]
    691                  g_bootloaderContext.commandInterface->stateData->dataPhase.dataBytesAvailable = packetLength;
   \   000000C0   0x9800             LDR      R0,[SP, #+0]
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   000000C6   0x68C9             LDR      R1,[R1, #+12]
   \   000000C8   0x68C9             LDR      R1,[R1, #+12]
   \   000000CA   0x6188             STR      R0,[R1, #+24]
    692          
    693                  status = sbloader_pump(packet, packetLength);
   \   000000CC   0x9900             LDR      R1,[SP, #+0]
   \   000000CE   0x9801             LDR      R0,[SP, #+4]
   \   000000D0   0x.... 0x....      BL       sbloader_pump
   \   000000D4   0x0007             MOVS     R7,R0
    694          
    695                  // kStatusRomLdrDataUnderrun means need more data
    696                  // kStatusRomLdrSectionOverrun means we reached the end of the sb file processing
    697                  // either of these are OK
    698                  if ((status == kStatusRomLdrDataUnderrun) || (status == kStatusRomLdrSectionOverrun))
   \   000000D6   0xF242 0x707D      MOVW     R0,#+10109
   \   000000DA   0x4287             CMP      R7,R0
   \   000000DC   0xD003             BEQ.N    ??handle_data_consumer_7
   \   000000DE   0xF242 0x7074      MOVW     R0,#+10100
   \   000000E2   0x4287             CMP      R7,R0
   \   000000E4   0xD10D             BNE.N    ??handle_data_consumer_8
    699                  {
    700                      status = kStatus_Success;
   \                     ??handle_data_consumer_7: (+1)
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x0007             MOVS     R7,R0
   \   000000EA   0xE00A             B.N      ??handle_data_consumer_8
    701                  }
    702              }
    703              else
    704          #endif // !BL_FEATURE_MIN_PROFILE
    705              {
    706                  // Consumer is memory interface.
    707                  status = g_bootloaderContext.memoryInterface->write(dataAddress, packetLength, packet);
   \                     ??handle_data_consumer_6: (+1)
   \   000000EC   0x9A01             LDR      R2,[SP, #+4]
   \   000000EE   0x9900             LDR      R1,[SP, #+0]
   \   000000F0   0x0030             MOVS     R0,R6
   \   000000F2   0x.... 0x....      LDR.W    R3,??DataTable27_2
   \   000000F6   0x681B             LDR      R3,[R3, #+0]
   \   000000F8   0x689B             LDR      R3,[R3, #+8]
   \   000000FA   0x4798             BLX      R3
   \   000000FC   0x0007             MOVS     R7,R0
    708                  dataAddress += packetLength;
   \   000000FE   0x9800             LDR      R0,[SP, #+0]
   \   00000100   0x1986             ADDS     R6,R0,R6
    709              }
    710          
    711              remaining -= packetLength;
   \                     ??handle_data_consumer_8: (+1)
   \   00000102   0x9800             LDR      R0,[SP, #+0]
   \   00000104   0x1A2D             SUBS     R5,R5,R0
    712          
    713          #ifdef TEST_RECEIVER_ABORT
    714              status = kStatus_Fail;
    715          #endif
    716          
    717              if (remaining == 0)
   \   00000106   0x2D00             CMP      R5,#+0
   \   00000108   0xD105             BNE.N    ??handle_data_consumer_9
    718              {
    719                  finalize_data_phase(status);
   \   0000010A   0x0038             MOVS     R0,R7
   \   0000010C   0x.... 0x....      BL       finalize_data_phase
    720                  *hasMoreData = false;
   \   00000110   0x2000             MOVS     R0,#+0
   \   00000112   0x7020             STRB     R0,[R4, #+0]
   \   00000114   0xE01A             B.N      ??handle_data_consumer_10
    721              }
    722              else if (status != kStatus_Success)
   \                     ??handle_data_consumer_9: (+1)
   \   00000116   0x2F00             CMP      R7,#+0
   \   00000118   0xD00E             BEQ.N    ??handle_data_consumer_11
    723              {
    724                  // Abort data phase due to error.
    725                  debug_printf("Data phase error 0x%x, aborting\r\n", status);
    726                  g_bootloaderContext.activePeripheral->packetInterface->abortDataPhase(g_bootloaderContext.activePeripheral);
   \   0000011A   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   0000011E   0x69C0             LDR      R0,[R0, #+28]
   \   00000120   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   00000124   0x69C9             LDR      R1,[R1, #+28]
   \   00000126   0x6949             LDR      R1,[R1, #+20]
   \   00000128   0x68C9             LDR      R1,[R1, #+12]
   \   0000012A   0x4788             BLX      R1
    727                  finalize_data_phase(status);
   \   0000012C   0x0038             MOVS     R0,R7
   \   0000012E   0x.... 0x....      BL       finalize_data_phase
    728                  *hasMoreData = false;
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0x7020             STRB     R0,[R4, #+0]
   \   00000136   0xE009             B.N      ??handle_data_consumer_10
    729              }
    730              else
    731              {
    732                  g_bootloaderContext.commandInterface->stateData->dataPhase.count = remaining;
   \                     ??handle_data_consumer_11: (+1)
   \   00000138   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   0000013C   0x68C0             LDR      R0,[R0, #+12]
   \   0000013E   0x68C0             LDR      R0,[R0, #+12]
   \   00000140   0x6105             STR      R5,[R0, #+16]
    733                  g_bootloaderContext.commandInterface->stateData->dataPhase.address = dataAddress;
   \   00000142   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000146   0x68C0             LDR      R0,[R0, #+12]
   \   00000148   0x68C0             LDR      R0,[R0, #+12]
   \   0000014A   0x6146             STR      R6,[R0, #+20]
    734              }
    735          
    736              return kStatus_Success;
   \                     ??handle_data_consumer_10: (+1)
   \   0000014C   0x2000             MOVS     R0,#+0
   \                     ??handle_data_consumer_1: (+1)
   \   0000014E   0xBDFE             POP      {R1-R7,PC}       ;; return
    737          }
    738          
    739          //! @brief Handle data phase with data producer (send to host).

   \                                 In section .text, align 2, keep-with-next
    740          status_t handle_data_producer(bool *hasMoreData)
    741          {
   \                     handle_data_producer: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x0004             MOVS     R4,R0
    742              if (g_bootloaderContext.commandInterface->stateData->dataPhase.count == 0)
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   0000000C   0x68C0             LDR      R0,[R0, #+12]
   \   0000000E   0x68C0             LDR      R0,[R0, #+12]
   \   00000010   0x6900             LDR      R0,[R0, #+16]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD106             BNE.N    ??handle_data_producer_0
    743              {
    744                  // No data phase.
    745                  *hasMoreData = false;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x7020             STRB     R0,[R4, #+0]
    746                  finalize_data_phase(kStatus_Success);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      BL       finalize_data_phase
    747                  return kStatus_Success;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE09F             B.N      ??handle_data_producer_1
    748              }
    749          
    750              *hasMoreData = true;
   \                     ??handle_data_producer_0: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x7020             STRB     R0,[R4, #+0]
    751              uint32_t remaining = g_bootloaderContext.commandInterface->stateData->dataPhase.count;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   0000002C   0x68C0             LDR      R0,[R0, #+12]
   \   0000002E   0x68C0             LDR      R0,[R0, #+12]
   \   00000030   0x6905             LDR      R5,[R0, #+16]
    752              uint32_t dataAddress = g_bootloaderContext.commandInterface->stateData->dataPhase.address;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000036   0x68C0             LDR      R0,[R0, #+12]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0x6946             LDR      R6,[R0, #+20]
    753              uint8_t *data = g_bootloaderContext.commandInterface->stateData->dataPhase.data;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000040   0x68C0             LDR      R0,[R0, #+12]
   \   00000042   0x68C0             LDR      R0,[R0, #+12]
   \   00000044   0xF8D0 0xA00C      LDR      R10,[R0, #+12]
    754              uint8_t commandTag = g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag;
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   0000004C   0x68C0             LDR      R0,[R0, #+12]
   \   0000004E   0x68C0             LDR      R0,[R0, #+12]
   \   00000050   0x7F07             LDRB     R7,[R0, #+28]
    755              status_t status = kStatus_Success;
   \   00000052   0xF05F 0x0800      MOVS     R8,#+0
    756          
    757              // Initialize the data packet to send.
    758              uint32_t packetSize;
    759              uint8_t packet[kMinPacketBufferSize];
    760          
    761              // Copy the data into the data packet.
    762              packetSize = MIN(kMinPacketBufferSize, remaining);
   \   00000056   0x2D21             CMP      R5,#+33
   \   00000058   0xD302             BCC.N    ??handle_data_producer_2
   \   0000005A   0xF05F 0x0920      MOVS     R9,#+32
   \   0000005E   0xE000             B.N      ??handle_data_producer_3
   \                     ??handle_data_producer_2: (+1)
   \   00000060   0x46A9             MOV      R9,R5
    763              if (data)
   \                     ??handle_data_producer_3: (+1)
   \   00000062   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000066   0xD00C             BEQ.N    ??handle_data_producer_4
    764              {
    765                  // Copy data using compiler-generated memcpy.
    766                  memcpy(packet, data, packetSize);
   \   00000068   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \   0000006C   0xF10D 0x0B04      ADD      R11,SP,#+4
   \   00000070   0x464A             MOV      R2,R9
   \   00000072   0x9900             LDR      R1,[SP, #+0]
   \   00000074   0x4658             MOV      R0,R11
   \   00000076   0x.... 0x....      BL       __aeabi_memcpy
    767                  data += packetSize;
   \   0000007A   0x44CA             ADD      R10,R10,R9
    768                  status = kStatus_Success;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x4680             MOV      R8,R0
   \   00000080   0xE02B             B.N      ??handle_data_producer_5
    769              }
    770              else
    771              {
    772                  if (commandTag == kCommandTag_ReadMemory)
   \                     ??handle_data_producer_4: (+1)
   \   00000082   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000084   0x2F03             CMP      R7,#+3
   \   00000086   0xD109             BNE.N    ??handle_data_producer_6
    773                  {
    774                      // Copy data using memory interface.
    775                      status = g_bootloaderContext.memoryInterface->read(dataAddress, packetSize, packet);
   \   00000088   0xAA01             ADD      R2,SP,#+4
   \   0000008A   0x4649             MOV      R1,R9
   \   0000008C   0x0030             MOVS     R0,R6
   \   0000008E   0x.... 0x....      LDR.W    R3,??DataTable27_2
   \   00000092   0x681B             LDR      R3,[R3, #+0]
   \   00000094   0x685B             LDR      R3,[R3, #+4]
   \   00000096   0x4798             BLX      R3
   \   00000098   0x4680             MOV      R8,R0
   \   0000009A   0xE01C             B.N      ??handle_data_producer_7
    776                  }
    777                  else if (commandTag == kCommandTag_FlashReadResource)
   \                     ??handle_data_producer_6: (+1)
   \   0000009C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000009E   0x2F10             CMP      R7,#+16
   \   000000A0   0xD119             BNE.N    ??handle_data_producer_7
    778                  {
    779          // Read data from special-purpose flash memory
    780          #if !defined(BOOTLOADER_HOST)
    781                      flash_read_resource_option_t option =
    782                          (flash_read_resource_option_t)g_bootloaderContext.commandInterface->stateData->dataPhase.option;
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   000000A6   0x68C0             LDR      R0,[R0, #+12]
   \   000000A8   0x68C0             LDR      R0,[R0, #+12]
   \   000000AA   0xF890 0xB01D      LDRB     R11,[R0, #+29]
    783                      lock_acquire();
   \   000000AE   0x.... 0x....      BL       lock_acquire
    784                      status = g_bootloaderContext.flashDriverInterface->flash_read_resource(
    785                          &g_bootloaderContext.flashState, dataAddress, (uint32_t *)packet, packetSize, option);
   \   000000B2   0x4658             MOV      R0,R11
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B6   0x9000             STR      R0,[SP, #+0]
   \   000000B8   0x464B             MOV      R3,R9
   \   000000BA   0xAA01             ADD      R2,SP,#+4
   \   000000BC   0x0031             MOVS     R1,R6
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   000000C2   0x.... 0x....      LDR.W    R12,??DataTable27_2
   \   000000C6   0xF8DC 0xC010      LDR      R12,[R12, #+16]
   \   000000CA   0xF8DC 0xC03C      LDR      R12,[R12, #+60]
   \   000000CE   0x47E0             BLX      R12
   \   000000D0   0x4680             MOV      R8,R0
    786                      lock_release();
   \   000000D2   0x.... 0x....      BL       lock_release
    787          #endif // BOOTLOADER_HOST
    788                  }
    789                  dataAddress += packetSize;
   \                     ??handle_data_producer_7: (+1)
   \   000000D6   0xEB19 0x0606      ADDS     R6,R9,R6
    790              }
    791              if (status != kStatus_Success)
   \                     ??handle_data_producer_5: (+1)
   \   000000DA   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000DE   0xD015             BEQ.N    ??handle_data_producer_8
    792              {
    793                  debug_printf("Error: %s returned status 0x%x, abort data phase\r\n",
    794                               (commandTag == kCommandTag_ReadMemory) ? "read memory" : "flash read resource", status);
    795                  // Send zero length packet to tell host we are aborting data phase
    796                  g_bootloaderContext.activePeripheral->packetInterface->writePacket(
    797                      g_bootloaderContext.activePeripheral, (const uint8_t *)packet, 0, kPacketType_Data);
   \   000000E0   0x2301             MOVS     R3,#+1
   \   000000E2   0x2200             MOVS     R2,#+0
   \   000000E4   0xA901             ADD      R1,SP,#+4
   \   000000E6   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   000000EA   0x69C0             LDR      R0,[R0, #+28]
   \   000000EC   0x.... 0x....      LDR.W    R12,??DataTable27_2
   \   000000F0   0xF8DC 0xC01C      LDR      R12,[R12, #+28]
   \   000000F4   0xF8DC 0xC014      LDR      R12,[R12, #+20]
   \   000000F8   0xF8DC 0xC008      LDR      R12,[R12, #+8]
   \   000000FC   0x47E0             BLX      R12
    798                  finalize_data_phase(status);
   \   000000FE   0x4640             MOV      R0,R8
   \   00000100   0x.... 0x....      BL       finalize_data_phase
    799                  *hasMoreData = false;
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0x7020             STRB     R0,[R4, #+0]
    800                  return kStatus_Success;
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0xE02B             B.N      ??handle_data_producer_1
    801              }
    802              remaining -= packetSize;
   \                     ??handle_data_producer_8: (+1)
   \   0000010C   0xEBB5 0x0509      SUBS     R5,R5,R9
    803          
    804          #ifdef TEST_SENDER_ABORT
    805          #ifndef WIN32
    806          // Disble IAR "statement is unreachable" error
    807          #pragma diag_suppress = Pe111
    808          #endif // WIN32
    809              // Send zero length packet to abort data phase.
    810              g_bootloaderContext.activePeripheral->packetInterface->writePacket(g_bootloaderContext.activePeripheral,
    811                                                                                 (const uint8_t *)packet, 0, kPacketType_Data);
    812              finalize_data_phase(kStatus_AbortDataPhase);
    813              *hasMoreData = false;
    814              return kStatus_Success;
    815          #endif // TEST_SENDER_ABORT;
    816          
    817              status = g_bootloaderContext.activePeripheral->packetInterface->writePacket(
    818                  g_bootloaderContext.activePeripheral, (const uint8_t *)packet, packetSize, kPacketType_Data);
   \   00000110   0x2301             MOVS     R3,#+1
   \   00000112   0x464A             MOV      R2,R9
   \   00000114   0xA901             ADD      R1,SP,#+4
   \   00000116   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   0000011A   0x69C0             LDR      R0,[R0, #+28]
   \   0000011C   0x.... 0x....      LDR.W    R12,??DataTable27_2
   \   00000120   0xF8DC 0xC01C      LDR      R12,[R12, #+28]
   \   00000124   0xF8DC 0xC014      LDR      R12,[R12, #+20]
   \   00000128   0xF8DC 0xC008      LDR      R12,[R12, #+8]
   \   0000012C   0x47E0             BLX      R12
   \   0000012E   0x4680             MOV      R8,R0
    819          
    820              if (remaining == 0)
   \   00000130   0x2D00             CMP      R5,#+0
   \   00000132   0xD105             BNE.N    ??handle_data_producer_9
    821              {
    822                  finalize_data_phase(status);
   \   00000134   0x4640             MOV      R0,R8
   \   00000136   0x.... 0x....      BL       finalize_data_phase
    823                  *hasMoreData = false;
   \   0000013A   0x2000             MOVS     R0,#+0
   \   0000013C   0x7020             STRB     R0,[R4, #+0]
   \   0000013E   0xE010             B.N      ??handle_data_producer_10
    824              }
    825              else if (status != kStatus_Success)
   \                     ??handle_data_producer_9: (+1)
   \   00000140   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000144   0xD005             BEQ.N    ??handle_data_producer_11
    826              {
    827                  debug_printf("writePacket aborted due to status 0x%x\r\n", status);
    828                  finalize_data_phase(status);
   \   00000146   0x4640             MOV      R0,R8
   \   00000148   0x.... 0x....      BL       finalize_data_phase
    829                  *hasMoreData = false;
   \   0000014C   0x2000             MOVS     R0,#+0
   \   0000014E   0x7020             STRB     R0,[R4, #+0]
   \   00000150   0xE007             B.N      ??handle_data_producer_10
    830              }
    831              else
    832              {
    833                  g_bootloaderContext.commandInterface->stateData->dataPhase.count = remaining;
   \                     ??handle_data_producer_11: (+1)
   \   00000152   0x....             LDR.N    R0,??DataTable27_2
   \   00000154   0x68C0             LDR      R0,[R0, #+12]
   \   00000156   0x68C0             LDR      R0,[R0, #+12]
   \   00000158   0x6105             STR      R5,[R0, #+16]
    834                  g_bootloaderContext.commandInterface->stateData->dataPhase.address = dataAddress;
   \   0000015A   0x....             LDR.N    R0,??DataTable27_2
   \   0000015C   0x68C0             LDR      R0,[R0, #+12]
   \   0000015E   0x68C0             LDR      R0,[R0, #+12]
   \   00000160   0x6146             STR      R6,[R0, #+20]
    835              }
    836          
    837              return kStatus_Success;
   \                     ??handle_data_producer_10: (+1)
   \   00000162   0x2000             MOVS     R0,#+0
   \                     ??handle_data_producer_1: (+1)
   \   00000164   0xB009             ADD      SP,SP,#+36
   \   00000166   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    838          }
    839          
    840          //! @brief Fill Memory command handler.

   \                                 In section .text, align 2, keep-with-next
    841          void handle_fill_memory(uint8_t *packet, uint32_t packetLength)
    842          {
   \                     handle_fill_memory: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    843              fill_memory_packet_t *command = (fill_memory_packet_t *)packet;
    844          
    845              status_t status =
    846                  g_bootloaderContext.memoryInterface->fill(command->startAddress, command->byteCount, command->patternWord);
   \   00000006   0x68E2             LDR      R2,[R4, #+12]
   \   00000008   0x68A1             LDR      R1,[R4, #+8]
   \   0000000A   0x6860             LDR      R0,[R4, #+4]
   \   0000000C   0x....             LDR.N    R3,??DataTable27_2
   \   0000000E   0x681B             LDR      R3,[R3, #+0]
   \   00000010   0x68DB             LDR      R3,[R3, #+12]
   \   00000012   0x4798             BLX      R3
   \   00000014   0x0006             MOVS     R6,R0
    847          
    848              send_generic_response(status, command->commandPacket.commandTag);
   \   00000016   0x7821             LDRB     R1,[R4, #+0]
   \   00000018   0x0030             MOVS     R0,R6
   \   0000001A   0x.... 0x....      BL       send_generic_response
    849          }
   \   0000001E   0xBD70             POP      {R4-R6,PC}       ;; return
    850          
    851          //! @brief Execute command handler.

   \                                 In section .text, align 2, keep-with-next
    852          void handle_execute(uint8_t *packet, uint32_t packetLength)
    853          {
   \                     handle_execute: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    854              execute_call_packet_t *command = (execute_call_packet_t *)packet;
   \   00000008   0x0026             MOVS     R6,R4
    855          
    856          #if !defined(BOOTLOADER_HOST)
    857              static uint32_t s_addr = 0;
    858              uint32_t call_address = command->callAddress;
   \   0000000A   0x6877             LDR      R7,[R6, #+4]
    859              uint32_t argument_word = command->argumentWord;
   \   0000000C   0xF8D6 0x8008      LDR      R8,[R6, #+8]
    860              s_addr = command->stackpointer;
   \   00000010   0x68F0             LDR      R0,[R6, #+12]
   \   00000012   0x....             LDR.N    R1,??DataTable27_4
   \   00000014   0x6008             STR      R0,[R1, #+0]
    861              status_t responseStatus = kStatus_Success;
   \   00000016   0xF05F 0x0900      MOVS     R9,#+0
    862          
    863              // Get RAM address ranges
    864              const memory_map_entry_t *map = &g_bootloaderContext.memoryMap[kIndexSRAM];
   \   0000001A   0x....             LDR.N    R0,??DataTable27_2
   \   0000001C   0x6840             LDR      R0,[R0, #+4]
   \   0000001E   0xF110 0x0A10      ADDS     R10,R0,#+16
    865          
    866              // Validate stack pointer address. It must either be 0 or within the RAM range.
    867              if (!((s_addr == 0) || ((s_addr >= map->startAddress) && (s_addr <= map->endAddress + 1))))
   \   00000022   0x....             LDR.N    R0,??DataTable27_4
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD00E             BEQ.N    ??handle_execute_0
   \   0000002A   0x....             LDR.N    R0,??DataTable27_4
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xF8DA 0x1000      LDR      R1,[R10, #+0]
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD306             BCC.N    ??handle_execute_1
   \   00000036   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \   0000003C   0x....             LDR.N    R1,??DataTable27_4
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0x4288             CMP      R0,R1
   \   00000042   0xD201             BCS.N    ??handle_execute_0
    868              {
    869                  // Invalid stack pointer value, respond with kStatus_InvalidArgument.
    870                  responseStatus = kStatus_InvalidArgument;
   \                     ??handle_execute_1: (+1)
   \   00000044   0x2004             MOVS     R0,#+4
   \   00000046   0x4681             MOV      R9,R0
    871              }
    872          
    873              // Validate call address.
    874              if (!is_valid_application_location(call_address))
   \                     ??handle_execute_0: (+1)
   \   00000048   0x0038             MOVS     R0,R7
   \   0000004A   0x.... 0x....      BL       is_valid_application_location
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD101             BNE.N    ??handle_execute_2
    875              {
    876                  // Invalid address, respond with kStatus_InvalidArgument.
    877                  responseStatus = kStatus_InvalidArgument;
   \   00000052   0x2004             MOVS     R0,#+4
   \   00000054   0x4681             MOV      R9,R0
    878              }
    879          
    880          #if BL_FEATURE_OTFAD_MODULE
    881              if (is_qspi_present())
    882              {
    883                  quadspi_cache_clear();
    884                  status_t status = otfad_init_as_needed();
    885                  if (status != kStatus_Success)
    886                  {
    887                      responseStatus = kStatus_OtfadInvalidKeyBlob;
    888                  }
    889                  update_qspi_otfad_init_status(status);
    890              }
    891          #endif
    892          
    893              // Send response immediately since call may not return
    894              send_generic_response(responseStatus, command->commandPacket.commandTag);
   \                     ??handle_execute_2: (+1)
   \   00000056   0x7831             LDRB     R1,[R6, #+0]
   \   00000058   0x4648             MOV      R0,R9
   \   0000005A   0x.... 0x....      BL       send_generic_response
    895          
    896              if (responseStatus == kStatus_Success)
   \   0000005E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000062   0xD11B             BNE.N    ??handle_execute_3
    897              {
    898                  static call_function_t s_callFunction = 0;
    899                  s_callFunction = (call_function_t)call_address;
   \   00000064   0x....             LDR.N    R0,??DataTable27_5
   \   00000066   0x6007             STR      R7,[R0, #+0]
    900          
    901                  // Prepare for shutdown.
    902                  shutdown_cleanup(kShutdownType_Shutdown);
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x.... 0x....      BL       shutdown_cleanup
    903          
    904                  // Static variables are needed since we are changing the stack pointer out from under the compiler
    905                  // we need to ensure the values we are using are not stored on the previous stack
    906                  static uint32_t s_argument = 0;
    907                  s_argument = argument_word;
   \   0000006E   0x....             LDR.N    R0,??DataTable27_6
   \   00000070   0xF8C0 0x8000      STR      R8,[R0, #+0]
    908          
    909                  if (s_addr)
   \   00000074   0x....             LDR.N    R0,??DataTable27_4
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD007             BEQ.N    ??handle_execute_4
    910                  {
    911                      // Set main stack pointer and process stack pointer
    912                      __set_MSP(s_addr);
   \   0000007C   0x....             LDR.N    R0,??DataTable27_4
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0xF380 0x8808      MSR      MSP,R0
    913                      __set_PSP(s_addr);
   \   00000084   0x....             LDR.N    R0,??DataTable27_4
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0xF380 0x8809      MSR      PSP,R0
    914                  }
    915          
    916                  s_callFunction(s_argument);
   \                     ??handle_execute_4: (+1)
   \   0000008C   0x....             LDR.N    R0,??DataTable27_6
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x....             LDR.N    R1,??DataTable27_5
   \   00000092   0x6809             LDR      R1,[R1, #+0]
   \   00000094   0x4788             BLX      R1
    917                  // Dummy fcuntion call, should never go to this fcuntion call
    918                  shutdown_cleanup(kShutdownType_Shutdown);
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x.... 0x....      BL       shutdown_cleanup
    919              }
    920          #else
    921              // Just send a successful response.
    922              send_generic_response(kStatus_Success, command->commandPacket.commandTag);
    923          #endif // BOOTLOADER_HOST
    924          }
   \                     ??handle_execute_3: (+1)
   \   0000009C   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .bss, align 4
   \                     `handle_execute::s_addr`:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     `handle_execute{3}{4}::s_callFunction`:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     `handle_execute{3}{4}::s_argument`:
   \   00000000                      DS8 4
    925          
    926          //! @brief Call command handler.

   \                                 In section .text, align 2, keep-with-next
    927          void handle_call(uint8_t *packet, uint32_t packetLength)
    928          {
   \                     handle_call: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    929              execute_call_packet_t *command = (execute_call_packet_t *)packet;
   \   00000008   0x0026             MOVS     R6,R4
    930              status_t responseStatus = kStatus_Success;
   \   0000000A   0x2700             MOVS     R7,#+0
    931          
    932          #if !defined(BOOTLOADER_HOST)
    933              // Validate call address.
    934              if (!is_valid_application_location(command->callAddress))
   \   0000000C   0x6870             LDR      R0,[R6, #+4]
   \   0000000E   0x.... 0x....      BL       is_valid_application_location
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD102             BNE.N    ??handle_call_0
    935              {
    936                  // Invalid address, respond with kStatus_InvalidArgument.
    937                  responseStatus = kStatus_InvalidArgument;
   \   00000016   0x2004             MOVS     R0,#+4
   \   00000018   0x0007             MOVS     R7,R0
   \   0000001A   0xE007             B.N      ??handle_call_1
    938              }
    939              else
    940              {
    941                  call_function_t callFunction = (call_function_t)command->callAddress;
   \                     ??handle_call_0: (+1)
   \   0000001C   0xF8D6 0x8004      LDR      R8,[R6, #+4]
    942                  shutdown_cleanup(kShutdownType_Cleanup);
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      BL       shutdown_cleanup
    943                  responseStatus = callFunction(command->argumentWord);
   \   00000026   0x68B0             LDR      R0,[R6, #+8]
   \   00000028   0x47C0             BLX      R8
   \   0000002A   0x0007             MOVS     R7,R0
    944              }
    945          #endif // BOOTLOADER_HOST
    946          
    947              send_generic_response(responseStatus, command->commandPacket.commandTag);
   \                     ??handle_call_1: (+1)
   \   0000002C   0x7831             LDRB     R1,[R6, #+0]
   \   0000002E   0x0038             MOVS     R0,R7
   \   00000030   0x.... 0x....      BL       send_generic_response
    948          }
   \   00000034   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    949          
    950          //! @brief Flash Security Disable command handler.

   \                                 In section .text, align 2, keep-with-next
    951          void handle_flash_security_disable(uint8_t *packet, uint32_t packetLength)
    952          {
   \                     handle_flash_security_disable: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    953              flash_security_disable_packet_t *command = (flash_security_disable_packet_t *)packet;
    954          
    955              status_t status = kStatus_Success;
   \   00000006   0x2600             MOVS     R6,#+0
    956          #if !defined(BOOTLOADER_HOST)
    957              // Flash interface wants little endian, so just send two uint32s.
    958              status = g_bootloaderContext.flashDriverInterface->flash_security_bypass(&g_bootloaderContext.flashState,
    959                                                                                       (uint8_t *)&command->keyLow);
   \   00000008   0x1D21             ADDS     R1,R4,#+4
   \   0000000A   0x....             LDR.N    R0,??DataTable27_3
   \   0000000C   0x....             LDR.N    R2,??DataTable27_2
   \   0000000E   0x6912             LDR      R2,[R2, #+16]
   \   00000010   0x69D2             LDR      R2,[R2, #+28]
   \   00000012   0x4790             BLX      R2
   \   00000014   0x0006             MOVS     R6,R0
    960          #endif // BOOTLOADER_HOST
    961          
    962              send_generic_response(status, command->commandPacket.commandTag);
   \   00000016   0x7821             LDRB     R1,[R4, #+0]
   \   00000018   0x0030             MOVS     R0,R6
   \   0000001A   0x.... 0x....      BL       send_generic_response
    963          }
   \   0000001E   0xBD70             POP      {R4-R6,PC}       ;; return
    964          
    965          //! @brief  Flash Program Once command handler

   \                                 In section .text, align 2, keep-with-next
    966          void handle_flash_program_once(uint8_t *packet, uint32_t length)
    967          {
   \                     handle_flash_program_once: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    968              flash_program_once_packet_t *command = (flash_program_once_packet_t *)packet;
    969          
    970              status_t status = kStatus_Success;
   \   00000006   0x2600             MOVS     R6,#+0
    971          
    972          #if !defined(BOOTLOADER_HOST)
    973              lock_acquire();
   \   00000008   0x.... 0x....      BL       lock_acquire
    974              status = g_bootloaderContext.flashDriverInterface->flash_program_once(
    975                  &g_bootloaderContext.flashState, command->index, &command->data[0], command->byteCount);
   \   0000000C   0x68A3             LDR      R3,[R4, #+8]
   \   0000000E   0xF114 0x020C      ADDS     R2,R4,#+12
   \   00000012   0x6861             LDR      R1,[R4, #+4]
   \   00000014   0x....             LDR.N    R0,??DataTable27_3
   \   00000016   0x....             LDR.N    R7,??DataTable27_2
   \   00000018   0x693F             LDR      R7,[R7, #+16]
   \   0000001A   0x6B7F             LDR      R7,[R7, #+52]
   \   0000001C   0x47B8             BLX      R7
   \   0000001E   0x0006             MOVS     R6,R0
    976              lock_release();
   \   00000020   0x.... 0x....      BL       lock_release
    977          #endif // BOOTLOADER_HOST
    978          
    979              send_generic_response(status, command->commandPacket.commandTag);
   \   00000024   0x7821             LDRB     R1,[R4, #+0]
   \   00000026   0x0030             MOVS     R0,R6
   \   00000028   0x.... 0x....      BL       send_generic_response
    980          }
   \   0000002C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    981          
    982          //! @brief  Flash Read Once command handler

   \                                 In section .text, align 2, keep-with-next
    983          void handle_flash_read_once(uint8_t *packet, uint32_t length)
    984          {
   \                     handle_flash_read_once: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    985              flash_read_once_packet_t *command = (flash_read_once_packet_t *)packet;
    986          
    987              uint32_t readOnceItemData[2] = { 0 };
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0xE9C0 0x1200      STRD     R1,R2,[R0, #+0]
    988          
    989              status_t status = kStatus_Success;
   \   00000012   0x2600             MOVS     R6,#+0
    990          
    991          #if !defined(BOOTLOADER_HOST)
    992              lock_acquire();
   \   00000014   0x.... 0x....      BL       lock_acquire
    993              status = g_bootloaderContext.flashDriverInterface->flash_read_once(&g_bootloaderContext.flashState, command->index,
    994                                                                                 &readOnceItemData[0], command->byteCount);
   \   00000018   0x68A3             LDR      R3,[R4, #+8]
   \   0000001A   0x466A             MOV      R2,SP
   \   0000001C   0x6861             LDR      R1,[R4, #+4]
   \   0000001E   0x....             LDR.N    R0,??DataTable27_3
   \   00000020   0x....             LDR.N    R7,??DataTable27_2
   \   00000022   0x693F             LDR      R7,[R7, #+16]
   \   00000024   0x6BBF             LDR      R7,[R7, #+56]
   \   00000026   0x47B8             BLX      R7
   \   00000028   0x0006             MOVS     R6,R0
    995              lock_release();
   \   0000002A   0x.... 0x....      BL       lock_release
    996          #endif // BOOTLOADER_HOST
    997          
    998              send_flash_read_once_response(status, readOnceItemData, command->byteCount);
   \   0000002E   0x68A2             LDR      R2,[R4, #+8]
   \   00000030   0x4669             MOV      R1,SP
   \   00000032   0x0030             MOVS     R0,R6
   \   00000034   0x.... 0x....      BL       send_flash_read_once_response
    999          }
   \   00000038   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
   1000          
   1001          //! @brief  Flash Read Resource command handler

   \                                 In section .text, align 2, keep-with-next
   1002          void handle_flash_read_resource(uint8_t *packet, uint32_t length)
   1003          {
   \                     handle_flash_read_resource: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1004              flash_read_resource_packet_t *command = (flash_read_resource_packet_t *)packet;
   1005          
   1006              // Start the data phase.
   1007              reset_data_phase();
   \   00000006   0x.... 0x....      BL       reset_data_phase
   1008              g_bootloaderContext.commandInterface->stateData->dataPhase.count = command->byteCount;
   \   0000000A   0x68A0             LDR      R0,[R4, #+8]
   \   0000000C   0x....             LDR.N    R1,??DataTable27_2
   \   0000000E   0x68C9             LDR      R1,[R1, #+12]
   \   00000010   0x68C9             LDR      R1,[R1, #+12]
   \   00000012   0x6108             STR      R0,[R1, #+16]
   1009              g_bootloaderContext.commandInterface->stateData->dataPhase.address = command->startAddress;
   \   00000014   0x6860             LDR      R0,[R4, #+4]
   \   00000016   0x....             LDR.N    R1,??DataTable27_2
   \   00000018   0x68C9             LDR      R1,[R1, #+12]
   \   0000001A   0x68C9             LDR      R1,[R1, #+12]
   \   0000001C   0x6148             STR      R0,[R1, #+20]
   1010              g_bootloaderContext.commandInterface->stateData->dataPhase.commandTag = kCommandTag_FlashReadResource;
   \   0000001E   0x2010             MOVS     R0,#+16
   \   00000020   0x....             LDR.N    R1,??DataTable27_2
   \   00000022   0x68C9             LDR      R1,[R1, #+12]
   \   00000024   0x68C9             LDR      R1,[R1, #+12]
   \   00000026   0x7708             STRB     R0,[R1, #+28]
   1011              g_bootloaderContext.commandInterface->stateData->dataPhase.option = (uint8_t)command->option;
   \   00000028   0x68E0             LDR      R0,[R4, #+12]
   \   0000002A   0x....             LDR.N    R1,??DataTable27_2
   \   0000002C   0x68C9             LDR      R1,[R1, #+12]
   \   0000002E   0x68C9             LDR      R1,[R1, #+12]
   \   00000030   0x7748             STRB     R0,[R1, #+29]
   1012              send_flash_read_resource_response(kStatus_Success, command->byteCount);
   \   00000032   0x68A1             LDR      R1,[R4, #+8]
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x.... 0x....      BL       send_flash_read_resource_response
   1013          }
   \   0000003A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1014          
   1015          //! @brief Send a generic response packet.

   \                                 In section .text, align 2, keep-with-next
   1016          void send_generic_response(uint32_t commandStatus, uint32_t commandTag)
   1017          {
   \                     send_generic_response: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1018              generic_response_packet_t responsePacket;
   1019              responsePacket.commandPacket.commandTag = kCommandTag_GenericResponse;
   \   00000008   0x20A0             MOVS     R0,#+160
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1020              responsePacket.commandPacket.flags = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1021              responsePacket.commandPacket.reserved = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF88D 0x0002      STRB     R0,[SP, #+2]
   1022              responsePacket.commandPacket.parameterCount = 2;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1023              responsePacket.status = commandStatus;
   \   00000020   0x9401             STR      R4,[SP, #+4]
   1024              responsePacket.commandTag = commandTag;
   \   00000022   0x9502             STR      R5,[SP, #+8]
   1025          
   1026              status_t status = g_bootloaderContext.activePeripheral->packetInterface->writePacket(
   1027                  g_bootloaderContext.activePeripheral, (const uint8_t *)&responsePacket, sizeof(responsePacket),
   1028                  kPacketType_Command);
   \   00000024   0x2300             MOVS     R3,#+0
   \   00000026   0x220C             MOVS     R2,#+12
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x....             LDR.N    R0,??DataTable27_2
   \   0000002C   0x69C0             LDR      R0,[R0, #+28]
   \   0000002E   0x....             LDR.N    R6,??DataTable27_2
   \   00000030   0x69F6             LDR      R6,[R6, #+28]
   \   00000032   0x6976             LDR      R6,[R6, #+20]
   \   00000034   0x68B6             LDR      R6,[R6, #+8]
   \   00000036   0x47B0             BLX      R6
   1029              if (status != kStatus_Success)
   \   00000038   0x2800             CMP      R0,#+0
   1030              {
   1031                  debug_printf("Error: writePacket returned status 0x%x\r\n", status);
   1032              }
   1033          }
   \                     ??send_generic_response_0: (+1)
   \   0000003A   0xBD7F             POP      {R0-R6,PC}       ;; return
   1034          
   1035          //! @brief Send a get property response packet.

   \                                 In section .text, align 2, keep-with-next
   1036          void send_get_property_response(uint32_t commandStatus, uint32_t *value, uint32_t numValues)
   1037          {
   \                     send_get_property_response: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1038              get_property_response_packet_t responsePacket;
   1039              responsePacket.commandPacket.commandTag = kCommandTag_GetPropertyResponse;
   \   0000000A   0x20A7             MOVS     R0,#+167
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1040              responsePacket.commandPacket.flags = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1041              responsePacket.commandPacket.reserved = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF88D 0x0002      STRB     R0,[SP, #+2]
   1042              responsePacket.commandPacket.parameterCount = 1 + numValues; // status + value words
   \   0000001C   0x1C70             ADDS     R0,R6,#+1
   \   0000001E   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1043              responsePacket.status = commandStatus;
   \   00000022   0x9401             STR      R4,[SP, #+4]
   1044          
   1045              for (uint32_t i = 0; i < numValues; ++i)
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??send_get_property_response_0: (+1)
   \   00000026   0x42B0             CMP      R0,R6
   \   00000028   0xD207             BCS.N    ??send_get_property_response_1
   1046              {
   1047                  responsePacket.propertyValue[i] = value[i];
   \   0000002A   0xF855 0x1020      LDR      R1,[R5, R0, LSL #+2]
   \   0000002E   0x466A             MOV      R2,SP
   \   00000030   0xEB02 0x0280      ADD      R2,R2,R0, LSL #+2
   \   00000034   0x6091             STR      R1,[R2, #+8]
   1048              }
   \   00000036   0x1C40             ADDS     R0,R0,#+1
   \   00000038   0xE7F5             B.N      ??send_get_property_response_0
   1049          
   1050              uint32_t packetSize =
   1051                  sizeof(responsePacket.commandPacket) + (responsePacket.commandPacket.parameterCount * sizeof(uint32_t));
   \                     ??send_get_property_response_1: (+1)
   \   0000003A   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   0000003E   0x0080             LSLS     R0,R0,#+2
   \   00000040   0x1D07             ADDS     R7,R0,#+4
   1052          
   1053              status_t status = g_bootloaderContext.activePeripheral->packetInterface->writePacket(
   1054                  g_bootloaderContext.activePeripheral, (const uint8_t *)&responsePacket, packetSize, kPacketType_Command);
   \   00000042   0x2300             MOVS     R3,#+0
   \   00000044   0x003A             MOVS     R2,R7
   \   00000046   0x4669             MOV      R1,SP
   \   00000048   0x....             LDR.N    R0,??DataTable27_2
   \   0000004A   0x69C0             LDR      R0,[R0, #+28]
   \   0000004C   0x.... 0x....      LDR.W    R12,??DataTable27_2
   \   00000050   0xF8DC 0xC01C      LDR      R12,[R12, #+28]
   \   00000054   0xF8DC 0xC014      LDR      R12,[R12, #+20]
   \   00000058   0xF8DC 0xC008      LDR      R12,[R12, #+8]
   \   0000005C   0x47E0             BLX      R12
   1055              if (status != kStatus_Success)
   \   0000005E   0x2800             CMP      R0,#+0
   1056              {
   1057                  debug_printf("Error: writePacket returned status 0x%x\r\n", status);
   1058              }
   1059          }
   \                     ??send_get_property_response_2: (+1)
   \   00000060   0xB009             ADD      SP,SP,#+36
   \   00000062   0xBDF0             POP      {R4-R7,PC}       ;; return
   1060          
   1061          //! @brief Send a read memory response packet.

   \                                 In section .text, align 2, keep-with-next
   1062          void send_read_memory_response(uint32_t commandStatus, uint32_t length)
   1063          {
   \                     send_read_memory_response: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1064              read_memory_response_packet_t responsePacket;
   1065              responsePacket.commandPacket.commandTag = kCommandTag_ReadMemoryResponse;
   \   00000008   0x20A3             MOVS     R0,#+163
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1066              responsePacket.commandPacket.flags = kCommandFlag_HasDataPhase;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1067              responsePacket.commandPacket.reserved = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF88D 0x0002      STRB     R0,[SP, #+2]
   1068              responsePacket.commandPacket.parameterCount = 2;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1069              responsePacket.status = commandStatus;
   \   00000020   0x9401             STR      R4,[SP, #+4]
   1070              responsePacket.dataByteCount = length;
   \   00000022   0x9502             STR      R5,[SP, #+8]
   1071          
   1072              status_t status = g_bootloaderContext.activePeripheral->packetInterface->writePacket(
   1073                  g_bootloaderContext.activePeripheral, (const uint8_t *)&responsePacket, sizeof(responsePacket),
   1074                  kPacketType_Command);
   \   00000024   0x2300             MOVS     R3,#+0
   \   00000026   0x220C             MOVS     R2,#+12
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x....             LDR.N    R0,??DataTable27_2
   \   0000002C   0x69C0             LDR      R0,[R0, #+28]
   \   0000002E   0x....             LDR.N    R6,??DataTable27_2
   \   00000030   0x69F6             LDR      R6,[R6, #+28]
   \   00000032   0x6976             LDR      R6,[R6, #+20]
   \   00000034   0x68B6             LDR      R6,[R6, #+8]
   \   00000036   0x47B0             BLX      R6
   1075              if (status != kStatus_Success)
   \   00000038   0x2800             CMP      R0,#+0
   1076              {
   1077                  debug_printf("Error: writePacket returned status 0x%x\r\n", status);
   1078              }
   1079          }
   \                     ??send_read_memory_response_0: (+1)
   \   0000003A   0xBD7F             POP      {R0-R6,PC}       ;; return
   1080          
   1081          //! @brief Send a flash read once resposne packet.

   \                                 In section .text, align 2, keep-with-next
   1082          void send_flash_read_once_response(uint32_t commandStatus, uint32_t *value, uint32_t byteCount)
   1083          {
   \                     send_flash_read_once_response: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1084              flash_read_once_response_packet_t responsePacket;
   1085              responsePacket.commandPacket.commandTag = kCommandTag_FlashReadOnceResponse;
   \   0000000A   0x20AF             MOVS     R0,#+175
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1086              responsePacket.commandPacket.flags = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1087              responsePacket.commandPacket.reserved = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF88D 0x0002      STRB     R0,[SP, #+2]
   1088              responsePacket.commandPacket.parameterCount = 2; // always includes two parameters: status and byte count
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1089              responsePacket.status = commandStatus;
   \   00000022   0x9401             STR      R4,[SP, #+4]
   1090          
   1091              if (commandStatus == kStatus_Success)
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD10E             BNE.N    ??send_flash_read_once_response_0
   1092              {
   1093                  responsePacket.commandPacket.parameterCount += byteCount / sizeof(uint32_t); // add parameter: data
   \   00000028   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   0000002C   0x08B1             LSRS     R1,R6,#+2
   \   0000002E   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   00000032   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1094                  responsePacket.byteCount = byteCount;
   \   00000036   0x9602             STR      R6,[SP, #+8]
   1095                  memcpy(responsePacket.data, value, byteCount);
   \   00000038   0xAF03             ADD      R7,SP,#+12
   \   0000003A   0x0032             MOVS     R2,R6
   \   0000003C   0x0029             MOVS     R1,R5
   \   0000003E   0x0038             MOVS     R0,R7
   \   00000040   0x.... 0x....      BL       __aeabi_memcpy
   1096              }
   \   00000044   0xE001             B.N      ??send_flash_read_once_response_1
   1097              else
   1098              {
   1099                  responsePacket.byteCount = 0;
   \                     ??send_flash_read_once_response_0: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x9002             STR      R0,[SP, #+8]
   1100              }
   1101          
   1102              uint32_t packetSize =
   1103                  sizeof(responsePacket.commandPacket) + (responsePacket.commandPacket.parameterCount * sizeof(uint32_t));
   \                     ??send_flash_read_once_response_1: (+1)
   \   0000004A   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   0000004E   0x0080             LSLS     R0,R0,#+2
   \   00000050   0x1D07             ADDS     R7,R0,#+4
   1104          
   1105              status_t status = g_bootloaderContext.activePeripheral->packetInterface->writePacket(
   1106                  g_bootloaderContext.activePeripheral, (const uint8_t *)&responsePacket, packetSize, kPacketType_Command);
   \   00000052   0x2300             MOVS     R3,#+0
   \   00000054   0x003A             MOVS     R2,R7
   \   00000056   0x4669             MOV      R1,SP
   \   00000058   0x....             LDR.N    R0,??DataTable27_2
   \   0000005A   0x69C0             LDR      R0,[R0, #+28]
   \   0000005C   0x.... 0x....      LDR.W    R12,??DataTable27_2
   \   00000060   0xF8DC 0xC01C      LDR      R12,[R12, #+28]
   \   00000064   0xF8DC 0xC014      LDR      R12,[R12, #+20]
   \   00000068   0xF8DC 0xC008      LDR      R12,[R12, #+8]
   \   0000006C   0x47E0             BLX      R12
   1107              if (status != kStatus_Success)
   \   0000006E   0x2800             CMP      R0,#+0
   1108              {
   1109                  debug_printf("Error: writePacket returned status 0x%x\r\n", status);
   1110              }
   1111          }
   \                     ??send_flash_read_once_response_2: (+1)
   \   00000070   0xB009             ADD      SP,SP,#+36
   \   00000072   0xBDF0             POP      {R4-R7,PC}       ;; return
   1112          
   1113          //! @brief Send a flash read resource memory response packet.

   \                                 In section .text, align 2, keep-with-next
   1114          void send_flash_read_resource_response(uint32_t commandStatus, uint32_t length)
   1115          {
   \                     send_flash_read_resource_response: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1116              flash_read_resource_response_packet_t responsePacket;
   1117              responsePacket.commandPacket.commandTag = kCommandTag_FlashReadResourceResponse;
   \   00000008   0x20B0             MOVS     R0,#+176
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1118              responsePacket.commandPacket.flags = kCommandFlag_HasDataPhase;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1119              responsePacket.commandPacket.reserved = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF88D 0x0002      STRB     R0,[SP, #+2]
   1120              responsePacket.commandPacket.parameterCount = 2;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1121              responsePacket.status = commandStatus;
   \   00000020   0x9401             STR      R4,[SP, #+4]
   1122              responsePacket.dataByteCount = length;
   \   00000022   0x9502             STR      R5,[SP, #+8]
   1123          
   1124              status_t status = g_bootloaderContext.activePeripheral->packetInterface->writePacket(
   1125                  g_bootloaderContext.activePeripheral, (const uint8_t *)&responsePacket, sizeof(responsePacket),
   1126                  kPacketType_Command);
   \   00000024   0x2300             MOVS     R3,#+0
   \   00000026   0x220C             MOVS     R2,#+12
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x....             LDR.N    R0,??DataTable27_2
   \   0000002C   0x69C0             LDR      R0,[R0, #+28]
   \   0000002E   0x....             LDR.N    R6,??DataTable27_2
   \   00000030   0x69F6             LDR      R6,[R6, #+28]
   \   00000032   0x6976             LDR      R6,[R6, #+20]
   \   00000034   0x68B6             LDR      R6,[R6, #+8]
   \   00000036   0x47B0             BLX      R6
   1127              if (status != kStatus_Success)
   \   00000038   0x2800             CMP      R0,#+0
   1128              {
   1129                  debug_printf("Error: writePacket returned status 0x%x\r\n", status);
   1130              }
   1131          }
   \                     ??send_flash_read_resource_response_0: (+1)
   \   0000003A   0xBD7F             POP      {R0-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0xE000ED0C         DC32     0xe000ed0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \   00000000   0x05FA0004         DC32     0x5fa0004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_2:
   \   00000000   0x........         DC32     g_bootloaderContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_3:
   \   00000000   0x........         DC32     g_bootloaderContext+0x20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_4:
   \   00000000   0x........         DC32     `handle_execute::s_addr`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_5:
   \   00000000   0x........         DC32     `handle_execute{3}{4}::s_callFunction`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_6:
   \   00000000   0x........         DC32     `handle_execute{3}{4}::s_argument`

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0, 0
   \              0x00000000   
   1132          
   1133          //! @}
   1134          
   1135          ////////////////////////////////////////////////////////////////////////////////
   1136          // EOF
   1137          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   NVIC_SystemReset
       0   bootloader_command_init
      16   bootloader_command_pump
        16   -- Indirect call
        16   -> handle_command
        16   -> handle_data
       8   finalize_data_phase
         8   -- Indirect call
         8   -> sbloader_finalize
         8   -> send_generic_response
       0   find_entry
      24   handle_call
        24   -- Indirect call
        24   -> is_valid_application_location
        24   -> send_generic_response
        24   -> shutdown_cleanup
      32   handle_command
        32   -- Indirect call
        32   -> find_entry
        32   -> send_generic_response
       8   handle_data
         8   -- Indirect call
      32   handle_data_consumer
        32   -- Indirect call
        32   -> finalize_data_phase
        32   -> sbloader_pump
      72   handle_data_producer
        72   -- Indirect call
        72   -> __aeabi_memcpy
        72   -> finalize_data_phase
        72   -> lock_acquire
        72   -> lock_release
      32   handle_execute
        32   -- Indirect call
        32   -> is_valid_application_location
        32   -> send_generic_response
        32   -> shutdown_cleanup
      16   handle_fill_memory
        16   -- Indirect call
        16   -> send_generic_response
      16   handle_flash_erase_all
        16   -> flash_mem_erase_all
        16   -> send_generic_response
      16   handle_flash_erase_all_unsecure
        16   -> flash_mem_erase_all_unsecure
        16   -> send_generic_response
      16   handle_flash_erase_region
        16   -- Indirect call
        16   -> send_generic_response
      24   handle_flash_program_once
        24   -- Indirect call
        24   -> lock_acquire
        24   -> lock_release
        24   -> send_generic_response
      32   handle_flash_read_once
        32   -- Indirect call
        32   -> lock_acquire
        32   -> lock_release
        32   -> send_flash_read_once_response
      16   handle_flash_read_resource
        16   -> reset_data_phase
        16   -> send_flash_read_resource_response
      16   handle_flash_security_disable
        16   -- Indirect call
        16   -> send_generic_response
      24   handle_get_property
        24   -- Indirect call
        24   -> send_get_property_response
      16   handle_read_memory
        16   -> reset_data_phase
        16   -> send_read_memory_response
      16   handle_receive_sb_file
        16   -> reset_data_phase
        16   -> sbloader_init
        16   -> send_generic_response
      16   handle_reset
        16   -- Indirect call
        16   -> NVIC_SystemReset
        16   -> send_generic_response
        16   -> shutdown_cleanup
      16   handle_set_property
        16   -- Indirect call
        16   -> send_generic_response
      16   handle_write_memory
        16   -> reset_data_phase
        16   -> send_generic_response
      16   reset_data_phase
        16   -> __aeabi_memset
      56   send_flash_read_once_response
        56   -- Indirect call
        56   -> __aeabi_memcpy
      32   send_flash_read_resource_response
        32   -- Indirect call
      32   send_generic_response
        32   -- Indirect call
      56   send_get_property_response
        56   -- Indirect call
      32   send_read_memory_response
        32   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
       4  ??DataTable27_3
       4  ??DataTable27_4
       4  ??DataTable27_5
       4  ??DataTable27_6
       8  ?_0
      34  NVIC_SystemReset
      16  bootloader_command_init
     202  bootloader_command_pump
     102  finalize_data_phase
      36  find_entry
      36  g_commandData
     144  g_commandHandlerTable
      16  g_commandInterface
      56  handle_call
     162  handle_command
      64  handle_data
     336  handle_data_consumer
     362  handle_data_producer
     160  handle_execute
      32  handle_fill_memory
      24  handle_flash_erase_all
      24  handle_flash_erase_all_unsecure
      34  handle_flash_erase_region
      46  handle_flash_program_once
      58  handle_flash_read_once
      60  handle_flash_read_resource
      32  handle_flash_security_disable
      64  handle_get_property
      56  handle_read_memory
      48  handle_receive_sb_file
      44  handle_reset
      34  handle_set_property
      56  handle_write_memory
      30  reset_data_phase
       4  s_addr
       4  s_argument
       4  s_callFunction
     116  send_flash_read_once_response
      60  send_flash_read_resource_response
      60  send_generic_response
     100  send_get_property_response
      60  send_read_memory_response

 
    48 bytes in section .bss
    16 bytes in section .data
   152 bytes in section .rodata
 2 596 bytes in section .text
 
 2 596 bytes of CODE  memory
   152 bytes of CONST memory
    64 bytes of DATA  memory

Errors: none
Warnings: none
