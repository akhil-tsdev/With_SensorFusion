###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       16/Sep/2016  13:23:51
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\security\src\aes_security.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\security\src\aes_security.c
#        -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\..\..\..\..\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -On --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\aes_security.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\aes_security.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\security\src\aes_security.c
      1          /*
      2           * Copyright (c) 2014, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "bootloader_common.h"
     32          #include "bootloader/bl_context.h"
     33          #include "fsl_device_registers.h"
     34          #include "ltc/ltc.h"
     35          #include "mmcau/mmcau.h"
     36          #include "security/aes_security.h"
     37          #include <string.h>
     38          
     39          /*******************************************************************************
     40           * Definitions
     41           ******************************************************************************/
     42          // This is enough space to allocate the debug version of the MMCAU functions as of commit 4b621d8
     43          #if BL_FEATURE_LOAD_MMCAU_LIB
     44          #define MMCAU_FUNCTION_MEMORY_MAX_SIZE 0x500
     45          
     46          typedef void (*user_mmcau_aes_init)(uint32_t *key, uint32_t *keySchedule, uint32_t *rcon);
     47          typedef void (*user_mmcau_aes_encrypt)(uint32_t *in, uint32_t *key, uint32_t *keySchedule, uint32_t *out);
     48          typedef void (*user_mmcau_aes_decrypt)(uint32_t *in, uint32_t *key, uint32_t *keySchedule, uint32_t *out);
     49          
     50          typedef struct mmcau_functions
     51          {
     52              user_mmcau_aes_init init;
     53              user_mmcau_aes_encrypt encrypt;
     54              user_mmcau_aes_decrypt decrypt;
     55          } mmcau_functions_t;
     56          
     57          static void loadMmcauFunctions(void);
     58          #endif // if BL_FEATURE_LOAD_MMCAU_LIB
     59          
     60          /*******************************************************************************
     61           * Variables
     62           ******************************************************************************/
     63          #if (FSL_FEATURE_SOC_MMCAU_COUNT && BL_FEATURE_ENCRYPTION_MMCAU)
     64          static uint32_t s_aesKeySchedule[AES_128_KEY_SCHEDULE_SIZE_WORDS];
     65          #endif
     66          
     67          #if BL_FEATURE_LOAD_MMCAU_LIB
     68          static mmcau_functions_t s_mmcauFunctions = { 0 };
     69          
     70          //! @brief A static buffer used to hold the MMCAU functions
     71          static uint8_t s_mmcauFunctionMemory[MMCAU_FUNCTION_MEMORY_MAX_SIZE];
     72          #endif // if BL_FEATURE_LOAD_MMCAU_LIB
     73          
     74          /*******************************************************************************
     75           * Code
     76           ******************************************************************************/
     77          
     78          // See aes_security.h for a description of this function.

   \                                 In section .text, align 2, keep-with-next
     79          void aes_init(uint32_t *key)
     80          {
   \                     aes_init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     81              if (is_ltc_present())
   \   00000004   0x.... 0x....      BL       is_ltc_present
     82              {
     83          #if (FSL_FEATURE_SOC_LTC_COUNT && BL_FEATURE_ENCRYPTION_LTC)
     84                  ltc_aes_init(key);
     85          #endif
     86              }
     87              else
     88              {
     89          #if (FSL_FEATURE_SOC_MMCAU_COUNT && BL_FEATURE_ENCRYPTION_MMCAU)
     90                  // rcon is only needed for MMCAU initialization and setting up the keyschedule, this code
     91                  // needed to be moved to here in order to make the code relocatable
     92                  uint32_t rcon[10] = { 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000,
     93                                        0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000 };
     94          
     95          #ifndef BL_FEATURE_LOAD_MMCAU_LIB
     96                  mmcau_aes_init(key, s_aesKeySchedule, rcon);
     97          #else
     98                  if (s_mmcauFunctions.init == 0)
     99                  {
    100                      loadMmcauFunctions();
    101                  }
    102          
    103                  if (s_mmcauFunctions.init)
    104                  {
    105                      s_mmcauFunctions.init(key, s_aesKeySchedule, rcon);
    106                  }
    107          #endif // BL_FEATURE_LOAD_MMCAU_LIB
    108          #endif // (FSL_FEATURE_SOC_MMCAU_COUNT && BL_FEATURE_ENCRYPTION_MMCAU)
    109              }
    110          }
   \   00000008   0xBD10             POP      {R4,PC}          ;; return
    111          
    112          // See aes_security.h for a description of this function.

   \                                 In section .text, align 2, keep-with-next
    113          void aes_encrypt(uint32_t *in, uint32_t *key, uint32_t *out)
    114          {
   \                     aes_encrypt: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    115              if (is_ltc_present())
   \   00000008   0x.... 0x....      BL       is_ltc_present
    116              {
    117          #if (FSL_FEATURE_SOC_LTC_COUNT && BL_FEATURE_ENCRYPTION_LTC)
    118                  ltc_aes_encrypt(in, key, out);
    119          #endif
    120              }
    121              else
    122              {
    123          #if (FSL_FEATURE_SOC_MMCAU_COUNT && BL_FEATURE_ENCRYPTION_MMCAU)
    124          
    125          #ifndef BL_FEATURE_LOAD_MMCAU_LIB
    126                  mmcau_aes_encrypt(in, key, s_aesKeySchedule, out);
    127          #else
    128                  if (s_mmcauFunctions.encrypt)
    129                  {
    130                      s_mmcauFunctions.encrypt(in, key, s_aesKeySchedule, out);
    131                  }
    132          #endif // BL_FEATURE_LOAD_MMCAU_LIB
    133          #endif // FSL_FEATURE_SOC_MMCAU_COUNT && BL_FEATURE_ENCRYPTION_MMCAU
    134              }
    135          }
   \   0000000C   0xBD70             POP      {R4-R6,PC}       ;; return
    136          
    137          // See aes_security.h for a description of this function.

   \                                 In section .text, align 2, keep-with-next
    138          void aes_decrypt(uint32_t *in, uint32_t *key, uint32_t *out)
    139          {
   \                     aes_decrypt: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    140              if (is_ltc_present())
   \   00000008   0x.... 0x....      BL       is_ltc_present
    141              {
    142          #if (FSL_FEATURE_SOC_LTC_COUNT && BL_FEATURE_ENCRYPTION_LTC)
    143                  ltc_aes_decrypt(in, key, out);
    144          #endif
    145              }
    146              else
    147              {
    148          #if (FSL_FEATURE_SOC_MMCAU_COUNT && BL_FEATURE_ENCRYPTION_MMCAU)
    149          #ifndef BL_FEATURE_LOAD_MMCAU_LIB
    150                  mmcau_aes_decrypt(in, key, s_aesKeySchedule, out);
    151          #else
    152                  if (s_mmcauFunctions.decrypt)
    153                  {
    154                      s_mmcauFunctions.decrypt(in, key, s_aesKeySchedule, out);
    155                  }
    156          #endif // BL_FEATURE_LOAD_MMCAU_LIB
    157          #endif // (FSL_FEATURE_SOC_MMCAU_COUNT && BL_FEATURE_ENCRYPTION_MMCAU)
    158              }
    159          }
   \   0000000C   0xBD70             POP      {R4-R6,PC}       ;; return
    160          
    161          //!< @brief This function is to load the MMCAU functions from a location that is provided in the BCA
    162          //!<  In the case of a debug build that has MMCAU_TEST defined it will load the info from the global
    163          //!<  variable g_mmcauFunctions to help facilitate testing.
    164          //!<  The location of the different functions in the binary blob are located through the info struct members
    165          //!<  The functions must be contiguous since the memory copy only copies one continuous block
    166          #if BL_FEATURE_LOAD_MMCAU_LIB
    167          void loadMmcauFunctions(void)
    168          {
    169              uint32_t mmcauInfoAddress;
    170          
    171          #if defined(DEBUG) && defined(MMCAU_TEST)
    172              extern uint32_t g_mmcauFunctions;
    173              mmcauInfoAddress = g_mmcauFunctions;
    174          #else
    175              mmcauInfoAddress = g_bootloaderContext.propertyInterface->store->configurationData.mmcauConfigPointer;
    176          #endif // DEBUG
    177          
    178              mmcau_function_info_t *info;
    179              uint32_t copyLength;
    180          
    181              if (mmcauInfoAddress != ~0)
    182              {
    183                  info = (mmcau_function_info_t *)mmcauInfoAddress;
    184          
    185          // Make sure that the aes library info isn't in exeucte-only region, because bootloader isn't allowed to
    186          // access such region.
    187          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    188                  if (is_in_execute_only_region(mmcauInfoAddress, sizeof(mmcau_function_info_t)))
    189                  {
    190                      return;
    191                  }
    192          #endif //  FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    193          
    194                  if (kMmcauInfoTag == info->tag)
    195                  {
    196                      copyLength = MIN(sizeof(s_mmcauFunctionMemory), info->length);
    197          // Make sure that the aes library isn't in exeucte-only region, because bootloader isn't allowed to
    198          // access such region.
    199          #if FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    200                      if (is_in_execute_only_region(info->aes_init_start, sizeof(copyLength)))
    201                      {
    202                          return;
    203                      }
    204          #endif //  FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    205          
    206                      memcpy(s_mmcauFunctionMemory, (void *)info->aes_init_start, copyLength);
    207          
    208                      // Add 1 to keep in thumb mode
    209                      s_mmcauFunctions.init = (user_mmcau_aes_init)(s_mmcauFunctionMemory + 1);
    210                      s_mmcauFunctions.encrypt =
    211                          (user_mmcau_aes_encrypt)(s_mmcauFunctionMemory + (info->aes_encrypt_start - info->aes_init_start) + 1);
    212                      s_mmcauFunctions.decrypt =
    213                          (user_mmcau_aes_decrypt)(s_mmcauFunctionMemory + (info->aes_decrypt_start - info->aes_init_start) + 1);
    214                  }
    215              }
    216          }
    217          
    218          #endif // BL_FEATURE_LOAD_MMCAU_LIB
    219          
    220          ////////////////////////////////////////////////////////////////////////////////
    221          // EOF
    222          ////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   aes_decrypt
        16   -> is_ltc_present
      16   aes_encrypt
        16   -> is_ltc_present
       8   aes_init
         8   -> is_ltc_present


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      14  aes_decrypt
      14  aes_encrypt
      10  aes_init

 
 38 bytes in section .text
 
 38 bytes of CODE memory

Errors: none
Warnings: none
