###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       02/Sep/2016  15:38:04
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\mmcau\src\mmcau_aes_functions.c
#    Command line =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\mmcau\src\mmcau_aes_functions.c
#        -D DEBUG -D NDEBUG -D USB_STACK_BM -D CPU_MK22FN1M0AVMC12 -D
#        CPU_IS_ARM_CORTEX_M4=1 -D IAR -D FREEDOM -D BL_TARGET_FLASH -D
#        TURINGSENSE=1 -lC
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\platform\devices\MK22FA12_MK64\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/autobaud\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/osa\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/usb/device/class\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/bm_usb\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/devices\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/platform/CMSIS/Include\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/startup\
#        -I
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader/../../../../src/drivers/common\
#        -Ohz --use_c++_inline
#    Locale       =  C
#    List file    =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\list\mmcau_aes_functions.lst
#    Object file  =  
#        C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\targets\MK22FA12_MK64\iar\freedom_bootloader\debug\obj\mmcau_aes_functions.o
#
###############################################################################

C:\Freescale\NXP_Kinetis_Bootloader_2_0_0\NXP_Kinetis_Bootloader_2_0_0\src\drivers\mmcau\src\mmcau_aes_functions.c
      1          /********************************************************************************/
      2          /********************************************************************************/
      3          /**/
      4          /* Copyright (c) Freescale Semiconductor, Inc 2011.*/
      5          /**/
      6          /* FILE NAME      : mmcau_aes_functions.c*/
      7          /* VERSION        : $Id: mmcau_aes_functions.c.rca 1.2 Sat Jan  8 01:21:45 2011 rzsx60 Experimental $*/
      8          /* TYPE           : Source C library code*/
      9          /* DEPARTMENT     : MSG R&D Core and Platforms*/
     10          /* AUTHOR         : David Schimke*/
     11          /* AUTHOR'S EMAIL : David.Schimke@freescale.com*/
     12          /* -----------------------------------------------------------------------------*/
     13          /* Release history*/
     14          /* VERSION  Date       AUTHOR           DESCRIPTION*/
     15          /*          08-2010    David Schimke    Initial Release*/
     16          /*          01-2011    David Schimke    Add byte reverse to correct double word*/
     17          /*                                      read of byte array inputs for little*/
     18          /*                                      endian, header added, comment cleanup*/
     19          /**/
     20          /********************************************************************************/
     21          /********************************************************************************/
     22          
     23          #include "security/aes_security.h"
     24          #include "fsl_device_registers.h"
     25          
     26          #define AES_128_NUMBER_ROUNDS 10
     27          
     28          #define mmcau_1_cmd(c1) (0x80000000 + ((c1) << 22))
     29          #define mmcau_2_cmds(c1, c2) (0x80100000 + ((c1) << 22) + ((c2) << 11))
     30          #define mmcau_3_cmds(c1, c2, c3) (0x80100200 + ((c1) << 22) + ((c2) << 11) + c3)
     31          #define byterev(d) (((d) >> 24) | (((d) >> 8) & 0xff00) | (((d) << 8) & 0xff0000) | ((d) << 24))
     32          
     33          // Opcodes
     34          #define TL 0
     35          #define TS 0
     36          #define CASR 0
     37          #define CAA 1
     38          #define CA0 2
     39          #define CA1 3
     40          #define CA2 4
     41          #define CA3 5
     42          #define CA4 6
     43          #define CA5 7
     44          #define CA6 8
     45          #define CA7 9
     46          #define CA8 10
     47          #define CNOP 0x000
     48          #define LDR 0x010
     49          #define STR 0x020
     50          #define ADR 0x030
     51          #define RADR 0x040
     52          #define ADRA 0x050
     53          #define XOR 0x060
     54          #define ROTL 0x070
     55          #define MVRA 0x080
     56          #define MVAR 0x090
     57          #define AESS 0x0a0
     58          #define AESIS 0x0b0
     59          #define AESC 0x0c0
     60          #define AESIC 0x0d0
     61          #define AESR 0x0e0
     62          #define AESIR 0x0f0
     63          #define DESR 0x100
     64          #define DESK 0x110
     65          #define HASH 0x120
     66          #define SHS 0x130
     67          #define MDS 0x140
     68          #define SHS2 0x150
     69          #define ILL 0x1f0
     70          #define IP 8
     71          #define FP 4
     72          #define DC 1
     73          #define CP 2
     74          #define KSL1 0
     75          #define KSL2 1
     76          #define KSR1 2
     77          #define KSR2 3
     78          #define HFF 0
     79          #define HFG 1
     80          #define HFH 2
     81          #define HFI 3
     82          #define HFP 2
     83          #define HFC 4
     84          #define HFM 5
     85          #define HF2C 6
     86          #define HF2M 7
     87          #define HF2S 8
     88          #define HF2T 9
     89          #define HF2U 10
     90          #define HF2V 11
     91          
     92          #define MMCAU_INDIRECT_MASK 0x800
     93          
     94          #define MMCAU_PPB_DIRECT ((volatile uint32_t *)CAU_BASE)
     95          #define MMCAU_PPB_INDIRECT ((volatile uint32_t *)(CAU_BASE | MMCAU_INDIRECT_MASK))
     96          
     97          /********************************************************************************/
     98          /********************************************************************************/
     99          
    100          /********************************************************************************/
    101          /**/
    102          /* AES: Performs an AES key expansion*/
    103          /*   arguments*/
    104          /*     *key         pointer to input key 128 bits in length */
    105          /*     *keySchedule pointer to key schedule 128 bits in length */
    106          /*     *rcon needs to be set to the following structure which must be located outside */
    107          /*           outside of this function in order to make this code relocatable */
    108          /*           unsigned int rcon[10] = {0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, */
    109          /*                                    0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000}; */
    110          /**/
    111          
    112          void mmcau_aes_init(uint32_t *key, uint32_t *keySchedule, uint32_t *rcon)
    113          {
    114              int32_t i, j;
    115          
    116              for (i = 0; i < 4; i++)
    117              {
    118                  keySchedule[i] = byterev(key[i]);
    119              }
    120          
    121              *(MMCAU_PPB_INDIRECT + (LDR + CAA)) = keySchedule[i - 1]; /* CAA= key[3]*/
                       ^
Error[Pe020]: identifier "CAU_BASE" is undefined
    122          
    123              for (j = 0; j < 10; j++)
    124              {
    125                  *(MMCAU_PPB_INDIRECT + (ROTL + CAA)) = 8;      /* rotate 8*/
    126                  *(MMCAU_PPB_DIRECT) = mmcau_1_cmd(AESS + CAA); /* SubBytes*/
    127                  *(MMCAU_PPB_INDIRECT + (XOR + CAA)) = rcon[j]; /* XOR rcon[j]*/
    128          
    129                  /* 1st calculation for keySchedule[4+0,8+0,12+0,16+0,20+0,24+0,28+0,32+0,36+0,40+0]*/
    130                  *(MMCAU_PPB_INDIRECT + (XOR + CAA)) = keySchedule[i - 4]; /*XOR key[i-4]*/
    131                  keySchedule[i++] = *(MMCAU_PPB_INDIRECT + (STR + CAA));   /*store key[i]*/
    132          
    133                  /* 2nd calculation for keySchedule[4+1,8+1,12+1,16+1,20+1,24+1,28+1,32+1,36+1,40+1]*/
    134                  *(MMCAU_PPB_INDIRECT + (XOR + CAA)) = keySchedule[i - 4]; /*XOR key[i-4]*/
    135                  keySchedule[i++] = *(MMCAU_PPB_INDIRECT + (STR + CAA));   /*store key[i]*/
    136          
    137                  /* 3rd calculation for keySchedule[4+2,8+2,12+2,16+2,20+2,24+2,28+2,32+2,36+2,40+2]*/
    138                  *(MMCAU_PPB_INDIRECT + (XOR + CAA)) = keySchedule[i - 4]; /*XOR key[i-4]*/
    139                  keySchedule[i++] = *(MMCAU_PPB_INDIRECT + (STR + CAA));   /*store key[i]*/
    140          
    141                  /* 4th calculation for keySchedule[4+3,8+3,12+3,16+3,20+3,24+3,28+3,32+3,36+3,40+3]*/
    142                  *(MMCAU_PPB_INDIRECT + (XOR + CAA)) = keySchedule[i - 4]; /*XOR key[i-4]*/
    143                  keySchedule[i++] = *(MMCAU_PPB_INDIRECT + (STR + CAA));   /*store key[i]*/
    144              }
    145          }
    146          
    147          /********************************************************************************/
    148          /********************************************************************************/
    149          /**/
    150          /* AES: Encrypts a single 16-byte block*/
    151          /*   arguments*/
    152          /*           *in          pointer to 16-byte block of input plaintext*/
    153          /*           *key         pointer to input key 128 bits in length*/
    154          /*           *keySchedule pointer to key schedule 128 bits in length*/
    155          /*           *out         pointer to 16-byte block of output ciphertext*/
    156          /**/
    157          /*   NOTE    Input and output blocks may overlap*/
    158          /**/
    159          
    160          void mmcau_aes_encrypt(uint32_t *in, uint32_t *key, uint32_t *keySchedule, uint32_t *out)
    161          {
    162              int32_t i, j;
    163          
    164              /* load the 4 plain test bytes into the CAU's CA0 - CA3 registers*/
    165              *(MMCAU_PPB_INDIRECT + (LDR + CA0)) = byterev(in[0]); /* load in[0]-> CA0*/
                       ^
Error[Pe020]: identifier "CAU_BASE" is undefined
    166              *(MMCAU_PPB_INDIRECT + (LDR + CA1)) = byterev(in[1]); /* load in[1]-> CA1*/
    167              *(MMCAU_PPB_INDIRECT + (LDR + CA2)) = byterev(in[2]); /* load in[2]-> CA2*/
    168              *(MMCAU_PPB_INDIRECT + (LDR + CA3)) = byterev(in[3]); /* load in[3]-> CA3*/
    169          
    170              /* XOR the first 4 keys into the CAU's CA0 - CA3 registers*/
    171              *(MMCAU_PPB_INDIRECT + (XOR + CA0)) = keySchedule[0]; /* XOR keys*/
    172              *(MMCAU_PPB_INDIRECT + (XOR + CA1)) = keySchedule[1];
    173              *(MMCAU_PPB_INDIRECT + (XOR + CA2)) = keySchedule[2];
    174              *(MMCAU_PPB_INDIRECT + (XOR + CA3)) = keySchedule[3];
    175          
    176              /* send a series of cau commands to perform the encryption*/
    177              for (i = 0, j = 4; i < AES_128_NUMBER_ROUNDS - 1; i++, j += 4)
    178              {
    179                  *(MMCAU_PPB_DIRECT) = mmcau_3_cmds(AESS + CA0, AESS + CA1, AESS + CA2); /*Sbytes*/
    180                  *(MMCAU_PPB_DIRECT) = mmcau_2_cmds(AESS + CA3, AESR);                   /*Sbyte,Shft*/
    181                  *(MMCAU_PPB_INDIRECT + (AESC + CA0)) = keySchedule[j];                  /* MixCols*/
    182                  *(MMCAU_PPB_INDIRECT + (AESC + CA1)) = keySchedule[j + 1];
    183                  *(MMCAU_PPB_INDIRECT + (AESC + CA2)) = keySchedule[j + 2];
    184                  *(MMCAU_PPB_INDIRECT + (AESC + CA3)) = keySchedule[j + 3];
    185              }
    186          
    187              *(MMCAU_PPB_DIRECT) = mmcau_3_cmds(AESS + CA0, AESS + CA1, AESS + CA2); /* SubBytes*/
    188              *(MMCAU_PPB_DIRECT) = mmcau_2_cmds(AESS + CA3, AESR);                   /*SByte,Shft*/
    189              *(MMCAU_PPB_INDIRECT + (XOR + CA0)) = keySchedule[j];                   /* XOR keys*/
    190              *(MMCAU_PPB_INDIRECT + (XOR + CA1)) = keySchedule[j + 1];
    191              *(MMCAU_PPB_INDIRECT + (XOR + CA2)) = keySchedule[j + 2];
    192              *(MMCAU_PPB_INDIRECT + (XOR + CA3)) = keySchedule[j + 3];
    193          
    194              /* store the 16-byte ciphertext output block into memory*/
    195              out[0] = *(MMCAU_PPB_INDIRECT + (STR + CA0)); /* store 1st 4 bytes*/
    196              out[1] = *(MMCAU_PPB_INDIRECT + (STR + CA1)); /* store 2nd 4 bytes*/
    197              out[2] = *(MMCAU_PPB_INDIRECT + (STR + CA2)); /* store 3rd 4 bytes*/
    198              out[3] = *(MMCAU_PPB_INDIRECT + (STR + CA3)); /* store 4th 4 bytes*/
    199          
    200              out[0] = byterev(out[0]); /* Reverse 1st 4 bytes*/
    201              out[1] = byterev(out[1]); /* Reverse 2nd 4 bytes*/
    202              out[2] = byterev(out[2]); /* Reverse 3rd 4 bytes*/
    203              out[3] = byterev(out[3]); /* Reverse 4th 4 bytes*/
    204          }
    205          
    206          /********************************************************************************/
    207          /********************************************************************************/
    208          /**/
    209          /* AES: Decrypts a single 16-byte block*/
    210          /*   arguments*/
    211          /*           *in          pointer to 16-byte block of input chiphertext*/
    212          /*           *key         pointer to input key 128 bits in length*/
    213          /*           *keySchedule pointer to key schedule 128 bits in length*/
    214          /*           *out         pointer to 16-byte block of output plaintext*/
    215          /**/
    216          /*   NOTE    Input and output blocks may overlap*/
    217          /**/
    218          
    219          void mmcau_aes_decrypt(uint32_t *in, uint32_t *key, uint32_t *keySchedule, uint32_t *out)
    220          {
    221              int32_t i;
    222          
    223              /* load the cipher bytes into the CAU's CA0 - CA3 registers*/
    224              *(MMCAU_PPB_INDIRECT + (LDR + CA0)) = byterev(in[0]); /* load in[0] -> CA0*/
                       ^
Error[Pe020]: identifier "CAU_BASE" is undefined
    225              *(MMCAU_PPB_INDIRECT + (LDR + CA1)) = byterev(in[1]); /* load in[1] -> CA1*/
    226              *(MMCAU_PPB_INDIRECT + (LDR + CA2)) = byterev(in[2]); /* load in[2] -> CA2*/
    227              *(MMCAU_PPB_INDIRECT + (LDR + CA3)) = byterev(in[3]); /* load in[3] -> CA3*/
    228          
    229              /* the keySchedule index (i) is adjusted to define the end of the elements*/
    230              /* the adjustment factor = f(nr) is defined by the expression:*/
    231              /*   end of keySchedule = 4 x (nr + 1) for nr = {10, 12, 14}*/
    232              i = 4 * (AES_128_NUMBER_ROUNDS + 1);
    233          
    234              /* XOR the keys into the CAU's CA0 - CA3 registers*/
    235              *(MMCAU_PPB_INDIRECT + (XOR + CA3)) = keySchedule[--i]; /* XOR keys*/
    236              *(MMCAU_PPB_INDIRECT + (XOR + CA2)) = keySchedule[--i];
    237              *(MMCAU_PPB_INDIRECT + (XOR + CA1)) = keySchedule[--i];
    238              *(MMCAU_PPB_INDIRECT + (XOR + CA0)) = keySchedule[--i];
    239          
    240              /* send a series of cau commands to perform the decryption*/
    241              while (i > 4)
    242              {
    243                  *(MMCAU_PPB_DIRECT) = mmcau_3_cmds(AESIR, AESIS + CA3, AESIS + CA2);
    244                  /* InvShiftRows,InvSubBytes*/
    245                  *(MMCAU_PPB_DIRECT) = mmcau_2_cmds(AESIS + CA1, AESIS + CA0); /* InvSubByts*/
    246                  *(MMCAU_PPB_INDIRECT + (AESIC + CA3)) = keySchedule[--i];     /* InvMxCols*/
    247                  *(MMCAU_PPB_INDIRECT + (AESIC + CA2)) = keySchedule[--i];
    248                  *(MMCAU_PPB_INDIRECT + (AESIC + CA1)) = keySchedule[--i];
    249                  *(MMCAU_PPB_INDIRECT + (AESIC + CA0)) = keySchedule[--i];
    250              }
    251          
    252              *(MMCAU_PPB_DIRECT) = mmcau_3_cmds(AESIR, AESIS + CA3, AESIS + CA2);
    253              /* InvShiftRows,InvSubBytes*/
    254              *(MMCAU_PPB_DIRECT) = mmcau_2_cmds(AESIS + CA1, AESIS + CA0); /* InvSBytes*/
    255              *(MMCAU_PPB_INDIRECT + (XOR + CA3)) = keySchedule[--i];       /* XOR keys*/
    256              *(MMCAU_PPB_INDIRECT + (XOR + CA2)) = keySchedule[--i];
    257              *(MMCAU_PPB_INDIRECT + (XOR + CA1)) = keySchedule[--i];
    258              *(MMCAU_PPB_INDIRECT + (XOR + CA0)) = keySchedule[--i];
    259          
    260              /* store the 16-byte ciphertext output block into memory*/
    261              out[0] = *(MMCAU_PPB_INDIRECT + (STR + CA0)); /* store 1st 4 bytes*/
    262              out[1] = *(MMCAU_PPB_INDIRECT + (STR + CA1)); /* store 2nd 4 bytes*/
    263              out[2] = *(MMCAU_PPB_INDIRECT + (STR + CA2)); /* store 3rd 4 bytes*/
    264              out[3] = *(MMCAU_PPB_INDIRECT + (STR + CA3)); /* store 4th 4 bytes*/
    265          
    266              out[0] = byterev(out[0]); /* Reverse 1st 4 bytes*/
    267              out[1] = byterev(out[1]); /* Reverse 2nd 4 bytes*/
    268              out[2] = byterev(out[2]); /* Reverse 3rd 4 bytes*/
    269              out[3] = byterev(out[3]); /* Reverse 4th 4 bytes*/
    270          }

Errors: 3
Warnings: none
